/*
** ###################################################################
**     Compilers:           Keil ARM C/C++ Compiler
**                          Freescale C/C++ for Embedded ARM
**                          GNU C Compiler
**                          GNU C Compiler - CodeSourcery Sourcery G++
**                          IAR ANSI C/C++ Compiler for ARM
**
**     Reference manual:    KL43P64M48SF6RM, Rev.3, Aug 2014
**     Version:             rev. 1.5, 2014-09-05
**     Build:               b141001
**
**     Abstract:
**         Extension to the CMSIS register access layer header.
**
**     Copyright (c) 2014 Freescale Semiconductor, Inc.
**     All rights reserved.
**
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
**     http:                 www.freescale.com
**     mail:                 support@freescale.com
**
**     Revisions:
**     - rev. 1.0 (2014-03-27)
**         Initial version.
**     - rev. 1.1 (2014-05-26)
**         I2S registers TCR2/RCR2 and others were changed.
**         FLEXIO register FLEXIO_VERID has now bitfields: FEATURE, MINOR, MAJOR.
**         Names of the bitfields of the FLEXIO_SHIFTBUF have been changed to the appropriate register name e.g.: FLEXIO_SHIFTBUFBBS_SHIFTBUFBBS.
**         Peripheral_BASES macros has been changed to Peripheral_BASE_PTRS, e.g.: ADC_BASES to ADC_BASE_PTRS.
**         Clock configuration for high range external oscillator has been added.
**         RFSYS module access has been added.
**     - rev. 1.2 (2014-07-10)
**         GPIO - Renamed modules PTA,PTB,PTC,PTD,PTE to GPIOA,GPIOB,GPIOC,GPIOD,GPIOE.
**         UART0 - UART0 module renamed to UART2.
**         I2S - removed MDR register.
**     - rev. 1.3 (2014-08-21)
**         UART2 - Removed ED register.
**         UART2 - Removed MODEM register.
**         UART2 - Removed IR register.
**         UART2 - Removed PFIFO register.
**         UART2 - Removed CFIFO register.
**         UART2 - Removed SFIFO register.
**         UART2 - Removed TWFIFO register.
**         UART2 - Removed TCFIFO register.
**         UART2 - Removed RWFIFO register.
**         UART2 - Removed RCFIFO register.
**         USB - Removed bitfield REG_EN in CLK_RECOVER_IRC_EN register.
**         SIM - Changed bitfield value MCGIRCLK to LIRC_CLK of bitfield CLKOUTSEL in SOPT2 register.
**         SIM - Removed bitfield DIEID in SDID register.
**     - rev. 1.4 (2014-09-01)
**         USB - USB0_CTL0 was renamed to USB0_OTGCTL register.
**         USB - USB0_CTL1 was renamed to USB0_CTL register.
**     - rev. 1.5 (2014-09-05)
**         USB - Renamed USBEN bitfield of USB0_CTL was renamed to USBENSOFEN.
**
** ###################################################################
*/

/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_MKL43Z4_REGISTERS_H__
#define __HW_MKL43Z4_REGISTERS_H__

#include "MKL43Z4.h"
#include "fsl_bitaccess.h"

/*
 * MKL43Z4 ADC
 *
 * Analog-to-Digital Converter
 *
 * Registers defined in this header file:
 * - HW_ADC_SC1n - ADC Status and Control Registers 1
 * - HW_ADC_CFG1 - ADC Configuration Register 1
 * - HW_ADC_CFG2 - ADC Configuration Register 2
 * - HW_ADC_Rn - ADC Data Result Register
 * - HW_ADC_CV1 - Compare Value Registers
 * - HW_ADC_CV2 - Compare Value Registers
 * - HW_ADC_SC2 - Status and Control Register 2
 * - HW_ADC_SC3 - Status and Control Register 3
 * - HW_ADC_OFS - ADC Offset Correction Register
 * - HW_ADC_PG - ADC Plus-Side Gain Register
 * - HW_ADC_MG - ADC Minus-Side Gain Register
 * - HW_ADC_CLPD - ADC Plus-Side General Calibration Value Register
 * - HW_ADC_CLPS - ADC Plus-Side General Calibration Value Register
 * - HW_ADC_CLP4 - ADC Plus-Side General Calibration Value Register
 * - HW_ADC_CLP3 - ADC Plus-Side General Calibration Value Register
 * - HW_ADC_CLP2 - ADC Plus-Side General Calibration Value Register
 * - HW_ADC_CLP1 - ADC Plus-Side General Calibration Value Register
 * - HW_ADC_CLP0 - ADC Plus-Side General Calibration Value Register
 * - HW_ADC_CLMD - ADC Minus-Side General Calibration Value Register
 * - HW_ADC_CLMS - ADC Minus-Side General Calibration Value Register
 * - HW_ADC_CLM4 - ADC Minus-Side General Calibration Value Register
 * - HW_ADC_CLM3 - ADC Minus-Side General Calibration Value Register
 * - HW_ADC_CLM2 - ADC Minus-Side General Calibration Value Register
 * - HW_ADC_CLM1 - ADC Minus-Side General Calibration Value Register
 * - HW_ADC_CLM0 - ADC Minus-Side General Calibration Value Register
 *
 * - hw_adc_t - Struct containing all module registers.
 */

#define HW_ADC_INSTANCE_COUNT (1U) /*!< Number of instances of the ADC module. */
#define HW_ADC0 (0U) /*!< Instance number for ADC0. */

/*******************************************************************************
 * HW_ADC_SC1n - ADC Status and Control Registers 1
 ******************************************************************************/

/*!
 * @brief HW_ADC_SC1n - ADC Status and Control Registers 1 (RW)
 *
 * Reset value: 0x0000001FU
 *
 * SC1A is used for both software and hardware trigger modes of operation. To
 * allow sequential conversions of the ADC to be triggered by internal peripherals,
 * the ADC can have more than one status and control register: one for each
 * conversion. The SC1B-SC1n registers indicate potentially multiple SC1 registers
 * for use only in hardware trigger mode. See the chip configuration information
 * about the number of SC1n registers specific to this device. The SC1n registers
 * have identical fields, and are used in a "ping-pong" approach to control ADC
 * operation. At any one point in time, only one of the SC1n registers is actively
 * controlling ADC conversions. Updating SC1A while SC1n is actively controlling
 * a conversion is allowed, and vice-versa for any of the SC1n registers specific
 * to this MCU. Writing SC1A while SC1A is actively controlling a conversion
 * aborts the current conversion. In Software Trigger mode, when SC2[ADTRG]=0,
 * writes to SC1A subsequently initiate a new conversion, if SC1[ADCH] contains a
 * value other than all 1s. Writing any of the SC1n registers while that specific
 * SC1n register is actively controlling a conversion aborts the current conversion.
 * None of the SC1B-SC1n registers are used for software trigger operation and
 * therefore writes to the SC1B-SC1n registers do not initiate a new conversion.
 */
typedef union _hw_adc_sc1n
{
    uint32_t U;
    struct _hw_adc_sc1n_bitfields
    {
        uint32_t ADCH : 5;             /*!< [4:0] Input channel select */
        uint32_t DIFF : 1;             /*!< [5] Differential Mode Enable */
        uint32_t AIEN : 1;             /*!< [6] Interrupt Enable */
        uint32_t COCO : 1;             /*!< [7] Conversion Complete Flag */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_adc_sc1n_t;

/*!
 * @name Constants and macros for entire ADC_SC1n register
 */
/*@{*/
#define HW_ADC_SC1n_COUNT (2U)

#define HW_ADC_SC1n_ADDR(x, n)   ((uint32_t)(x) + 0x0U + (0x4U * (n)))

#define HW_ADC_SC1n(x, n)        (*(__IO hw_adc_sc1n_t *) HW_ADC_SC1n_ADDR(x, n))
#define HW_ADC_SC1n_RD(x, n)     (HW_ADC_SC1n(x, n).U)
#define HW_ADC_SC1n_WR(x, n, v)  (HW_ADC_SC1n(x, n).U = (v))
#define HW_ADC_SC1n_SET(x, n, v) (BME_OR32(HW_ADC_SC1n_ADDR(x, n), (uint32_t)(v)))
#define HW_ADC_SC1n_CLR(x, n, v) (BME_AND32(HW_ADC_SC1n_ADDR(x, n), (uint32_t)(~(v))))
#define HW_ADC_SC1n_TOG(x, n, v) (BME_XOR32(HW_ADC_SC1n_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC1n bitfields
 */

/*!
 * @name Register ADC_SC1n, field ADCH[4:0] (RW)
 *
 * Selects one of the input channels. The input channel decode depends on the
 * value of DIFF. DAD0-DAD3 are associated with the input pin pairs DADPx and
 * DADMx. Some of the input channel options in the bitfield-setting descriptions might
 * not be available for your device. For the actual ADC channel assignments for
 * your device, see the Chip Configuration details. The successive approximation
 * converter subsystem is turned off when the channel select bits are all set,
 * that is, ADCH = 11111. This feature allows explicit disabling of the ADC and
 * isolation of the input channel from all sources. Terminating continuous
 * conversions this way prevents an additional single conversion from being performed. It
 * is not necessary to set ADCH to all 1s to place the ADC in a low-power state
 * when continuous conversions are not enabled because the module automatically
 * enters a low-power state when a conversion completes.
 *
 * Values:
 * - 00000 - When DIFF=0, DADP0 is selected as input; when DIFF=1, DAD0 is
 *     selected as input.
 * - 00001 - When DIFF=0, DADP1 is selected as input; when DIFF=1, DAD1 is
 *     selected as input.
 * - 00010 - When DIFF=0, DADP2 is selected as input; when DIFF=1, DAD2 is
 *     selected as input.
 * - 00011 - When DIFF=0, DADP3 is selected as input; when DIFF=1, DAD3 is
 *     selected as input.
 * - 00100 - When DIFF=0, AD4 is selected as input; when DIFF=1, it is reserved.
 * - 00101 - When DIFF=0, AD5 is selected as input; when DIFF=1, it is reserved.
 * - 00110 - When DIFF=0, AD6 is selected as input; when DIFF=1, it is reserved.
 * - 00111 - When DIFF=0, AD7 is selected as input; when DIFF=1, it is reserved.
 * - 01000 - When DIFF=0, AD8 is selected as input; when DIFF=1, it is reserved.
 * - 01001 - When DIFF=0, AD9 is selected as input; when DIFF=1, it is reserved.
 * - 01010 - When DIFF=0, AD10 is selected as input; when DIFF=1, it is reserved.
 * - 01011 - When DIFF=0, AD11 is selected as input; when DIFF=1, it is reserved.
 * - 01100 - When DIFF=0, AD12 is selected as input; when DIFF=1, it is reserved.
 * - 01101 - When DIFF=0, AD13 is selected as input; when DIFF=1, it is reserved.
 * - 01110 - When DIFF=0, AD14 is selected as input; when DIFF=1, it is reserved.
 * - 01111 - When DIFF=0, AD15 is selected as input; when DIFF=1, it is reserved.
 * - 10000 - When DIFF=0, AD16 is selected as input; when DIFF=1, it is reserved.
 * - 10001 - When DIFF=0, AD17 is selected as input; when DIFF=1, it is reserved.
 * - 10010 - When DIFF=0, AD18 is selected as input; when DIFF=1, it is reserved.
 * - 10011 - When DIFF=0, AD19 is selected as input; when DIFF=1, it is reserved.
 * - 10100 - When DIFF=0, AD20 is selected as input; when DIFF=1, it is reserved.
 * - 10101 - When DIFF=0, AD21 is selected as input; when DIFF=1, it is reserved.
 * - 10110 - When DIFF=0, AD22 is selected as input; when DIFF=1, it is reserved.
 * - 10111 - When DIFF=0, AD23 is selected as input; when DIFF=1, it is reserved.
 * - 11000 - Reserved.
 * - 11001 - Reserved.
 * - 11010 - When DIFF=0, Temp Sensor (single-ended) is selected as input; when
 *     DIFF=1, Temp Sensor (differential) is selected as input.
 * - 11011 - When DIFF=0, Bandgap (single-ended) is selected as input; when
 *     DIFF=1, Bandgap (differential) is selected as input.
 * - 11100 - Reserved.
 * - 11101 - When DIFF=0,VREFSH is selected as input; when DIFF=1, -VREFSH
 *     (differential) is selected as input. Voltage reference selected is determined
 *     by SC2[REFSEL].
 * - 11110 - When DIFF=0,VREFSL is selected as input; when DIFF=1, it is
 *     reserved. Voltage reference selected is determined by SC2[REFSEL].
 * - 11111 - Module is disabled.
 */
/*@{*/
#define BP_ADC_SC1n_ADCH     (0U)          /*!< Bit position for ADC_SC1n_ADCH. */
#define BM_ADC_SC1n_ADCH     (0x0000001FU) /*!< Bit mask for ADC_SC1n_ADCH. */
#define BS_ADC_SC1n_ADCH     (5U)          /*!< Bit field size in bits for ADC_SC1n_ADCH. */

/*! @brief Read current value of the ADC_SC1n_ADCH field. */
#define BR_ADC_SC1n_ADCH(x, n) (BME_UBFX32(HW_ADC_SC1n_ADDR(x, n), BP_ADC_SC1n_ADCH, BS_ADC_SC1n_ADCH))

/*! @brief Format value for bitfield ADC_SC1n_ADCH. */
#define BF_ADC_SC1n_ADCH(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_SC1n_ADCH) & BM_ADC_SC1n_ADCH)

/*! @brief Set the ADCH field to a new value. */
#define BW_ADC_SC1n_ADCH(x, n, v) (BME_BFI32(HW_ADC_SC1n_ADDR(x, n), ((uint32_t)(v) << BP_ADC_SC1n_ADCH), BP_ADC_SC1n_ADCH, 5))
/*@}*/

/*!
 * @name Register ADC_SC1n, field DIFF[5] (RW)
 *
 * Configures the ADC to operate in differential mode. When enabled, this mode
 * automatically selects from the differential channels, and changes the
 * conversion algorithm and the number of cycles to complete a conversion.
 *
 * Values:
 * - 0 - Single-ended conversions and input channels are selected.
 * - 1 - Differential conversions and input channels are selected.
 */
/*@{*/
#define BP_ADC_SC1n_DIFF     (5U)          /*!< Bit position for ADC_SC1n_DIFF. */
#define BM_ADC_SC1n_DIFF     (0x00000020U) /*!< Bit mask for ADC_SC1n_DIFF. */
#define BS_ADC_SC1n_DIFF     (1U)          /*!< Bit field size in bits for ADC_SC1n_DIFF. */

/*! @brief Read current value of the ADC_SC1n_DIFF field. */
#define BR_ADC_SC1n_DIFF(x, n) (BME_UBFX32(HW_ADC_SC1n_ADDR(x, n), BP_ADC_SC1n_DIFF, BS_ADC_SC1n_DIFF))

/*! @brief Format value for bitfield ADC_SC1n_DIFF. */
#define BF_ADC_SC1n_DIFF(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_SC1n_DIFF) & BM_ADC_SC1n_DIFF)

/*! @brief Set the DIFF field to a new value. */
#define BW_ADC_SC1n_DIFF(x, n, v) (BME_BFI32(HW_ADC_SC1n_ADDR(x, n), ((uint32_t)(v) << BP_ADC_SC1n_DIFF), BP_ADC_SC1n_DIFF, 1))
/*@}*/

/*!
 * @name Register ADC_SC1n, field AIEN[6] (RW)
 *
 * Enables conversion complete interrupts. When COCO becomes set while the
 * respective AIEN is high, an interrupt is asserted.
 *
 * Values:
 * - 0 - Conversion complete interrupt is disabled.
 * - 1 - Conversion complete interrupt is enabled.
 */
/*@{*/
#define BP_ADC_SC1n_AIEN     (6U)          /*!< Bit position for ADC_SC1n_AIEN. */
#define BM_ADC_SC1n_AIEN     (0x00000040U) /*!< Bit mask for ADC_SC1n_AIEN. */
#define BS_ADC_SC1n_AIEN     (1U)          /*!< Bit field size in bits for ADC_SC1n_AIEN. */

/*! @brief Read current value of the ADC_SC1n_AIEN field. */
#define BR_ADC_SC1n_AIEN(x, n) (BME_UBFX32(HW_ADC_SC1n_ADDR(x, n), BP_ADC_SC1n_AIEN, BS_ADC_SC1n_AIEN))

/*! @brief Format value for bitfield ADC_SC1n_AIEN. */
#define BF_ADC_SC1n_AIEN(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_SC1n_AIEN) & BM_ADC_SC1n_AIEN)

/*! @brief Set the AIEN field to a new value. */
#define BW_ADC_SC1n_AIEN(x, n, v) (BME_BFI32(HW_ADC_SC1n_ADDR(x, n), ((uint32_t)(v) << BP_ADC_SC1n_AIEN), BP_ADC_SC1n_AIEN, 1))
/*@}*/

/*!
 * @name Register ADC_SC1n, field COCO[7] (RO)
 *
 * This is a read-only field that is set each time a conversion is completed
 * when the compare function is disabled, or SC2[ACFE]=0 and the hardware average
 * function is disabled, or SC3[AVGE]=0. When the compare function is enabled, or
 * SC2[ACFE]=1, COCO is set upon completion of a conversion only if the compare
 * result is true. When the hardware average function is enabled, or SC3[AVGE]=1,
 * COCO is set upon completion of the selected number of conversions (determined
 * by AVGS). COCO in SC1A is also set at the completion of a calibration sequence.
 * COCO is cleared when the respective SC1n register is written or when the
 * respective Rn register is read.
 *
 * Values:
 * - 0 - Conversion is not completed.
 * - 1 - Conversion is completed.
 */
/*@{*/
#define BP_ADC_SC1n_COCO     (7U)          /*!< Bit position for ADC_SC1n_COCO. */
#define BM_ADC_SC1n_COCO     (0x00000080U) /*!< Bit mask for ADC_SC1n_COCO. */
#define BS_ADC_SC1n_COCO     (1U)          /*!< Bit field size in bits for ADC_SC1n_COCO. */

/*! @brief Read current value of the ADC_SC1n_COCO field. */
#define BR_ADC_SC1n_COCO(x, n) (BME_UBFX32(HW_ADC_SC1n_ADDR(x, n), BP_ADC_SC1n_COCO, BS_ADC_SC1n_COCO))
/*@}*/

/*******************************************************************************
 * HW_ADC_CFG1 - ADC Configuration Register 1
 ******************************************************************************/

/*!
 * @brief HW_ADC_CFG1 - ADC Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The configuration Register 1 (CFG1) selects the mode of operation, clock
 * source, clock divide, and configuration for low power or long sample time.
 */
typedef union _hw_adc_cfg1
{
    uint32_t U;
    struct _hw_adc_cfg1_bitfields
    {
        uint32_t ADICLK : 2;           /*!< [1:0] Input Clock Select */
        uint32_t MODE : 2;             /*!< [3:2] Conversion mode selection */
        uint32_t ADLSMP : 1;           /*!< [4] Sample Time Configuration */
        uint32_t ADIV : 2;             /*!< [6:5] Clock Divide Select */
        uint32_t ADLPC : 1;            /*!< [7] Low-Power Configuration */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_adc_cfg1_t;

/*!
 * @name Constants and macros for entire ADC_CFG1 register
 */
/*@{*/
#define HW_ADC_CFG1_ADDR(x)      ((uint32_t)(x) + 0x8U)

#define HW_ADC_CFG1(x)           (*(__IO hw_adc_cfg1_t *) HW_ADC_CFG1_ADDR(x))
#define HW_ADC_CFG1_RD(x)        (HW_ADC_CFG1(x).U)
#define HW_ADC_CFG1_WR(x, v)     (HW_ADC_CFG1(x).U = (v))
#define HW_ADC_CFG1_SET(x, v)    (BME_OR32(HW_ADC_CFG1_ADDR(x), (uint32_t)(v)))
#define HW_ADC_CFG1_CLR(x, v)    (BME_AND32(HW_ADC_CFG1_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_CFG1_TOG(x, v)    (BME_XOR32(HW_ADC_CFG1_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG1 bitfields
 */

/*!
 * @name Register ADC_CFG1, field ADICLK[1:0] (RW)
 *
 * Selects the input clock source to generate the internal clock, ADCK. Note
 * that when the ADACK clock source is selected, it is not required to be active
 * prior to conversion start. When it is selected and it is not active prior to a
 * conversion start, when CFG2[ADACKEN]=0, the asynchronous clock is activated at
 * the start of a conversion and deactivated when conversions are terminated. In
 * this case, there is an associated clock startup delay each time the clock
 * source is re-activated.
 *
 * Values:
 * - 00 - Bus clock
 * - 01 - Bus clock divided by 2(BUSCLK/DIV2)
 * - 10 - Alternate clock (ALTCLK)
 * - 11 - Asynchronous clock (ADACK)
 */
/*@{*/
#define BP_ADC_CFG1_ADICLK   (0U)          /*!< Bit position for ADC_CFG1_ADICLK. */
#define BM_ADC_CFG1_ADICLK   (0x00000003U) /*!< Bit mask for ADC_CFG1_ADICLK. */
#define BS_ADC_CFG1_ADICLK   (2U)          /*!< Bit field size in bits for ADC_CFG1_ADICLK. */

/*! @brief Read current value of the ADC_CFG1_ADICLK field. */
#define BR_ADC_CFG1_ADICLK(x) (BME_UBFX32(HW_ADC_CFG1_ADDR(x), BP_ADC_CFG1_ADICLK, BS_ADC_CFG1_ADICLK))

/*! @brief Format value for bitfield ADC_CFG1_ADICLK. */
#define BF_ADC_CFG1_ADICLK(v) ((uint32_t)((uint32_t)(v) << BP_ADC_CFG1_ADICLK) & BM_ADC_CFG1_ADICLK)

/*! @brief Set the ADICLK field to a new value. */
#define BW_ADC_CFG1_ADICLK(x, v) (BME_BFI32(HW_ADC_CFG1_ADDR(x), ((uint32_t)(v) << BP_ADC_CFG1_ADICLK), BP_ADC_CFG1_ADICLK, 2))
/*@}*/

/*!
 * @name Register ADC_CFG1, field MODE[3:2] (RW)
 *
 * Selects the ADC resolution mode.
 *
 * Values:
 * - 00 - When DIFF=0:It is single-ended 8-bit conversion; when DIFF=1, it is
 *     differential 9-bit conversion with 2's complement output.
 * - 01 - When DIFF=0:It is single-ended 12-bit conversion ; when DIFF=1, it is
 *     differential 13-bit conversion with 2's complement output.
 * - 10 - When DIFF=0:It is single-ended 10-bit conversion. ; when DIFF=1, it is
 *     differential 11-bit conversion with 2's complement output
 * - 11 - When DIFF=0:It is single-ended 16-bit conversion..; when DIFF=1, it is
 *     differential 16-bit conversion with 2's complement output
 */
/*@{*/
#define BP_ADC_CFG1_MODE     (2U)          /*!< Bit position for ADC_CFG1_MODE. */
#define BM_ADC_CFG1_MODE     (0x0000000CU) /*!< Bit mask for ADC_CFG1_MODE. */
#define BS_ADC_CFG1_MODE     (2U)          /*!< Bit field size in bits for ADC_CFG1_MODE. */

/*! @brief Read current value of the ADC_CFG1_MODE field. */
#define BR_ADC_CFG1_MODE(x)  (BME_UBFX32(HW_ADC_CFG1_ADDR(x), BP_ADC_CFG1_MODE, BS_ADC_CFG1_MODE))

/*! @brief Format value for bitfield ADC_CFG1_MODE. */
#define BF_ADC_CFG1_MODE(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CFG1_MODE) & BM_ADC_CFG1_MODE)

/*! @brief Set the MODE field to a new value. */
#define BW_ADC_CFG1_MODE(x, v) (BME_BFI32(HW_ADC_CFG1_ADDR(x), ((uint32_t)(v) << BP_ADC_CFG1_MODE), BP_ADC_CFG1_MODE, 2))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADLSMP[4] (RW)
 *
 * Selects between different sample times based on the conversion mode selected.
 * This field adjusts the sample period to allow higher impedance inputs to be
 * accurately sampled or to maximize conversion speed for lower impedance inputs.
 * Longer sample times can also be used to lower overall power consumption if
 * continuous conversions are enabled and high conversion rates are not required.
 * When ADLSMP=1, the long sample time select bits, (ADLSTS[1:0]), can select the
 * extent of the long sample time.
 *
 * Values:
 * - 0 - Short sample time.
 * - 1 - Long sample time.
 */
/*@{*/
#define BP_ADC_CFG1_ADLSMP   (4U)          /*!< Bit position for ADC_CFG1_ADLSMP. */
#define BM_ADC_CFG1_ADLSMP   (0x00000010U) /*!< Bit mask for ADC_CFG1_ADLSMP. */
#define BS_ADC_CFG1_ADLSMP   (1U)          /*!< Bit field size in bits for ADC_CFG1_ADLSMP. */

/*! @brief Read current value of the ADC_CFG1_ADLSMP field. */
#define BR_ADC_CFG1_ADLSMP(x) (BME_UBFX32(HW_ADC_CFG1_ADDR(x), BP_ADC_CFG1_ADLSMP, BS_ADC_CFG1_ADLSMP))

/*! @brief Format value for bitfield ADC_CFG1_ADLSMP. */
#define BF_ADC_CFG1_ADLSMP(v) ((uint32_t)((uint32_t)(v) << BP_ADC_CFG1_ADLSMP) & BM_ADC_CFG1_ADLSMP)

/*! @brief Set the ADLSMP field to a new value. */
#define BW_ADC_CFG1_ADLSMP(x, v) (BME_BFI32(HW_ADC_CFG1_ADDR(x), ((uint32_t)(v) << BP_ADC_CFG1_ADLSMP), BP_ADC_CFG1_ADLSMP, 1))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADIV[6:5] (RW)
 *
 * Selects the divide ratio used by the ADC to generate the internal clock ADCK.
 *
 * Values:
 * - 00 - The divide ratio is 1 and the clock rate is input clock.
 * - 01 - The divide ratio is 2 and the clock rate is (input clock)/2.
 * - 10 - The divide ratio is 4 and the clock rate is (input clock)/4.
 * - 11 - The divide ratio is 8 and the clock rate is (input clock)/8.
 */
/*@{*/
#define BP_ADC_CFG1_ADIV     (5U)          /*!< Bit position for ADC_CFG1_ADIV. */
#define BM_ADC_CFG1_ADIV     (0x00000060U) /*!< Bit mask for ADC_CFG1_ADIV. */
#define BS_ADC_CFG1_ADIV     (2U)          /*!< Bit field size in bits for ADC_CFG1_ADIV. */

/*! @brief Read current value of the ADC_CFG1_ADIV field. */
#define BR_ADC_CFG1_ADIV(x)  (BME_UBFX32(HW_ADC_CFG1_ADDR(x), BP_ADC_CFG1_ADIV, BS_ADC_CFG1_ADIV))

/*! @brief Format value for bitfield ADC_CFG1_ADIV. */
#define BF_ADC_CFG1_ADIV(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CFG1_ADIV) & BM_ADC_CFG1_ADIV)

/*! @brief Set the ADIV field to a new value. */
#define BW_ADC_CFG1_ADIV(x, v) (BME_BFI32(HW_ADC_CFG1_ADDR(x), ((uint32_t)(v) << BP_ADC_CFG1_ADIV), BP_ADC_CFG1_ADIV, 2))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADLPC[7] (RW)
 *
 * Controls the power configuration of the successive approximation converter.
 * This optimizes power consumption when higher sample rates are not required.
 *
 * Values:
 * - 0 - Normal power configuration.
 * - 1 - Low-power configuration. The power is reduced at the expense of maximum
 *     clock speed.
 */
/*@{*/
#define BP_ADC_CFG1_ADLPC    (7U)          /*!< Bit position for ADC_CFG1_ADLPC. */
#define BM_ADC_CFG1_ADLPC    (0x00000080U) /*!< Bit mask for ADC_CFG1_ADLPC. */
#define BS_ADC_CFG1_ADLPC    (1U)          /*!< Bit field size in bits for ADC_CFG1_ADLPC. */

/*! @brief Read current value of the ADC_CFG1_ADLPC field. */
#define BR_ADC_CFG1_ADLPC(x) (BME_UBFX32(HW_ADC_CFG1_ADDR(x), BP_ADC_CFG1_ADLPC, BS_ADC_CFG1_ADLPC))

/*! @brief Format value for bitfield ADC_CFG1_ADLPC. */
#define BF_ADC_CFG1_ADLPC(v) ((uint32_t)((uint32_t)(v) << BP_ADC_CFG1_ADLPC) & BM_ADC_CFG1_ADLPC)

/*! @brief Set the ADLPC field to a new value. */
#define BW_ADC_CFG1_ADLPC(x, v) (BME_BFI32(HW_ADC_CFG1_ADDR(x), ((uint32_t)(v) << BP_ADC_CFG1_ADLPC), BP_ADC_CFG1_ADLPC, 1))
/*@}*/

/*******************************************************************************
 * HW_ADC_CFG2 - ADC Configuration Register 2
 ******************************************************************************/

/*!
 * @brief HW_ADC_CFG2 - ADC Configuration Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Configuration Register 2 (CFG2) selects the special high-speed configuration
 * for very high speed conversions and selects the long sample time duration
 * during long sample mode.
 */
typedef union _hw_adc_cfg2
{
    uint32_t U;
    struct _hw_adc_cfg2_bitfields
    {
        uint32_t ADLSTS : 2;           /*!< [1:0] Long Sample Time Select */
        uint32_t ADHSC : 1;            /*!< [2] High-Speed Configuration */
        uint32_t ADACKEN : 1;          /*!< [3] Asynchronous Clock Output Enable */
        uint32_t MUXSEL : 1;           /*!< [4] ADC Mux Select */
        uint32_t RESERVED0 : 27;       /*!< [31:5]  */
    } B;
} hw_adc_cfg2_t;

/*!
 * @name Constants and macros for entire ADC_CFG2 register
 */
/*@{*/
#define HW_ADC_CFG2_ADDR(x)      ((uint32_t)(x) + 0xCU)

#define HW_ADC_CFG2(x)           (*(__IO hw_adc_cfg2_t *) HW_ADC_CFG2_ADDR(x))
#define HW_ADC_CFG2_RD(x)        (HW_ADC_CFG2(x).U)
#define HW_ADC_CFG2_WR(x, v)     (HW_ADC_CFG2(x).U = (v))
#define HW_ADC_CFG2_SET(x, v)    (BME_OR32(HW_ADC_CFG2_ADDR(x), (uint32_t)(v)))
#define HW_ADC_CFG2_CLR(x, v)    (BME_AND32(HW_ADC_CFG2_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_CFG2_TOG(x, v)    (BME_XOR32(HW_ADC_CFG2_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG2 bitfields
 */

/*!
 * @name Register ADC_CFG2, field ADLSTS[1:0] (RW)
 *
 * Selects between the extended sample times when long sample time is selected,
 * that is, when CFG1[ADLSMP]=1. This allows higher impedance inputs to be
 * accurately sampled or to maximize conversion speed for lower impedance inputs.
 * Longer sample times can also be used to lower overall power consumption when
 * continuous conversions are enabled if high conversion rates are not required.
 *
 * Values:
 * - 00 - Default longest sample time; 20 extra ADCK cycles; 24 ADCK cycles
 *     total.
 * - 01 - 12 extra ADCK cycles; 16 ADCK cycles total sample time.
 * - 10 - 6 extra ADCK cycles; 10 ADCK cycles total sample time.
 * - 11 - 2 extra ADCK cycles; 6 ADCK cycles total sample time.
 */
/*@{*/
#define BP_ADC_CFG2_ADLSTS   (0U)          /*!< Bit position for ADC_CFG2_ADLSTS. */
#define BM_ADC_CFG2_ADLSTS   (0x00000003U) /*!< Bit mask for ADC_CFG2_ADLSTS. */
#define BS_ADC_CFG2_ADLSTS   (2U)          /*!< Bit field size in bits for ADC_CFG2_ADLSTS. */

/*! @brief Read current value of the ADC_CFG2_ADLSTS field. */
#define BR_ADC_CFG2_ADLSTS(x) (BME_UBFX32(HW_ADC_CFG2_ADDR(x), BP_ADC_CFG2_ADLSTS, BS_ADC_CFG2_ADLSTS))

/*! @brief Format value for bitfield ADC_CFG2_ADLSTS. */
#define BF_ADC_CFG2_ADLSTS(v) ((uint32_t)((uint32_t)(v) << BP_ADC_CFG2_ADLSTS) & BM_ADC_CFG2_ADLSTS)

/*! @brief Set the ADLSTS field to a new value. */
#define BW_ADC_CFG2_ADLSTS(x, v) (BME_BFI32(HW_ADC_CFG2_ADDR(x), ((uint32_t)(v) << BP_ADC_CFG2_ADLSTS), BP_ADC_CFG2_ADLSTS, 2))
/*@}*/

/*!
 * @name Register ADC_CFG2, field ADHSC[2] (RW)
 *
 * Configures the ADC for very high-speed operation. The conversion sequence is
 * altered with 2 ADCK cycles added to the conversion time to allow higher speed
 * conversion clocks.
 *
 * Values:
 * - 0 - Normal conversion sequence selected.
 * - 1 - High-speed conversion sequence selected with 2 additional ADCK cycles
 *     to total conversion time.
 */
/*@{*/
#define BP_ADC_CFG2_ADHSC    (2U)          /*!< Bit position for ADC_CFG2_ADHSC. */
#define BM_ADC_CFG2_ADHSC    (0x00000004U) /*!< Bit mask for ADC_CFG2_ADHSC. */
#define BS_ADC_CFG2_ADHSC    (1U)          /*!< Bit field size in bits for ADC_CFG2_ADHSC. */

/*! @brief Read current value of the ADC_CFG2_ADHSC field. */
#define BR_ADC_CFG2_ADHSC(x) (BME_UBFX32(HW_ADC_CFG2_ADDR(x), BP_ADC_CFG2_ADHSC, BS_ADC_CFG2_ADHSC))

/*! @brief Format value for bitfield ADC_CFG2_ADHSC. */
#define BF_ADC_CFG2_ADHSC(v) ((uint32_t)((uint32_t)(v) << BP_ADC_CFG2_ADHSC) & BM_ADC_CFG2_ADHSC)

/*! @brief Set the ADHSC field to a new value. */
#define BW_ADC_CFG2_ADHSC(x, v) (BME_BFI32(HW_ADC_CFG2_ADDR(x), ((uint32_t)(v) << BP_ADC_CFG2_ADHSC), BP_ADC_CFG2_ADHSC, 1))
/*@}*/

/*!
 * @name Register ADC_CFG2, field ADACKEN[3] (RW)
 *
 * Enables the asynchronous clock source and the clock source output regardless
 * of the conversion and status of CFG1[ADICLK]. Based on MCU configuration, the
 * asynchronous clock may be used by other modules. See chip configuration
 * information. Setting this field allows the clock to be used even while the ADC is
 * idle or operating from a different clock source. Also, latency of initiating a
 * single or first-continuous conversion with the asynchronous clock selected is
 * reduced because the ADACK clock is already operational.
 *
 * Values:
 * - 0 - Asynchronous clock output disabled; Asynchronous clock is enabled only
 *     if selected by ADICLK and a conversion is active.
 * - 1 - Asynchronous clock and clock output is enabled regardless of the state
 *     of the ADC.
 */
/*@{*/
#define BP_ADC_CFG2_ADACKEN  (3U)          /*!< Bit position for ADC_CFG2_ADACKEN. */
#define BM_ADC_CFG2_ADACKEN  (0x00000008U) /*!< Bit mask for ADC_CFG2_ADACKEN. */
#define BS_ADC_CFG2_ADACKEN  (1U)          /*!< Bit field size in bits for ADC_CFG2_ADACKEN. */

/*! @brief Read current value of the ADC_CFG2_ADACKEN field. */
#define BR_ADC_CFG2_ADACKEN(x) (BME_UBFX32(HW_ADC_CFG2_ADDR(x), BP_ADC_CFG2_ADACKEN, BS_ADC_CFG2_ADACKEN))

/*! @brief Format value for bitfield ADC_CFG2_ADACKEN. */
#define BF_ADC_CFG2_ADACKEN(v) ((uint32_t)((uint32_t)(v) << BP_ADC_CFG2_ADACKEN) & BM_ADC_CFG2_ADACKEN)

/*! @brief Set the ADACKEN field to a new value. */
#define BW_ADC_CFG2_ADACKEN(x, v) (BME_BFI32(HW_ADC_CFG2_ADDR(x), ((uint32_t)(v) << BP_ADC_CFG2_ADACKEN), BP_ADC_CFG2_ADACKEN, 1))
/*@}*/

/*!
 * @name Register ADC_CFG2, field MUXSEL[4] (RW)
 *
 * Changes the ADC mux setting to select between alternate sets of ADC channels.
 *
 * Values:
 * - 0 - ADxxa channels are selected.
 * - 1 - ADxxb channels are selected.
 */
/*@{*/
#define BP_ADC_CFG2_MUXSEL   (4U)          /*!< Bit position for ADC_CFG2_MUXSEL. */
#define BM_ADC_CFG2_MUXSEL   (0x00000010U) /*!< Bit mask for ADC_CFG2_MUXSEL. */
#define BS_ADC_CFG2_MUXSEL   (1U)          /*!< Bit field size in bits for ADC_CFG2_MUXSEL. */

/*! @brief Read current value of the ADC_CFG2_MUXSEL field. */
#define BR_ADC_CFG2_MUXSEL(x) (BME_UBFX32(HW_ADC_CFG2_ADDR(x), BP_ADC_CFG2_MUXSEL, BS_ADC_CFG2_MUXSEL))

/*! @brief Format value for bitfield ADC_CFG2_MUXSEL. */
#define BF_ADC_CFG2_MUXSEL(v) ((uint32_t)((uint32_t)(v) << BP_ADC_CFG2_MUXSEL) & BM_ADC_CFG2_MUXSEL)

/*! @brief Set the MUXSEL field to a new value. */
#define BW_ADC_CFG2_MUXSEL(x, v) (BME_BFI32(HW_ADC_CFG2_ADDR(x), ((uint32_t)(v) << BP_ADC_CFG2_MUXSEL), BP_ADC_CFG2_MUXSEL, 1))
/*@}*/

/*******************************************************************************
 * HW_ADC_Rn - ADC Data Result Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_Rn - ADC Data Result Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The data result registers (Rn) contain the result of an ADC conversion of the
 * channel selected by the corresponding status and channel control register
 * (SC1A:SC1n). For every status and channel control register, there is a
 * corresponding data result register. Unused bits in R n are cleared in unsigned
 * right-aligned modes and carry the sign bit (MSB) in sign-extended 2's complement modes.
 * For example, when configured for 10-bit single-ended mode, D[15:10] are
 * cleared. When configured for 11-bit differential mode, D[15:10] carry the sign bit,
 * that is, bit 10 extended through bit 15. The following table describes the
 * behavior of the data result registers in the different modes of operation. Data
 * result register description Conversion mode D15 D14 D13 D12 D11 D10 D9 D8 D7
 * D6 D5 D4 D3 D2 D1 D0 Format 16-bit differential S D D D D D D D D D D D D D D D
 * Signed 2's complement 16-bit single-ended D D D D D D D D D D D D D D D D
 * Unsigned right justified 13-bit differential S S S S D D D D D D D D D D D D
 * Sign-extended 2's complement 12-bit single-ended 0 0 0 0 D D D D D D D D D D D D
 * Unsigned right-justified 11-bit differential S S S S S S D D D D D D D D D D
 * Sign-extended 2's complement 10-bit single-ended 0 0 0 0 0 0 D D D D D D D D D D
 * Unsigned right-justified 9-bit differential S S S S S S S S D D D D D D D D
 * Sign-extended 2's complement 8-bit single-ended 0 0 0 0 0 0 0 0 D D D D D D D D
 * Unsigned right-justified S: Sign bit or sign bit extension; D: Data, which is
 * 2's complement data if indicated
 */
typedef union _hw_adc_rn
{
    uint32_t U;
    struct _hw_adc_rn_bitfields
    {
        uint32_t D : 16;               /*!< [15:0] Data result */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_adc_rn_t;

/*!
 * @name Constants and macros for entire ADC_Rn register
 */
/*@{*/
#define HW_ADC_Rn_COUNT (2U)

#define HW_ADC_Rn_ADDR(x, n)     ((uint32_t)(x) + 0x10U + (0x4U * (n)))

#define HW_ADC_Rn(x, n)          (*(__I hw_adc_rn_t *) HW_ADC_Rn_ADDR(x, n))
#define HW_ADC_Rn_RD(x, n)       (HW_ADC_Rn(x, n).U)
/*@}*/

/*
 * Constants & macros for individual ADC_Rn bitfields
 */

/*!
 * @name Register ADC_Rn, field D[15:0] (RO)
 */
/*@{*/
#define BP_ADC_Rn_D          (0U)          /*!< Bit position for ADC_Rn_D. */
#define BM_ADC_Rn_D          (0x0000FFFFU) /*!< Bit mask for ADC_Rn_D. */
#define BS_ADC_Rn_D          (16U)         /*!< Bit field size in bits for ADC_Rn_D. */

/*! @brief Read current value of the ADC_Rn_D field. */
#define BR_ADC_Rn_D(x, n)    (BME_UBFX32(HW_ADC_Rn_ADDR(x, n), BP_ADC_Rn_D, BS_ADC_Rn_D))
/*@}*/

/*******************************************************************************
 * HW_ADC_CV1 - Compare Value Registers
 ******************************************************************************/

/*!
 * @brief HW_ADC_CV1 - Compare Value Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Compare Value Registers (CV1 and CV2) contain a compare value used to
 * compare the conversion result when the compare function is enabled, that is,
 * SC2[ACFE]=1. This register is formatted in the same way as the Rn registers in
 * different modes of operation for both bit position definition and value format
 * using unsigned or sign-extended 2's complement. Therefore, the compare function
 * uses only the CVn fields that are related to the ADC mode of operation. The
 * compare value 2 register (CV2) is used only when the compare range function is
 * enabled, that is, SC2[ACREN]=1.
 */
typedef union _hw_adc_cv1
{
    uint32_t U;
    struct _hw_adc_cv1_bitfields
    {
        uint32_t CV : 16;              /*!< [15:0] Compare Value. */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_adc_cv1_t;

/*!
 * @name Constants and macros for entire ADC_CV1 register
 */
/*@{*/
#define HW_ADC_CV1_ADDR(x)       ((uint32_t)(x) + 0x18U)

#define HW_ADC_CV1(x)            (*(__IO hw_adc_cv1_t *) HW_ADC_CV1_ADDR(x))
#define HW_ADC_CV1_RD(x)         (HW_ADC_CV1(x).U)
#define HW_ADC_CV1_WR(x, v)      (HW_ADC_CV1(x).U = (v))
#define HW_ADC_CV1_SET(x, v)     (BME_OR32(HW_ADC_CV1_ADDR(x), (uint32_t)(v)))
#define HW_ADC_CV1_CLR(x, v)     (BME_AND32(HW_ADC_CV1_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_CV1_TOG(x, v)     (BME_XOR32(HW_ADC_CV1_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CV1 bitfields
 */

/*!
 * @name Register ADC_CV1, field CV[15:0] (RW)
 */
/*@{*/
#define BP_ADC_CV1_CV        (0U)          /*!< Bit position for ADC_CV1_CV. */
#define BM_ADC_CV1_CV        (0x0000FFFFU) /*!< Bit mask for ADC_CV1_CV. */
#define BS_ADC_CV1_CV        (16U)         /*!< Bit field size in bits for ADC_CV1_CV. */

/*! @brief Read current value of the ADC_CV1_CV field. */
#define BR_ADC_CV1_CV(x)     (BME_UBFX32(HW_ADC_CV1_ADDR(x), BP_ADC_CV1_CV, BS_ADC_CV1_CV))

/*! @brief Format value for bitfield ADC_CV1_CV. */
#define BF_ADC_CV1_CV(v)     ((uint32_t)((uint32_t)(v) << BP_ADC_CV1_CV) & BM_ADC_CV1_CV)

/*! @brief Set the CV field to a new value. */
#define BW_ADC_CV1_CV(x, v)  (BME_BFI32(HW_ADC_CV1_ADDR(x), ((uint32_t)(v) << BP_ADC_CV1_CV), BP_ADC_CV1_CV, 16))
/*@}*/

/*******************************************************************************
 * HW_ADC_CV2 - Compare Value Registers
 ******************************************************************************/

/*!
 * @brief HW_ADC_CV2 - Compare Value Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Compare Value Registers (CV1 and CV2) contain a compare value used to
 * compare the conversion result when the compare function is enabled, that is,
 * SC2[ACFE]=1. This register is formatted in the same way as the Rn registers in
 * different modes of operation for both bit position definition and value format
 * using unsigned or sign-extended 2's complement. Therefore, the compare function
 * uses only the CVn fields that are related to the ADC mode of operation. The
 * compare value 2 register (CV2) is used only when the compare range function is
 * enabled, that is, SC2[ACREN]=1.
 */
typedef union _hw_adc_cv2
{
    uint32_t U;
    struct _hw_adc_cv2_bitfields
    {
        uint32_t CV : 16;              /*!< [15:0] Compare Value. */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_adc_cv2_t;

/*!
 * @name Constants and macros for entire ADC_CV2 register
 */
/*@{*/
#define HW_ADC_CV2_ADDR(x)       ((uint32_t)(x) + 0x1CU)

#define HW_ADC_CV2(x)            (*(__IO hw_adc_cv2_t *) HW_ADC_CV2_ADDR(x))
#define HW_ADC_CV2_RD(x)         (HW_ADC_CV2(x).U)
#define HW_ADC_CV2_WR(x, v)      (HW_ADC_CV2(x).U = (v))
#define HW_ADC_CV2_SET(x, v)     (BME_OR32(HW_ADC_CV2_ADDR(x), (uint32_t)(v)))
#define HW_ADC_CV2_CLR(x, v)     (BME_AND32(HW_ADC_CV2_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_CV2_TOG(x, v)     (BME_XOR32(HW_ADC_CV2_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CV2 bitfields
 */

/*!
 * @name Register ADC_CV2, field CV[15:0] (RW)
 */
/*@{*/
#define BP_ADC_CV2_CV        (0U)          /*!< Bit position for ADC_CV2_CV. */
#define BM_ADC_CV2_CV        (0x0000FFFFU) /*!< Bit mask for ADC_CV2_CV. */
#define BS_ADC_CV2_CV        (16U)         /*!< Bit field size in bits for ADC_CV2_CV. */

/*! @brief Read current value of the ADC_CV2_CV field. */
#define BR_ADC_CV2_CV(x)     (BME_UBFX32(HW_ADC_CV2_ADDR(x), BP_ADC_CV2_CV, BS_ADC_CV2_CV))

/*! @brief Format value for bitfield ADC_CV2_CV. */
#define BF_ADC_CV2_CV(v)     ((uint32_t)((uint32_t)(v) << BP_ADC_CV2_CV) & BM_ADC_CV2_CV)

/*! @brief Set the CV field to a new value. */
#define BW_ADC_CV2_CV(x, v)  (BME_BFI32(HW_ADC_CV2_ADDR(x), ((uint32_t)(v) << BP_ADC_CV2_CV), BP_ADC_CV2_CV, 16))
/*@}*/

/*******************************************************************************
 * HW_ADC_SC2 - Status and Control Register 2
 ******************************************************************************/

/*!
 * @brief HW_ADC_SC2 - Status and Control Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The status and control register 2 (SC2) contains the conversion active,
 * hardware/software trigger select, compare function, and voltage reference select of
 * the ADC module.
 */
typedef union _hw_adc_sc2
{
    uint32_t U;
    struct _hw_adc_sc2_bitfields
    {
        uint32_t REFSEL : 2;           /*!< [1:0] Voltage Reference Selection */
        uint32_t DMAEN : 1;            /*!< [2] DMA Enable */
        uint32_t ACREN : 1;            /*!< [3] Compare Function Range Enable */
        uint32_t ACFGT : 1;            /*!< [4] Compare Function Greater Than Enable */
        uint32_t ACFE : 1;             /*!< [5] Compare Function Enable */
        uint32_t ADTRG : 1;            /*!< [6] Conversion Trigger Select */
        uint32_t ADACT : 1;            /*!< [7] Conversion Active */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_adc_sc2_t;

/*!
 * @name Constants and macros for entire ADC_SC2 register
 */
/*@{*/
#define HW_ADC_SC2_ADDR(x)       ((uint32_t)(x) + 0x20U)

#define HW_ADC_SC2(x)            (*(__IO hw_adc_sc2_t *) HW_ADC_SC2_ADDR(x))
#define HW_ADC_SC2_RD(x)         (HW_ADC_SC2(x).U)
#define HW_ADC_SC2_WR(x, v)      (HW_ADC_SC2(x).U = (v))
#define HW_ADC_SC2_SET(x, v)     (BME_OR32(HW_ADC_SC2_ADDR(x), (uint32_t)(v)))
#define HW_ADC_SC2_CLR(x, v)     (BME_AND32(HW_ADC_SC2_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_SC2_TOG(x, v)     (BME_XOR32(HW_ADC_SC2_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC2 bitfields
 */

/*!
 * @name Register ADC_SC2, field REFSEL[1:0] (RW)
 *
 * Selects the voltage reference source used for conversions.
 *
 * Values:
 * - 00 - Default voltage reference pin pair, that is, external pins VREFH and
 *     VREFL
 * - 01 - Alternate reference pair, that is, VALTH and VALTL . This pair may be
 *     additional external pins or internal sources depending on the MCU
 *     configuration. See the chip configuration information for details specific to this
 *     MCU
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
#define BP_ADC_SC2_REFSEL    (0U)          /*!< Bit position for ADC_SC2_REFSEL. */
#define BM_ADC_SC2_REFSEL    (0x00000003U) /*!< Bit mask for ADC_SC2_REFSEL. */
#define BS_ADC_SC2_REFSEL    (2U)          /*!< Bit field size in bits for ADC_SC2_REFSEL. */

/*! @brief Read current value of the ADC_SC2_REFSEL field. */
#define BR_ADC_SC2_REFSEL(x) (BME_UBFX32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_REFSEL, BS_ADC_SC2_REFSEL))

/*! @brief Format value for bitfield ADC_SC2_REFSEL. */
#define BF_ADC_SC2_REFSEL(v) ((uint32_t)((uint32_t)(v) << BP_ADC_SC2_REFSEL) & BM_ADC_SC2_REFSEL)

/*! @brief Set the REFSEL field to a new value. */
#define BW_ADC_SC2_REFSEL(x, v) (BME_BFI32(HW_ADC_SC2_ADDR(x), ((uint32_t)(v) << BP_ADC_SC2_REFSEL), BP_ADC_SC2_REFSEL, 2))
/*@}*/

/*!
 * @name Register ADC_SC2, field DMAEN[2] (RW)
 *
 * Values:
 * - 0 - DMA is disabled.
 * - 1 - DMA is enabled and will assert the ADC DMA request during an ADC
 *     conversion complete event noted when any of the SC1n[COCO] flags is asserted.
 */
/*@{*/
#define BP_ADC_SC2_DMAEN     (2U)          /*!< Bit position for ADC_SC2_DMAEN. */
#define BM_ADC_SC2_DMAEN     (0x00000004U) /*!< Bit mask for ADC_SC2_DMAEN. */
#define BS_ADC_SC2_DMAEN     (1U)          /*!< Bit field size in bits for ADC_SC2_DMAEN. */

/*! @brief Read current value of the ADC_SC2_DMAEN field. */
#define BR_ADC_SC2_DMAEN(x)  (BME_UBFX32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_DMAEN, BS_ADC_SC2_DMAEN))

/*! @brief Format value for bitfield ADC_SC2_DMAEN. */
#define BF_ADC_SC2_DMAEN(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_SC2_DMAEN) & BM_ADC_SC2_DMAEN)

/*! @brief Set the DMAEN field to a new value. */
#define BW_ADC_SC2_DMAEN(x, v) (BME_BFI32(HW_ADC_SC2_ADDR(x), ((uint32_t)(v) << BP_ADC_SC2_DMAEN), BP_ADC_SC2_DMAEN, 1))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACREN[3] (RW)
 *
 * Configures the compare function to check if the conversion result of the
 * input being monitored is either between or outside the range formed by CV1 and CV2
 * determined by the value of ACFGT. ACFE must be set for ACFGT to have any
 * effect.
 *
 * Values:
 * - 0 - Range function disabled. Only CV1 is compared.
 * - 1 - Range function enabled. Both CV1 and CV2 are compared.
 */
/*@{*/
#define BP_ADC_SC2_ACREN     (3U)          /*!< Bit position for ADC_SC2_ACREN. */
#define BM_ADC_SC2_ACREN     (0x00000008U) /*!< Bit mask for ADC_SC2_ACREN. */
#define BS_ADC_SC2_ACREN     (1U)          /*!< Bit field size in bits for ADC_SC2_ACREN. */

/*! @brief Read current value of the ADC_SC2_ACREN field. */
#define BR_ADC_SC2_ACREN(x)  (BME_UBFX32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ACREN, BS_ADC_SC2_ACREN))

/*! @brief Format value for bitfield ADC_SC2_ACREN. */
#define BF_ADC_SC2_ACREN(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_SC2_ACREN) & BM_ADC_SC2_ACREN)

/*! @brief Set the ACREN field to a new value. */
#define BW_ADC_SC2_ACREN(x, v) (BME_BFI32(HW_ADC_SC2_ADDR(x), ((uint32_t)(v) << BP_ADC_SC2_ACREN), BP_ADC_SC2_ACREN, 1))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFGT[4] (RW)
 *
 * Configures the compare function to check the conversion result relative to
 * the CV1 and CV2 based upon the value of ACREN. ACFE must be set for ACFGT to
 * have any effect.
 *
 * Values:
 * - 0 - Configures less than threshold, outside range not inclusive and inside
 *     range not inclusive; functionality based on the values placed in CV1 and
 *     CV2.
 * - 1 - Configures greater than or equal to threshold, outside and inside
 *     ranges inclusive; functionality based on the values placed in CV1 and CV2.
 */
/*@{*/
#define BP_ADC_SC2_ACFGT     (4U)          /*!< Bit position for ADC_SC2_ACFGT. */
#define BM_ADC_SC2_ACFGT     (0x00000010U) /*!< Bit mask for ADC_SC2_ACFGT. */
#define BS_ADC_SC2_ACFGT     (1U)          /*!< Bit field size in bits for ADC_SC2_ACFGT. */

/*! @brief Read current value of the ADC_SC2_ACFGT field. */
#define BR_ADC_SC2_ACFGT(x)  (BME_UBFX32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ACFGT, BS_ADC_SC2_ACFGT))

/*! @brief Format value for bitfield ADC_SC2_ACFGT. */
#define BF_ADC_SC2_ACFGT(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_SC2_ACFGT) & BM_ADC_SC2_ACFGT)

/*! @brief Set the ACFGT field to a new value. */
#define BW_ADC_SC2_ACFGT(x, v) (BME_BFI32(HW_ADC_SC2_ADDR(x), ((uint32_t)(v) << BP_ADC_SC2_ACFGT), BP_ADC_SC2_ACFGT, 1))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFE[5] (RW)
 *
 * Enables the compare function.
 *
 * Values:
 * - 0 - Compare function disabled.
 * - 1 - Compare function enabled.
 */
/*@{*/
#define BP_ADC_SC2_ACFE      (5U)          /*!< Bit position for ADC_SC2_ACFE. */
#define BM_ADC_SC2_ACFE      (0x00000020U) /*!< Bit mask for ADC_SC2_ACFE. */
#define BS_ADC_SC2_ACFE      (1U)          /*!< Bit field size in bits for ADC_SC2_ACFE. */

/*! @brief Read current value of the ADC_SC2_ACFE field. */
#define BR_ADC_SC2_ACFE(x)   (BME_UBFX32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ACFE, BS_ADC_SC2_ACFE))

/*! @brief Format value for bitfield ADC_SC2_ACFE. */
#define BF_ADC_SC2_ACFE(v)   ((uint32_t)((uint32_t)(v) << BP_ADC_SC2_ACFE) & BM_ADC_SC2_ACFE)

/*! @brief Set the ACFE field to a new value. */
#define BW_ADC_SC2_ACFE(x, v) (BME_BFI32(HW_ADC_SC2_ADDR(x), ((uint32_t)(v) << BP_ADC_SC2_ACFE), BP_ADC_SC2_ACFE, 1))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADTRG[6] (RW)
 *
 * Selects the type of trigger used for initiating a conversion. Two types of
 * trigger are selectable: Software trigger: When software trigger is selected, a
 * conversion is initiated following a write to SC1A. Hardware trigger: When
 * hardware trigger is selected, a conversion is initiated following the assertion of
 * the ADHWT input after a pulse of the ADHWTSn input.
 *
 * Values:
 * - 0 - Software trigger selected.
 * - 1 - Hardware trigger selected.
 */
/*@{*/
#define BP_ADC_SC2_ADTRG     (6U)          /*!< Bit position for ADC_SC2_ADTRG. */
#define BM_ADC_SC2_ADTRG     (0x00000040U) /*!< Bit mask for ADC_SC2_ADTRG. */
#define BS_ADC_SC2_ADTRG     (1U)          /*!< Bit field size in bits for ADC_SC2_ADTRG. */

/*! @brief Read current value of the ADC_SC2_ADTRG field. */
#define BR_ADC_SC2_ADTRG(x)  (BME_UBFX32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ADTRG, BS_ADC_SC2_ADTRG))

/*! @brief Format value for bitfield ADC_SC2_ADTRG. */
#define BF_ADC_SC2_ADTRG(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_SC2_ADTRG) & BM_ADC_SC2_ADTRG)

/*! @brief Set the ADTRG field to a new value. */
#define BW_ADC_SC2_ADTRG(x, v) (BME_BFI32(HW_ADC_SC2_ADDR(x), ((uint32_t)(v) << BP_ADC_SC2_ADTRG), BP_ADC_SC2_ADTRG, 1))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADACT[7] (RO)
 *
 * Indicates that a conversion or hardware averaging is in progress. ADACT is
 * set when a conversion is initiated and cleared when a conversion is completed or
 * aborted.
 *
 * Values:
 * - 0 - Conversion not in progress.
 * - 1 - Conversion in progress.
 */
/*@{*/
#define BP_ADC_SC2_ADACT     (7U)          /*!< Bit position for ADC_SC2_ADACT. */
#define BM_ADC_SC2_ADACT     (0x00000080U) /*!< Bit mask for ADC_SC2_ADACT. */
#define BS_ADC_SC2_ADACT     (1U)          /*!< Bit field size in bits for ADC_SC2_ADACT. */

/*! @brief Read current value of the ADC_SC2_ADACT field. */
#define BR_ADC_SC2_ADACT(x)  (BME_UBFX32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ADACT, BS_ADC_SC2_ADACT))
/*@}*/

/*******************************************************************************
 * HW_ADC_SC3 - Status and Control Register 3
 ******************************************************************************/

/*!
 * @brief HW_ADC_SC3 - Status and Control Register 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Status and Control Register 3 (SC3) controls the calibration, continuous
 * convert, and hardware averaging functions of the ADC module.
 */
typedef union _hw_adc_sc3
{
    uint32_t U;
    struct _hw_adc_sc3_bitfields
    {
        uint32_t AVGS : 2;             /*!< [1:0] Hardware Average Select */
        uint32_t AVGE : 1;             /*!< [2] Hardware Average Enable */
        uint32_t ADCO : 1;             /*!< [3] Continuous Conversion Enable */
        uint32_t RESERVED0 : 2;        /*!< [5:4]  */
        uint32_t CALF : 1;             /*!< [6] Calibration Failed Flag */
        uint32_t CAL : 1;              /*!< [7] Calibration */
        uint32_t RESERVED1 : 24;       /*!< [31:8]  */
    } B;
} hw_adc_sc3_t;

/*!
 * @name Constants and macros for entire ADC_SC3 register
 */
/*@{*/
#define HW_ADC_SC3_ADDR(x)       ((uint32_t)(x) + 0x24U)

#define HW_ADC_SC3(x)            (*(__IO hw_adc_sc3_t *) HW_ADC_SC3_ADDR(x))
#define HW_ADC_SC3_RD(x)         (HW_ADC_SC3(x).U)
#define HW_ADC_SC3_WR(x, v)      (HW_ADC_SC3(x).U = (v))
#define HW_ADC_SC3_SET(x, v)     (BME_OR32(HW_ADC_SC3_ADDR(x), (uint32_t)(v)))
#define HW_ADC_SC3_CLR(x, v)     (BME_AND32(HW_ADC_SC3_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_SC3_TOG(x, v)     (BME_XOR32(HW_ADC_SC3_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC3 bitfields
 */

/*!
 * @name Register ADC_SC3, field AVGS[1:0] (RW)
 *
 * Determines how many ADC conversions will be averaged to create the ADC
 * average result.
 *
 * Values:
 * - 00 - 4 samples averaged.
 * - 01 - 8 samples averaged.
 * - 10 - 16 samples averaged.
 * - 11 - 32 samples averaged.
 */
/*@{*/
#define BP_ADC_SC3_AVGS      (0U)          /*!< Bit position for ADC_SC3_AVGS. */
#define BM_ADC_SC3_AVGS      (0x00000003U) /*!< Bit mask for ADC_SC3_AVGS. */
#define BS_ADC_SC3_AVGS      (2U)          /*!< Bit field size in bits for ADC_SC3_AVGS. */

/*! @brief Read current value of the ADC_SC3_AVGS field. */
#define BR_ADC_SC3_AVGS(x)   (BME_UBFX32(HW_ADC_SC3_ADDR(x), BP_ADC_SC3_AVGS, BS_ADC_SC3_AVGS))

/*! @brief Format value for bitfield ADC_SC3_AVGS. */
#define BF_ADC_SC3_AVGS(v)   ((uint32_t)((uint32_t)(v) << BP_ADC_SC3_AVGS) & BM_ADC_SC3_AVGS)

/*! @brief Set the AVGS field to a new value. */
#define BW_ADC_SC3_AVGS(x, v) (BME_BFI32(HW_ADC_SC3_ADDR(x), ((uint32_t)(v) << BP_ADC_SC3_AVGS), BP_ADC_SC3_AVGS, 2))
/*@}*/

/*!
 * @name Register ADC_SC3, field AVGE[2] (RW)
 *
 * Enables the hardware average function of the ADC.
 *
 * Values:
 * - 0 - Hardware average function disabled.
 * - 1 - Hardware average function enabled.
 */
/*@{*/
#define BP_ADC_SC3_AVGE      (2U)          /*!< Bit position for ADC_SC3_AVGE. */
#define BM_ADC_SC3_AVGE      (0x00000004U) /*!< Bit mask for ADC_SC3_AVGE. */
#define BS_ADC_SC3_AVGE      (1U)          /*!< Bit field size in bits for ADC_SC3_AVGE. */

/*! @brief Read current value of the ADC_SC3_AVGE field. */
#define BR_ADC_SC3_AVGE(x)   (BME_UBFX32(HW_ADC_SC3_ADDR(x), BP_ADC_SC3_AVGE, BS_ADC_SC3_AVGE))

/*! @brief Format value for bitfield ADC_SC3_AVGE. */
#define BF_ADC_SC3_AVGE(v)   ((uint32_t)((uint32_t)(v) << BP_ADC_SC3_AVGE) & BM_ADC_SC3_AVGE)

/*! @brief Set the AVGE field to a new value. */
#define BW_ADC_SC3_AVGE(x, v) (BME_BFI32(HW_ADC_SC3_ADDR(x), ((uint32_t)(v) << BP_ADC_SC3_AVGE), BP_ADC_SC3_AVGE, 1))
/*@}*/

/*!
 * @name Register ADC_SC3, field ADCO[3] (RW)
 *
 * Enables continuous conversions.
 *
 * Values:
 * - 0 - One conversion or one set of conversions if the hardware average
 *     function is enabled, that is, AVGE=1, after initiating a conversion.
 * - 1 - Continuous conversions or sets of conversions if the hardware average
 *     function is enabled, that is, AVGE=1, after initiating a conversion.
 */
/*@{*/
#define BP_ADC_SC3_ADCO      (3U)          /*!< Bit position for ADC_SC3_ADCO. */
#define BM_ADC_SC3_ADCO      (0x00000008U) /*!< Bit mask for ADC_SC3_ADCO. */
#define BS_ADC_SC3_ADCO      (1U)          /*!< Bit field size in bits for ADC_SC3_ADCO. */

/*! @brief Read current value of the ADC_SC3_ADCO field. */
#define BR_ADC_SC3_ADCO(x)   (BME_UBFX32(HW_ADC_SC3_ADDR(x), BP_ADC_SC3_ADCO, BS_ADC_SC3_ADCO))

/*! @brief Format value for bitfield ADC_SC3_ADCO. */
#define BF_ADC_SC3_ADCO(v)   ((uint32_t)((uint32_t)(v) << BP_ADC_SC3_ADCO) & BM_ADC_SC3_ADCO)

/*! @brief Set the ADCO field to a new value. */
#define BW_ADC_SC3_ADCO(x, v) (BME_BFI32(HW_ADC_SC3_ADDR(x), ((uint32_t)(v) << BP_ADC_SC3_ADCO), BP_ADC_SC3_ADCO, 1))
/*@}*/

/*!
 * @name Register ADC_SC3, field CALF[6] (RO)
 *
 * Displays the result of the calibration sequence. The calibration sequence
 * will fail if SC2[ADTRG] = 1, any ADC register is written, or any stop mode is
 * entered before the calibration sequence completes. Writing 1 to CALF clears it.
 *
 * Values:
 * - 0 - Calibration completed normally.
 * - 1 - Calibration failed. ADC accuracy specifications are not guaranteed.
 */
/*@{*/
#define BP_ADC_SC3_CALF      (6U)          /*!< Bit position for ADC_SC3_CALF. */
#define BM_ADC_SC3_CALF      (0x00000040U) /*!< Bit mask for ADC_SC3_CALF. */
#define BS_ADC_SC3_CALF      (1U)          /*!< Bit field size in bits for ADC_SC3_CALF. */

/*! @brief Read current value of the ADC_SC3_CALF field. */
#define BR_ADC_SC3_CALF(x)   (BME_UBFX32(HW_ADC_SC3_ADDR(x), BP_ADC_SC3_CALF, BS_ADC_SC3_CALF))
/*@}*/

/*!
 * @name Register ADC_SC3, field CAL[7] (RW)
 *
 * Begins the calibration sequence when set. This field stays set while the
 * calibration is in progress and is cleared when the calibration sequence is
 * completed. CALF must be checked to determine the result of the calibration sequence.
 * Once started, the calibration routine cannot be interrupted by writes to the
 * ADC registers or the results will be invalid and CALF will set. Setting CAL
 * will abort any current conversion.
 */
/*@{*/
#define BP_ADC_SC3_CAL       (7U)          /*!< Bit position for ADC_SC3_CAL. */
#define BM_ADC_SC3_CAL       (0x00000080U) /*!< Bit mask for ADC_SC3_CAL. */
#define BS_ADC_SC3_CAL       (1U)          /*!< Bit field size in bits for ADC_SC3_CAL. */

/*! @brief Read current value of the ADC_SC3_CAL field. */
#define BR_ADC_SC3_CAL(x)    (BME_UBFX32(HW_ADC_SC3_ADDR(x), BP_ADC_SC3_CAL, BS_ADC_SC3_CAL))

/*! @brief Format value for bitfield ADC_SC3_CAL. */
#define BF_ADC_SC3_CAL(v)    ((uint32_t)((uint32_t)(v) << BP_ADC_SC3_CAL) & BM_ADC_SC3_CAL)

/*! @brief Set the CAL field to a new value. */
#define BW_ADC_SC3_CAL(x, v) (BME_BFI32(HW_ADC_SC3_ADDR(x), ((uint32_t)(v) << BP_ADC_SC3_CAL), BP_ADC_SC3_CAL, 1))
/*@}*/

/*******************************************************************************
 * HW_ADC_OFS - ADC Offset Correction Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_OFS - ADC Offset Correction Register (RW)
 *
 * Reset value: 0x00000004U
 *
 * The ADC Offset Correction Register (OFS) contains the user-selected or
 * calibration-generated offset error correction value. This register is a 2's
 * complement, left-justified, 16-bit value . The value in OFS is subtracted from the
 * conversion and the result is transferred into the result registers, Rn. If the
 * result is greater than the maximum or less than the minimum result value, it is
 * forced to the appropriate limit for the current mode of operation.
 */
typedef union _hw_adc_ofs
{
    uint32_t U;
    struct _hw_adc_ofs_bitfields
    {
        uint32_t OFS : 16;             /*!< [15:0] Offset Error Correction Value */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_adc_ofs_t;

/*!
 * @name Constants and macros for entire ADC_OFS register
 */
/*@{*/
#define HW_ADC_OFS_ADDR(x)       ((uint32_t)(x) + 0x28U)

#define HW_ADC_OFS(x)            (*(__IO hw_adc_ofs_t *) HW_ADC_OFS_ADDR(x))
#define HW_ADC_OFS_RD(x)         (HW_ADC_OFS(x).U)
#define HW_ADC_OFS_WR(x, v)      (HW_ADC_OFS(x).U = (v))
#define HW_ADC_OFS_SET(x, v)     (BME_OR32(HW_ADC_OFS_ADDR(x), (uint32_t)(v)))
#define HW_ADC_OFS_CLR(x, v)     (BME_AND32(HW_ADC_OFS_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_OFS_TOG(x, v)     (BME_XOR32(HW_ADC_OFS_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_OFS bitfields
 */

/*!
 * @name Register ADC_OFS, field OFS[15:0] (RW)
 */
/*@{*/
#define BP_ADC_OFS_OFS       (0U)          /*!< Bit position for ADC_OFS_OFS. */
#define BM_ADC_OFS_OFS       (0x0000FFFFU) /*!< Bit mask for ADC_OFS_OFS. */
#define BS_ADC_OFS_OFS       (16U)         /*!< Bit field size in bits for ADC_OFS_OFS. */

/*! @brief Read current value of the ADC_OFS_OFS field. */
#define BR_ADC_OFS_OFS(x)    (BME_UBFX32(HW_ADC_OFS_ADDR(x), BP_ADC_OFS_OFS, BS_ADC_OFS_OFS))

/*! @brief Format value for bitfield ADC_OFS_OFS. */
#define BF_ADC_OFS_OFS(v)    ((uint32_t)((uint32_t)(v) << BP_ADC_OFS_OFS) & BM_ADC_OFS_OFS)

/*! @brief Set the OFS field to a new value. */
#define BW_ADC_OFS_OFS(x, v) (BME_BFI32(HW_ADC_OFS_ADDR(x), ((uint32_t)(v) << BP_ADC_OFS_OFS), BP_ADC_OFS_OFS, 16))
/*@}*/

/*******************************************************************************
 * HW_ADC_PG - ADC Plus-Side Gain Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_PG - ADC Plus-Side Gain Register (RW)
 *
 * Reset value: 0x00008200U
 *
 * The Plus-Side Gain Register (PG) contains the gain error correction for the
 * plus-side input in differential mode or the overall conversion in single-ended
 * mode. PG, a 16-bit real number in binary format, is the gain adjustment
 * factor, with the radix point fixed between ADPG15 and ADPG14. This register must be
 * written by the user with the value described in the calibration procedure.
 * Otherwise, the gain error specifications may not be met.
 */
typedef union _hw_adc_pg
{
    uint32_t U;
    struct _hw_adc_pg_bitfields
    {
        uint32_t PG : 16;              /*!< [15:0] Plus-Side Gain */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_adc_pg_t;

/*!
 * @name Constants and macros for entire ADC_PG register
 */
/*@{*/
#define HW_ADC_PG_ADDR(x)        ((uint32_t)(x) + 0x2CU)

#define HW_ADC_PG(x)             (*(__IO hw_adc_pg_t *) HW_ADC_PG_ADDR(x))
#define HW_ADC_PG_RD(x)          (HW_ADC_PG(x).U)
#define HW_ADC_PG_WR(x, v)       (HW_ADC_PG(x).U = (v))
#define HW_ADC_PG_SET(x, v)      (BME_OR32(HW_ADC_PG_ADDR(x), (uint32_t)(v)))
#define HW_ADC_PG_CLR(x, v)      (BME_AND32(HW_ADC_PG_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_PG_TOG(x, v)      (BME_XOR32(HW_ADC_PG_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_PG bitfields
 */

/*!
 * @name Register ADC_PG, field PG[15:0] (RW)
 */
/*@{*/
#define BP_ADC_PG_PG         (0U)          /*!< Bit position for ADC_PG_PG. */
#define BM_ADC_PG_PG         (0x0000FFFFU) /*!< Bit mask for ADC_PG_PG. */
#define BS_ADC_PG_PG         (16U)         /*!< Bit field size in bits for ADC_PG_PG. */

/*! @brief Read current value of the ADC_PG_PG field. */
#define BR_ADC_PG_PG(x)      (BME_UBFX32(HW_ADC_PG_ADDR(x), BP_ADC_PG_PG, BS_ADC_PG_PG))

/*! @brief Format value for bitfield ADC_PG_PG. */
#define BF_ADC_PG_PG(v)      ((uint32_t)((uint32_t)(v) << BP_ADC_PG_PG) & BM_ADC_PG_PG)

/*! @brief Set the PG field to a new value. */
#define BW_ADC_PG_PG(x, v)   (BME_BFI32(HW_ADC_PG_ADDR(x), ((uint32_t)(v) << BP_ADC_PG_PG), BP_ADC_PG_PG, 16))
/*@}*/

/*******************************************************************************
 * HW_ADC_MG - ADC Minus-Side Gain Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_MG - ADC Minus-Side Gain Register (RW)
 *
 * Reset value: 0x00008200U
 *
 * The Minus-Side Gain Register (MG) contains the gain error correction for the
 * minus-side input in differential mode. This register is ignored in
 * single-ended mode. MG, a 16-bit real number in binary format, is the gain adjustment
 * factor, with the radix point fixed between ADMG15 and ADMG14. This register must
 * be written by the user with the value described in the calibration procedure.
 * Otherwise, the gain error specifications may not be met.
 */
typedef union _hw_adc_mg
{
    uint32_t U;
    struct _hw_adc_mg_bitfields
    {
        uint32_t MG : 16;              /*!< [15:0] Minus-Side Gain */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_adc_mg_t;

/*!
 * @name Constants and macros for entire ADC_MG register
 */
/*@{*/
#define HW_ADC_MG_ADDR(x)        ((uint32_t)(x) + 0x30U)

#define HW_ADC_MG(x)             (*(__IO hw_adc_mg_t *) HW_ADC_MG_ADDR(x))
#define HW_ADC_MG_RD(x)          (HW_ADC_MG(x).U)
#define HW_ADC_MG_WR(x, v)       (HW_ADC_MG(x).U = (v))
#define HW_ADC_MG_SET(x, v)      (BME_OR32(HW_ADC_MG_ADDR(x), (uint32_t)(v)))
#define HW_ADC_MG_CLR(x, v)      (BME_AND32(HW_ADC_MG_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_MG_TOG(x, v)      (BME_XOR32(HW_ADC_MG_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_MG bitfields
 */

/*!
 * @name Register ADC_MG, field MG[15:0] (RW)
 */
/*@{*/
#define BP_ADC_MG_MG         (0U)          /*!< Bit position for ADC_MG_MG. */
#define BM_ADC_MG_MG         (0x0000FFFFU) /*!< Bit mask for ADC_MG_MG. */
#define BS_ADC_MG_MG         (16U)         /*!< Bit field size in bits for ADC_MG_MG. */

/*! @brief Read current value of the ADC_MG_MG field. */
#define BR_ADC_MG_MG(x)      (BME_UBFX32(HW_ADC_MG_ADDR(x), BP_ADC_MG_MG, BS_ADC_MG_MG))

/*! @brief Format value for bitfield ADC_MG_MG. */
#define BF_ADC_MG_MG(v)      ((uint32_t)((uint32_t)(v) << BP_ADC_MG_MG) & BM_ADC_MG_MG)

/*! @brief Set the MG field to a new value. */
#define BW_ADC_MG_MG(x, v)   (BME_BFI32(HW_ADC_MG_ADDR(x), ((uint32_t)(v) << BP_ADC_MG_MG), BP_ADC_MG_MG, 16))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLPD - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLPD - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x0000000AU
 *
 * The Plus-Side General Calibration Value Registers (CLPx) contain calibration
 * information that is generated by the calibration function. These registers
 * contain seven calibration values of varying widths: CLP0[5:0], CLP1[6:0],
 * CLP2[7:0], CLP3[8:0], CLP4[9:0], CLPS[5:0], and CLPD[5:0]. CLPx are automatically set
 * when the self-calibration sequence is done, that is, CAL is cleared. If these
 * registers are written by the user after calibration, the linearity error
 * specifications may not be met.
 */
typedef union _hw_adc_clpd
{
    uint32_t U;
    struct _hw_adc_clpd_bitfields
    {
        uint32_t CLPD : 6;             /*!< [5:0] Calibration Value */
        uint32_t RESERVED0 : 26;       /*!< [31:6]  */
    } B;
} hw_adc_clpd_t;

/*!
 * @name Constants and macros for entire ADC_CLPD register
 */
/*@{*/
#define HW_ADC_CLPD_ADDR(x)      ((uint32_t)(x) + 0x34U)

#define HW_ADC_CLPD(x)           (*(__IO hw_adc_clpd_t *) HW_ADC_CLPD_ADDR(x))
#define HW_ADC_CLPD_RD(x)        (HW_ADC_CLPD(x).U)
#define HW_ADC_CLPD_WR(x, v)     (HW_ADC_CLPD(x).U = (v))
#define HW_ADC_CLPD_SET(x, v)    (BME_OR32(HW_ADC_CLPD_ADDR(x), (uint32_t)(v)))
#define HW_ADC_CLPD_CLR(x, v)    (BME_AND32(HW_ADC_CLPD_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_CLPD_TOG(x, v)    (BME_XOR32(HW_ADC_CLPD_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPD bitfields
 */

/*!
 * @name Register ADC_CLPD, field CLPD[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLPD_CLPD     (0U)          /*!< Bit position for ADC_CLPD_CLPD. */
#define BM_ADC_CLPD_CLPD     (0x0000003FU) /*!< Bit mask for ADC_CLPD_CLPD. */
#define BS_ADC_CLPD_CLPD     (6U)          /*!< Bit field size in bits for ADC_CLPD_CLPD. */

/*! @brief Read current value of the ADC_CLPD_CLPD field. */
#define BR_ADC_CLPD_CLPD(x)  (BME_UBFX32(HW_ADC_CLPD_ADDR(x), BP_ADC_CLPD_CLPD, BS_ADC_CLPD_CLPD))

/*! @brief Format value for bitfield ADC_CLPD_CLPD. */
#define BF_ADC_CLPD_CLPD(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLPD_CLPD) & BM_ADC_CLPD_CLPD)

/*! @brief Set the CLPD field to a new value. */
#define BW_ADC_CLPD_CLPD(x, v) (BME_BFI32(HW_ADC_CLPD_ADDR(x), ((uint32_t)(v) << BP_ADC_CLPD_CLPD), BP_ADC_CLPD_CLPD, 6))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLPS - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLPS - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLPD register description.
 */
typedef union _hw_adc_clps
{
    uint32_t U;
    struct _hw_adc_clps_bitfields
    {
        uint32_t CLPS : 6;             /*!< [5:0] Calibration Value */
        uint32_t RESERVED0 : 26;       /*!< [31:6]  */
    } B;
} hw_adc_clps_t;

/*!
 * @name Constants and macros for entire ADC_CLPS register
 */
/*@{*/
#define HW_ADC_CLPS_ADDR(x)      ((uint32_t)(x) + 0x38U)

#define HW_ADC_CLPS(x)           (*(__IO hw_adc_clps_t *) HW_ADC_CLPS_ADDR(x))
#define HW_ADC_CLPS_RD(x)        (HW_ADC_CLPS(x).U)
#define HW_ADC_CLPS_WR(x, v)     (HW_ADC_CLPS(x).U = (v))
#define HW_ADC_CLPS_SET(x, v)    (BME_OR32(HW_ADC_CLPS_ADDR(x), (uint32_t)(v)))
#define HW_ADC_CLPS_CLR(x, v)    (BME_AND32(HW_ADC_CLPS_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_CLPS_TOG(x, v)    (BME_XOR32(HW_ADC_CLPS_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPS bitfields
 */

/*!
 * @name Register ADC_CLPS, field CLPS[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLPS_CLPS     (0U)          /*!< Bit position for ADC_CLPS_CLPS. */
#define BM_ADC_CLPS_CLPS     (0x0000003FU) /*!< Bit mask for ADC_CLPS_CLPS. */
#define BS_ADC_CLPS_CLPS     (6U)          /*!< Bit field size in bits for ADC_CLPS_CLPS. */

/*! @brief Read current value of the ADC_CLPS_CLPS field. */
#define BR_ADC_CLPS_CLPS(x)  (BME_UBFX32(HW_ADC_CLPS_ADDR(x), BP_ADC_CLPS_CLPS, BS_ADC_CLPS_CLPS))

/*! @brief Format value for bitfield ADC_CLPS_CLPS. */
#define BF_ADC_CLPS_CLPS(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLPS_CLPS) & BM_ADC_CLPS_CLPS)

/*! @brief Set the CLPS field to a new value. */
#define BW_ADC_CLPS_CLPS(x, v) (BME_BFI32(HW_ADC_CLPS_ADDR(x), ((uint32_t)(v) << BP_ADC_CLPS_CLPS), BP_ADC_CLPS_CLPS, 6))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLP4 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLP4 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000200U
 *
 * For more information, see CLPD register description.
 */
typedef union _hw_adc_clp4
{
    uint32_t U;
    struct _hw_adc_clp4_bitfields
    {
        uint32_t CLP4 : 10;            /*!< [9:0] Calibration Value */
        uint32_t RESERVED0 : 22;       /*!< [31:10]  */
    } B;
} hw_adc_clp4_t;

/*!
 * @name Constants and macros for entire ADC_CLP4 register
 */
/*@{*/
#define HW_ADC_CLP4_ADDR(x)      ((uint32_t)(x) + 0x3CU)

#define HW_ADC_CLP4(x)           (*(__IO hw_adc_clp4_t *) HW_ADC_CLP4_ADDR(x))
#define HW_ADC_CLP4_RD(x)        (HW_ADC_CLP4(x).U)
#define HW_ADC_CLP4_WR(x, v)     (HW_ADC_CLP4(x).U = (v))
#define HW_ADC_CLP4_SET(x, v)    (BME_OR32(HW_ADC_CLP4_ADDR(x), (uint32_t)(v)))
#define HW_ADC_CLP4_CLR(x, v)    (BME_AND32(HW_ADC_CLP4_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_CLP4_TOG(x, v)    (BME_XOR32(HW_ADC_CLP4_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP4 bitfields
 */

/*!
 * @name Register ADC_CLP4, field CLP4[9:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLP4_CLP4     (0U)          /*!< Bit position for ADC_CLP4_CLP4. */
#define BM_ADC_CLP4_CLP4     (0x000003FFU) /*!< Bit mask for ADC_CLP4_CLP4. */
#define BS_ADC_CLP4_CLP4     (10U)         /*!< Bit field size in bits for ADC_CLP4_CLP4. */

/*! @brief Read current value of the ADC_CLP4_CLP4 field. */
#define BR_ADC_CLP4_CLP4(x)  (BME_UBFX32(HW_ADC_CLP4_ADDR(x), BP_ADC_CLP4_CLP4, BS_ADC_CLP4_CLP4))

/*! @brief Format value for bitfield ADC_CLP4_CLP4. */
#define BF_ADC_CLP4_CLP4(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLP4_CLP4) & BM_ADC_CLP4_CLP4)

/*! @brief Set the CLP4 field to a new value. */
#define BW_ADC_CLP4_CLP4(x, v) (BME_BFI32(HW_ADC_CLP4_ADDR(x), ((uint32_t)(v) << BP_ADC_CLP4_CLP4), BP_ADC_CLP4_CLP4, 10))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLP3 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLP3 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000100U
 *
 * For more information, see CLPD register description.
 */
typedef union _hw_adc_clp3
{
    uint32_t U;
    struct _hw_adc_clp3_bitfields
    {
        uint32_t CLP3 : 9;             /*!< [8:0] Calibration Value */
        uint32_t RESERVED0 : 23;       /*!< [31:9]  */
    } B;
} hw_adc_clp3_t;

/*!
 * @name Constants and macros for entire ADC_CLP3 register
 */
/*@{*/
#define HW_ADC_CLP3_ADDR(x)      ((uint32_t)(x) + 0x40U)

#define HW_ADC_CLP3(x)           (*(__IO hw_adc_clp3_t *) HW_ADC_CLP3_ADDR(x))
#define HW_ADC_CLP3_RD(x)        (HW_ADC_CLP3(x).U)
#define HW_ADC_CLP3_WR(x, v)     (HW_ADC_CLP3(x).U = (v))
#define HW_ADC_CLP3_SET(x, v)    (BME_OR32(HW_ADC_CLP3_ADDR(x), (uint32_t)(v)))
#define HW_ADC_CLP3_CLR(x, v)    (BME_AND32(HW_ADC_CLP3_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_CLP3_TOG(x, v)    (BME_XOR32(HW_ADC_CLP3_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP3 bitfields
 */

/*!
 * @name Register ADC_CLP3, field CLP3[8:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLP3_CLP3     (0U)          /*!< Bit position for ADC_CLP3_CLP3. */
#define BM_ADC_CLP3_CLP3     (0x000001FFU) /*!< Bit mask for ADC_CLP3_CLP3. */
#define BS_ADC_CLP3_CLP3     (9U)          /*!< Bit field size in bits for ADC_CLP3_CLP3. */

/*! @brief Read current value of the ADC_CLP3_CLP3 field. */
#define BR_ADC_CLP3_CLP3(x)  (BME_UBFX32(HW_ADC_CLP3_ADDR(x), BP_ADC_CLP3_CLP3, BS_ADC_CLP3_CLP3))

/*! @brief Format value for bitfield ADC_CLP3_CLP3. */
#define BF_ADC_CLP3_CLP3(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLP3_CLP3) & BM_ADC_CLP3_CLP3)

/*! @brief Set the CLP3 field to a new value. */
#define BW_ADC_CLP3_CLP3(x, v) (BME_BFI32(HW_ADC_CLP3_ADDR(x), ((uint32_t)(v) << BP_ADC_CLP3_CLP3), BP_ADC_CLP3_CLP3, 9))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLP2 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLP2 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000080U
 *
 * For more information, see CLPD register description.
 */
typedef union _hw_adc_clp2
{
    uint32_t U;
    struct _hw_adc_clp2_bitfields
    {
        uint32_t CLP2 : 8;             /*!< [7:0] Calibration Value */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_adc_clp2_t;

/*!
 * @name Constants and macros for entire ADC_CLP2 register
 */
/*@{*/
#define HW_ADC_CLP2_ADDR(x)      ((uint32_t)(x) + 0x44U)

#define HW_ADC_CLP2(x)           (*(__IO hw_adc_clp2_t *) HW_ADC_CLP2_ADDR(x))
#define HW_ADC_CLP2_RD(x)        (HW_ADC_CLP2(x).U)
#define HW_ADC_CLP2_WR(x, v)     (HW_ADC_CLP2(x).U = (v))
#define HW_ADC_CLP2_SET(x, v)    (BME_OR32(HW_ADC_CLP2_ADDR(x), (uint32_t)(v)))
#define HW_ADC_CLP2_CLR(x, v)    (BME_AND32(HW_ADC_CLP2_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_CLP2_TOG(x, v)    (BME_XOR32(HW_ADC_CLP2_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP2 bitfields
 */

/*!
 * @name Register ADC_CLP2, field CLP2[7:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLP2_CLP2     (0U)          /*!< Bit position for ADC_CLP2_CLP2. */
#define BM_ADC_CLP2_CLP2     (0x000000FFU) /*!< Bit mask for ADC_CLP2_CLP2. */
#define BS_ADC_CLP2_CLP2     (8U)          /*!< Bit field size in bits for ADC_CLP2_CLP2. */

/*! @brief Read current value of the ADC_CLP2_CLP2 field. */
#define BR_ADC_CLP2_CLP2(x)  (BME_UBFX32(HW_ADC_CLP2_ADDR(x), BP_ADC_CLP2_CLP2, BS_ADC_CLP2_CLP2))

/*! @brief Format value for bitfield ADC_CLP2_CLP2. */
#define BF_ADC_CLP2_CLP2(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLP2_CLP2) & BM_ADC_CLP2_CLP2)

/*! @brief Set the CLP2 field to a new value. */
#define BW_ADC_CLP2_CLP2(x, v) (BME_BFI32(HW_ADC_CLP2_ADDR(x), ((uint32_t)(v) << BP_ADC_CLP2_CLP2), BP_ADC_CLP2_CLP2, 8))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLP1 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLP1 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000040U
 *
 * For more information, see CLPD register description.
 */
typedef union _hw_adc_clp1
{
    uint32_t U;
    struct _hw_adc_clp1_bitfields
    {
        uint32_t CLP1 : 7;             /*!< [6:0] Calibration Value */
        uint32_t RESERVED0 : 25;       /*!< [31:7]  */
    } B;
} hw_adc_clp1_t;

/*!
 * @name Constants and macros for entire ADC_CLP1 register
 */
/*@{*/
#define HW_ADC_CLP1_ADDR(x)      ((uint32_t)(x) + 0x48U)

#define HW_ADC_CLP1(x)           (*(__IO hw_adc_clp1_t *) HW_ADC_CLP1_ADDR(x))
#define HW_ADC_CLP1_RD(x)        (HW_ADC_CLP1(x).U)
#define HW_ADC_CLP1_WR(x, v)     (HW_ADC_CLP1(x).U = (v))
#define HW_ADC_CLP1_SET(x, v)    (BME_OR32(HW_ADC_CLP1_ADDR(x), (uint32_t)(v)))
#define HW_ADC_CLP1_CLR(x, v)    (BME_AND32(HW_ADC_CLP1_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_CLP1_TOG(x, v)    (BME_XOR32(HW_ADC_CLP1_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP1 bitfields
 */

/*!
 * @name Register ADC_CLP1, field CLP1[6:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLP1_CLP1     (0U)          /*!< Bit position for ADC_CLP1_CLP1. */
#define BM_ADC_CLP1_CLP1     (0x0000007FU) /*!< Bit mask for ADC_CLP1_CLP1. */
#define BS_ADC_CLP1_CLP1     (7U)          /*!< Bit field size in bits for ADC_CLP1_CLP1. */

/*! @brief Read current value of the ADC_CLP1_CLP1 field. */
#define BR_ADC_CLP1_CLP1(x)  (BME_UBFX32(HW_ADC_CLP1_ADDR(x), BP_ADC_CLP1_CLP1, BS_ADC_CLP1_CLP1))

/*! @brief Format value for bitfield ADC_CLP1_CLP1. */
#define BF_ADC_CLP1_CLP1(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLP1_CLP1) & BM_ADC_CLP1_CLP1)

/*! @brief Set the CLP1 field to a new value. */
#define BW_ADC_CLP1_CLP1(x, v) (BME_BFI32(HW_ADC_CLP1_ADDR(x), ((uint32_t)(v) << BP_ADC_CLP1_CLP1), BP_ADC_CLP1_CLP1, 7))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLP0 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLP0 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLPD register description.
 */
typedef union _hw_adc_clp0
{
    uint32_t U;
    struct _hw_adc_clp0_bitfields
    {
        uint32_t CLP0 : 6;             /*!< [5:0] Calibration Value */
        uint32_t RESERVED0 : 26;       /*!< [31:6]  */
    } B;
} hw_adc_clp0_t;

/*!
 * @name Constants and macros for entire ADC_CLP0 register
 */
/*@{*/
#define HW_ADC_CLP0_ADDR(x)      ((uint32_t)(x) + 0x4CU)

#define HW_ADC_CLP0(x)           (*(__IO hw_adc_clp0_t *) HW_ADC_CLP0_ADDR(x))
#define HW_ADC_CLP0_RD(x)        (HW_ADC_CLP0(x).U)
#define HW_ADC_CLP0_WR(x, v)     (HW_ADC_CLP0(x).U = (v))
#define HW_ADC_CLP0_SET(x, v)    (BME_OR32(HW_ADC_CLP0_ADDR(x), (uint32_t)(v)))
#define HW_ADC_CLP0_CLR(x, v)    (BME_AND32(HW_ADC_CLP0_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_CLP0_TOG(x, v)    (BME_XOR32(HW_ADC_CLP0_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP0 bitfields
 */

/*!
 * @name Register ADC_CLP0, field CLP0[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLP0_CLP0     (0U)          /*!< Bit position for ADC_CLP0_CLP0. */
#define BM_ADC_CLP0_CLP0     (0x0000003FU) /*!< Bit mask for ADC_CLP0_CLP0. */
#define BS_ADC_CLP0_CLP0     (6U)          /*!< Bit field size in bits for ADC_CLP0_CLP0. */

/*! @brief Read current value of the ADC_CLP0_CLP0 field. */
#define BR_ADC_CLP0_CLP0(x)  (BME_UBFX32(HW_ADC_CLP0_ADDR(x), BP_ADC_CLP0_CLP0, BS_ADC_CLP0_CLP0))

/*! @brief Format value for bitfield ADC_CLP0_CLP0. */
#define BF_ADC_CLP0_CLP0(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLP0_CLP0) & BM_ADC_CLP0_CLP0)

/*! @brief Set the CLP0 field to a new value. */
#define BW_ADC_CLP0_CLP0(x, v) (BME_BFI32(HW_ADC_CLP0_ADDR(x), ((uint32_t)(v) << BP_ADC_CLP0_CLP0), BP_ADC_CLP0_CLP0, 6))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLMD - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLMD - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x0000000AU
 *
 * The Minus-Side General Calibration Value (CLMx) registers contain calibration
 * information that is generated by the calibration function. These registers
 * contain seven calibration values of varying widths: CLM0[5:0], CLM1[6:0],
 * CLM2[7:0], CLM3[8:0], CLM4[9:0], CLMS[5:0], and CLMD[5:0]. CLMx are automatically
 * set when the self-calibration sequence is done, that is, CAL is cleared. If
 * these registers are written by the user after calibration, the linearity error
 * specifications may not be met.
 */
typedef union _hw_adc_clmd
{
    uint32_t U;
    struct _hw_adc_clmd_bitfields
    {
        uint32_t CLMD : 6;             /*!< [5:0] Calibration Value */
        uint32_t RESERVED0 : 26;       /*!< [31:6]  */
    } B;
} hw_adc_clmd_t;

/*!
 * @name Constants and macros for entire ADC_CLMD register
 */
/*@{*/
#define HW_ADC_CLMD_ADDR(x)      ((uint32_t)(x) + 0x54U)

#define HW_ADC_CLMD(x)           (*(__IO hw_adc_clmd_t *) HW_ADC_CLMD_ADDR(x))
#define HW_ADC_CLMD_RD(x)        (HW_ADC_CLMD(x).U)
#define HW_ADC_CLMD_WR(x, v)     (HW_ADC_CLMD(x).U = (v))
#define HW_ADC_CLMD_SET(x, v)    (BME_OR32(HW_ADC_CLMD_ADDR(x), (uint32_t)(v)))
#define HW_ADC_CLMD_CLR(x, v)    (BME_AND32(HW_ADC_CLMD_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_CLMD_TOG(x, v)    (BME_XOR32(HW_ADC_CLMD_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLMD bitfields
 */

/*!
 * @name Register ADC_CLMD, field CLMD[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLMD_CLMD     (0U)          /*!< Bit position for ADC_CLMD_CLMD. */
#define BM_ADC_CLMD_CLMD     (0x0000003FU) /*!< Bit mask for ADC_CLMD_CLMD. */
#define BS_ADC_CLMD_CLMD     (6U)          /*!< Bit field size in bits for ADC_CLMD_CLMD. */

/*! @brief Read current value of the ADC_CLMD_CLMD field. */
#define BR_ADC_CLMD_CLMD(x)  (BME_UBFX32(HW_ADC_CLMD_ADDR(x), BP_ADC_CLMD_CLMD, BS_ADC_CLMD_CLMD))

/*! @brief Format value for bitfield ADC_CLMD_CLMD. */
#define BF_ADC_CLMD_CLMD(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLMD_CLMD) & BM_ADC_CLMD_CLMD)

/*! @brief Set the CLMD field to a new value. */
#define BW_ADC_CLMD_CLMD(x, v) (BME_BFI32(HW_ADC_CLMD_ADDR(x), ((uint32_t)(v) << BP_ADC_CLMD_CLMD), BP_ADC_CLMD_CLMD, 6))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLMS - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLMS - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLMD register description.
 */
typedef union _hw_adc_clms
{
    uint32_t U;
    struct _hw_adc_clms_bitfields
    {
        uint32_t CLMS : 6;             /*!< [5:0] Calibration Value */
        uint32_t RESERVED0 : 26;       /*!< [31:6]  */
    } B;
} hw_adc_clms_t;

/*!
 * @name Constants and macros for entire ADC_CLMS register
 */
/*@{*/
#define HW_ADC_CLMS_ADDR(x)      ((uint32_t)(x) + 0x58U)

#define HW_ADC_CLMS(x)           (*(__IO hw_adc_clms_t *) HW_ADC_CLMS_ADDR(x))
#define HW_ADC_CLMS_RD(x)        (HW_ADC_CLMS(x).U)
#define HW_ADC_CLMS_WR(x, v)     (HW_ADC_CLMS(x).U = (v))
#define HW_ADC_CLMS_SET(x, v)    (BME_OR32(HW_ADC_CLMS_ADDR(x), (uint32_t)(v)))
#define HW_ADC_CLMS_CLR(x, v)    (BME_AND32(HW_ADC_CLMS_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_CLMS_TOG(x, v)    (BME_XOR32(HW_ADC_CLMS_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLMS bitfields
 */

/*!
 * @name Register ADC_CLMS, field CLMS[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLMS_CLMS     (0U)          /*!< Bit position for ADC_CLMS_CLMS. */
#define BM_ADC_CLMS_CLMS     (0x0000003FU) /*!< Bit mask for ADC_CLMS_CLMS. */
#define BS_ADC_CLMS_CLMS     (6U)          /*!< Bit field size in bits for ADC_CLMS_CLMS. */

/*! @brief Read current value of the ADC_CLMS_CLMS field. */
#define BR_ADC_CLMS_CLMS(x)  (BME_UBFX32(HW_ADC_CLMS_ADDR(x), BP_ADC_CLMS_CLMS, BS_ADC_CLMS_CLMS))

/*! @brief Format value for bitfield ADC_CLMS_CLMS. */
#define BF_ADC_CLMS_CLMS(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLMS_CLMS) & BM_ADC_CLMS_CLMS)

/*! @brief Set the CLMS field to a new value. */
#define BW_ADC_CLMS_CLMS(x, v) (BME_BFI32(HW_ADC_CLMS_ADDR(x), ((uint32_t)(v) << BP_ADC_CLMS_CLMS), BP_ADC_CLMS_CLMS, 6))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLM4 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLM4 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000200U
 *
 * For more information, see CLMD register description.
 */
typedef union _hw_adc_clm4
{
    uint32_t U;
    struct _hw_adc_clm4_bitfields
    {
        uint32_t CLM4 : 10;            /*!< [9:0] Calibration Value */
        uint32_t RESERVED0 : 22;       /*!< [31:10]  */
    } B;
} hw_adc_clm4_t;

/*!
 * @name Constants and macros for entire ADC_CLM4 register
 */
/*@{*/
#define HW_ADC_CLM4_ADDR(x)      ((uint32_t)(x) + 0x5CU)

#define HW_ADC_CLM4(x)           (*(__IO hw_adc_clm4_t *) HW_ADC_CLM4_ADDR(x))
#define HW_ADC_CLM4_RD(x)        (HW_ADC_CLM4(x).U)
#define HW_ADC_CLM4_WR(x, v)     (HW_ADC_CLM4(x).U = (v))
#define HW_ADC_CLM4_SET(x, v)    (BME_OR32(HW_ADC_CLM4_ADDR(x), (uint32_t)(v)))
#define HW_ADC_CLM4_CLR(x, v)    (BME_AND32(HW_ADC_CLM4_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_CLM4_TOG(x, v)    (BME_XOR32(HW_ADC_CLM4_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM4 bitfields
 */

/*!
 * @name Register ADC_CLM4, field CLM4[9:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLM4_CLM4     (0U)          /*!< Bit position for ADC_CLM4_CLM4. */
#define BM_ADC_CLM4_CLM4     (0x000003FFU) /*!< Bit mask for ADC_CLM4_CLM4. */
#define BS_ADC_CLM4_CLM4     (10U)         /*!< Bit field size in bits for ADC_CLM4_CLM4. */

/*! @brief Read current value of the ADC_CLM4_CLM4 field. */
#define BR_ADC_CLM4_CLM4(x)  (BME_UBFX32(HW_ADC_CLM4_ADDR(x), BP_ADC_CLM4_CLM4, BS_ADC_CLM4_CLM4))

/*! @brief Format value for bitfield ADC_CLM4_CLM4. */
#define BF_ADC_CLM4_CLM4(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLM4_CLM4) & BM_ADC_CLM4_CLM4)

/*! @brief Set the CLM4 field to a new value. */
#define BW_ADC_CLM4_CLM4(x, v) (BME_BFI32(HW_ADC_CLM4_ADDR(x), ((uint32_t)(v) << BP_ADC_CLM4_CLM4), BP_ADC_CLM4_CLM4, 10))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLM3 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLM3 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000100U
 *
 * For more information, see CLMD register description.
 */
typedef union _hw_adc_clm3
{
    uint32_t U;
    struct _hw_adc_clm3_bitfields
    {
        uint32_t CLM3 : 9;             /*!< [8:0] Calibration Value */
        uint32_t RESERVED0 : 23;       /*!< [31:9]  */
    } B;
} hw_adc_clm3_t;

/*!
 * @name Constants and macros for entire ADC_CLM3 register
 */
/*@{*/
#define HW_ADC_CLM3_ADDR(x)      ((uint32_t)(x) + 0x60U)

#define HW_ADC_CLM3(x)           (*(__IO hw_adc_clm3_t *) HW_ADC_CLM3_ADDR(x))
#define HW_ADC_CLM3_RD(x)        (HW_ADC_CLM3(x).U)
#define HW_ADC_CLM3_WR(x, v)     (HW_ADC_CLM3(x).U = (v))
#define HW_ADC_CLM3_SET(x, v)    (BME_OR32(HW_ADC_CLM3_ADDR(x), (uint32_t)(v)))
#define HW_ADC_CLM3_CLR(x, v)    (BME_AND32(HW_ADC_CLM3_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_CLM3_TOG(x, v)    (BME_XOR32(HW_ADC_CLM3_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM3 bitfields
 */

/*!
 * @name Register ADC_CLM3, field CLM3[8:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLM3_CLM3     (0U)          /*!< Bit position for ADC_CLM3_CLM3. */
#define BM_ADC_CLM3_CLM3     (0x000001FFU) /*!< Bit mask for ADC_CLM3_CLM3. */
#define BS_ADC_CLM3_CLM3     (9U)          /*!< Bit field size in bits for ADC_CLM3_CLM3. */

/*! @brief Read current value of the ADC_CLM3_CLM3 field. */
#define BR_ADC_CLM3_CLM3(x)  (BME_UBFX32(HW_ADC_CLM3_ADDR(x), BP_ADC_CLM3_CLM3, BS_ADC_CLM3_CLM3))

/*! @brief Format value for bitfield ADC_CLM3_CLM3. */
#define BF_ADC_CLM3_CLM3(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLM3_CLM3) & BM_ADC_CLM3_CLM3)

/*! @brief Set the CLM3 field to a new value. */
#define BW_ADC_CLM3_CLM3(x, v) (BME_BFI32(HW_ADC_CLM3_ADDR(x), ((uint32_t)(v) << BP_ADC_CLM3_CLM3), BP_ADC_CLM3_CLM3, 9))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLM2 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLM2 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000080U
 *
 * For more information, see CLMD register description.
 */
typedef union _hw_adc_clm2
{
    uint32_t U;
    struct _hw_adc_clm2_bitfields
    {
        uint32_t CLM2 : 8;             /*!< [7:0] Calibration Value */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_adc_clm2_t;

/*!
 * @name Constants and macros for entire ADC_CLM2 register
 */
/*@{*/
#define HW_ADC_CLM2_ADDR(x)      ((uint32_t)(x) + 0x64U)

#define HW_ADC_CLM2(x)           (*(__IO hw_adc_clm2_t *) HW_ADC_CLM2_ADDR(x))
#define HW_ADC_CLM2_RD(x)        (HW_ADC_CLM2(x).U)
#define HW_ADC_CLM2_WR(x, v)     (HW_ADC_CLM2(x).U = (v))
#define HW_ADC_CLM2_SET(x, v)    (BME_OR32(HW_ADC_CLM2_ADDR(x), (uint32_t)(v)))
#define HW_ADC_CLM2_CLR(x, v)    (BME_AND32(HW_ADC_CLM2_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_CLM2_TOG(x, v)    (BME_XOR32(HW_ADC_CLM2_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM2 bitfields
 */

/*!
 * @name Register ADC_CLM2, field CLM2[7:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLM2_CLM2     (0U)          /*!< Bit position for ADC_CLM2_CLM2. */
#define BM_ADC_CLM2_CLM2     (0x000000FFU) /*!< Bit mask for ADC_CLM2_CLM2. */
#define BS_ADC_CLM2_CLM2     (8U)          /*!< Bit field size in bits for ADC_CLM2_CLM2. */

/*! @brief Read current value of the ADC_CLM2_CLM2 field. */
#define BR_ADC_CLM2_CLM2(x)  (BME_UBFX32(HW_ADC_CLM2_ADDR(x), BP_ADC_CLM2_CLM2, BS_ADC_CLM2_CLM2))

/*! @brief Format value for bitfield ADC_CLM2_CLM2. */
#define BF_ADC_CLM2_CLM2(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLM2_CLM2) & BM_ADC_CLM2_CLM2)

/*! @brief Set the CLM2 field to a new value. */
#define BW_ADC_CLM2_CLM2(x, v) (BME_BFI32(HW_ADC_CLM2_ADDR(x), ((uint32_t)(v) << BP_ADC_CLM2_CLM2), BP_ADC_CLM2_CLM2, 8))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLM1 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLM1 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000040U
 *
 * For more information, see CLMD register description.
 */
typedef union _hw_adc_clm1
{
    uint32_t U;
    struct _hw_adc_clm1_bitfields
    {
        uint32_t CLM1 : 7;             /*!< [6:0] Calibration Value */
        uint32_t RESERVED0 : 25;       /*!< [31:7]  */
    } B;
} hw_adc_clm1_t;

/*!
 * @name Constants and macros for entire ADC_CLM1 register
 */
/*@{*/
#define HW_ADC_CLM1_ADDR(x)      ((uint32_t)(x) + 0x68U)

#define HW_ADC_CLM1(x)           (*(__IO hw_adc_clm1_t *) HW_ADC_CLM1_ADDR(x))
#define HW_ADC_CLM1_RD(x)        (HW_ADC_CLM1(x).U)
#define HW_ADC_CLM1_WR(x, v)     (HW_ADC_CLM1(x).U = (v))
#define HW_ADC_CLM1_SET(x, v)    (BME_OR32(HW_ADC_CLM1_ADDR(x), (uint32_t)(v)))
#define HW_ADC_CLM1_CLR(x, v)    (BME_AND32(HW_ADC_CLM1_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_CLM1_TOG(x, v)    (BME_XOR32(HW_ADC_CLM1_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM1 bitfields
 */

/*!
 * @name Register ADC_CLM1, field CLM1[6:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLM1_CLM1     (0U)          /*!< Bit position for ADC_CLM1_CLM1. */
#define BM_ADC_CLM1_CLM1     (0x0000007FU) /*!< Bit mask for ADC_CLM1_CLM1. */
#define BS_ADC_CLM1_CLM1     (7U)          /*!< Bit field size in bits for ADC_CLM1_CLM1. */

/*! @brief Read current value of the ADC_CLM1_CLM1 field. */
#define BR_ADC_CLM1_CLM1(x)  (BME_UBFX32(HW_ADC_CLM1_ADDR(x), BP_ADC_CLM1_CLM1, BS_ADC_CLM1_CLM1))

/*! @brief Format value for bitfield ADC_CLM1_CLM1. */
#define BF_ADC_CLM1_CLM1(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLM1_CLM1) & BM_ADC_CLM1_CLM1)

/*! @brief Set the CLM1 field to a new value. */
#define BW_ADC_CLM1_CLM1(x, v) (BME_BFI32(HW_ADC_CLM1_ADDR(x), ((uint32_t)(v) << BP_ADC_CLM1_CLM1), BP_ADC_CLM1_CLM1, 7))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLM0 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLM0 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLMD register description.
 */
typedef union _hw_adc_clm0
{
    uint32_t U;
    struct _hw_adc_clm0_bitfields
    {
        uint32_t CLM0 : 6;             /*!< [5:0] Calibration Value */
        uint32_t RESERVED0 : 26;       /*!< [31:6]  */
    } B;
} hw_adc_clm0_t;

/*!
 * @name Constants and macros for entire ADC_CLM0 register
 */
/*@{*/
#define HW_ADC_CLM0_ADDR(x)      ((uint32_t)(x) + 0x6CU)

#define HW_ADC_CLM0(x)           (*(__IO hw_adc_clm0_t *) HW_ADC_CLM0_ADDR(x))
#define HW_ADC_CLM0_RD(x)        (HW_ADC_CLM0(x).U)
#define HW_ADC_CLM0_WR(x, v)     (HW_ADC_CLM0(x).U = (v))
#define HW_ADC_CLM0_SET(x, v)    (BME_OR32(HW_ADC_CLM0_ADDR(x), (uint32_t)(v)))
#define HW_ADC_CLM0_CLR(x, v)    (BME_AND32(HW_ADC_CLM0_ADDR(x), (uint32_t)(~(v))))
#define HW_ADC_CLM0_TOG(x, v)    (BME_XOR32(HW_ADC_CLM0_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM0 bitfields
 */

/*!
 * @name Register ADC_CLM0, field CLM0[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLM0_CLM0     (0U)          /*!< Bit position for ADC_CLM0_CLM0. */
#define BM_ADC_CLM0_CLM0     (0x0000003FU) /*!< Bit mask for ADC_CLM0_CLM0. */
#define BS_ADC_CLM0_CLM0     (6U)          /*!< Bit field size in bits for ADC_CLM0_CLM0. */

/*! @brief Read current value of the ADC_CLM0_CLM0 field. */
#define BR_ADC_CLM0_CLM0(x)  (BME_UBFX32(HW_ADC_CLM0_ADDR(x), BP_ADC_CLM0_CLM0, BS_ADC_CLM0_CLM0))

/*! @brief Format value for bitfield ADC_CLM0_CLM0. */
#define BF_ADC_CLM0_CLM0(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLM0_CLM0) & BM_ADC_CLM0_CLM0)

/*! @brief Set the CLM0 field to a new value. */
#define BW_ADC_CLM0_CLM0(x, v) (BME_BFI32(HW_ADC_CLM0_ADDR(x), ((uint32_t)(v) << BP_ADC_CLM0_CLM0), BP_ADC_CLM0_CLM0, 6))
/*@}*/

/*******************************************************************************
 * hw_adc_t - module struct
 ******************************************************************************/
/*!
 * @brief All ADC module registers.
 */
#pragma pack(1)
typedef struct _hw_adc
{
    __IO hw_adc_sc1n_t SC1n[2];            /*!< [0x0] ADC Status and Control Registers 1 */
    __IO hw_adc_cfg1_t CFG1;               /*!< [0x8] ADC Configuration Register 1 */
    __IO hw_adc_cfg2_t CFG2;               /*!< [0xC] ADC Configuration Register 2 */
    __I hw_adc_rn_t Rn[2];                 /*!< [0x10] ADC Data Result Register */
    __IO hw_adc_cv1_t CV1;                 /*!< [0x18] Compare Value Registers */
    __IO hw_adc_cv2_t CV2;                 /*!< [0x1C] Compare Value Registers */
    __IO hw_adc_sc2_t SC2;                 /*!< [0x20] Status and Control Register 2 */
    __IO hw_adc_sc3_t SC3;                 /*!< [0x24] Status and Control Register 3 */
    __IO hw_adc_ofs_t OFS;                 /*!< [0x28] ADC Offset Correction Register */
    __IO hw_adc_pg_t PG;                   /*!< [0x2C] ADC Plus-Side Gain Register */
    __IO hw_adc_mg_t MG;                   /*!< [0x30] ADC Minus-Side Gain Register */
    __IO hw_adc_clpd_t CLPD;               /*!< [0x34] ADC Plus-Side General Calibration Value Register */
    __IO hw_adc_clps_t CLPS;               /*!< [0x38] ADC Plus-Side General Calibration Value Register */
    __IO hw_adc_clp4_t CLP4;               /*!< [0x3C] ADC Plus-Side General Calibration Value Register */
    __IO hw_adc_clp3_t CLP3;               /*!< [0x40] ADC Plus-Side General Calibration Value Register */
    __IO hw_adc_clp2_t CLP2;               /*!< [0x44] ADC Plus-Side General Calibration Value Register */
    __IO hw_adc_clp1_t CLP1;               /*!< [0x48] ADC Plus-Side General Calibration Value Register */
    __IO hw_adc_clp0_t CLP0;               /*!< [0x4C] ADC Plus-Side General Calibration Value Register */
    uint8_t _reserved0[4];
    __IO hw_adc_clmd_t CLMD;               /*!< [0x54] ADC Minus-Side General Calibration Value Register */
    __IO hw_adc_clms_t CLMS;               /*!< [0x58] ADC Minus-Side General Calibration Value Register */
    __IO hw_adc_clm4_t CLM4;               /*!< [0x5C] ADC Minus-Side General Calibration Value Register */
    __IO hw_adc_clm3_t CLM3;               /*!< [0x60] ADC Minus-Side General Calibration Value Register */
    __IO hw_adc_clm2_t CLM2;               /*!< [0x64] ADC Minus-Side General Calibration Value Register */
    __IO hw_adc_clm1_t CLM1;               /*!< [0x68] ADC Minus-Side General Calibration Value Register */
    __IO hw_adc_clm0_t CLM0;               /*!< [0x6C] ADC Minus-Side General Calibration Value Register */
} hw_adc_t;
#pragma pack()

/*! @brief Macro to access all ADC registers. */
/*! @param x ADC module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_ADC_REGS(ADC0_BASE)</code>. */
#define HW_ADC_REGS(x) (*(hw_adc_t *)(x))

/*
 * MKL43Z4 CMP
 *
 * High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
 *
 * Registers defined in this header file:
 * - HW_CMP_CR0 - CMP Control Register 0
 * - HW_CMP_CR1 - CMP Control Register 1
 * - HW_CMP_FPR - CMP Filter Period Register
 * - HW_CMP_SCR - CMP Status and Control Register
 * - HW_CMP_DACCR - DAC Control Register
 * - HW_CMP_MUXCR - MUX Control Register
 *
 * - hw_cmp_t - Struct containing all module registers.
 */

#define HW_CMP_INSTANCE_COUNT (1U) /*!< Number of instances of the CMP module. */
#define HW_CMP0 (0U) /*!< Instance number for CMP0. */

/*******************************************************************************
 * HW_CMP_CR0 - CMP Control Register 0
 ******************************************************************************/

/*!
 * @brief HW_CMP_CR0 - CMP Control Register 0 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_cmp_cr0
{
    uint8_t U;
    struct _hw_cmp_cr0_bitfields
    {
        uint8_t HYSTCTR : 2;           /*!< [1:0] Comparator hard block hysteresis
                                        * control */
        uint8_t RESERVED0 : 2;         /*!< [3:2]  */
        uint8_t FILTER_CNT : 3;        /*!< [6:4] Filter Sample Count */
        uint8_t RESERVED1 : 1;         /*!< [7]  */
    } B;
} hw_cmp_cr0_t;

/*!
 * @name Constants and macros for entire CMP_CR0 register
 */
/*@{*/
#define HW_CMP_CR0_ADDR(x)       ((uint32_t)(x) + 0x0U)

#define HW_CMP_CR0(x)            (*(__IO hw_cmp_cr0_t *) HW_CMP_CR0_ADDR(x))
#define HW_CMP_CR0_RD(x)         (HW_CMP_CR0(x).U)
#define HW_CMP_CR0_WR(x, v)      (HW_CMP_CR0(x).U = (v))
#define HW_CMP_CR0_SET(x, v)     (BME_OR8(HW_CMP_CR0_ADDR(x), (uint8_t)(v)))
#define HW_CMP_CR0_CLR(x, v)     (BME_AND8(HW_CMP_CR0_ADDR(x), (uint8_t)(~(v))))
#define HW_CMP_CR0_TOG(x, v)     (BME_XOR8(HW_CMP_CR0_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual CMP_CR0 bitfields
 */

/*!
 * @name Register CMP_CR0, field HYSTCTR[1:0] (RW)
 *
 * Defines the programmable hysteresis level. The hysteresis values associated
 * with each level are device-specific. See the Data Sheet of the device for the
 * exact values.
 *
 * Values:
 * - 00 - Level 0
 * - 01 - Level 1
 * - 10 - Level 2
 * - 11 - Level 3
 */
/*@{*/
#define BP_CMP_CR0_HYSTCTR   (0U)          /*!< Bit position for CMP_CR0_HYSTCTR. */
#define BM_CMP_CR0_HYSTCTR   (0x03U)       /*!< Bit mask for CMP_CR0_HYSTCTR. */
#define BS_CMP_CR0_HYSTCTR   (2U)          /*!< Bit field size in bits for CMP_CR0_HYSTCTR. */

/*! @brief Read current value of the CMP_CR0_HYSTCTR field. */
#define BR_CMP_CR0_HYSTCTR(x) (BME_UBFX8(HW_CMP_CR0_ADDR(x), BP_CMP_CR0_HYSTCTR, BS_CMP_CR0_HYSTCTR))

/*! @brief Format value for bitfield CMP_CR0_HYSTCTR. */
#define BF_CMP_CR0_HYSTCTR(v) ((uint8_t)((uint8_t)(v) << BP_CMP_CR0_HYSTCTR) & BM_CMP_CR0_HYSTCTR)

/*! @brief Set the HYSTCTR field to a new value. */
#define BW_CMP_CR0_HYSTCTR(x, v) (BME_BFI8(HW_CMP_CR0_ADDR(x), ((uint8_t)(v) << BP_CMP_CR0_HYSTCTR), BP_CMP_CR0_HYSTCTR, 2))
/*@}*/

/*!
 * @name Register CMP_CR0, field FILTER_CNT[6:4] (RW)
 *
 * Represents the number of consecutive samples that must agree prior to the
 * comparator ouput filter accepting a new output state. For information regarding
 * filter programming and latency, see the Functional descriptionThe CMP module
 * can be used to compare two analog input voltages applied to INP and INM. .
 *
 * Values:
 * - 000 - Filter is disabled. SE = 0, COUT = COUTA.
 * - 001 - One sample must agree. The comparator output is simply sampled.
 * - 010 - 2 consecutive samples must agree.
 * - 011 - 3 consecutive samples must agree.
 * - 100 - 4 consecutive samples must agree.
 * - 101 - 5 consecutive samples must agree.
 * - 110 - 6 consecutive samples must agree.
 * - 111 - 7 consecutive samples must agree.
 */
/*@{*/
#define BP_CMP_CR0_FILTER_CNT (4U)         /*!< Bit position for CMP_CR0_FILTER_CNT. */
#define BM_CMP_CR0_FILTER_CNT (0x70U)      /*!< Bit mask for CMP_CR0_FILTER_CNT. */
#define BS_CMP_CR0_FILTER_CNT (3U)         /*!< Bit field size in bits for CMP_CR0_FILTER_CNT. */

/*! @brief Read current value of the CMP_CR0_FILTER_CNT field. */
#define BR_CMP_CR0_FILTER_CNT(x) (BME_UBFX8(HW_CMP_CR0_ADDR(x), BP_CMP_CR0_FILTER_CNT, BS_CMP_CR0_FILTER_CNT))

/*! @brief Format value for bitfield CMP_CR0_FILTER_CNT. */
#define BF_CMP_CR0_FILTER_CNT(v) ((uint8_t)((uint8_t)(v) << BP_CMP_CR0_FILTER_CNT) & BM_CMP_CR0_FILTER_CNT)

/*! @brief Set the FILTER_CNT field to a new value. */
#define BW_CMP_CR0_FILTER_CNT(x, v) (BME_BFI8(HW_CMP_CR0_ADDR(x), ((uint8_t)(v) << BP_CMP_CR0_FILTER_CNT), BP_CMP_CR0_FILTER_CNT, 3))
/*@}*/

/*******************************************************************************
 * HW_CMP_CR1 - CMP Control Register 1
 ******************************************************************************/

/*!
 * @brief HW_CMP_CR1 - CMP Control Register 1 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_cmp_cr1
{
    uint8_t U;
    struct _hw_cmp_cr1_bitfields
    {
        uint8_t EN : 1;                /*!< [0] Comparator Module Enable */
        uint8_t OPE : 1;               /*!< [1] Comparator Output Pin Enable */
        uint8_t COS : 1;               /*!< [2] Comparator Output Select */
        uint8_t INV : 1;               /*!< [3] Comparator INVERT */
        uint8_t PMODE : 1;             /*!< [4] Power Mode Select */
        uint8_t TRIGM : 1;             /*!< [5] Trigger Mode Enable */
        uint8_t WE : 1;                /*!< [6] Windowing Enable */
        uint8_t SE : 1;                /*!< [7] Sample Enable */
    } B;
} hw_cmp_cr1_t;

/*!
 * @name Constants and macros for entire CMP_CR1 register
 */
/*@{*/
#define HW_CMP_CR1_ADDR(x)       ((uint32_t)(x) + 0x1U)

#define HW_CMP_CR1(x)            (*(__IO hw_cmp_cr1_t *) HW_CMP_CR1_ADDR(x))
#define HW_CMP_CR1_RD(x)         (HW_CMP_CR1(x).U)
#define HW_CMP_CR1_WR(x, v)      (HW_CMP_CR1(x).U = (v))
#define HW_CMP_CR1_SET(x, v)     (BME_OR8(HW_CMP_CR1_ADDR(x), (uint8_t)(v)))
#define HW_CMP_CR1_CLR(x, v)     (BME_AND8(HW_CMP_CR1_ADDR(x), (uint8_t)(~(v))))
#define HW_CMP_CR1_TOG(x, v)     (BME_XOR8(HW_CMP_CR1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual CMP_CR1 bitfields
 */

/*!
 * @name Register CMP_CR1, field EN[0] (RW)
 *
 * Enables the Analog Comparator module. When the module is not enabled, it
 * remains in the off state, and consumes no power. When the user selects the same
 * input from analog mux to the positive and negative port, the comparator is
 * disabled automatically.
 *
 * Values:
 * - 0 - Analog Comparator is disabled.
 * - 1 - Analog Comparator is enabled.
 */
/*@{*/
#define BP_CMP_CR1_EN        (0U)          /*!< Bit position for CMP_CR1_EN. */
#define BM_CMP_CR1_EN        (0x01U)       /*!< Bit mask for CMP_CR1_EN. */
#define BS_CMP_CR1_EN        (1U)          /*!< Bit field size in bits for CMP_CR1_EN. */

/*! @brief Read current value of the CMP_CR1_EN field. */
#define BR_CMP_CR1_EN(x)     (BME_UBFX8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_EN, BS_CMP_CR1_EN))

/*! @brief Format value for bitfield CMP_CR1_EN. */
#define BF_CMP_CR1_EN(v)     ((uint8_t)((uint8_t)(v) << BP_CMP_CR1_EN) & BM_CMP_CR1_EN)

/*! @brief Set the EN field to a new value. */
#define BW_CMP_CR1_EN(x, v)  (BME_BFI8(HW_CMP_CR1_ADDR(x), ((uint8_t)(v) << BP_CMP_CR1_EN), BP_CMP_CR1_EN, 1))
/*@}*/

/*!
 * @name Register CMP_CR1, field OPE[1] (RW)
 *
 * Values:
 * - 0 - CMPO is not available on the associated CMPO output pin. If the
 *     comparator does not own the pin, this field has no effect.
 * - 1 - CMPO is available on the associated CMPO output pin. The comparator
 *     output (CMPO) is driven out on the associated CMPO output pin if the
 *     comparator owns the pin. If the comparator does not own the field, this bit has no
 *     effect.
 */
/*@{*/
#define BP_CMP_CR1_OPE       (1U)          /*!< Bit position for CMP_CR1_OPE. */
#define BM_CMP_CR1_OPE       (0x02U)       /*!< Bit mask for CMP_CR1_OPE. */
#define BS_CMP_CR1_OPE       (1U)          /*!< Bit field size in bits for CMP_CR1_OPE. */

/*! @brief Read current value of the CMP_CR1_OPE field. */
#define BR_CMP_CR1_OPE(x)    (BME_UBFX8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_OPE, BS_CMP_CR1_OPE))

/*! @brief Format value for bitfield CMP_CR1_OPE. */
#define BF_CMP_CR1_OPE(v)    ((uint8_t)((uint8_t)(v) << BP_CMP_CR1_OPE) & BM_CMP_CR1_OPE)

/*! @brief Set the OPE field to a new value. */
#define BW_CMP_CR1_OPE(x, v) (BME_BFI8(HW_CMP_CR1_ADDR(x), ((uint8_t)(v) << BP_CMP_CR1_OPE), BP_CMP_CR1_OPE, 1))
/*@}*/

/*!
 * @name Register CMP_CR1, field COS[2] (RW)
 *
 * Values:
 * - 0 - Set the filtered comparator output (CMPO) to equal COUT.
 * - 1 - Set the unfiltered comparator output (CMPO) to equal COUTA.
 */
/*@{*/
#define BP_CMP_CR1_COS       (2U)          /*!< Bit position for CMP_CR1_COS. */
#define BM_CMP_CR1_COS       (0x04U)       /*!< Bit mask for CMP_CR1_COS. */
#define BS_CMP_CR1_COS       (1U)          /*!< Bit field size in bits for CMP_CR1_COS. */

/*! @brief Read current value of the CMP_CR1_COS field. */
#define BR_CMP_CR1_COS(x)    (BME_UBFX8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_COS, BS_CMP_CR1_COS))

/*! @brief Format value for bitfield CMP_CR1_COS. */
#define BF_CMP_CR1_COS(v)    ((uint8_t)((uint8_t)(v) << BP_CMP_CR1_COS) & BM_CMP_CR1_COS)

/*! @brief Set the COS field to a new value. */
#define BW_CMP_CR1_COS(x, v) (BME_BFI8(HW_CMP_CR1_ADDR(x), ((uint8_t)(v) << BP_CMP_CR1_COS), BP_CMP_CR1_COS, 1))
/*@}*/

/*!
 * @name Register CMP_CR1, field INV[3] (RW)
 *
 * Allows selection of the polarity of the analog comparator function. It is
 * also driven to the COUT output, on both the device pin and as SCR[COUT], when
 * OPE=0.
 *
 * Values:
 * - 0 - Does not invert the comparator output.
 * - 1 - Inverts the comparator output.
 */
/*@{*/
#define BP_CMP_CR1_INV       (3U)          /*!< Bit position for CMP_CR1_INV. */
#define BM_CMP_CR1_INV       (0x08U)       /*!< Bit mask for CMP_CR1_INV. */
#define BS_CMP_CR1_INV       (1U)          /*!< Bit field size in bits for CMP_CR1_INV. */

/*! @brief Read current value of the CMP_CR1_INV field. */
#define BR_CMP_CR1_INV(x)    (BME_UBFX8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_INV, BS_CMP_CR1_INV))

/*! @brief Format value for bitfield CMP_CR1_INV. */
#define BF_CMP_CR1_INV(v)    ((uint8_t)((uint8_t)(v) << BP_CMP_CR1_INV) & BM_CMP_CR1_INV)

/*! @brief Set the INV field to a new value. */
#define BW_CMP_CR1_INV(x, v) (BME_BFI8(HW_CMP_CR1_ADDR(x), ((uint8_t)(v) << BP_CMP_CR1_INV), BP_CMP_CR1_INV, 1))
/*@}*/

/*!
 * @name Register CMP_CR1, field PMODE[4] (RW)
 *
 * See the electrical specifications table in the device Data Sheet for details.
 *
 * Values:
 * - 0 - Low-Speed (LS) Comparison mode selected. In this mode, CMP has slower
 *     output propagation delay and lower current consumption.
 * - 1 - High-Speed (HS) Comparison mode selected. In this mode, CMP has faster
 *     output propagation delay and higher current consumption.
 */
/*@{*/
#define BP_CMP_CR1_PMODE     (4U)          /*!< Bit position for CMP_CR1_PMODE. */
#define BM_CMP_CR1_PMODE     (0x10U)       /*!< Bit mask for CMP_CR1_PMODE. */
#define BS_CMP_CR1_PMODE     (1U)          /*!< Bit field size in bits for CMP_CR1_PMODE. */

/*! @brief Read current value of the CMP_CR1_PMODE field. */
#define BR_CMP_CR1_PMODE(x)  (BME_UBFX8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_PMODE, BS_CMP_CR1_PMODE))

/*! @brief Format value for bitfield CMP_CR1_PMODE. */
#define BF_CMP_CR1_PMODE(v)  ((uint8_t)((uint8_t)(v) << BP_CMP_CR1_PMODE) & BM_CMP_CR1_PMODE)

/*! @brief Set the PMODE field to a new value. */
#define BW_CMP_CR1_PMODE(x, v) (BME_BFI8(HW_CMP_CR1_ADDR(x), ((uint8_t)(v) << BP_CMP_CR1_PMODE), BP_CMP_CR1_PMODE, 1))
/*@}*/

/*!
 * @name Register CMP_CR1, field TRIGM[5] (RW)
 *
 * CMP and DAC are configured to CMP Trigger mode when CMP_CR1[TRIGM] is set to
 * 1. In addition, the CMP should be enabled. If the DAC is to be used as a
 * reference to the CMP, it should also be enabled. CMP Trigger mode depends on an
 * external timer resource to periodically enable the CMP and 6-bit DAC in order to
 * generate a triggered compare. Upon setting TRIGM, the CMP and DAC are placed
 * in a standby state until an external timer resource trigger is received. See
 * the chip configuration for details about the external timer resource.
 *
 * Values:
 * - 0 - Trigger mode is disabled.
 * - 1 - Trigger mode is enabled.
 */
/*@{*/
#define BP_CMP_CR1_TRIGM     (5U)          /*!< Bit position for CMP_CR1_TRIGM. */
#define BM_CMP_CR1_TRIGM     (0x20U)       /*!< Bit mask for CMP_CR1_TRIGM. */
#define BS_CMP_CR1_TRIGM     (1U)          /*!< Bit field size in bits for CMP_CR1_TRIGM. */

/*! @brief Read current value of the CMP_CR1_TRIGM field. */
#define BR_CMP_CR1_TRIGM(x)  (BME_UBFX8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_TRIGM, BS_CMP_CR1_TRIGM))

/*! @brief Format value for bitfield CMP_CR1_TRIGM. */
#define BF_CMP_CR1_TRIGM(v)  ((uint8_t)((uint8_t)(v) << BP_CMP_CR1_TRIGM) & BM_CMP_CR1_TRIGM)

/*! @brief Set the TRIGM field to a new value. */
#define BW_CMP_CR1_TRIGM(x, v) (BME_BFI8(HW_CMP_CR1_ADDR(x), ((uint8_t)(v) << BP_CMP_CR1_TRIGM), BP_CMP_CR1_TRIGM, 1))
/*@}*/

/*!
 * @name Register CMP_CR1, field WE[6] (RW)
 *
 * The CMP does not support window compare function and a 0 must always be
 * written to WE.
 *
 * Values:
 * - 0 - Windowing mode is not selected.
 * - 1 - Windowing mode is selected.
 */
/*@{*/
#define BP_CMP_CR1_WE        (6U)          /*!< Bit position for CMP_CR1_WE. */
#define BM_CMP_CR1_WE        (0x40U)       /*!< Bit mask for CMP_CR1_WE. */
#define BS_CMP_CR1_WE        (1U)          /*!< Bit field size in bits for CMP_CR1_WE. */

/*! @brief Read current value of the CMP_CR1_WE field. */
#define BR_CMP_CR1_WE(x)     (BME_UBFX8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_WE, BS_CMP_CR1_WE))

/*! @brief Format value for bitfield CMP_CR1_WE. */
#define BF_CMP_CR1_WE(v)     ((uint8_t)((uint8_t)(v) << BP_CMP_CR1_WE) & BM_CMP_CR1_WE)

/*! @brief Set the WE field to a new value. */
#define BW_CMP_CR1_WE(x, v)  (BME_BFI8(HW_CMP_CR1_ADDR(x), ((uint8_t)(v) << BP_CMP_CR1_WE), BP_CMP_CR1_WE, 1))
/*@}*/

/*!
 * @name Register CMP_CR1, field SE[7] (RW)
 *
 * SE must be clear to 0 and usage of sample operation is limited to a divided
 * version of the bus clock.
 *
 * Values:
 * - 0 - Sampling mode is not selected.
 * - 1 - Sampling mode is selected.
 */
/*@{*/
#define BP_CMP_CR1_SE        (7U)          /*!< Bit position for CMP_CR1_SE. */
#define BM_CMP_CR1_SE        (0x80U)       /*!< Bit mask for CMP_CR1_SE. */
#define BS_CMP_CR1_SE        (1U)          /*!< Bit field size in bits for CMP_CR1_SE. */

/*! @brief Read current value of the CMP_CR1_SE field. */
#define BR_CMP_CR1_SE(x)     (BME_UBFX8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_SE, BS_CMP_CR1_SE))

/*! @brief Format value for bitfield CMP_CR1_SE. */
#define BF_CMP_CR1_SE(v)     ((uint8_t)((uint8_t)(v) << BP_CMP_CR1_SE) & BM_CMP_CR1_SE)

/*! @brief Set the SE field to a new value. */
#define BW_CMP_CR1_SE(x, v)  (BME_BFI8(HW_CMP_CR1_ADDR(x), ((uint8_t)(v) << BP_CMP_CR1_SE), BP_CMP_CR1_SE, 1))
/*@}*/

/*******************************************************************************
 * HW_CMP_FPR - CMP Filter Period Register
 ******************************************************************************/

/*!
 * @brief HW_CMP_FPR - CMP Filter Period Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_cmp_fpr
{
    uint8_t U;
    struct _hw_cmp_fpr_bitfields
    {
        uint8_t FILT_PER : 8;          /*!< [7:0] Filter Sample Period */
    } B;
} hw_cmp_fpr_t;

/*!
 * @name Constants and macros for entire CMP_FPR register
 */
/*@{*/
#define HW_CMP_FPR_ADDR(x)       ((uint32_t)(x) + 0x2U)

#define HW_CMP_FPR(x)            (*(__IO hw_cmp_fpr_t *) HW_CMP_FPR_ADDR(x))
#define HW_CMP_FPR_RD(x)         (HW_CMP_FPR(x).U)
#define HW_CMP_FPR_WR(x, v)      (HW_CMP_FPR(x).U = (v))
#define HW_CMP_FPR_SET(x, v)     (BME_OR8(HW_CMP_FPR_ADDR(x), (uint8_t)(v)))
#define HW_CMP_FPR_CLR(x, v)     (BME_AND8(HW_CMP_FPR_ADDR(x), (uint8_t)(~(v))))
#define HW_CMP_FPR_TOG(x, v)     (BME_XOR8(HW_CMP_FPR_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual CMP_FPR bitfields
 */

/*!
 * @name Register CMP_FPR, field FILT_PER[7:0] (RW)
 *
 * Specifies the sampling period, in bus clock cycles, of the comparator output
 * filter, when CR1[SE]=0. Setting FILT_PER to 0x0 disables the filter. Filter
 * programming and latency details appear in the Functional descriptionThe CMP
 * module can be used to compare two analog input voltages applied to INP and INM. .
 */
/*@{*/
#define BP_CMP_FPR_FILT_PER  (0U)          /*!< Bit position for CMP_FPR_FILT_PER. */
#define BM_CMP_FPR_FILT_PER  (0xFFU)       /*!< Bit mask for CMP_FPR_FILT_PER. */
#define BS_CMP_FPR_FILT_PER  (8U)          /*!< Bit field size in bits for CMP_FPR_FILT_PER. */

/*! @brief Read current value of the CMP_FPR_FILT_PER field. */
#define BR_CMP_FPR_FILT_PER(x) (HW_CMP_FPR(x).U)

/*! @brief Format value for bitfield CMP_FPR_FILT_PER. */
#define BF_CMP_FPR_FILT_PER(v) ((uint8_t)((uint8_t)(v) << BP_CMP_FPR_FILT_PER) & BM_CMP_FPR_FILT_PER)

/*! @brief Set the FILT_PER field to a new value. */
#define BW_CMP_FPR_FILT_PER(x, v) (HW_CMP_FPR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_CMP_SCR - CMP Status and Control Register
 ******************************************************************************/

/*!
 * @brief HW_CMP_SCR - CMP Status and Control Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_cmp_scr
{
    uint8_t U;
    struct _hw_cmp_scr_bitfields
    {
        uint8_t COUT : 1;              /*!< [0] Analog Comparator Output */
        uint8_t CFF : 1;               /*!< [1] Analog Comparator Flag Falling */
        uint8_t CFR : 1;               /*!< [2] Analog Comparator Flag Rising */
        uint8_t IEF : 1;               /*!< [3] Comparator Interrupt Enable Falling */
        uint8_t IER : 1;               /*!< [4] Comparator Interrupt Enable Rising */
        uint8_t RESERVED0 : 1;         /*!< [5]  */
        uint8_t DMAEN : 1;             /*!< [6] DMA Enable Control */
        uint8_t RESERVED1 : 1;         /*!< [7]  */
    } B;
} hw_cmp_scr_t;

/*!
 * @name Constants and macros for entire CMP_SCR register
 */
/*@{*/
#define HW_CMP_SCR_ADDR(x)       ((uint32_t)(x) + 0x3U)

#define HW_CMP_SCR(x)            (*(__IO hw_cmp_scr_t *) HW_CMP_SCR_ADDR(x))
#define HW_CMP_SCR_RD(x)         (HW_CMP_SCR(x).U)
#define HW_CMP_SCR_WR(x, v)      (HW_CMP_SCR(x).U = (v))
#define HW_CMP_SCR_SET(x, v)     (BME_OR8(HW_CMP_SCR_ADDR(x), (uint8_t)(v)))
#define HW_CMP_SCR_CLR(x, v)     (BME_AND8(HW_CMP_SCR_ADDR(x), (uint8_t)(~(v))))
#define HW_CMP_SCR_TOG(x, v)     (BME_XOR8(HW_CMP_SCR_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual CMP_SCR bitfields
 */

/*!
 * @name Register CMP_SCR, field COUT[0] (RO)
 *
 * Returns the current value of the Analog Comparator output, when read. The
 * field is reset to 0 and will read as CR1[INV] when the Analog Comparator module
 * is disabled, that is, when CR1[EN] = 0. Writes to this field are ignored.
 */
/*@{*/
#define BP_CMP_SCR_COUT      (0U)          /*!< Bit position for CMP_SCR_COUT. */
#define BM_CMP_SCR_COUT      (0x01U)       /*!< Bit mask for CMP_SCR_COUT. */
#define BS_CMP_SCR_COUT      (1U)          /*!< Bit field size in bits for CMP_SCR_COUT. */

/*! @brief Read current value of the CMP_SCR_COUT field. */
#define BR_CMP_SCR_COUT(x)   (BME_UBFX8(HW_CMP_SCR_ADDR(x), BP_CMP_SCR_COUT, BS_CMP_SCR_COUT))
/*@}*/

/*!
 * @name Register CMP_SCR, field CFF[1] (W1C)
 *
 * Detects a falling-edge on COUT, when set, during normal operation. CFF is
 * cleared by writing 1 to it. During Stop modes, CFF is edge sensitive .
 *
 * Values:
 * - 0 - Falling-edge on COUT has not been detected.
 * - 1 - Falling-edge on COUT has occurred.
 */
/*@{*/
#define BP_CMP_SCR_CFF       (1U)          /*!< Bit position for CMP_SCR_CFF. */
#define BM_CMP_SCR_CFF       (0x02U)       /*!< Bit mask for CMP_SCR_CFF. */
#define BS_CMP_SCR_CFF       (1U)          /*!< Bit field size in bits for CMP_SCR_CFF. */

/*! @brief Read current value of the CMP_SCR_CFF field. */
#define BR_CMP_SCR_CFF(x)    (BME_UBFX8(HW_CMP_SCR_ADDR(x), BP_CMP_SCR_CFF, BS_CMP_SCR_CFF))

/*! @brief Format value for bitfield CMP_SCR_CFF. */
#define BF_CMP_SCR_CFF(v)    ((uint8_t)((uint8_t)(v) << BP_CMP_SCR_CFF) & BM_CMP_SCR_CFF)

/*! @brief Set the CFF field to a new value. */
#define BW_CMP_SCR_CFF(x, v) (BME_BFI8(HW_CMP_SCR_ADDR(x), ((uint8_t)(v) << BP_CMP_SCR_CFF), BP_CMP_SCR_CFF, 1))
/*@}*/

/*!
 * @name Register CMP_SCR, field CFR[2] (W1C)
 *
 * Detects a rising-edge on COUT, when set, during normal operation. CFR is
 * cleared by writing 1 to it. During Stop modes, CFR is edge sensitive .
 *
 * Values:
 * - 0 - Rising-edge on COUT has not been detected.
 * - 1 - Rising-edge on COUT has occurred.
 */
/*@{*/
#define BP_CMP_SCR_CFR       (2U)          /*!< Bit position for CMP_SCR_CFR. */
#define BM_CMP_SCR_CFR       (0x04U)       /*!< Bit mask for CMP_SCR_CFR. */
#define BS_CMP_SCR_CFR       (1U)          /*!< Bit field size in bits for CMP_SCR_CFR. */

/*! @brief Read current value of the CMP_SCR_CFR field. */
#define BR_CMP_SCR_CFR(x)    (BME_UBFX8(HW_CMP_SCR_ADDR(x), BP_CMP_SCR_CFR, BS_CMP_SCR_CFR))

/*! @brief Format value for bitfield CMP_SCR_CFR. */
#define BF_CMP_SCR_CFR(v)    ((uint8_t)((uint8_t)(v) << BP_CMP_SCR_CFR) & BM_CMP_SCR_CFR)

/*! @brief Set the CFR field to a new value. */
#define BW_CMP_SCR_CFR(x, v) (BME_BFI8(HW_CMP_SCR_ADDR(x), ((uint8_t)(v) << BP_CMP_SCR_CFR), BP_CMP_SCR_CFR, 1))
/*@}*/

/*!
 * @name Register CMP_SCR, field IEF[3] (RW)
 *
 * Enables the CFF interrupt from the CMP. When this field is set, an interrupt
 * will be asserted when CFF is set.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
#define BP_CMP_SCR_IEF       (3U)          /*!< Bit position for CMP_SCR_IEF. */
#define BM_CMP_SCR_IEF       (0x08U)       /*!< Bit mask for CMP_SCR_IEF. */
#define BS_CMP_SCR_IEF       (1U)          /*!< Bit field size in bits for CMP_SCR_IEF. */

/*! @brief Read current value of the CMP_SCR_IEF field. */
#define BR_CMP_SCR_IEF(x)    (BME_UBFX8(HW_CMP_SCR_ADDR(x), BP_CMP_SCR_IEF, BS_CMP_SCR_IEF))

/*! @brief Format value for bitfield CMP_SCR_IEF. */
#define BF_CMP_SCR_IEF(v)    ((uint8_t)((uint8_t)(v) << BP_CMP_SCR_IEF) & BM_CMP_SCR_IEF)

/*! @brief Set the IEF field to a new value. */
#define BW_CMP_SCR_IEF(x, v) (BME_BFI8(HW_CMP_SCR_ADDR(x), ((uint8_t)(v) << BP_CMP_SCR_IEF), BP_CMP_SCR_IEF, 1))
/*@}*/

/*!
 * @name Register CMP_SCR, field IER[4] (RW)
 *
 * Enables the CFR interrupt from the CMP. When this field is set, an interrupt
 * will be asserted when CFR is set.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
#define BP_CMP_SCR_IER       (4U)          /*!< Bit position for CMP_SCR_IER. */
#define BM_CMP_SCR_IER       (0x10U)       /*!< Bit mask for CMP_SCR_IER. */
#define BS_CMP_SCR_IER       (1U)          /*!< Bit field size in bits for CMP_SCR_IER. */

/*! @brief Read current value of the CMP_SCR_IER field. */
#define BR_CMP_SCR_IER(x)    (BME_UBFX8(HW_CMP_SCR_ADDR(x), BP_CMP_SCR_IER, BS_CMP_SCR_IER))

/*! @brief Format value for bitfield CMP_SCR_IER. */
#define BF_CMP_SCR_IER(v)    ((uint8_t)((uint8_t)(v) << BP_CMP_SCR_IER) & BM_CMP_SCR_IER)

/*! @brief Set the IER field to a new value. */
#define BW_CMP_SCR_IER(x, v) (BME_BFI8(HW_CMP_SCR_ADDR(x), ((uint8_t)(v) << BP_CMP_SCR_IER), BP_CMP_SCR_IER, 1))
/*@}*/

/*!
 * @name Register CMP_SCR, field DMAEN[6] (RW)
 *
 * Enables the DMA transfer triggered from the CMP module. When this field is
 * set, a DMA request is asserted when CFR or CFF is set.
 *
 * Values:
 * - 0 - DMA is disabled.
 * - 1 - DMA is enabled.
 */
/*@{*/
#define BP_CMP_SCR_DMAEN     (6U)          /*!< Bit position for CMP_SCR_DMAEN. */
#define BM_CMP_SCR_DMAEN     (0x40U)       /*!< Bit mask for CMP_SCR_DMAEN. */
#define BS_CMP_SCR_DMAEN     (1U)          /*!< Bit field size in bits for CMP_SCR_DMAEN. */

/*! @brief Read current value of the CMP_SCR_DMAEN field. */
#define BR_CMP_SCR_DMAEN(x)  (BME_UBFX8(HW_CMP_SCR_ADDR(x), BP_CMP_SCR_DMAEN, BS_CMP_SCR_DMAEN))

/*! @brief Format value for bitfield CMP_SCR_DMAEN. */
#define BF_CMP_SCR_DMAEN(v)  ((uint8_t)((uint8_t)(v) << BP_CMP_SCR_DMAEN) & BM_CMP_SCR_DMAEN)

/*! @brief Set the DMAEN field to a new value. */
#define BW_CMP_SCR_DMAEN(x, v) (BME_BFI8(HW_CMP_SCR_ADDR(x), ((uint8_t)(v) << BP_CMP_SCR_DMAEN), BP_CMP_SCR_DMAEN, 1))
/*@}*/

/*******************************************************************************
 * HW_CMP_DACCR - DAC Control Register
 ******************************************************************************/

/*!
 * @brief HW_CMP_DACCR - DAC Control Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_cmp_daccr
{
    uint8_t U;
    struct _hw_cmp_daccr_bitfields
    {
        uint8_t VOSEL : 6;             /*!< [5:0] DAC Output Voltage Select */
        uint8_t VRSEL : 1;             /*!< [6] Supply Voltage Reference Source Select */
        uint8_t DACEN : 1;             /*!< [7] DAC Enable */
    } B;
} hw_cmp_daccr_t;

/*!
 * @name Constants and macros for entire CMP_DACCR register
 */
/*@{*/
#define HW_CMP_DACCR_ADDR(x)     ((uint32_t)(x) + 0x4U)

#define HW_CMP_DACCR(x)          (*(__IO hw_cmp_daccr_t *) HW_CMP_DACCR_ADDR(x))
#define HW_CMP_DACCR_RD(x)       (HW_CMP_DACCR(x).U)
#define HW_CMP_DACCR_WR(x, v)    (HW_CMP_DACCR(x).U = (v))
#define HW_CMP_DACCR_SET(x, v)   (BME_OR8(HW_CMP_DACCR_ADDR(x), (uint8_t)(v)))
#define HW_CMP_DACCR_CLR(x, v)   (BME_AND8(HW_CMP_DACCR_ADDR(x), (uint8_t)(~(v))))
#define HW_CMP_DACCR_TOG(x, v)   (BME_XOR8(HW_CMP_DACCR_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual CMP_DACCR bitfields
 */

/*!
 * @name Register CMP_DACCR, field VOSEL[5:0] (RW)
 *
 * Selects an output voltage from one of 64 distinct levels. DACO = (V in /64) *
 * (VOSEL[5:0] + 1) , so the DACO range is from V in /64 to V in .
 */
/*@{*/
#define BP_CMP_DACCR_VOSEL   (0U)          /*!< Bit position for CMP_DACCR_VOSEL. */
#define BM_CMP_DACCR_VOSEL   (0x3FU)       /*!< Bit mask for CMP_DACCR_VOSEL. */
#define BS_CMP_DACCR_VOSEL   (6U)          /*!< Bit field size in bits for CMP_DACCR_VOSEL. */

/*! @brief Read current value of the CMP_DACCR_VOSEL field. */
#define BR_CMP_DACCR_VOSEL(x) (BME_UBFX8(HW_CMP_DACCR_ADDR(x), BP_CMP_DACCR_VOSEL, BS_CMP_DACCR_VOSEL))

/*! @brief Format value for bitfield CMP_DACCR_VOSEL. */
#define BF_CMP_DACCR_VOSEL(v) ((uint8_t)((uint8_t)(v) << BP_CMP_DACCR_VOSEL) & BM_CMP_DACCR_VOSEL)

/*! @brief Set the VOSEL field to a new value. */
#define BW_CMP_DACCR_VOSEL(x, v) (BME_BFI8(HW_CMP_DACCR_ADDR(x), ((uint8_t)(v) << BP_CMP_DACCR_VOSEL), BP_CMP_DACCR_VOSEL, 6))
/*@}*/

/*!
 * @name Register CMP_DACCR, field VRSEL[6] (RW)
 *
 * Values:
 * - 0 - Vin1 is selected as resistor ladder network supply reference.
 * - 1 - Vin2 is selected as resistor ladder network supply reference.
 */
/*@{*/
#define BP_CMP_DACCR_VRSEL   (6U)          /*!< Bit position for CMP_DACCR_VRSEL. */
#define BM_CMP_DACCR_VRSEL   (0x40U)       /*!< Bit mask for CMP_DACCR_VRSEL. */
#define BS_CMP_DACCR_VRSEL   (1U)          /*!< Bit field size in bits for CMP_DACCR_VRSEL. */

/*! @brief Read current value of the CMP_DACCR_VRSEL field. */
#define BR_CMP_DACCR_VRSEL(x) (BME_UBFX8(HW_CMP_DACCR_ADDR(x), BP_CMP_DACCR_VRSEL, BS_CMP_DACCR_VRSEL))

/*! @brief Format value for bitfield CMP_DACCR_VRSEL. */
#define BF_CMP_DACCR_VRSEL(v) ((uint8_t)((uint8_t)(v) << BP_CMP_DACCR_VRSEL) & BM_CMP_DACCR_VRSEL)

/*! @brief Set the VRSEL field to a new value. */
#define BW_CMP_DACCR_VRSEL(x, v) (BME_BFI8(HW_CMP_DACCR_ADDR(x), ((uint8_t)(v) << BP_CMP_DACCR_VRSEL), BP_CMP_DACCR_VRSEL, 1))
/*@}*/

/*!
 * @name Register CMP_DACCR, field DACEN[7] (RW)
 *
 * Enables the DAC. When the DAC is disabled, it is powered down to conserve
 * power.
 *
 * Values:
 * - 0 - DAC is disabled.
 * - 1 - DAC is enabled.
 */
/*@{*/
#define BP_CMP_DACCR_DACEN   (7U)          /*!< Bit position for CMP_DACCR_DACEN. */
#define BM_CMP_DACCR_DACEN   (0x80U)       /*!< Bit mask for CMP_DACCR_DACEN. */
#define BS_CMP_DACCR_DACEN   (1U)          /*!< Bit field size in bits for CMP_DACCR_DACEN. */

/*! @brief Read current value of the CMP_DACCR_DACEN field. */
#define BR_CMP_DACCR_DACEN(x) (BME_UBFX8(HW_CMP_DACCR_ADDR(x), BP_CMP_DACCR_DACEN, BS_CMP_DACCR_DACEN))

/*! @brief Format value for bitfield CMP_DACCR_DACEN. */
#define BF_CMP_DACCR_DACEN(v) ((uint8_t)((uint8_t)(v) << BP_CMP_DACCR_DACEN) & BM_CMP_DACCR_DACEN)

/*! @brief Set the DACEN field to a new value. */
#define BW_CMP_DACCR_DACEN(x, v) (BME_BFI8(HW_CMP_DACCR_ADDR(x), ((uint8_t)(v) << BP_CMP_DACCR_DACEN), BP_CMP_DACCR_DACEN, 1))
/*@}*/

/*******************************************************************************
 * HW_CMP_MUXCR - MUX Control Register
 ******************************************************************************/

/*!
 * @brief HW_CMP_MUXCR - MUX Control Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_cmp_muxcr
{
    uint8_t U;
    struct _hw_cmp_muxcr_bitfields
    {
        uint8_t MSEL : 3;              /*!< [2:0] Minus Input Mux Control */
        uint8_t PSEL : 3;              /*!< [5:3] Plus Input Mux Control */
        uint8_t RESERVED0 : 1;         /*!< [6]  */
        uint8_t PSTM : 1;              /*!< [7] Pass Through Mode Enable */
    } B;
} hw_cmp_muxcr_t;

/*!
 * @name Constants and macros for entire CMP_MUXCR register
 */
/*@{*/
#define HW_CMP_MUXCR_ADDR(x)     ((uint32_t)(x) + 0x5U)

#define HW_CMP_MUXCR(x)          (*(__IO hw_cmp_muxcr_t *) HW_CMP_MUXCR_ADDR(x))
#define HW_CMP_MUXCR_RD(x)       (HW_CMP_MUXCR(x).U)
#define HW_CMP_MUXCR_WR(x, v)    (HW_CMP_MUXCR(x).U = (v))
#define HW_CMP_MUXCR_SET(x, v)   (BME_OR8(HW_CMP_MUXCR_ADDR(x), (uint8_t)(v)))
#define HW_CMP_MUXCR_CLR(x, v)   (BME_AND8(HW_CMP_MUXCR_ADDR(x), (uint8_t)(~(v))))
#define HW_CMP_MUXCR_TOG(x, v)   (BME_XOR8(HW_CMP_MUXCR_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual CMP_MUXCR bitfields
 */

/*!
 * @name Register CMP_MUXCR, field MSEL[2:0] (RW)
 *
 * Determines which input is selected for the minus input of the comparator. For
 * INx inputs, see CMP, DAC, and ANMUX block diagrams. When an inappropriate
 * operation selects the same input for both muxes, the comparator automatically
 * shuts down to prevent itself from becoming a noise generator.
 *
 * Values:
 * - 000 - IN0
 * - 001 - IN1
 * - 010 - IN2
 * - 011 - IN3
 * - 100 - IN4
 * - 101 - IN5
 * - 110 - IN6
 * - 111 - IN7
 */
/*@{*/
#define BP_CMP_MUXCR_MSEL    (0U)          /*!< Bit position for CMP_MUXCR_MSEL. */
#define BM_CMP_MUXCR_MSEL    (0x07U)       /*!< Bit mask for CMP_MUXCR_MSEL. */
#define BS_CMP_MUXCR_MSEL    (3U)          /*!< Bit field size in bits for CMP_MUXCR_MSEL. */

/*! @brief Read current value of the CMP_MUXCR_MSEL field. */
#define BR_CMP_MUXCR_MSEL(x) (BME_UBFX8(HW_CMP_MUXCR_ADDR(x), BP_CMP_MUXCR_MSEL, BS_CMP_MUXCR_MSEL))

/*! @brief Format value for bitfield CMP_MUXCR_MSEL. */
#define BF_CMP_MUXCR_MSEL(v) ((uint8_t)((uint8_t)(v) << BP_CMP_MUXCR_MSEL) & BM_CMP_MUXCR_MSEL)

/*! @brief Set the MSEL field to a new value. */
#define BW_CMP_MUXCR_MSEL(x, v) (BME_BFI8(HW_CMP_MUXCR_ADDR(x), ((uint8_t)(v) << BP_CMP_MUXCR_MSEL), BP_CMP_MUXCR_MSEL, 3))
/*@}*/

/*!
 * @name Register CMP_MUXCR, field PSEL[5:3] (RW)
 *
 * Determines which input is selected for the plus input of the comparator. For
 * INx inputs, see CMP, DAC, and ANMUX block diagrams. When an inappropriate
 * operation selects the same input for both muxes, the comparator automatically
 * shuts down to prevent itself from becoming a noise generator.
 *
 * Values:
 * - 000 - IN0
 * - 001 - IN1
 * - 010 - IN2
 * - 011 - IN3
 * - 100 - IN4
 * - 101 - IN5
 * - 110 - IN6
 * - 111 - IN7
 */
/*@{*/
#define BP_CMP_MUXCR_PSEL    (3U)          /*!< Bit position for CMP_MUXCR_PSEL. */
#define BM_CMP_MUXCR_PSEL    (0x38U)       /*!< Bit mask for CMP_MUXCR_PSEL. */
#define BS_CMP_MUXCR_PSEL    (3U)          /*!< Bit field size in bits for CMP_MUXCR_PSEL. */

/*! @brief Read current value of the CMP_MUXCR_PSEL field. */
#define BR_CMP_MUXCR_PSEL(x) (BME_UBFX8(HW_CMP_MUXCR_ADDR(x), BP_CMP_MUXCR_PSEL, BS_CMP_MUXCR_PSEL))

/*! @brief Format value for bitfield CMP_MUXCR_PSEL. */
#define BF_CMP_MUXCR_PSEL(v) ((uint8_t)((uint8_t)(v) << BP_CMP_MUXCR_PSEL) & BM_CMP_MUXCR_PSEL)

/*! @brief Set the PSEL field to a new value. */
#define BW_CMP_MUXCR_PSEL(x, v) (BME_BFI8(HW_CMP_MUXCR_ADDR(x), ((uint8_t)(v) << BP_CMP_MUXCR_PSEL), BP_CMP_MUXCR_PSEL, 3))
/*@}*/

/*!
 * @name Register CMP_MUXCR, field PSTM[7] (RW)
 *
 * This bit is used to enable to MUX pass through mode. Pass through mode is
 * always available but for some devices this feature must be always disabled due to
 * the lack of package pins.
 *
 * Values:
 * - 0 - Pass Through Mode is disabled.
 * - 1 - Pass Through Mode is enabled.
 */
/*@{*/
#define BP_CMP_MUXCR_PSTM    (7U)          /*!< Bit position for CMP_MUXCR_PSTM. */
#define BM_CMP_MUXCR_PSTM    (0x80U)       /*!< Bit mask for CMP_MUXCR_PSTM. */
#define BS_CMP_MUXCR_PSTM    (1U)          /*!< Bit field size in bits for CMP_MUXCR_PSTM. */

/*! @brief Read current value of the CMP_MUXCR_PSTM field. */
#define BR_CMP_MUXCR_PSTM(x) (BME_UBFX8(HW_CMP_MUXCR_ADDR(x), BP_CMP_MUXCR_PSTM, BS_CMP_MUXCR_PSTM))

/*! @brief Format value for bitfield CMP_MUXCR_PSTM. */
#define BF_CMP_MUXCR_PSTM(v) ((uint8_t)((uint8_t)(v) << BP_CMP_MUXCR_PSTM) & BM_CMP_MUXCR_PSTM)

/*! @brief Set the PSTM field to a new value. */
#define BW_CMP_MUXCR_PSTM(x, v) (BME_BFI8(HW_CMP_MUXCR_ADDR(x), ((uint8_t)(v) << BP_CMP_MUXCR_PSTM), BP_CMP_MUXCR_PSTM, 1))
/*@}*/

/*******************************************************************************
 * hw_cmp_t - module struct
 ******************************************************************************/
/*!
 * @brief All CMP module registers.
 */
#pragma pack(1)
typedef struct _hw_cmp
{
    __IO hw_cmp_cr0_t CR0;                 /*!< [0x0] CMP Control Register 0 */
    __IO hw_cmp_cr1_t CR1;                 /*!< [0x1] CMP Control Register 1 */
    __IO hw_cmp_fpr_t FPR;                 /*!< [0x2] CMP Filter Period Register */
    __IO hw_cmp_scr_t SCR;                 /*!< [0x3] CMP Status and Control Register */
    __IO hw_cmp_daccr_t DACCR;             /*!< [0x4] DAC Control Register */
    __IO hw_cmp_muxcr_t MUXCR;             /*!< [0x5] MUX Control Register */
} hw_cmp_t;
#pragma pack()

/*! @brief Macro to access all CMP registers. */
/*! @param x CMP module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_CMP_REGS(CMP0_BASE)</code>. */
#define HW_CMP_REGS(x) (*(hw_cmp_t *)(x))

/*
 * MKL43Z4 DAC
 *
 * 12-Bit Digital-to-Analog Converter
 *
 * Registers defined in this header file:
 * - HW_DAC_DATnL - DAC Data Low Register
 * - HW_DAC_DATnH - DAC Data High Register
 * - HW_DAC_SR - DAC Status Register
 * - HW_DAC_C0 - DAC Control Register
 * - HW_DAC_C1 - DAC Control Register 1
 * - HW_DAC_C2 - DAC Control Register 2
 *
 * - hw_dac_t - Struct containing all module registers.
 */

#define HW_DAC_INSTANCE_COUNT (1U) /*!< Number of instances of the DAC module. */
#define HW_DAC0 (0U) /*!< Instance number for DAC0. */

/*******************************************************************************
 * HW_DAC_DATnL - DAC Data Low Register
 ******************************************************************************/

/*!
 * @brief HW_DAC_DATnL - DAC Data Low Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_dac_datnl
{
    uint8_t U;
    struct _hw_dac_datnl_bitfields
    {
        uint8_t DATA0 : 8;             /*!< [7:0] DATA0 */
    } B;
} hw_dac_datnl_t;

/*!
 * @name Constants and macros for entire DAC_DATnL register
 */
/*@{*/
#define HW_DAC_DATnL_COUNT (2U)

#define HW_DAC_DATnL_ADDR(x, n)  ((uint32_t)(x) + 0x0U + (0x2U * (n)))

#define HW_DAC_DATnL(x, n)       (*(__IO hw_dac_datnl_t *) HW_DAC_DATnL_ADDR(x, n))
#define HW_DAC_DATnL_RD(x, n)    (HW_DAC_DATnL(x, n).U)
#define HW_DAC_DATnL_WR(x, n, v) (HW_DAC_DATnL(x, n).U = (v))
#define HW_DAC_DATnL_SET(x, n, v) (BME_OR8(HW_DAC_DATnL_ADDR(x, n), (uint8_t)(v)))
#define HW_DAC_DATnL_CLR(x, n, v) (BME_AND8(HW_DAC_DATnL_ADDR(x, n), (uint8_t)(~(v))))
#define HW_DAC_DATnL_TOG(x, n, v) (BME_XOR8(HW_DAC_DATnL_ADDR(x, n), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual DAC_DATnL bitfields
 */

/*!
 * @name Register DAC_DATnL, field DATA0[7:0] (RW)
 *
 * When the DAC buffer is not enabled, DATA[11:0] controls the output voltage
 * based on the following formula: V out = V in * (1 + DACDAT0[11:0])/4096 When the
 * DAC buffer is enabled, DATA is mapped to the 16-word buffer.
 */
/*@{*/
#define BP_DAC_DATnL_DATA0   (0U)          /*!< Bit position for DAC_DATnL_DATA0. */
#define BM_DAC_DATnL_DATA0   (0xFFU)       /*!< Bit mask for DAC_DATnL_DATA0. */
#define BS_DAC_DATnL_DATA0   (8U)          /*!< Bit field size in bits for DAC_DATnL_DATA0. */

/*! @brief Read current value of the DAC_DATnL_DATA0 field. */
#define BR_DAC_DATnL_DATA0(x, n) (HW_DAC_DATnL(x, n).U)

/*! @brief Format value for bitfield DAC_DATnL_DATA0. */
#define BF_DAC_DATnL_DATA0(v) ((uint8_t)((uint8_t)(v) << BP_DAC_DATnL_DATA0) & BM_DAC_DATnL_DATA0)

/*! @brief Set the DATA0 field to a new value. */
#define BW_DAC_DATnL_DATA0(x, n, v) (HW_DAC_DATnL_WR(x, n, v))
/*@}*/
/*******************************************************************************
 * HW_DAC_DATnH - DAC Data High Register
 ******************************************************************************/

/*!
 * @brief HW_DAC_DATnH - DAC Data High Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_dac_datnh
{
    uint8_t U;
    struct _hw_dac_datnh_bitfields
    {
        uint8_t DATA1 : 4;             /*!< [3:0] DATA1 */
        uint8_t RESERVED0 : 4;         /*!< [7:4]  */
    } B;
} hw_dac_datnh_t;

/*!
 * @name Constants and macros for entire DAC_DATnH register
 */
/*@{*/
#define HW_DAC_DATnH_COUNT (2U)

#define HW_DAC_DATnH_ADDR(x, n)  ((uint32_t)(x) + 0x1U + (0x2U * (n)))

#define HW_DAC_DATnH(x, n)       (*(__IO hw_dac_datnh_t *) HW_DAC_DATnH_ADDR(x, n))
#define HW_DAC_DATnH_RD(x, n)    (HW_DAC_DATnH(x, n).U)
#define HW_DAC_DATnH_WR(x, n, v) (HW_DAC_DATnH(x, n).U = (v))
#define HW_DAC_DATnH_SET(x, n, v) (BME_OR8(HW_DAC_DATnH_ADDR(x, n), (uint8_t)(v)))
#define HW_DAC_DATnH_CLR(x, n, v) (BME_AND8(HW_DAC_DATnH_ADDR(x, n), (uint8_t)(~(v))))
#define HW_DAC_DATnH_TOG(x, n, v) (BME_XOR8(HW_DAC_DATnH_ADDR(x, n), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual DAC_DATnH bitfields
 */

/*!
 * @name Register DAC_DATnH, field DATA1[3:0] (RW)
 *
 * When the DAC Buffer is not enabled, DATA[11:0] controls the output voltage
 * based on the following formula. V out = V in * (1 + DACDAT0[11:0])/4096 When the
 * DAC buffer is enabled, DATA[11:0] is mapped to the 16-word buffer.
 */
/*@{*/
#define BP_DAC_DATnH_DATA1   (0U)          /*!< Bit position for DAC_DATnH_DATA1. */
#define BM_DAC_DATnH_DATA1   (0x0FU)       /*!< Bit mask for DAC_DATnH_DATA1. */
#define BS_DAC_DATnH_DATA1   (4U)          /*!< Bit field size in bits for DAC_DATnH_DATA1. */

/*! @brief Read current value of the DAC_DATnH_DATA1 field. */
#define BR_DAC_DATnH_DATA1(x, n) (BME_UBFX8(HW_DAC_DATnH_ADDR(x, n), BP_DAC_DATnH_DATA1, BS_DAC_DATnH_DATA1))

/*! @brief Format value for bitfield DAC_DATnH_DATA1. */
#define BF_DAC_DATnH_DATA1(v) ((uint8_t)((uint8_t)(v) << BP_DAC_DATnH_DATA1) & BM_DAC_DATnH_DATA1)

/*! @brief Set the DATA1 field to a new value. */
#define BW_DAC_DATnH_DATA1(x, n, v) (BME_BFI8(HW_DAC_DATnH_ADDR(x, n), ((uint8_t)(v) << BP_DAC_DATnH_DATA1), BP_DAC_DATnH_DATA1, 4))
/*@}*/

/*******************************************************************************
 * HW_DAC_SR - DAC Status Register
 ******************************************************************************/

/*!
 * @brief HW_DAC_SR - DAC Status Register (RW)
 *
 * Reset value: 0x02U
 *
 * If DMA is enabled, the flags can be cleared automatically by DMA when the DMA
 * request is done. Writing 0 to a field clears it whereas writing 1 has no
 * effect. After reset, DACBFRPTF is set and can be cleared by software, if needed.
 * The flags are set only when the data buffer status is changed.
 */
typedef union _hw_dac_sr
{
    uint8_t U;
    struct _hw_dac_sr_bitfields
    {
        uint8_t DACBFRPBF : 1;         /*!< [0] DAC Buffer Read Pointer Bottom
                                        * Position Flag */
        uint8_t DACBFRPTF : 1;         /*!< [1] DAC Buffer Read Pointer Top Position
                                        * Flag */
        uint8_t RESERVED0 : 6;         /*!< [7:2]  */
    } B;
} hw_dac_sr_t;

/*!
 * @name Constants and macros for entire DAC_SR register
 */
/*@{*/
#define HW_DAC_SR_ADDR(x)        ((uint32_t)(x) + 0x20U)

#define HW_DAC_SR(x)             (*(__IO hw_dac_sr_t *) HW_DAC_SR_ADDR(x))
#define HW_DAC_SR_RD(x)          (HW_DAC_SR(x).U)
#define HW_DAC_SR_WR(x, v)       (HW_DAC_SR(x).U = (v))
#define HW_DAC_SR_SET(x, v)      (BME_OR8(HW_DAC_SR_ADDR(x), (uint8_t)(v)))
#define HW_DAC_SR_CLR(x, v)      (BME_AND8(HW_DAC_SR_ADDR(x), (uint8_t)(~(v))))
#define HW_DAC_SR_TOG(x, v)      (BME_XOR8(HW_DAC_SR_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual DAC_SR bitfields
 */

/*!
 * @name Register DAC_SR, field DACBFRPBF[0] (RW)
 *
 * In FIFO mode, it is FIFO FULL status bit. It means FIFO read pointer equals
 * Write Pointer because of Write Pointer increase. If this bit is set, any write
 * to FIFO from either DMA or CPU is ignored by DAC. It is cleared if there is
 * any DAC trigger making the DAC read pointer increase. Write to this bit is
 * ignored in FIFO mode.
 *
 * Values:
 * - 0 - The DAC buffer read pointer is not equal to C2[DACBFUP].
 * - 1 - The DAC buffer read pointer is equal to C2[DACBFUP].
 */
/*@{*/
#define BP_DAC_SR_DACBFRPBF  (0U)          /*!< Bit position for DAC_SR_DACBFRPBF. */
#define BM_DAC_SR_DACBFRPBF  (0x01U)       /*!< Bit mask for DAC_SR_DACBFRPBF. */
#define BS_DAC_SR_DACBFRPBF  (1U)          /*!< Bit field size in bits for DAC_SR_DACBFRPBF. */

/*! @brief Read current value of the DAC_SR_DACBFRPBF field. */
#define BR_DAC_SR_DACBFRPBF(x) (BME_UBFX8(HW_DAC_SR_ADDR(x), BP_DAC_SR_DACBFRPBF, BS_DAC_SR_DACBFRPBF))

/*! @brief Format value for bitfield DAC_SR_DACBFRPBF. */
#define BF_DAC_SR_DACBFRPBF(v) ((uint8_t)((uint8_t)(v) << BP_DAC_SR_DACBFRPBF) & BM_DAC_SR_DACBFRPBF)

/*! @brief Set the DACBFRPBF field to a new value. */
#define BW_DAC_SR_DACBFRPBF(x, v) (BME_BFI8(HW_DAC_SR_ADDR(x), ((uint8_t)(v) << BP_DAC_SR_DACBFRPBF), BP_DAC_SR_DACBFRPBF, 1))
/*@}*/

/*!
 * @name Register DAC_SR, field DACBFRPTF[1] (RW)
 *
 * In FIFO mode, it is FIFO nearly empty flag. It is set when only one data
 * remains in FIFO. Any DAC trigger does not increase the Read Pointer if this bit is
 * set to avoid any possible glitch or abrupt change at DAC output. It is
 * cleared automatically if FIFO is not empty.
 *
 * Values:
 * - 0 - The DAC buffer read pointer is not zero.
 * - 1 - The DAC buffer read pointer is zero.
 */
/*@{*/
#define BP_DAC_SR_DACBFRPTF  (1U)          /*!< Bit position for DAC_SR_DACBFRPTF. */
#define BM_DAC_SR_DACBFRPTF  (0x02U)       /*!< Bit mask for DAC_SR_DACBFRPTF. */
#define BS_DAC_SR_DACBFRPTF  (1U)          /*!< Bit field size in bits for DAC_SR_DACBFRPTF. */

/*! @brief Read current value of the DAC_SR_DACBFRPTF field. */
#define BR_DAC_SR_DACBFRPTF(x) (BME_UBFX8(HW_DAC_SR_ADDR(x), BP_DAC_SR_DACBFRPTF, BS_DAC_SR_DACBFRPTF))

/*! @brief Format value for bitfield DAC_SR_DACBFRPTF. */
#define BF_DAC_SR_DACBFRPTF(v) ((uint8_t)((uint8_t)(v) << BP_DAC_SR_DACBFRPTF) & BM_DAC_SR_DACBFRPTF)

/*! @brief Set the DACBFRPTF field to a new value. */
#define BW_DAC_SR_DACBFRPTF(x, v) (BME_BFI8(HW_DAC_SR_ADDR(x), ((uint8_t)(v) << BP_DAC_SR_DACBFRPTF), BP_DAC_SR_DACBFRPTF, 1))
/*@}*/

/*******************************************************************************
 * HW_DAC_C0 - DAC Control Register
 ******************************************************************************/

/*!
 * @brief HW_DAC_C0 - DAC Control Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_dac_c0
{
    uint8_t U;
    struct _hw_dac_c0_bitfields
    {
        uint8_t DACBBIEN : 1;          /*!< [0] DAC Buffer Read Pointer Bottom Flag
                                        * Interrupt Enable */
        uint8_t DACBTIEN : 1;          /*!< [1] DAC Buffer Read Pointer Top Flag
                                        * Interrupt Enable */
        uint8_t RESERVED0 : 1;         /*!< [2]  */
        uint8_t LPEN : 1;              /*!< [3] DAC Low Power Control */
        uint8_t DACSWTRG : 1;          /*!< [4] DAC Software Trigger */
        uint8_t DACTRGSEL : 1;         /*!< [5] DAC Trigger Select */
        uint8_t DACRFS : 1;            /*!< [6] DAC Reference Select */
        uint8_t DACEN : 1;             /*!< [7] DAC Enable */
    } B;
} hw_dac_c0_t;

/*!
 * @name Constants and macros for entire DAC_C0 register
 */
/*@{*/
#define HW_DAC_C0_ADDR(x)        ((uint32_t)(x) + 0x21U)

#define HW_DAC_C0(x)             (*(__IO hw_dac_c0_t *) HW_DAC_C0_ADDR(x))
#define HW_DAC_C0_RD(x)          (HW_DAC_C0(x).U)
#define HW_DAC_C0_WR(x, v)       (HW_DAC_C0(x).U = (v))
#define HW_DAC_C0_SET(x, v)      (BME_OR8(HW_DAC_C0_ADDR(x), (uint8_t)(v)))
#define HW_DAC_C0_CLR(x, v)      (BME_AND8(HW_DAC_C0_ADDR(x), (uint8_t)(~(v))))
#define HW_DAC_C0_TOG(x, v)      (BME_XOR8(HW_DAC_C0_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual DAC_C0 bitfields
 */

/*!
 * @name Register DAC_C0, field DACBBIEN[0] (RW)
 *
 * Values:
 * - 0 - The DAC buffer read pointer bottom flag interrupt is disabled.
 * - 1 - The DAC buffer read pointer bottom flag interrupt is enabled.
 */
/*@{*/
#define BP_DAC_C0_DACBBIEN   (0U)          /*!< Bit position for DAC_C0_DACBBIEN. */
#define BM_DAC_C0_DACBBIEN   (0x01U)       /*!< Bit mask for DAC_C0_DACBBIEN. */
#define BS_DAC_C0_DACBBIEN   (1U)          /*!< Bit field size in bits for DAC_C0_DACBBIEN. */

/*! @brief Read current value of the DAC_C0_DACBBIEN field. */
#define BR_DAC_C0_DACBBIEN(x) (BME_UBFX8(HW_DAC_C0_ADDR(x), BP_DAC_C0_DACBBIEN, BS_DAC_C0_DACBBIEN))

/*! @brief Format value for bitfield DAC_C0_DACBBIEN. */
#define BF_DAC_C0_DACBBIEN(v) ((uint8_t)((uint8_t)(v) << BP_DAC_C0_DACBBIEN) & BM_DAC_C0_DACBBIEN)

/*! @brief Set the DACBBIEN field to a new value. */
#define BW_DAC_C0_DACBBIEN(x, v) (BME_BFI8(HW_DAC_C0_ADDR(x), ((uint8_t)(v) << BP_DAC_C0_DACBBIEN), BP_DAC_C0_DACBBIEN, 1))
/*@}*/

/*!
 * @name Register DAC_C0, field DACBTIEN[1] (RW)
 *
 * Values:
 * - 0 - The DAC buffer read pointer top flag interrupt is disabled.
 * - 1 - The DAC buffer read pointer top flag interrupt is enabled.
 */
/*@{*/
#define BP_DAC_C0_DACBTIEN   (1U)          /*!< Bit position for DAC_C0_DACBTIEN. */
#define BM_DAC_C0_DACBTIEN   (0x02U)       /*!< Bit mask for DAC_C0_DACBTIEN. */
#define BS_DAC_C0_DACBTIEN   (1U)          /*!< Bit field size in bits for DAC_C0_DACBTIEN. */

/*! @brief Read current value of the DAC_C0_DACBTIEN field. */
#define BR_DAC_C0_DACBTIEN(x) (BME_UBFX8(HW_DAC_C0_ADDR(x), BP_DAC_C0_DACBTIEN, BS_DAC_C0_DACBTIEN))

/*! @brief Format value for bitfield DAC_C0_DACBTIEN. */
#define BF_DAC_C0_DACBTIEN(v) ((uint8_t)((uint8_t)(v) << BP_DAC_C0_DACBTIEN) & BM_DAC_C0_DACBTIEN)

/*! @brief Set the DACBTIEN field to a new value. */
#define BW_DAC_C0_DACBTIEN(x, v) (BME_BFI8(HW_DAC_C0_ADDR(x), ((uint8_t)(v) << BP_DAC_C0_DACBTIEN), BP_DAC_C0_DACBTIEN, 1))
/*@}*/

/*!
 * @name Register DAC_C0, field LPEN[3] (RW)
 *
 * See the 12-bit DAC electrical characteristics of the device data sheet for
 * details on the impact of the modes below.
 *
 * Values:
 * - 0 - High-Power mode
 * - 1 - Low-Power mode
 */
/*@{*/
#define BP_DAC_C0_LPEN       (3U)          /*!< Bit position for DAC_C0_LPEN. */
#define BM_DAC_C0_LPEN       (0x08U)       /*!< Bit mask for DAC_C0_LPEN. */
#define BS_DAC_C0_LPEN       (1U)          /*!< Bit field size in bits for DAC_C0_LPEN. */

/*! @brief Read current value of the DAC_C0_LPEN field. */
#define BR_DAC_C0_LPEN(x)    (BME_UBFX8(HW_DAC_C0_ADDR(x), BP_DAC_C0_LPEN, BS_DAC_C0_LPEN))

/*! @brief Format value for bitfield DAC_C0_LPEN. */
#define BF_DAC_C0_LPEN(v)    ((uint8_t)((uint8_t)(v) << BP_DAC_C0_LPEN) & BM_DAC_C0_LPEN)

/*! @brief Set the LPEN field to a new value. */
#define BW_DAC_C0_LPEN(x, v) (BME_BFI8(HW_DAC_C0_ADDR(x), ((uint8_t)(v) << BP_DAC_C0_LPEN), BP_DAC_C0_LPEN, 1))
/*@}*/

/*!
 * @name Register DAC_C0, field DACSWTRG[4] (WORZ)
 *
 * Active high. This is a write-only field, which always reads 0. If DAC
 * software trigger is selected and buffer is enabled, writing 1 to this field will
 * advance the buffer read pointer once.
 *
 * Values:
 * - 0 - The DAC soft trigger is not valid.
 * - 1 - The DAC soft trigger is valid.
 */
/*@{*/
#define BP_DAC_C0_DACSWTRG   (4U)          /*!< Bit position for DAC_C0_DACSWTRG. */
#define BM_DAC_C0_DACSWTRG   (0x10U)       /*!< Bit mask for DAC_C0_DACSWTRG. */
#define BS_DAC_C0_DACSWTRG   (1U)          /*!< Bit field size in bits for DAC_C0_DACSWTRG. */

/*! @brief Format value for bitfield DAC_C0_DACSWTRG. */
#define BF_DAC_C0_DACSWTRG(v) ((uint8_t)((uint8_t)(v) << BP_DAC_C0_DACSWTRG) & BM_DAC_C0_DACSWTRG)

/*! @brief Set the DACSWTRG field to a new value. */
#define BW_DAC_C0_DACSWTRG(x, v) (BME_BFI8(HW_DAC_C0_ADDR(x), ((uint8_t)(v) << BP_DAC_C0_DACSWTRG), BP_DAC_C0_DACSWTRG, 1))
/*@}*/

/*!
 * @name Register DAC_C0, field DACTRGSEL[5] (RW)
 *
 * Values:
 * - 0 - The DAC hardware trigger is selected.
 * - 1 - The DAC software trigger is selected.
 */
/*@{*/
#define BP_DAC_C0_DACTRGSEL  (5U)          /*!< Bit position for DAC_C0_DACTRGSEL. */
#define BM_DAC_C0_DACTRGSEL  (0x20U)       /*!< Bit mask for DAC_C0_DACTRGSEL. */
#define BS_DAC_C0_DACTRGSEL  (1U)          /*!< Bit field size in bits for DAC_C0_DACTRGSEL. */

/*! @brief Read current value of the DAC_C0_DACTRGSEL field. */
#define BR_DAC_C0_DACTRGSEL(x) (BME_UBFX8(HW_DAC_C0_ADDR(x), BP_DAC_C0_DACTRGSEL, BS_DAC_C0_DACTRGSEL))

/*! @brief Format value for bitfield DAC_C0_DACTRGSEL. */
#define BF_DAC_C0_DACTRGSEL(v) ((uint8_t)((uint8_t)(v) << BP_DAC_C0_DACTRGSEL) & BM_DAC_C0_DACTRGSEL)

/*! @brief Set the DACTRGSEL field to a new value. */
#define BW_DAC_C0_DACTRGSEL(x, v) (BME_BFI8(HW_DAC_C0_ADDR(x), ((uint8_t)(v) << BP_DAC_C0_DACTRGSEL), BP_DAC_C0_DACTRGSEL, 1))
/*@}*/

/*!
 * @name Register DAC_C0, field DACRFS[6] (RW)
 *
 * Values:
 * - 0 - The DAC selects DACREF_1 as the reference voltage.
 * - 1 - The DAC selects DACREF_2 as the reference voltage.
 */
/*@{*/
#define BP_DAC_C0_DACRFS     (6U)          /*!< Bit position for DAC_C0_DACRFS. */
#define BM_DAC_C0_DACRFS     (0x40U)       /*!< Bit mask for DAC_C0_DACRFS. */
#define BS_DAC_C0_DACRFS     (1U)          /*!< Bit field size in bits for DAC_C0_DACRFS. */

/*! @brief Read current value of the DAC_C0_DACRFS field. */
#define BR_DAC_C0_DACRFS(x)  (BME_UBFX8(HW_DAC_C0_ADDR(x), BP_DAC_C0_DACRFS, BS_DAC_C0_DACRFS))

/*! @brief Format value for bitfield DAC_C0_DACRFS. */
#define BF_DAC_C0_DACRFS(v)  ((uint8_t)((uint8_t)(v) << BP_DAC_C0_DACRFS) & BM_DAC_C0_DACRFS)

/*! @brief Set the DACRFS field to a new value. */
#define BW_DAC_C0_DACRFS(x, v) (BME_BFI8(HW_DAC_C0_ADDR(x), ((uint8_t)(v) << BP_DAC_C0_DACRFS), BP_DAC_C0_DACRFS, 1))
/*@}*/

/*!
 * @name Register DAC_C0, field DACEN[7] (RW)
 *
 * Starts the Programmable Reference Generator operation.
 *
 * Values:
 * - 0 - The DAC system is disabled.
 * - 1 - The DAC system is enabled.
 */
/*@{*/
#define BP_DAC_C0_DACEN      (7U)          /*!< Bit position for DAC_C0_DACEN. */
#define BM_DAC_C0_DACEN      (0x80U)       /*!< Bit mask for DAC_C0_DACEN. */
#define BS_DAC_C0_DACEN      (1U)          /*!< Bit field size in bits for DAC_C0_DACEN. */

/*! @brief Read current value of the DAC_C0_DACEN field. */
#define BR_DAC_C0_DACEN(x)   (BME_UBFX8(HW_DAC_C0_ADDR(x), BP_DAC_C0_DACEN, BS_DAC_C0_DACEN))

/*! @brief Format value for bitfield DAC_C0_DACEN. */
#define BF_DAC_C0_DACEN(v)   ((uint8_t)((uint8_t)(v) << BP_DAC_C0_DACEN) & BM_DAC_C0_DACEN)

/*! @brief Set the DACEN field to a new value. */
#define BW_DAC_C0_DACEN(x, v) (BME_BFI8(HW_DAC_C0_ADDR(x), ((uint8_t)(v) << BP_DAC_C0_DACEN), BP_DAC_C0_DACEN, 1))
/*@}*/

/*******************************************************************************
 * HW_DAC_C1 - DAC Control Register 1
 ******************************************************************************/

/*!
 * @brief HW_DAC_C1 - DAC Control Register 1 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_dac_c1
{
    uint8_t U;
    struct _hw_dac_c1_bitfields
    {
        uint8_t DACBFEN : 1;           /*!< [0] DAC Buffer Enable */
        uint8_t DACBFMD : 2;           /*!< [2:1] DAC Buffer Work Mode Select */
        uint8_t RESERVED0 : 4;         /*!< [6:3]  */
        uint8_t DMAEN : 1;             /*!< [7] DMA Enable Select */
    } B;
} hw_dac_c1_t;

/*!
 * @name Constants and macros for entire DAC_C1 register
 */
/*@{*/
#define HW_DAC_C1_ADDR(x)        ((uint32_t)(x) + 0x22U)

#define HW_DAC_C1(x)             (*(__IO hw_dac_c1_t *) HW_DAC_C1_ADDR(x))
#define HW_DAC_C1_RD(x)          (HW_DAC_C1(x).U)
#define HW_DAC_C1_WR(x, v)       (HW_DAC_C1(x).U = (v))
#define HW_DAC_C1_SET(x, v)      (BME_OR8(HW_DAC_C1_ADDR(x), (uint8_t)(v)))
#define HW_DAC_C1_CLR(x, v)      (BME_AND8(HW_DAC_C1_ADDR(x), (uint8_t)(~(v))))
#define HW_DAC_C1_TOG(x, v)      (BME_XOR8(HW_DAC_C1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual DAC_C1 bitfields
 */

/*!
 * @name Register DAC_C1, field DACBFEN[0] (RW)
 *
 * Values:
 * - 0 - Buffer read pointer is disabled. The converted data is always the first
 *     word of the buffer.
 * - 1 - Buffer read pointer is enabled. The converted data is the word that the
 *     read pointer points to. It means converted data can be from any word of
 *     the buffer.
 */
/*@{*/
#define BP_DAC_C1_DACBFEN    (0U)          /*!< Bit position for DAC_C1_DACBFEN. */
#define BM_DAC_C1_DACBFEN    (0x01U)       /*!< Bit mask for DAC_C1_DACBFEN. */
#define BS_DAC_C1_DACBFEN    (1U)          /*!< Bit field size in bits for DAC_C1_DACBFEN. */

/*! @brief Read current value of the DAC_C1_DACBFEN field. */
#define BR_DAC_C1_DACBFEN(x) (BME_UBFX8(HW_DAC_C1_ADDR(x), BP_DAC_C1_DACBFEN, BS_DAC_C1_DACBFEN))

/*! @brief Format value for bitfield DAC_C1_DACBFEN. */
#define BF_DAC_C1_DACBFEN(v) ((uint8_t)((uint8_t)(v) << BP_DAC_C1_DACBFEN) & BM_DAC_C1_DACBFEN)

/*! @brief Set the DACBFEN field to a new value. */
#define BW_DAC_C1_DACBFEN(x, v) (BME_BFI8(HW_DAC_C1_ADDR(x), ((uint8_t)(v) << BP_DAC_C1_DACBFEN), BP_DAC_C1_DACBFEN, 1))
/*@}*/

/*!
 * @name Register DAC_C1, field DACBFMD[2:1] (RW)
 *
 * Values:
 * - 00 - Normal mode
 * - 01 - Reserved
 * - 10 - One-Time Scan mode
 * - 11 - FIFO mode
 */
/*@{*/
#define BP_DAC_C1_DACBFMD    (1U)          /*!< Bit position for DAC_C1_DACBFMD. */
#define BM_DAC_C1_DACBFMD    (0x06U)       /*!< Bit mask for DAC_C1_DACBFMD. */
#define BS_DAC_C1_DACBFMD    (2U)          /*!< Bit field size in bits for DAC_C1_DACBFMD. */

/*! @brief Read current value of the DAC_C1_DACBFMD field. */
#define BR_DAC_C1_DACBFMD(x) (BME_UBFX8(HW_DAC_C1_ADDR(x), BP_DAC_C1_DACBFMD, BS_DAC_C1_DACBFMD))

/*! @brief Format value for bitfield DAC_C1_DACBFMD. */
#define BF_DAC_C1_DACBFMD(v) ((uint8_t)((uint8_t)(v) << BP_DAC_C1_DACBFMD) & BM_DAC_C1_DACBFMD)

/*! @brief Set the DACBFMD field to a new value. */
#define BW_DAC_C1_DACBFMD(x, v) (BME_BFI8(HW_DAC_C1_ADDR(x), ((uint8_t)(v) << BP_DAC_C1_DACBFMD), BP_DAC_C1_DACBFMD, 2))
/*@}*/

/*!
 * @name Register DAC_C1, field DMAEN[7] (RW)
 *
 * Values:
 * - 0 - DMA is disabled.
 * - 1 - DMA is enabled. When DMA is enabled, the DMA request will be generated
 *     by original interrupts. The interrupts will not be presented on this
 *     module at the same time.
 */
/*@{*/
#define BP_DAC_C1_DMAEN      (7U)          /*!< Bit position for DAC_C1_DMAEN. */
#define BM_DAC_C1_DMAEN      (0x80U)       /*!< Bit mask for DAC_C1_DMAEN. */
#define BS_DAC_C1_DMAEN      (1U)          /*!< Bit field size in bits for DAC_C1_DMAEN. */

/*! @brief Read current value of the DAC_C1_DMAEN field. */
#define BR_DAC_C1_DMAEN(x)   (BME_UBFX8(HW_DAC_C1_ADDR(x), BP_DAC_C1_DMAEN, BS_DAC_C1_DMAEN))

/*! @brief Format value for bitfield DAC_C1_DMAEN. */
#define BF_DAC_C1_DMAEN(v)   ((uint8_t)((uint8_t)(v) << BP_DAC_C1_DMAEN) & BM_DAC_C1_DMAEN)

/*! @brief Set the DMAEN field to a new value. */
#define BW_DAC_C1_DMAEN(x, v) (BME_BFI8(HW_DAC_C1_ADDR(x), ((uint8_t)(v) << BP_DAC_C1_DMAEN), BP_DAC_C1_DMAEN, 1))
/*@}*/

/*******************************************************************************
 * HW_DAC_C2 - DAC Control Register 2
 ******************************************************************************/

/*!
 * @brief HW_DAC_C2 - DAC Control Register 2 (RW)
 *
 * Reset value: 0x01U
 */
typedef union _hw_dac_c2
{
    uint8_t U;
    struct _hw_dac_c2_bitfields
    {
        uint8_t DACBFUP : 1;           /*!< [0] DAC Buffer Upper Limit */
        uint8_t RESERVED0 : 3;         /*!< [3:1]  */
        uint8_t DACBFRP : 1;           /*!< [4] DAC Buffer Read Pointer */
        uint8_t RESERVED1 : 3;         /*!< [7:5]  */
    } B;
} hw_dac_c2_t;

/*!
 * @name Constants and macros for entire DAC_C2 register
 */
/*@{*/
#define HW_DAC_C2_ADDR(x)        ((uint32_t)(x) + 0x23U)

#define HW_DAC_C2(x)             (*(__IO hw_dac_c2_t *) HW_DAC_C2_ADDR(x))
#define HW_DAC_C2_RD(x)          (HW_DAC_C2(x).U)
#define HW_DAC_C2_WR(x, v)       (HW_DAC_C2(x).U = (v))
#define HW_DAC_C2_SET(x, v)      (BME_OR8(HW_DAC_C2_ADDR(x), (uint8_t)(v)))
#define HW_DAC_C2_CLR(x, v)      (BME_AND8(HW_DAC_C2_ADDR(x), (uint8_t)(~(v))))
#define HW_DAC_C2_TOG(x, v)      (BME_XOR8(HW_DAC_C2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual DAC_C2 bitfields
 */

/*!
 * @name Register DAC_C2, field DACBFUP[0] (RW)
 *
 * In normal mode it selects the upper limit of the DAC buffer. The buffer read
 * pointer cannot exceed it. In FIFO mode it is the FIFO write pointer. User
 * cannot set Buffer Up limit in FIFO mode. In Normal mode its reset value is MAX.
 * When IP is configured to FIFO mode, this register becomes Write_Pointer, and its
 * value is initially set to equal READ_POINTER automatically, and the FIFO
 * status is empty. It is writable and user can configure it to the same address to
 * reset FIFO as empty.
 */
/*@{*/
#define BP_DAC_C2_DACBFUP    (0U)          /*!< Bit position for DAC_C2_DACBFUP. */
#define BM_DAC_C2_DACBFUP    (0x01U)       /*!< Bit mask for DAC_C2_DACBFUP. */
#define BS_DAC_C2_DACBFUP    (1U)          /*!< Bit field size in bits for DAC_C2_DACBFUP. */

/*! @brief Read current value of the DAC_C2_DACBFUP field. */
#define BR_DAC_C2_DACBFUP(x) (BME_UBFX8(HW_DAC_C2_ADDR(x), BP_DAC_C2_DACBFUP, BS_DAC_C2_DACBFUP))

/*! @brief Format value for bitfield DAC_C2_DACBFUP. */
#define BF_DAC_C2_DACBFUP(v) ((uint8_t)((uint8_t)(v) << BP_DAC_C2_DACBFUP) & BM_DAC_C2_DACBFUP)

/*! @brief Set the DACBFUP field to a new value. */
#define BW_DAC_C2_DACBFUP(x, v) (BME_BFI8(HW_DAC_C2_ADDR(x), ((uint8_t)(v) << BP_DAC_C2_DACBFUP), BP_DAC_C2_DACBFUP, 1))
/*@}*/

/*!
 * @name Register DAC_C2, field DACBFRP[4] (RW)
 *
 * In normal mode it keeps the current value of the buffer read pointer. FIFO
 * mode, it is the FIFO read pointer. It is writable in FIFO mode. User can
 * configure it to same address to reset FIFO as empty.
 */
/*@{*/
#define BP_DAC_C2_DACBFRP    (4U)          /*!< Bit position for DAC_C2_DACBFRP. */
#define BM_DAC_C2_DACBFRP    (0x10U)       /*!< Bit mask for DAC_C2_DACBFRP. */
#define BS_DAC_C2_DACBFRP    (1U)          /*!< Bit field size in bits for DAC_C2_DACBFRP. */

/*! @brief Read current value of the DAC_C2_DACBFRP field. */
#define BR_DAC_C2_DACBFRP(x) (BME_UBFX8(HW_DAC_C2_ADDR(x), BP_DAC_C2_DACBFRP, BS_DAC_C2_DACBFRP))

/*! @brief Format value for bitfield DAC_C2_DACBFRP. */
#define BF_DAC_C2_DACBFRP(v) ((uint8_t)((uint8_t)(v) << BP_DAC_C2_DACBFRP) & BM_DAC_C2_DACBFRP)

/*! @brief Set the DACBFRP field to a new value. */
#define BW_DAC_C2_DACBFRP(x, v) (BME_BFI8(HW_DAC_C2_ADDR(x), ((uint8_t)(v) << BP_DAC_C2_DACBFRP), BP_DAC_C2_DACBFRP, 1))
/*@}*/

/*******************************************************************************
 * hw_dac_t - module struct
 ******************************************************************************/
/*!
 * @brief All DAC module registers.
 */
#pragma pack(1)
typedef struct _hw_dac
{
    struct {
        __IO hw_dac_datnl_t DATnL;         /*!< [0x0] DAC Data Low Register */
        __IO hw_dac_datnh_t DATnH;         /*!< [0x1] DAC Data High Register */
    } DAT[2];
    uint8_t _reserved0[28];
    __IO hw_dac_sr_t SR;                   /*!< [0x20] DAC Status Register */
    __IO hw_dac_c0_t C0;                   /*!< [0x21] DAC Control Register */
    __IO hw_dac_c1_t C1;                   /*!< [0x22] DAC Control Register 1 */
    __IO hw_dac_c2_t C2;                   /*!< [0x23] DAC Control Register 2 */
} hw_dac_t;
#pragma pack()

/*! @brief Macro to access all DAC registers. */
/*! @param x DAC module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_DAC_REGS(DAC0_BASE)</code>. */
#define HW_DAC_REGS(x) (*(hw_dac_t *)(x))

/*
 * MKL43Z4 DMA
 *
 * DMA Controller
 *
 * Registers defined in this header file:
 * - HW_DMA_SARn - Source Address Register
 * - HW_DMA_DARn - Destination Address Register
 * - HW_DMA_DSRn - DMA_DSR0 register.
 * - HW_DMA_DSR_BCRn - DMA Status Register / Byte Count Register
 * - HW_DMA_DCRn - DMA Control Register
 *
 * - hw_dma_t - Struct containing all module registers.
 */

#define HW_DMA_INSTANCE_COUNT (1U) /*!< Number of instances of the DMA module. */
#define HW_DMA (0U) /*!< Instance number for DMA. */

/*******************************************************************************
 * HW_DMA_SARn - Source Address Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_SARn - Source Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * For this register: Only 32-bit writes are allowed. 16-bit and 8-bit writes
 * result in a bus error. Only four values are allowed to be written to bits 31-20
 * of this register. A write of any other value to these bits causes a
 * configuration error when the channel starts to execute. For more information about the
 * configuration error, see the description of the CEConfiguration Error field of
 * DSR.
 */
typedef union _hw_dma_sarn
{
    uint32_t U;
    struct _hw_dma_sarn_bitfields
    {
        uint32_t SAR : 32;             /*!< [31:0] SAR */
    } B;
} hw_dma_sarn_t;

/*!
 * @name Constants and macros for entire DMA_SARn register
 */
/*@{*/
#define HW_DMA_SARn_COUNT (4U)

#define HW_DMA_SARn_ADDR(x, n)   ((uint32_t)(x) + 0x100U + (0x10U * (n)))

#define HW_DMA_SARn(x, n)        (*(__IO hw_dma_sarn_t *) HW_DMA_SARn_ADDR(x, n))
#define HW_DMA_SARn_RD(x, n)     (HW_DMA_SARn(x, n).U)
#define HW_DMA_SARn_WR(x, n, v)  (HW_DMA_SARn(x, n).U = (v))
#define HW_DMA_SARn_SET(x, n, v) (BME_OR32(HW_DMA_SARn_ADDR(x, n), (uint32_t)(v)))
#define HW_DMA_SARn_CLR(x, n, v) (BME_AND32(HW_DMA_SARn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_DMA_SARn_TOG(x, n, v) (BME_XOR32(HW_DMA_SARn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual DMA_SARn bitfields
 */

/*!
 * @name Register DMA_SARn, field SAR[31:0] (RW)
 *
 * Each SAR contains the byte address used by the DMA controller to read data.
 * The SARn is typically aligned on a 0-modulo-ssize boundary-that is, on the
 * natural alignment of the source data. Bits 31-20 of this register must be written
 * with one of only four allowed values. Each of these four allowed values
 * corresponds to a valid region of the device's memory map. The allowed values are:
 * 0x000x_xxxx 0x1FFx_xxxx 0x200x_xxxx 0x400x_xxxx After being written with one of
 * the allowed values, bits 31-20 read back as the written value. After being
 * written with any other value, bits 31-20 read back as an indeterminate value.
 */
/*@{*/
#define BP_DMA_SARn_SAR      (0U)          /*!< Bit position for DMA_SARn_SAR. */
#define BM_DMA_SARn_SAR      (0xFFFFFFFFU) /*!< Bit mask for DMA_SARn_SAR. */
#define BS_DMA_SARn_SAR      (32U)         /*!< Bit field size in bits for DMA_SARn_SAR. */

/*! @brief Read current value of the DMA_SARn_SAR field. */
#define BR_DMA_SARn_SAR(x, n) (HW_DMA_SARn(x, n).U)

/*! @brief Format value for bitfield DMA_SARn_SAR. */
#define BF_DMA_SARn_SAR(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_SARn_SAR) & BM_DMA_SARn_SAR)

/*! @brief Set the SAR field to a new value. */
#define BW_DMA_SARn_SAR(x, n, v) (HW_DMA_SARn_WR(x, n, v))
/*@}*/
/*******************************************************************************
 * HW_DMA_DARn - Destination Address Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_DARn - Destination Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * For this register: Only 32-bit writes are allowed. 16-bit and 8-bit writes
 * result in a bus error. Only four values are allowed to be written to bits 31-20
 * of this register. A write of any other value to these bits causes a
 * configuration error when the channel starts to execute. For more information about the
 * configuration error, see the description of the CEConfiguration Error field of
 * DSR.
 */
typedef union _hw_dma_darn
{
    uint32_t U;
    struct _hw_dma_darn_bitfields
    {
        uint32_t DAR : 32;             /*!< [31:0] DAR */
    } B;
} hw_dma_darn_t;

/*!
 * @name Constants and macros for entire DMA_DARn register
 */
/*@{*/
#define HW_DMA_DARn_COUNT (4U)

#define HW_DMA_DARn_ADDR(x, n)   ((uint32_t)(x) + 0x104U + (0x10U * (n)))

#define HW_DMA_DARn(x, n)        (*(__IO hw_dma_darn_t *) HW_DMA_DARn_ADDR(x, n))
#define HW_DMA_DARn_RD(x, n)     (HW_DMA_DARn(x, n).U)
#define HW_DMA_DARn_WR(x, n, v)  (HW_DMA_DARn(x, n).U = (v))
#define HW_DMA_DARn_SET(x, n, v) (BME_OR32(HW_DMA_DARn_ADDR(x, n), (uint32_t)(v)))
#define HW_DMA_DARn_CLR(x, n, v) (BME_AND32(HW_DMA_DARn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_DMA_DARn_TOG(x, n, v) (BME_XOR32(HW_DMA_DARn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual DMA_DARn bitfields
 */

/*!
 * @name Register DMA_DARn, field DAR[31:0] (RW)
 *
 * Each DAR contains the byte address used by the DMA controller to write data.
 * The DARn is typically aligned on a 0-modulo-dsize boundary-that is, on the
 * natural alignment of the destination data. Bits 31-20 of this register must be
 * written with one of only four allowed values. Each of these four allowed values
 * corresponds to a valid region of the device's memory map. The allowed values
 * are: 0x000x_xxxx 0x1FFx_xxxx 0x200x_xxxx 0x400x_xxxx After being written with
 * one of the allowed values, bits 31-20 read back as the written value. After
 * being written with any other value, bits 31-20 read back as an indeterminate
 * value.
 */
/*@{*/
#define BP_DMA_DARn_DAR      (0U)          /*!< Bit position for DMA_DARn_DAR. */
#define BM_DMA_DARn_DAR      (0xFFFFFFFFU) /*!< Bit mask for DMA_DARn_DAR. */
#define BS_DMA_DARn_DAR      (32U)         /*!< Bit field size in bits for DMA_DARn_DAR. */

/*! @brief Read current value of the DMA_DARn_DAR field. */
#define BR_DMA_DARn_DAR(x, n) (HW_DMA_DARn(x, n).U)

/*! @brief Format value for bitfield DMA_DARn_DAR. */
#define BF_DMA_DARn_DAR(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_DARn_DAR) & BM_DMA_DARn_DAR)

/*! @brief Set the DAR field to a new value. */
#define BW_DMA_DARn_DAR(x, n, v) (HW_DMA_DARn_WR(x, n, v))
/*@}*/
/*******************************************************************************
 * HW_DMA_DSRn - DMA_DSR0 register.
 ******************************************************************************/

/*!
 * @brief HW_DMA_DSRn - DMA_DSR0 register. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_dma_dsrn
{
    uint8_t U;
    struct _hw_dma_dsrn_bitfields
    {
        uint8_t RESERVED0 : 8;         /*!< [7:0]  */
    } B;
} hw_dma_dsrn_t;

/*!
 * @name Constants and macros for entire DMA_DSRn register
 */
/*@{*/
#define HW_DMA_DSRn_COUNT (4U)

#define HW_DMA_DSRn_ADDR(x, n)   ((uint32_t)(x) + 0x10BU + (0x10U * (n)))

#define HW_DMA_DSRn(x, n)        (*(__IO hw_dma_dsrn_t *) HW_DMA_DSRn_ADDR(x, n))
#define HW_DMA_DSRn_RD(x, n)     (HW_DMA_DSRn(x, n).U)
#define HW_DMA_DSRn_WR(x, n, v)  (HW_DMA_DSRn(x, n).U = (v))
#define HW_DMA_DSRn_SET(x, n, v) (BME_OR8(HW_DMA_DSRn_ADDR(x, n), (uint8_t)(v)))
#define HW_DMA_DSRn_CLR(x, n, v) (BME_AND8(HW_DMA_DSRn_ADDR(x, n), (uint8_t)(~(v))))
#define HW_DMA_DSRn_TOG(x, n, v) (BME_XOR8(HW_DMA_DSRn_ADDR(x, n), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual DMA_DSRn bitfields
 */
/*******************************************************************************
 * HW_DMA_DSR_BCRn - DMA Status Register / Byte Count Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_DSR_BCRn - DMA Status Register / Byte Count Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * DSR and BCR are two logical registers that occupy one 32-bit address. DSRn
 * occupies bits 31-24, and BCRn occupies bits 23-0. DSRn contains flags indicating
 * the channel status, and BCRn contains the number of bytes yet to be
 * transferred for a given block. On the successful completion of the write transfer, BCRn
 * decrements by 1, 2, or 4 for 8-bit, 16-bit, or 32-bit accesses, respectively.
 * BCRn is cleared if a 1 is written to DSR[DONE]. In response to an event, the
 * DMA controller writes to the appropriate DSRn bit. Only a write to DSRn[DONE]
 * results in action. DSRn[DONE] is set when the block transfer is complete. When
 * a transfer sequence is initiated and BCRn[BCR] is not a multiple of 4 or 2
 * when the DMA is configured for 32-bit or 16-bit transfers, respectively,
 * DSRn[CE] is set and no transfer occurs.
 */
typedef union _hw_dma_dsr_bcrn
{
    uint32_t U;
    struct _hw_dma_dsr_bcrn_bitfields
    {
        uint32_t BCR : 24;             /*!< [23:0] BCR */
        uint32_t DONE : 1;             /*!< [24] Transactions Done */
        uint32_t BSY : 1;              /*!< [25] Busy */
        uint32_t REQ : 1;              /*!< [26] Request */
        uint32_t RESERVED0 : 1;        /*!< [27]  */
        uint32_t BED : 1;              /*!< [28] Bus Error on Destination */
        uint32_t BES : 1;              /*!< [29] Bus Error on Source */
        uint32_t CE : 1;               /*!< [30] Configuration Error */
        uint32_t RESERVED1 : 1;        /*!< [31]  */
    } B;
} hw_dma_dsr_bcrn_t;

/*!
 * @name Constants and macros for entire DMA_DSR_BCRn register
 */
/*@{*/
#define HW_DMA_DSR_BCRn_COUNT (4U)

#define HW_DMA_DSR_BCRn_ADDR(x, n) ((uint32_t)(x) + 0x108U + (0x10U * (n)))

#define HW_DMA_DSR_BCRn(x, n)    (*(__IO hw_dma_dsr_bcrn_t *) HW_DMA_DSR_BCRn_ADDR(x, n))
#define HW_DMA_DSR_BCRn_RD(x, n) (HW_DMA_DSR_BCRn(x, n).U)
#define HW_DMA_DSR_BCRn_WR(x, n, v) (HW_DMA_DSR_BCRn(x, n).U = (v))
#define HW_DMA_DSR_BCRn_SET(x, n, v) (BME_OR32(HW_DMA_DSR_BCRn_ADDR(x, n), (uint32_t)(v)))
#define HW_DMA_DSR_BCRn_CLR(x, n, v) (BME_AND32(HW_DMA_DSR_BCRn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_DMA_DSR_BCRn_TOG(x, n, v) (BME_XOR32(HW_DMA_DSR_BCRn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual DMA_DSR_BCRn bitfields
 */

/*!
 * @name Register DMA_DSR_BCRn, field BCR[23:0] (RW)
 *
 * This field contains the number of bytes yet to be transferred for a given
 * block. BCR must be written with a value equal to or less than 0F_FFFFh. After
 * being written with a value in this range, bits 23-20 of BCR read back as 0000b. A
 * write to BCR of a value greater than 0F_FFFFh causes a configuration error
 * when the channel starts to execute. After being written with a value in this
 * range, bits 23-20 of BCR read back as 0001b.
 */
/*@{*/
#define BP_DMA_DSR_BCRn_BCR  (0U)          /*!< Bit position for DMA_DSR_BCRn_BCR. */
#define BM_DMA_DSR_BCRn_BCR  (0x00FFFFFFU) /*!< Bit mask for DMA_DSR_BCRn_BCR. */
#define BS_DMA_DSR_BCRn_BCR  (24U)         /*!< Bit field size in bits for DMA_DSR_BCRn_BCR. */

/*! @brief Read current value of the DMA_DSR_BCRn_BCR field. */
#define BR_DMA_DSR_BCRn_BCR(x, n) (HW_DMA_DSR_BCRn(x, n).B.BCR)

/*! @brief Format value for bitfield DMA_DSR_BCRn_BCR. */
#define BF_DMA_DSR_BCRn_BCR(v) ((uint32_t)((uint32_t)(v) << BP_DMA_DSR_BCRn_BCR) & BM_DMA_DSR_BCRn_BCR)

/*! @brief Set the BCR field to a new value. */
#define BW_DMA_DSR_BCRn_BCR(x, n, v) (HW_DMA_DSR_BCRn_WR(x, n, (HW_DMA_DSR_BCRn_RD(x, n) & ~BM_DMA_DSR_BCRn_BCR) | BF_DMA_DSR_BCRn_BCR(v)))
/*@}*/

/*!
 * @name Register DMA_DSR_BCRn, field DONE[24] (W1C)
 *
 * Set when all DMA controller transactions complete as determined by transfer
 * count, or based on error conditions. When BCR reaches 0, DONE is set when the
 * final transfer completes successfully. DONE can also be used to abort a
 * transfer by resetting the status bits. When a transfer completes, software must clear
 * DONE before reprogramming the DMA.
 *
 * Values:
 * - 0 - DMA transfer is not yet complete. Writing a 0 has no effect.
 * - 1 - DMA transfer completed. Writing a 1 to this bit clears all DMA status
 *     bits and should be used in an interrupt service routine to clear the DMA
 *     interrupt and error bits.
 */
/*@{*/
#define BP_DMA_DSR_BCRn_DONE (24U)         /*!< Bit position for DMA_DSR_BCRn_DONE. */
#define BM_DMA_DSR_BCRn_DONE (0x01000000U) /*!< Bit mask for DMA_DSR_BCRn_DONE. */
#define BS_DMA_DSR_BCRn_DONE (1U)          /*!< Bit field size in bits for DMA_DSR_BCRn_DONE. */

/*! @brief Read current value of the DMA_DSR_BCRn_DONE field. */
#define BR_DMA_DSR_BCRn_DONE(x, n) (BME_UBFX32(HW_DMA_DSR_BCRn_ADDR(x, n), BP_DMA_DSR_BCRn_DONE, BS_DMA_DSR_BCRn_DONE))

/*! @brief Format value for bitfield DMA_DSR_BCRn_DONE. */
#define BF_DMA_DSR_BCRn_DONE(v) ((uint32_t)((uint32_t)(v) << BP_DMA_DSR_BCRn_DONE) & BM_DMA_DSR_BCRn_DONE)

/*! @brief Set the DONE field to a new value. */
#define BW_DMA_DSR_BCRn_DONE(x, n, v) (BME_BFI32(HW_DMA_DSR_BCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DSR_BCRn_DONE), BP_DMA_DSR_BCRn_DONE, 1))
/*@}*/

/*!
 * @name Register DMA_DSR_BCRn, field BSY[25] (RO)
 *
 * Values:
 * - 0 - DMA channel is inactive. Cleared when the DMA has finished the last
 *     transaction.
 * - 1 - BSY is set the first time the channel is enabled after a transfer is
 *     initiated.
 */
/*@{*/
#define BP_DMA_DSR_BCRn_BSY  (25U)         /*!< Bit position for DMA_DSR_BCRn_BSY. */
#define BM_DMA_DSR_BCRn_BSY  (0x02000000U) /*!< Bit mask for DMA_DSR_BCRn_BSY. */
#define BS_DMA_DSR_BCRn_BSY  (1U)          /*!< Bit field size in bits for DMA_DSR_BCRn_BSY. */

/*! @brief Read current value of the DMA_DSR_BCRn_BSY field. */
#define BR_DMA_DSR_BCRn_BSY(x, n) (BME_UBFX32(HW_DMA_DSR_BCRn_ADDR(x, n), BP_DMA_DSR_BCRn_BSY, BS_DMA_DSR_BCRn_BSY))
/*@}*/

/*!
 * @name Register DMA_DSR_BCRn, field REQ[26] (RO)
 *
 * Values:
 * - 0 - No request is pending or the channel is currently active. Cleared when
 *     the channel is selected.
 * - 1 - The DMA channel has a transfer remaining and the channel is not
 *     selected.
 */
/*@{*/
#define BP_DMA_DSR_BCRn_REQ  (26U)         /*!< Bit position for DMA_DSR_BCRn_REQ. */
#define BM_DMA_DSR_BCRn_REQ  (0x04000000U) /*!< Bit mask for DMA_DSR_BCRn_REQ. */
#define BS_DMA_DSR_BCRn_REQ  (1U)          /*!< Bit field size in bits for DMA_DSR_BCRn_REQ. */

/*! @brief Read current value of the DMA_DSR_BCRn_REQ field. */
#define BR_DMA_DSR_BCRn_REQ(x, n) (BME_UBFX32(HW_DMA_DSR_BCRn_ADDR(x, n), BP_DMA_DSR_BCRn_REQ, BS_DMA_DSR_BCRn_REQ))
/*@}*/

/*!
 * @name Register DMA_DSR_BCRn, field BED[28] (RO)
 *
 * BED is cleared at hardware reset or by writing a 1 to DONE.
 *
 * Values:
 * - 0 - No bus error occurred.
 * - 1 - The DMA channel terminated with a bus error during the write portion of
 *     a transfer.
 */
/*@{*/
#define BP_DMA_DSR_BCRn_BED  (28U)         /*!< Bit position for DMA_DSR_BCRn_BED. */
#define BM_DMA_DSR_BCRn_BED  (0x10000000U) /*!< Bit mask for DMA_DSR_BCRn_BED. */
#define BS_DMA_DSR_BCRn_BED  (1U)          /*!< Bit field size in bits for DMA_DSR_BCRn_BED. */

/*! @brief Read current value of the DMA_DSR_BCRn_BED field. */
#define BR_DMA_DSR_BCRn_BED(x, n) (BME_UBFX32(HW_DMA_DSR_BCRn_ADDR(x, n), BP_DMA_DSR_BCRn_BED, BS_DMA_DSR_BCRn_BED))
/*@}*/

/*!
 * @name Register DMA_DSR_BCRn, field BES[29] (RO)
 *
 * BES is cleared at hardware reset or by writing a 1 to DONE.
 *
 * Values:
 * - 0 - No bus error occurred.
 * - 1 - The DMA channel terminated with a bus error during the read portion of
 *     a transfer.
 */
/*@{*/
#define BP_DMA_DSR_BCRn_BES  (29U)         /*!< Bit position for DMA_DSR_BCRn_BES. */
#define BM_DMA_DSR_BCRn_BES  (0x20000000U) /*!< Bit mask for DMA_DSR_BCRn_BES. */
#define BS_DMA_DSR_BCRn_BES  (1U)          /*!< Bit field size in bits for DMA_DSR_BCRn_BES. */

/*! @brief Read current value of the DMA_DSR_BCRn_BES field. */
#define BR_DMA_DSR_BCRn_BES(x, n) (BME_UBFX32(HW_DMA_DSR_BCRn_ADDR(x, n), BP_DMA_DSR_BCRn_BES, BS_DMA_DSR_BCRn_BES))
/*@}*/

/*!
 * @name Register DMA_DSR_BCRn, field CE[30] (RO)
 *
 * Any of the following conditions causes a configuration error: BCR, SAR, or
 * DAR does not match the requested transfer size. A value greater than 0F_FFFFh is
 * written to BCR. Bits 31-20 of SAR or DAR are written with a value other than
 * one of the allowed values. See SARSAR and DARDAR . SSIZE or DSIZE is set to an
 * unsupported value. BCR equals 0 when the DMA receives a start condition. CE
 * is cleared at hardware reset or by writing a 1 to DONE.
 *
 * Values:
 * - 0 - No configuration error exists.
 * - 1 - A configuration error has occurred.
 */
/*@{*/
#define BP_DMA_DSR_BCRn_CE   (30U)         /*!< Bit position for DMA_DSR_BCRn_CE. */
#define BM_DMA_DSR_BCRn_CE   (0x40000000U) /*!< Bit mask for DMA_DSR_BCRn_CE. */
#define BS_DMA_DSR_BCRn_CE   (1U)          /*!< Bit field size in bits for DMA_DSR_BCRn_CE. */

/*! @brief Read current value of the DMA_DSR_BCRn_CE field. */
#define BR_DMA_DSR_BCRn_CE(x, n) (BME_UBFX32(HW_DMA_DSR_BCRn_ADDR(x, n), BP_DMA_DSR_BCRn_CE, BS_DMA_DSR_BCRn_CE))
/*@}*/
/*******************************************************************************
 * HW_DMA_DCRn - DMA Control Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_DCRn - DMA Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_dcrn
{
    uint32_t U;
    struct _hw_dma_dcrn_bitfields
    {
        uint32_t LCH2 : 2;             /*!< [1:0] Link Channel 2 */
        uint32_t LCH1 : 2;             /*!< [3:2] Link Channel 1 */
        uint32_t LINKCC : 2;           /*!< [5:4] Link Channel Control */
        uint32_t RESERVED0 : 1;        /*!< [6]  */
        uint32_t D_REQ : 1;            /*!< [7] Disable Request */
        uint32_t DMOD : 4;             /*!< [11:8] Destination Address Modulo */
        uint32_t SMOD : 4;             /*!< [15:12] Source Address Modulo */
        uint32_t START : 1;            /*!< [16] Start Transfer */
        uint32_t DSIZE : 2;            /*!< [18:17] Destination Size */
        uint32_t DINC : 1;             /*!< [19] Destination Increment */
        uint32_t SSIZE : 2;            /*!< [21:20] Source Size */
        uint32_t SINC : 1;             /*!< [22] Source Increment */
        uint32_t EADREQ : 1;           /*!< [23] Enable asynchronous DMA requests */
        uint32_t RESERVED1 : 4;        /*!< [27:24]  */
        uint32_t AA : 1;               /*!< [28] Auto-align */
        uint32_t CS : 1;               /*!< [29] Cycle Steal */
        uint32_t ERQ : 1;              /*!< [30] Enable Peripheral Request */
        uint32_t EINT : 1;             /*!< [31] Enable Interrupt on Completion of
                                        * Transfer */
    } B;
} hw_dma_dcrn_t;

/*!
 * @name Constants and macros for entire DMA_DCRn register
 */
/*@{*/
#define HW_DMA_DCRn_COUNT (4U)

#define HW_DMA_DCRn_ADDR(x, n)   ((uint32_t)(x) + 0x10CU + (0x10U * (n)))

#define HW_DMA_DCRn(x, n)        (*(__IO hw_dma_dcrn_t *) HW_DMA_DCRn_ADDR(x, n))
#define HW_DMA_DCRn_RD(x, n)     (HW_DMA_DCRn(x, n).U)
#define HW_DMA_DCRn_WR(x, n, v)  (HW_DMA_DCRn(x, n).U = (v))
#define HW_DMA_DCRn_SET(x, n, v) (BME_OR32(HW_DMA_DCRn_ADDR(x, n), (uint32_t)(v)))
#define HW_DMA_DCRn_CLR(x, n, v) (BME_AND32(HW_DMA_DCRn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_DMA_DCRn_TOG(x, n, v) (BME_XOR32(HW_DMA_DCRn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCRn bitfields
 */

/*!
 * @name Register DMA_DCRn, field LCH2[1:0] (RW)
 *
 * Indicates the DMA channel assigned as link channel 2. The link channel number
 * cannot be the same as the currently executing channel, and generates a
 * configuration error if this is attempted (DSRn[CE] is set).
 *
 * Values:
 * - 00 - DMA Channel 0
 * - 01 - DMA Channel 1
 * - 10 - DMA Channel 2
 * - 11 - DMA Channel 3
 */
/*@{*/
#define BP_DMA_DCRn_LCH2     (0U)          /*!< Bit position for DMA_DCRn_LCH2. */
#define BM_DMA_DCRn_LCH2     (0x00000003U) /*!< Bit mask for DMA_DCRn_LCH2. */
#define BS_DMA_DCRn_LCH2     (2U)          /*!< Bit field size in bits for DMA_DCRn_LCH2. */

/*! @brief Read current value of the DMA_DCRn_LCH2 field. */
#define BR_DMA_DCRn_LCH2(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_LCH2, BS_DMA_DCRn_LCH2))

/*! @brief Format value for bitfield DMA_DCRn_LCH2. */
#define BF_DMA_DCRn_LCH2(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_LCH2) & BM_DMA_DCRn_LCH2)

/*! @brief Set the LCH2 field to a new value. */
#define BW_DMA_DCRn_LCH2(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_LCH2), BP_DMA_DCRn_LCH2, 2))
/*@}*/

/*!
 * @name Register DMA_DCRn, field LCH1[3:2] (RW)
 *
 * Indicates the DMA channel assigned as link channel 1. The link channel number
 * cannot be the same as the currently executing channel, and generates a
 * configuration error if this is attempted (DSRn[CE] is set).
 *
 * Values:
 * - 00 - DMA Channel 0
 * - 01 - DMA Channel 1
 * - 10 - DMA Channel 2
 * - 11 - DMA Channel 3
 */
/*@{*/
#define BP_DMA_DCRn_LCH1     (2U)          /*!< Bit position for DMA_DCRn_LCH1. */
#define BM_DMA_DCRn_LCH1     (0x0000000CU) /*!< Bit mask for DMA_DCRn_LCH1. */
#define BS_DMA_DCRn_LCH1     (2U)          /*!< Bit field size in bits for DMA_DCRn_LCH1. */

/*! @brief Read current value of the DMA_DCRn_LCH1 field. */
#define BR_DMA_DCRn_LCH1(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_LCH1, BS_DMA_DCRn_LCH1))

/*! @brief Format value for bitfield DMA_DCRn_LCH1. */
#define BF_DMA_DCRn_LCH1(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_LCH1) & BM_DMA_DCRn_LCH1)

/*! @brief Set the LCH1 field to a new value. */
#define BW_DMA_DCRn_LCH1(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_LCH1), BP_DMA_DCRn_LCH1, 2))
/*@}*/

/*!
 * @name Register DMA_DCRn, field LINKCC[5:4] (RW)
 *
 * Allows DMA channels to have their transfers linked. The current DMA channel
 * triggers a DMA request to the linked channels (LCH1 or LCH2) depending on the
 * condition described by the LINKCC bits. If not in cycle steal mode (DCRn[CS]=0)
 * and LINKCC equals 01 or 10, no link to LCH1 occurs. If LINKCC equals 01, a
 * link to LCH1 is created after each cycle-steal transfer performed by the current
 * DMA channel is completed. As the last cycle-steal is performed and the BCR
 * reaches zero, then the link to LCH1 is closed and a link to LCH2 is created.
 *
 * Values:
 * - 00 - No channel-to-channel linking
 * - 01 - Perform a link to channel LCH1 after each cycle-steal transfer
 *     followed by a link to LCH2 after the BCR decrements to 0.
 * - 10 - Perform a link to channel LCH1 after each cycle-steal transfer
 * - 11 - Perform a link to channel LCH1 after the BCR decrements to 0.
 */
/*@{*/
#define BP_DMA_DCRn_LINKCC   (4U)          /*!< Bit position for DMA_DCRn_LINKCC. */
#define BM_DMA_DCRn_LINKCC   (0x00000030U) /*!< Bit mask for DMA_DCRn_LINKCC. */
#define BS_DMA_DCRn_LINKCC   (2U)          /*!< Bit field size in bits for DMA_DCRn_LINKCC. */

/*! @brief Read current value of the DMA_DCRn_LINKCC field. */
#define BR_DMA_DCRn_LINKCC(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_LINKCC, BS_DMA_DCRn_LINKCC))

/*! @brief Format value for bitfield DMA_DCRn_LINKCC. */
#define BF_DMA_DCRn_LINKCC(v) ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_LINKCC) & BM_DMA_DCRn_LINKCC)

/*! @brief Set the LINKCC field to a new value. */
#define BW_DMA_DCRn_LINKCC(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_LINKCC), BP_DMA_DCRn_LINKCC, 2))
/*@}*/

/*!
 * @name Register DMA_DCRn, field D_REQ[7] (RW)
 *
 * DMA hardware automatically clears the corresponding DCRn[ERQ] bit when the
 * byte count register reaches 0.
 *
 * Values:
 * - 0 - ERQ bit is not affected.
 * - 1 - ERQ bit is cleared when the BCR is exhausted.
 */
/*@{*/
#define BP_DMA_DCRn_D_REQ    (7U)          /*!< Bit position for DMA_DCRn_D_REQ. */
#define BM_DMA_DCRn_D_REQ    (0x00000080U) /*!< Bit mask for DMA_DCRn_D_REQ. */
#define BS_DMA_DCRn_D_REQ    (1U)          /*!< Bit field size in bits for DMA_DCRn_D_REQ. */

/*! @brief Read current value of the DMA_DCRn_D_REQ field. */
#define BR_DMA_DCRn_D_REQ(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_D_REQ, BS_DMA_DCRn_D_REQ))

/*! @brief Format value for bitfield DMA_DCRn_D_REQ. */
#define BF_DMA_DCRn_D_REQ(v) ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_D_REQ) & BM_DMA_DCRn_D_REQ)

/*! @brief Set the D_REQ field to a new value. */
#define BW_DMA_DCRn_D_REQ(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_D_REQ), BP_DMA_DCRn_D_REQ, 1))
/*@}*/

/*!
 * @name Register DMA_DCRn, field DMOD[11:8] (RW)
 *
 * Defines the size of the destination data circular buffer used by the DMA
 * Controller. If enabled (DMOD value is non-zero), the buffer base address is
 * located on a boundary of the buffer size. The value of this boundary depends on the
 * initial destination address (DAR). The base address should be aligned to a
 * 0-modulo-(circular buffer size) boundary. Misaligned buffers are not possible.
 * The boundary is forced to the value determined by the upper address bits in the
 * field selection.
 *
 * Values:
 * - 0000 - Buffer disabled
 * - 0001 - Circular buffer size is 16 bytes
 * - 0010 - Circular buffer size is 32 bytes
 * - 0011 - Circular buffer size is 64 bytes
 * - 0100 - Circular buffer size is 128 bytes
 * - 0101 - Circular buffer size is 256 bytes
 * - 0110 - Circular buffer size is 512 bytes
 * - 0111 - Circular buffer size is 1 KB
 * - 1000 - Circular buffer size is 2 KB
 * - 1001 - Circular buffer size is 4 KB
 * - 1010 - Circular buffer size is 8 KB
 * - 1011 - Circular buffer size is 16 KB
 * - 1100 - Circular buffer size is 32 KB
 * - 1101 - Circular buffer size is 64 KB
 * - 1110 - Circular buffer size is 128 KB
 * - 1111 - Circular buffer size is 256 KB
 */
/*@{*/
#define BP_DMA_DCRn_DMOD     (8U)          /*!< Bit position for DMA_DCRn_DMOD. */
#define BM_DMA_DCRn_DMOD     (0x00000F00U) /*!< Bit mask for DMA_DCRn_DMOD. */
#define BS_DMA_DCRn_DMOD     (4U)          /*!< Bit field size in bits for DMA_DCRn_DMOD. */

/*! @brief Read current value of the DMA_DCRn_DMOD field. */
#define BR_DMA_DCRn_DMOD(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_DMOD, BS_DMA_DCRn_DMOD))

/*! @brief Format value for bitfield DMA_DCRn_DMOD. */
#define BF_DMA_DCRn_DMOD(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_DMOD) & BM_DMA_DCRn_DMOD)

/*! @brief Set the DMOD field to a new value. */
#define BW_DMA_DCRn_DMOD(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_DMOD), BP_DMA_DCRn_DMOD, 4))
/*@}*/

/*!
 * @name Register DMA_DCRn, field SMOD[15:12] (RW)
 *
 * Defines the size of the source data circular buffer used by the DMA
 * Controller. If enabled (SMOD is non-zero), the buffer base address is located on a
 * boundary of the buffer size. The value of this boundary is based upon the initial
 * source address (SAR). The base address should be aligned to a
 * 0-modulo-(circular buffer size) boundary. Misaligned buffers are not possible. The boundary is
 * forced to the value determined by the upper address bits in the field
 * selection.
 *
 * Values:
 * - 0000 - Buffer disabled
 * - 0001 - Circular buffer size is 16 bytes.
 * - 0010 - Circular buffer size is 32 bytes.
 * - 0011 - Circular buffer size is 64 bytes.
 * - 0100 - Circular buffer size is 128 bytes.
 * - 0101 - Circular buffer size is 256 bytes.
 * - 0110 - Circular buffer size is 512 bytes.
 * - 0111 - Circular buffer size is 1 KB.
 * - 1000 - Circular buffer size is 2 KB.
 * - 1001 - Circular buffer size is 4 KB.
 * - 1010 - Circular buffer size is 8 KB.
 * - 1011 - Circular buffer size is 16 KB.
 * - 1100 - Circular buffer size is 32 KB.
 * - 1101 - Circular buffer size is 64 KB.
 * - 1110 - Circular buffer size is 128 KB.
 * - 1111 - Circular buffer size is 256 KB.
 */
/*@{*/
#define BP_DMA_DCRn_SMOD     (12U)         /*!< Bit position for DMA_DCRn_SMOD. */
#define BM_DMA_DCRn_SMOD     (0x0000F000U) /*!< Bit mask for DMA_DCRn_SMOD. */
#define BS_DMA_DCRn_SMOD     (4U)          /*!< Bit field size in bits for DMA_DCRn_SMOD. */

/*! @brief Read current value of the DMA_DCRn_SMOD field. */
#define BR_DMA_DCRn_SMOD(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_SMOD, BS_DMA_DCRn_SMOD))

/*! @brief Format value for bitfield DMA_DCRn_SMOD. */
#define BF_DMA_DCRn_SMOD(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_SMOD) & BM_DMA_DCRn_SMOD)

/*! @brief Set the SMOD field to a new value. */
#define BW_DMA_DCRn_SMOD(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_SMOD), BP_DMA_DCRn_SMOD, 4))
/*@}*/

/*!
 * @name Register DMA_DCRn, field START[16] (WORZ)
 *
 * Values:
 * - 0 - DMA inactive
 * - 1 - The DMA begins the transfer in accordance to the values in the TCDn.
 *     START is cleared automatically after one module clock and always reads as
 *     logic 0.
 */
/*@{*/
#define BP_DMA_DCRn_START    (16U)         /*!< Bit position for DMA_DCRn_START. */
#define BM_DMA_DCRn_START    (0x00010000U) /*!< Bit mask for DMA_DCRn_START. */
#define BS_DMA_DCRn_START    (1U)          /*!< Bit field size in bits for DMA_DCRn_START. */

/*! @brief Format value for bitfield DMA_DCRn_START. */
#define BF_DMA_DCRn_START(v) ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_START) & BM_DMA_DCRn_START)

/*! @brief Set the START field to a new value. */
#define BW_DMA_DCRn_START(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_START), BP_DMA_DCRn_START, 1))
/*@}*/

/*!
 * @name Register DMA_DCRn, field DSIZE[18:17] (RW)
 *
 * Determines the data size of the destination bus cycle for the DMA controller.
 *
 * Values:
 * - 00 - 32-bit
 * - 01 - 8-bit
 * - 10 - 16-bit
 * - 11 - Reserved (generates a configuration error (DSRn[CE]) if incorrectly
 *     specified at time of channel activation)
 */
/*@{*/
#define BP_DMA_DCRn_DSIZE    (17U)         /*!< Bit position for DMA_DCRn_DSIZE. */
#define BM_DMA_DCRn_DSIZE    (0x00060000U) /*!< Bit mask for DMA_DCRn_DSIZE. */
#define BS_DMA_DCRn_DSIZE    (2U)          /*!< Bit field size in bits for DMA_DCRn_DSIZE. */

/*! @brief Read current value of the DMA_DCRn_DSIZE field. */
#define BR_DMA_DCRn_DSIZE(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_DSIZE, BS_DMA_DCRn_DSIZE))

/*! @brief Format value for bitfield DMA_DCRn_DSIZE. */
#define BF_DMA_DCRn_DSIZE(v) ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_DSIZE) & BM_DMA_DCRn_DSIZE)

/*! @brief Set the DSIZE field to a new value. */
#define BW_DMA_DCRn_DSIZE(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_DSIZE), BP_DMA_DCRn_DSIZE, 2))
/*@}*/

/*!
 * @name Register DMA_DCRn, field DINC[19] (RW)
 *
 * Controls whether the destination address increments after each successful
 * transfer.
 *
 * Values:
 * - 0 - No change to the DAR after a successful transfer.
 * - 1 - The DAR increments by 1, 2, 4 depending upon the size of the transfer.
 */
/*@{*/
#define BP_DMA_DCRn_DINC     (19U)         /*!< Bit position for DMA_DCRn_DINC. */
#define BM_DMA_DCRn_DINC     (0x00080000U) /*!< Bit mask for DMA_DCRn_DINC. */
#define BS_DMA_DCRn_DINC     (1U)          /*!< Bit field size in bits for DMA_DCRn_DINC. */

/*! @brief Read current value of the DMA_DCRn_DINC field. */
#define BR_DMA_DCRn_DINC(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_DINC, BS_DMA_DCRn_DINC))

/*! @brief Format value for bitfield DMA_DCRn_DINC. */
#define BF_DMA_DCRn_DINC(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_DINC) & BM_DMA_DCRn_DINC)

/*! @brief Set the DINC field to a new value. */
#define BW_DMA_DCRn_DINC(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_DINC), BP_DMA_DCRn_DINC, 1))
/*@}*/

/*!
 * @name Register DMA_DCRn, field SSIZE[21:20] (RW)
 *
 * Determines the data size of the source bus cycle for the DMA controller.
 *
 * Values:
 * - 00 - 32-bit
 * - 01 - 8-bit
 * - 10 - 16-bit
 * - 11 - Reserved (generates a configuration error (DSRn[CE]) if incorrectly
 *     specified at time of channel activation)
 */
/*@{*/
#define BP_DMA_DCRn_SSIZE    (20U)         /*!< Bit position for DMA_DCRn_SSIZE. */
#define BM_DMA_DCRn_SSIZE    (0x00300000U) /*!< Bit mask for DMA_DCRn_SSIZE. */
#define BS_DMA_DCRn_SSIZE    (2U)          /*!< Bit field size in bits for DMA_DCRn_SSIZE. */

/*! @brief Read current value of the DMA_DCRn_SSIZE field. */
#define BR_DMA_DCRn_SSIZE(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_SSIZE, BS_DMA_DCRn_SSIZE))

/*! @brief Format value for bitfield DMA_DCRn_SSIZE. */
#define BF_DMA_DCRn_SSIZE(v) ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_SSIZE) & BM_DMA_DCRn_SSIZE)

/*! @brief Set the SSIZE field to a new value. */
#define BW_DMA_DCRn_SSIZE(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_SSIZE), BP_DMA_DCRn_SSIZE, 2))
/*@}*/

/*!
 * @name Register DMA_DCRn, field SINC[22] (RW)
 *
 * Controls whether the source address increments after each successful transfer.
 *
 * Values:
 * - 0 - No change to SAR after a successful transfer.
 * - 1 - The SAR increments by 1, 2, 4 as determined by the transfer size.
 */
/*@{*/
#define BP_DMA_DCRn_SINC     (22U)         /*!< Bit position for DMA_DCRn_SINC. */
#define BM_DMA_DCRn_SINC     (0x00400000U) /*!< Bit mask for DMA_DCRn_SINC. */
#define BS_DMA_DCRn_SINC     (1U)          /*!< Bit field size in bits for DMA_DCRn_SINC. */

/*! @brief Read current value of the DMA_DCRn_SINC field. */
#define BR_DMA_DCRn_SINC(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_SINC, BS_DMA_DCRn_SINC))

/*! @brief Format value for bitfield DMA_DCRn_SINC. */
#define BF_DMA_DCRn_SINC(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_SINC) & BM_DMA_DCRn_SINC)

/*! @brief Set the SINC field to a new value. */
#define BW_DMA_DCRn_SINC(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_SINC), BP_DMA_DCRn_SINC, 1))
/*@}*/

/*!
 * @name Register DMA_DCRn, field EADREQ[23] (RW)
 *
 * Enables the channel to support asynchronous DREQs while the MCU is in Stop
 * mode.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_DMA_DCRn_EADREQ   (23U)         /*!< Bit position for DMA_DCRn_EADREQ. */
#define BM_DMA_DCRn_EADREQ   (0x00800000U) /*!< Bit mask for DMA_DCRn_EADREQ. */
#define BS_DMA_DCRn_EADREQ   (1U)          /*!< Bit field size in bits for DMA_DCRn_EADREQ. */

/*! @brief Read current value of the DMA_DCRn_EADREQ field. */
#define BR_DMA_DCRn_EADREQ(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_EADREQ, BS_DMA_DCRn_EADREQ))

/*! @brief Format value for bitfield DMA_DCRn_EADREQ. */
#define BF_DMA_DCRn_EADREQ(v) ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_EADREQ) & BM_DMA_DCRn_EADREQ)

/*! @brief Set the EADREQ field to a new value. */
#define BW_DMA_DCRn_EADREQ(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_EADREQ), BP_DMA_DCRn_EADREQ, 1))
/*@}*/

/*!
 * @name Register DMA_DCRn, field AA[28] (RW)
 *
 * AA and SIZE bits determine whether the source or destination is auto-aligned;
 * that is, transfers are optimized based on the address and size.
 *
 * Values:
 * - 0 - Auto-align disabled
 * - 1 - If SSIZE indicates a transfer no smaller than DSIZE, source accesses
 *     are auto-aligned; otherwise, destination accesses are auto-aligned. Source
 *     alignment takes precedence over destination alignment. If auto-alignment is
 *     enabled, the appropriate address register increments, regardless of DINC
 *     or SINC.
 */
/*@{*/
#define BP_DMA_DCRn_AA       (28U)         /*!< Bit position for DMA_DCRn_AA. */
#define BM_DMA_DCRn_AA       (0x10000000U) /*!< Bit mask for DMA_DCRn_AA. */
#define BS_DMA_DCRn_AA       (1U)          /*!< Bit field size in bits for DMA_DCRn_AA. */

/*! @brief Read current value of the DMA_DCRn_AA field. */
#define BR_DMA_DCRn_AA(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_AA, BS_DMA_DCRn_AA))

/*! @brief Format value for bitfield DMA_DCRn_AA. */
#define BF_DMA_DCRn_AA(v)    ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_AA) & BM_DMA_DCRn_AA)

/*! @brief Set the AA field to a new value. */
#define BW_DMA_DCRn_AA(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_AA), BP_DMA_DCRn_AA, 1))
/*@}*/

/*!
 * @name Register DMA_DCRn, field CS[29] (RW)
 *
 * Values:
 * - 0 - DMA continuously makes read/write transfers until the BCR decrements to
 *     0.
 * - 1 - Forces a single read/write transfer per request.
 */
/*@{*/
#define BP_DMA_DCRn_CS       (29U)         /*!< Bit position for DMA_DCRn_CS. */
#define BM_DMA_DCRn_CS       (0x20000000U) /*!< Bit mask for DMA_DCRn_CS. */
#define BS_DMA_DCRn_CS       (1U)          /*!< Bit field size in bits for DMA_DCRn_CS. */

/*! @brief Read current value of the DMA_DCRn_CS field. */
#define BR_DMA_DCRn_CS(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_CS, BS_DMA_DCRn_CS))

/*! @brief Format value for bitfield DMA_DCRn_CS. */
#define BF_DMA_DCRn_CS(v)    ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_CS) & BM_DMA_DCRn_CS)

/*! @brief Set the CS field to a new value. */
#define BW_DMA_DCRn_CS(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_CS), BP_DMA_DCRn_CS, 1))
/*@}*/

/*!
 * @name Register DMA_DCRn, field ERQ[30] (RW)
 *
 * Be careful: a collision can occur between START and D_REQ when ERQ is 1.
 *
 * Values:
 * - 0 - Peripheral request is ignored.
 * - 1 - Enables peripheral request to initiate transfer. A software-initiated
 *     request (setting START) is always enabled.
 */
/*@{*/
#define BP_DMA_DCRn_ERQ      (30U)         /*!< Bit position for DMA_DCRn_ERQ. */
#define BM_DMA_DCRn_ERQ      (0x40000000U) /*!< Bit mask for DMA_DCRn_ERQ. */
#define BS_DMA_DCRn_ERQ      (1U)          /*!< Bit field size in bits for DMA_DCRn_ERQ. */

/*! @brief Read current value of the DMA_DCRn_ERQ field. */
#define BR_DMA_DCRn_ERQ(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_ERQ, BS_DMA_DCRn_ERQ))

/*! @brief Format value for bitfield DMA_DCRn_ERQ. */
#define BF_DMA_DCRn_ERQ(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_ERQ) & BM_DMA_DCRn_ERQ)

/*! @brief Set the ERQ field to a new value. */
#define BW_DMA_DCRn_ERQ(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_ERQ), BP_DMA_DCRn_ERQ, 1))
/*@}*/

/*!
 * @name Register DMA_DCRn, field EINT[31] (RW)
 *
 * Determines whether an interrupt is generated by completing a transfer or by
 * the occurrence of an error condition.
 *
 * Values:
 * - 0 - No interrupt is generated.
 * - 1 - Interrupt signal is enabled.
 */
/*@{*/
#define BP_DMA_DCRn_EINT     (31U)         /*!< Bit position for DMA_DCRn_EINT. */
#define BM_DMA_DCRn_EINT     (0x80000000U) /*!< Bit mask for DMA_DCRn_EINT. */
#define BS_DMA_DCRn_EINT     (1U)          /*!< Bit field size in bits for DMA_DCRn_EINT. */

/*! @brief Read current value of the DMA_DCRn_EINT field. */
#define BR_DMA_DCRn_EINT(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_EINT, BS_DMA_DCRn_EINT))

/*! @brief Format value for bitfield DMA_DCRn_EINT. */
#define BF_DMA_DCRn_EINT(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_EINT) & BM_DMA_DCRn_EINT)

/*! @brief Set the EINT field to a new value. */
#define BW_DMA_DCRn_EINT(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_EINT), BP_DMA_DCRn_EINT, 1))
/*@}*/

/*
** Start of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma push
  #pragma anon_unions
#elif defined(__CWCC__)
  #pragma push
  #pragma cpp_extensions on
#elif defined(__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=extended
#else
  #error Not supported compiler type
#endif

/*******************************************************************************
 * hw_dma_t - module struct
 ******************************************************************************/
/*!
 * @brief All DMA module registers.
 */
#pragma pack(1)
typedef struct _hw_dma
{
    uint8_t _reserved0[256];
    struct {
        __IO hw_dma_sarn_t SARn;           /*!< [0x100] Source Address Register */
        __IO hw_dma_darn_t DARn;           /*!< [0x104] Destination Address Register */
        union {
            struct {
                uint8_t _reserved0[3];
                __IO hw_dma_dsrn_t DSRn;   /*!< [0x10B] DMA_DSR0 register. */
            } DMA_DSR_ACCESS8BIT;
            __IO hw_dma_dsr_bcrn_t DSR_BCRn; /*!< [0x108] DMA Status Register / Byte Count Register */
        };
        __IO hw_dma_dcrn_t DCRn;           /*!< [0x10C] DMA Control Register */
    } DMA[4];
} hw_dma_t;
#pragma pack()

/*! @brief Macro to access all DMA registers. */
/*! @param x DMA module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_DMA_REGS(DMA_BASE)</code>. */
#define HW_DMA_REGS(x) (*(hw_dma_t *)(x))

/*
** End of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma pop
#elif defined(__CWCC__)
  #pragma pop
#elif defined(__GNUC__)
  /* leave anonymous unions enabled */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=default
#else
  #error Not supported compiler type
#endif

/*
 * MKL43Z4 DMAMUX
 *
 * DMA channel multiplexor
 *
 * Registers defined in this header file:
 * - HW_DMAMUX_CHCFGn - Channel Configuration register
 *
 * - hw_dmamux_t - Struct containing all module registers.
 */

#define HW_DMAMUX_INSTANCE_COUNT (1U) /*!< Number of instances of the DMAMUX module. */
#define HW_DMAMUX0 (0U) /*!< Instance number for DMAMUX0. */

/*******************************************************************************
 * HW_DMAMUX_CHCFGn - Channel Configuration register
 ******************************************************************************/

/*!
 * @brief HW_DMAMUX_CHCFGn - Channel Configuration register (RW)
 *
 * Reset value: 0x00U
 *
 * Each of the DMA channels can be independently enabled/disabled and associated
 * with one of the DMA slots (peripheral slots or always-on slots) in the
 * system. Setting multiple CHCFG registers with the same source value will result in
 * unpredictable behavior. This is true, even if a channel is disabled (ENBL==0).
 * Before changing the trigger or source settings, a DMA channel must be disabled
 * via CHCFGn[ENBL].
 */
typedef union _hw_dmamux_chcfgn
{
    uint8_t U;
    struct _hw_dmamux_chcfgn_bitfields
    {
        uint8_t SOURCE : 6;            /*!< [5:0] DMA Channel Source (Slot) */
        uint8_t TRIG : 1;              /*!< [6] DMA Channel Trigger Enable */
        uint8_t ENBL : 1;              /*!< [7] DMA Channel Enable */
    } B;
} hw_dmamux_chcfgn_t;

/*!
 * @name Constants and macros for entire DMAMUX_CHCFGn register
 */
/*@{*/
#define HW_DMAMUX_CHCFGn_COUNT (4U)

#define HW_DMAMUX_CHCFGn_ADDR(x, n) ((uint32_t)(x) + 0x0U + (0x1U * (n)))

#define HW_DMAMUX_CHCFGn(x, n)   (*(__IO hw_dmamux_chcfgn_t *) HW_DMAMUX_CHCFGn_ADDR(x, n))
#define HW_DMAMUX_CHCFGn_RD(x, n) (HW_DMAMUX_CHCFGn(x, n).U)
#define HW_DMAMUX_CHCFGn_WR(x, n, v) (HW_DMAMUX_CHCFGn(x, n).U = (v))
#define HW_DMAMUX_CHCFGn_SET(x, n, v) (BME_OR8(HW_DMAMUX_CHCFGn_ADDR(x, n), (uint8_t)(v)))
#define HW_DMAMUX_CHCFGn_CLR(x, n, v) (BME_AND8(HW_DMAMUX_CHCFGn_ADDR(x, n), (uint8_t)(~(v))))
#define HW_DMAMUX_CHCFGn_TOG(x, n, v) (BME_XOR8(HW_DMAMUX_CHCFGn_ADDR(x, n), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual DMAMUX_CHCFGn bitfields
 */

/*!
 * @name Register DMAMUX_CHCFGn, field SOURCE[5:0] (RW)
 *
 * Specifies which DMA source, if any, is routed to a particular DMA channel.
 * See the chip-specific DMAMUX information for details about the peripherals and
 * their slot numbers.
 */
/*@{*/
#define BP_DMAMUX_CHCFGn_SOURCE (0U)       /*!< Bit position for DMAMUX_CHCFGn_SOURCE. */
#define BM_DMAMUX_CHCFGn_SOURCE (0x3FU)    /*!< Bit mask for DMAMUX_CHCFGn_SOURCE. */
#define BS_DMAMUX_CHCFGn_SOURCE (6U)       /*!< Bit field size in bits for DMAMUX_CHCFGn_SOURCE. */

/*! @brief Read current value of the DMAMUX_CHCFGn_SOURCE field. */
#define BR_DMAMUX_CHCFGn_SOURCE(x, n) (BME_UBFX8(HW_DMAMUX_CHCFGn_ADDR(x, n), BP_DMAMUX_CHCFGn_SOURCE, BS_DMAMUX_CHCFGn_SOURCE))

/*! @brief Format value for bitfield DMAMUX_CHCFGn_SOURCE. */
#define BF_DMAMUX_CHCFGn_SOURCE(v) ((uint8_t)((uint8_t)(v) << BP_DMAMUX_CHCFGn_SOURCE) & BM_DMAMUX_CHCFGn_SOURCE)

/*! @brief Set the SOURCE field to a new value. */
#define BW_DMAMUX_CHCFGn_SOURCE(x, n, v) (BME_BFI8(HW_DMAMUX_CHCFGn_ADDR(x, n), ((uint8_t)(v) << BP_DMAMUX_CHCFGn_SOURCE), BP_DMAMUX_CHCFGn_SOURCE, 6))
/*@}*/

/*!
 * @name Register DMAMUX_CHCFGn, field TRIG[6] (RW)
 *
 * Enables the periodic trigger capability for the triggered DMA channel.
 *
 * Values:
 * - 0 - Triggering is disabled. If triggering is disabled and ENBL is set, the
 *     DMA Channel will simply route the specified source to the DMA channel.
 *     (Normal mode)
 * - 1 - Triggering is enabled. If triggering is enabled and ENBL is set, the
 *     DMAMUX is in Periodic Trigger mode.
 */
/*@{*/
#define BP_DMAMUX_CHCFGn_TRIG (6U)         /*!< Bit position for DMAMUX_CHCFGn_TRIG. */
#define BM_DMAMUX_CHCFGn_TRIG (0x40U)      /*!< Bit mask for DMAMUX_CHCFGn_TRIG. */
#define BS_DMAMUX_CHCFGn_TRIG (1U)         /*!< Bit field size in bits for DMAMUX_CHCFGn_TRIG. */

/*! @brief Read current value of the DMAMUX_CHCFGn_TRIG field. */
#define BR_DMAMUX_CHCFGn_TRIG(x, n) (BME_UBFX8(HW_DMAMUX_CHCFGn_ADDR(x, n), BP_DMAMUX_CHCFGn_TRIG, BS_DMAMUX_CHCFGn_TRIG))

/*! @brief Format value for bitfield DMAMUX_CHCFGn_TRIG. */
#define BF_DMAMUX_CHCFGn_TRIG(v) ((uint8_t)((uint8_t)(v) << BP_DMAMUX_CHCFGn_TRIG) & BM_DMAMUX_CHCFGn_TRIG)

/*! @brief Set the TRIG field to a new value. */
#define BW_DMAMUX_CHCFGn_TRIG(x, n, v) (BME_BFI8(HW_DMAMUX_CHCFGn_ADDR(x, n), ((uint8_t)(v) << BP_DMAMUX_CHCFGn_TRIG), BP_DMAMUX_CHCFGn_TRIG, 1))
/*@}*/

/*!
 * @name Register DMAMUX_CHCFGn, field ENBL[7] (RW)
 *
 * Enables the DMA channel.
 *
 * Values:
 * - 0 - DMA channel is disabled. This mode is primarily used during
 *     configuration of the DMAMux. The DMA has separate channel enables/disables, which
 *     should be used to disable or reconfigure a DMA channel.
 * - 1 - DMA channel is enabled
 */
/*@{*/
#define BP_DMAMUX_CHCFGn_ENBL (7U)         /*!< Bit position for DMAMUX_CHCFGn_ENBL. */
#define BM_DMAMUX_CHCFGn_ENBL (0x80U)      /*!< Bit mask for DMAMUX_CHCFGn_ENBL. */
#define BS_DMAMUX_CHCFGn_ENBL (1U)         /*!< Bit field size in bits for DMAMUX_CHCFGn_ENBL. */

/*! @brief Read current value of the DMAMUX_CHCFGn_ENBL field. */
#define BR_DMAMUX_CHCFGn_ENBL(x, n) (BME_UBFX8(HW_DMAMUX_CHCFGn_ADDR(x, n), BP_DMAMUX_CHCFGn_ENBL, BS_DMAMUX_CHCFGn_ENBL))

/*! @brief Format value for bitfield DMAMUX_CHCFGn_ENBL. */
#define BF_DMAMUX_CHCFGn_ENBL(v) ((uint8_t)((uint8_t)(v) << BP_DMAMUX_CHCFGn_ENBL) & BM_DMAMUX_CHCFGn_ENBL)

/*! @brief Set the ENBL field to a new value. */
#define BW_DMAMUX_CHCFGn_ENBL(x, n, v) (BME_BFI8(HW_DMAMUX_CHCFGn_ADDR(x, n), ((uint8_t)(v) << BP_DMAMUX_CHCFGn_ENBL), BP_DMAMUX_CHCFGn_ENBL, 1))
/*@}*/

/*******************************************************************************
 * hw_dmamux_t - module struct
 ******************************************************************************/
/*!
 * @brief All DMAMUX module registers.
 */
#pragma pack(1)
typedef struct _hw_dmamux
{
    __IO hw_dmamux_chcfgn_t CHCFGn[4];     /*!< [0x0] Channel Configuration register */
} hw_dmamux_t;
#pragma pack()

/*! @brief Macro to access all DMAMUX registers. */
/*! @param x DMAMUX module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_DMAMUX_REGS(DMAMUX0_BASE)</code>. */
#define HW_DMAMUX_REGS(x) (*(hw_dmamux_t *)(x))

/*
 * MKL43Z4 FLEXIO
 *
 * The FLEXIO Memory Map/Register Definition can be found here.
 *
 * Registers defined in this header file:
 * - HW_FLEXIO_VERID - Version ID Register
 * - HW_FLEXIO_PARAM - Parameter Register
 * - HW_FLEXIO_CTRL - FlexIO Control Register
 * - HW_FLEXIO_SHIFTSTAT - Shifter Status Register
 * - HW_FLEXIO_SHIFTERR - Shifter Error Register
 * - HW_FLEXIO_TIMSTAT - Timer Status Register
 * - HW_FLEXIO_SHIFTSIEN - Shifter Status Interrupt Enable
 * - HW_FLEXIO_SHIFTEIEN - Shifter Error Interrupt Enable
 * - HW_FLEXIO_TIMIEN - Timer Interrupt Enable Register
 * - HW_FLEXIO_SHIFTSDEN - Shifter Status DMA Enable
 * - HW_FLEXIO_SHIFTCTLn - Shifter Control N Register
 * - HW_FLEXIO_SHIFTCFGn - Shifter Configuration N Register
 * - HW_FLEXIO_SHIFTBUFn - Shifter Buffer N Register
 * - HW_FLEXIO_SHIFTBUFBBSn - Shifter Buffer N Bit Byte Swapped Register
 * - HW_FLEXIO_SHIFTBUFBYSn - Shifter Buffer N Byte Swapped Register
 * - HW_FLEXIO_SHIFTBUFBISn - Shifter Buffer N Bit Swapped Register
 * - HW_FLEXIO_TIMCTLn - Timer Control N Register
 * - HW_FLEXIO_TIMCFGn - Timer Configuration N Register
 * - HW_FLEXIO_TIMCMPn - Timer Compare N Register
 *
 * - hw_flexio_t - Struct containing all module registers.
 */

#define HW_FLEXIO_INSTANCE_COUNT (1U) /*!< Number of instances of the FLEXIO module. */
#define HW_FLEXIO (0U) /*!< Instance number for FLEXIO. */

/*******************************************************************************
 * HW_FLEXIO_VERID - Version ID Register
 ******************************************************************************/

/*!
 * @brief HW_FLEXIO_VERID - Version ID Register (RO)
 *
 * Reset value: 0x01000000U
 *
 * .
 */
typedef union _hw_flexio_verid
{
    uint32_t U;
    struct _hw_flexio_verid_bitfields
    {
        uint32_t FEATURE : 16;         /*!< [15:0] Feature Specification Number */
        uint32_t MINOR : 8;            /*!< [23:16] Minor Version Number */
        uint32_t MAJOR : 8;            /*!< [31:24] Major Version Number */
    } B;
} hw_flexio_verid_t;

/*!
 * @name Constants and macros for entire FLEXIO_VERID register
 */
/*@{*/
#define HW_FLEXIO_VERID_ADDR(x)  ((uint32_t)(x) + 0x0U)

#define HW_FLEXIO_VERID(x)       (*(__I hw_flexio_verid_t *) HW_FLEXIO_VERID_ADDR(x))
#define HW_FLEXIO_VERID_RD(x)    (HW_FLEXIO_VERID(x).U)
/*@}*/

/*
 * Constants & macros for individual FLEXIO_VERID bitfields
 */

/*!
 * @name Register FLEXIO_VERID, field FEATURE[15:0] (RO)
 *
 * This read only field returns the feature set number.
 *
 * Values:
 * - 0 - Standard features implemented.
 * - 1 - Supports state, logic and parallel modes.
 */
/*@{*/
#define BP_FLEXIO_VERID_FEATURE (0U)       /*!< Bit position for FLEXIO_VERID_FEATURE. */
#define BM_FLEXIO_VERID_FEATURE (0x0000FFFFU) /*!< Bit mask for FLEXIO_VERID_FEATURE. */
#define BS_FLEXIO_VERID_FEATURE (16U)      /*!< Bit field size in bits for FLEXIO_VERID_FEATURE. */

/*! @brief Read current value of the FLEXIO_VERID_FEATURE field. */
#define BR_FLEXIO_VERID_FEATURE(x) (BME_UBFX32(HW_FLEXIO_VERID_ADDR(x), BP_FLEXIO_VERID_FEATURE, BS_FLEXIO_VERID_FEATURE))
/*@}*/

/*!
 * @name Register FLEXIO_VERID, field MINOR[23:16] (RO)
 *
 * This read only field returns the minor version number for the module
 * specification.
 */
/*@{*/
#define BP_FLEXIO_VERID_MINOR (16U)        /*!< Bit position for FLEXIO_VERID_MINOR. */
#define BM_FLEXIO_VERID_MINOR (0x00FF0000U) /*!< Bit mask for FLEXIO_VERID_MINOR. */
#define BS_FLEXIO_VERID_MINOR (8U)         /*!< Bit field size in bits for FLEXIO_VERID_MINOR. */

/*! @brief Read current value of the FLEXIO_VERID_MINOR field. */
#define BR_FLEXIO_VERID_MINOR(x) (BME_UBFX32(HW_FLEXIO_VERID_ADDR(x), BP_FLEXIO_VERID_MINOR, BS_FLEXIO_VERID_MINOR))
/*@}*/

/*!
 * @name Register FLEXIO_VERID, field MAJOR[31:24] (RO)
 *
 * This read only field returns the major version number for the module
 * specification.
 */
/*@{*/
#define BP_FLEXIO_VERID_MAJOR (24U)        /*!< Bit position for FLEXIO_VERID_MAJOR. */
#define BM_FLEXIO_VERID_MAJOR (0xFF000000U) /*!< Bit mask for FLEXIO_VERID_MAJOR. */
#define BS_FLEXIO_VERID_MAJOR (8U)         /*!< Bit field size in bits for FLEXIO_VERID_MAJOR. */

/*! @brief Read current value of the FLEXIO_VERID_MAJOR field. */
#define BR_FLEXIO_VERID_MAJOR(x) (BME_UBFX32(HW_FLEXIO_VERID_ADDR(x), BP_FLEXIO_VERID_MAJOR, BS_FLEXIO_VERID_MAJOR))
/*@}*/

/*******************************************************************************
 * HW_FLEXIO_PARAM - Parameter Register
 ******************************************************************************/

/*!
 * @brief HW_FLEXIO_PARAM - Parameter Register (RO)
 *
 * Reset value: 0x10080404U
 *
 * .
 */
typedef union _hw_flexio_param
{
    uint32_t U;
    struct _hw_flexio_param_bitfields
    {
        uint32_t SHIFTER : 8;          /*!< [7:0] Shifter Number */
        uint32_t TIMER : 8;            /*!< [15:8] Timer Number */
        uint32_t PIN : 8;              /*!< [23:16] Pin Number */
        uint32_t TRIGGER : 8;          /*!< [31:24] Trigger Number */
    } B;
} hw_flexio_param_t;

/*!
 * @name Constants and macros for entire FLEXIO_PARAM register
 */
/*@{*/
#define HW_FLEXIO_PARAM_ADDR(x)  ((uint32_t)(x) + 0x4U)

#define HW_FLEXIO_PARAM(x)       (*(__I hw_flexio_param_t *) HW_FLEXIO_PARAM_ADDR(x))
#define HW_FLEXIO_PARAM_RD(x)    (HW_FLEXIO_PARAM(x).U)
/*@}*/

/*
 * Constants & macros for individual FLEXIO_PARAM bitfields
 */

/*!
 * @name Register FLEXIO_PARAM, field SHIFTER[7:0] (RO)
 *
 * Number of Shifters implemented.
 */
/*@{*/
#define BP_FLEXIO_PARAM_SHIFTER (0U)       /*!< Bit position for FLEXIO_PARAM_SHIFTER. */
#define BM_FLEXIO_PARAM_SHIFTER (0x000000FFU) /*!< Bit mask for FLEXIO_PARAM_SHIFTER. */
#define BS_FLEXIO_PARAM_SHIFTER (8U)       /*!< Bit field size in bits for FLEXIO_PARAM_SHIFTER. */

/*! @brief Read current value of the FLEXIO_PARAM_SHIFTER field. */
#define BR_FLEXIO_PARAM_SHIFTER(x) (BME_UBFX32(HW_FLEXIO_PARAM_ADDR(x), BP_FLEXIO_PARAM_SHIFTER, BS_FLEXIO_PARAM_SHIFTER))
/*@}*/

/*!
 * @name Register FLEXIO_PARAM, field TIMER[15:8] (RO)
 *
 * Number of Timers implemented.
 */
/*@{*/
#define BP_FLEXIO_PARAM_TIMER (8U)         /*!< Bit position for FLEXIO_PARAM_TIMER. */
#define BM_FLEXIO_PARAM_TIMER (0x0000FF00U) /*!< Bit mask for FLEXIO_PARAM_TIMER. */
#define BS_FLEXIO_PARAM_TIMER (8U)         /*!< Bit field size in bits for FLEXIO_PARAM_TIMER. */

/*! @brief Read current value of the FLEXIO_PARAM_TIMER field. */
#define BR_FLEXIO_PARAM_TIMER(x) (BME_UBFX32(HW_FLEXIO_PARAM_ADDR(x), BP_FLEXIO_PARAM_TIMER, BS_FLEXIO_PARAM_TIMER))
/*@}*/

/*!
 * @name Register FLEXIO_PARAM, field PIN[23:16] (RO)
 *
 * Number of Pins implemented.
 */
/*@{*/
#define BP_FLEXIO_PARAM_PIN  (16U)         /*!< Bit position for FLEXIO_PARAM_PIN. */
#define BM_FLEXIO_PARAM_PIN  (0x00FF0000U) /*!< Bit mask for FLEXIO_PARAM_PIN. */
#define BS_FLEXIO_PARAM_PIN  (8U)          /*!< Bit field size in bits for FLEXIO_PARAM_PIN. */

/*! @brief Read current value of the FLEXIO_PARAM_PIN field. */
#define BR_FLEXIO_PARAM_PIN(x) (BME_UBFX32(HW_FLEXIO_PARAM_ADDR(x), BP_FLEXIO_PARAM_PIN, BS_FLEXIO_PARAM_PIN))
/*@}*/

/*!
 * @name Register FLEXIO_PARAM, field TRIGGER[31:24] (RO)
 *
 * Number of external triggers implemented.
 */
/*@{*/
#define BP_FLEXIO_PARAM_TRIGGER (24U)      /*!< Bit position for FLEXIO_PARAM_TRIGGER. */
#define BM_FLEXIO_PARAM_TRIGGER (0xFF000000U) /*!< Bit mask for FLEXIO_PARAM_TRIGGER. */
#define BS_FLEXIO_PARAM_TRIGGER (8U)       /*!< Bit field size in bits for FLEXIO_PARAM_TRIGGER. */

/*! @brief Read current value of the FLEXIO_PARAM_TRIGGER field. */
#define BR_FLEXIO_PARAM_TRIGGER(x) (BME_UBFX32(HW_FLEXIO_PARAM_ADDR(x), BP_FLEXIO_PARAM_TRIGGER, BS_FLEXIO_PARAM_TRIGGER))
/*@}*/

/*******************************************************************************
 * HW_FLEXIO_CTRL - FlexIO Control Register
 ******************************************************************************/

/*!
 * @brief HW_FLEXIO_CTRL - FlexIO Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
typedef union _hw_flexio_ctrl
{
    uint32_t U;
    struct _hw_flexio_ctrl_bitfields
    {
        uint32_t FLEXEN : 1;           /*!< [0] FlexIO Enable */
        uint32_t SWRST : 1;            /*!< [1] Software Reset */
        uint32_t FASTACC : 1;          /*!< [2] Fast Access */
        uint32_t RESERVED0 : 27;       /*!< [29:3]  */
        uint32_t DBGE : 1;             /*!< [30] Debug Enable */
        uint32_t DOZEN : 1;            /*!< [31] Doze Enable */
    } B;
} hw_flexio_ctrl_t;

/*!
 * @name Constants and macros for entire FLEXIO_CTRL register
 */
/*@{*/
#define HW_FLEXIO_CTRL_ADDR(x)   ((uint32_t)(x) + 0x8U)

#define HW_FLEXIO_CTRL(x)        (*(__IO hw_flexio_ctrl_t *) HW_FLEXIO_CTRL_ADDR(x))
#define HW_FLEXIO_CTRL_RD(x)     (HW_FLEXIO_CTRL(x).U)
#define HW_FLEXIO_CTRL_WR(x, v)  (HW_FLEXIO_CTRL(x).U = (v))
#define HW_FLEXIO_CTRL_SET(x, v) (BME_OR32(HW_FLEXIO_CTRL_ADDR(x), (uint32_t)(v)))
#define HW_FLEXIO_CTRL_CLR(x, v) (BME_AND32(HW_FLEXIO_CTRL_ADDR(x), (uint32_t)(~(v))))
#define HW_FLEXIO_CTRL_TOG(x, v) (BME_XOR32(HW_FLEXIO_CTRL_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_CTRL bitfields
 */

/*!
 * @name Register FLEXIO_CTRL, field FLEXEN[0] (RW)
 *
 * Values:
 * - 0 - FlexIO module is disabled.
 * - 1 - FlexIO module is enabled.
 */
/*@{*/
#define BP_FLEXIO_CTRL_FLEXEN (0U)         /*!< Bit position for FLEXIO_CTRL_FLEXEN. */
#define BM_FLEXIO_CTRL_FLEXEN (0x00000001U) /*!< Bit mask for FLEXIO_CTRL_FLEXEN. */
#define BS_FLEXIO_CTRL_FLEXEN (1U)         /*!< Bit field size in bits for FLEXIO_CTRL_FLEXEN. */

/*! @brief Read current value of the FLEXIO_CTRL_FLEXEN field. */
#define BR_FLEXIO_CTRL_FLEXEN(x) (BME_UBFX32(HW_FLEXIO_CTRL_ADDR(x), BP_FLEXIO_CTRL_FLEXEN, BS_FLEXIO_CTRL_FLEXEN))

/*! @brief Format value for bitfield FLEXIO_CTRL_FLEXEN. */
#define BF_FLEXIO_CTRL_FLEXEN(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_CTRL_FLEXEN) & BM_FLEXIO_CTRL_FLEXEN)

/*! @brief Set the FLEXEN field to a new value. */
#define BW_FLEXIO_CTRL_FLEXEN(x, v) (BME_BFI32(HW_FLEXIO_CTRL_ADDR(x), ((uint32_t)(v) << BP_FLEXIO_CTRL_FLEXEN), BP_FLEXIO_CTRL_FLEXEN, 1))
/*@}*/

/*!
 * @name Register FLEXIO_CTRL, field SWRST[1] (RW)
 *
 * The FlexIO Control Register is not affected by the software reset, all other
 * logic in the FlexIO is affected by the software reset and register accesses
 * are ignored until this bit is cleared. This register bit will remain set until
 * cleared by software, and the reset has cleared in the FlexIO clock domain.
 *
 * Values:
 * - 0 - Software reset is disabled
 * - 1 - Software reset is enabled, all FlexIO registers except the Control
 *     Register are reset.
 */
/*@{*/
#define BP_FLEXIO_CTRL_SWRST (1U)          /*!< Bit position for FLEXIO_CTRL_SWRST. */
#define BM_FLEXIO_CTRL_SWRST (0x00000002U) /*!< Bit mask for FLEXIO_CTRL_SWRST. */
#define BS_FLEXIO_CTRL_SWRST (1U)          /*!< Bit field size in bits for FLEXIO_CTRL_SWRST. */

/*! @brief Read current value of the FLEXIO_CTRL_SWRST field. */
#define BR_FLEXIO_CTRL_SWRST(x) (BME_UBFX32(HW_FLEXIO_CTRL_ADDR(x), BP_FLEXIO_CTRL_SWRST, BS_FLEXIO_CTRL_SWRST))

/*! @brief Format value for bitfield FLEXIO_CTRL_SWRST. */
#define BF_FLEXIO_CTRL_SWRST(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_CTRL_SWRST) & BM_FLEXIO_CTRL_SWRST)

/*! @brief Set the SWRST field to a new value. */
#define BW_FLEXIO_CTRL_SWRST(x, v) (BME_BFI32(HW_FLEXIO_CTRL_ADDR(x), ((uint32_t)(v) << BP_FLEXIO_CTRL_SWRST), BP_FLEXIO_CTRL_SWRST, 1))
/*@}*/

/*!
 * @name Register FLEXIO_CTRL, field FASTACC[2] (RW)
 *
 * Enables fast register accesses to FlexIO registers, but requires the FlexIO
 * clock to be at least twice the frequency of the bus clock.
 *
 * Values:
 * - 0 - Configures for normal register accesses to FlexIO
 * - 1 - Configures for fast register accesses to FlexIO
 */
/*@{*/
#define BP_FLEXIO_CTRL_FASTACC (2U)        /*!< Bit position for FLEXIO_CTRL_FASTACC. */
#define BM_FLEXIO_CTRL_FASTACC (0x00000004U) /*!< Bit mask for FLEXIO_CTRL_FASTACC. */
#define BS_FLEXIO_CTRL_FASTACC (1U)        /*!< Bit field size in bits for FLEXIO_CTRL_FASTACC. */

/*! @brief Read current value of the FLEXIO_CTRL_FASTACC field. */
#define BR_FLEXIO_CTRL_FASTACC(x) (BME_UBFX32(HW_FLEXIO_CTRL_ADDR(x), BP_FLEXIO_CTRL_FASTACC, BS_FLEXIO_CTRL_FASTACC))

/*! @brief Format value for bitfield FLEXIO_CTRL_FASTACC. */
#define BF_FLEXIO_CTRL_FASTACC(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_CTRL_FASTACC) & BM_FLEXIO_CTRL_FASTACC)

/*! @brief Set the FASTACC field to a new value. */
#define BW_FLEXIO_CTRL_FASTACC(x, v) (BME_BFI32(HW_FLEXIO_CTRL_ADDR(x), ((uint32_t)(v) << BP_FLEXIO_CTRL_FASTACC), BP_FLEXIO_CTRL_FASTACC, 1))
/*@}*/

/*!
 * @name Register FLEXIO_CTRL, field DBGE[30] (RW)
 *
 * Enables FlexIO operation in Debug mode.
 *
 * Values:
 * - 0 - FlexIO is disabled in debug modes.
 * - 1 - FlexIO is enabled in debug modes
 */
/*@{*/
#define BP_FLEXIO_CTRL_DBGE  (30U)         /*!< Bit position for FLEXIO_CTRL_DBGE. */
#define BM_FLEXIO_CTRL_DBGE  (0x40000000U) /*!< Bit mask for FLEXIO_CTRL_DBGE. */
#define BS_FLEXIO_CTRL_DBGE  (1U)          /*!< Bit field size in bits for FLEXIO_CTRL_DBGE. */

/*! @brief Read current value of the FLEXIO_CTRL_DBGE field. */
#define BR_FLEXIO_CTRL_DBGE(x) (BME_UBFX32(HW_FLEXIO_CTRL_ADDR(x), BP_FLEXIO_CTRL_DBGE, BS_FLEXIO_CTRL_DBGE))

/*! @brief Format value for bitfield FLEXIO_CTRL_DBGE. */
#define BF_FLEXIO_CTRL_DBGE(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_CTRL_DBGE) & BM_FLEXIO_CTRL_DBGE)

/*! @brief Set the DBGE field to a new value. */
#define BW_FLEXIO_CTRL_DBGE(x, v) (BME_BFI32(HW_FLEXIO_CTRL_ADDR(x), ((uint32_t)(v) << BP_FLEXIO_CTRL_DBGE), BP_FLEXIO_CTRL_DBGE, 1))
/*@}*/

/*!
 * @name Register FLEXIO_CTRL, field DOZEN[31] (RW)
 *
 * Disables FlexIO operation in Doze modes. This field is ignored and the FlexIO
 * always disabled in low-leakage stop modes.
 *
 * Values:
 * - 0 - FlexIO enabled in Doze modes.
 * - 1 - FlexIO disabled in Doze modes.
 */
/*@{*/
#define BP_FLEXIO_CTRL_DOZEN (31U)         /*!< Bit position for FLEXIO_CTRL_DOZEN. */
#define BM_FLEXIO_CTRL_DOZEN (0x80000000U) /*!< Bit mask for FLEXIO_CTRL_DOZEN. */
#define BS_FLEXIO_CTRL_DOZEN (1U)          /*!< Bit field size in bits for FLEXIO_CTRL_DOZEN. */

/*! @brief Read current value of the FLEXIO_CTRL_DOZEN field. */
#define BR_FLEXIO_CTRL_DOZEN(x) (BME_UBFX32(HW_FLEXIO_CTRL_ADDR(x), BP_FLEXIO_CTRL_DOZEN, BS_FLEXIO_CTRL_DOZEN))

/*! @brief Format value for bitfield FLEXIO_CTRL_DOZEN. */
#define BF_FLEXIO_CTRL_DOZEN(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_CTRL_DOZEN) & BM_FLEXIO_CTRL_DOZEN)

/*! @brief Set the DOZEN field to a new value. */
#define BW_FLEXIO_CTRL_DOZEN(x, v) (BME_BFI32(HW_FLEXIO_CTRL_ADDR(x), ((uint32_t)(v) << BP_FLEXIO_CTRL_DOZEN), BP_FLEXIO_CTRL_DOZEN, 1))
/*@}*/

/*******************************************************************************
 * HW_FLEXIO_SHIFTSTAT - Shifter Status Register
 ******************************************************************************/

/*!
 * @brief HW_FLEXIO_SHIFTSTAT - Shifter Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
typedef union _hw_flexio_shiftstat
{
    uint32_t U;
    struct _hw_flexio_shiftstat_bitfields
    {
        uint32_t SSF : 4;              /*!< [3:0] Shifter Status Flag */
        uint32_t RESERVED0 : 28;       /*!< [31:4]  */
    } B;
} hw_flexio_shiftstat_t;

/*!
 * @name Constants and macros for entire FLEXIO_SHIFTSTAT register
 */
/*@{*/
#define HW_FLEXIO_SHIFTSTAT_ADDR(x) ((uint32_t)(x) + 0x10U)

#define HW_FLEXIO_SHIFTSTAT(x)   (*(__IO hw_flexio_shiftstat_t *) HW_FLEXIO_SHIFTSTAT_ADDR(x))
#define HW_FLEXIO_SHIFTSTAT_RD(x) (HW_FLEXIO_SHIFTSTAT(x).U)
#define HW_FLEXIO_SHIFTSTAT_WR(x, v) (HW_FLEXIO_SHIFTSTAT(x).U = (v))
#define HW_FLEXIO_SHIFTSTAT_SET(x, v) (BME_OR32(HW_FLEXIO_SHIFTSTAT_ADDR(x), (uint32_t)(v)))
#define HW_FLEXIO_SHIFTSTAT_CLR(x, v) (BME_AND32(HW_FLEXIO_SHIFTSTAT_ADDR(x), (uint32_t)(~(v))))
#define HW_FLEXIO_SHIFTSTAT_TOG(x, v) (BME_XOR32(HW_FLEXIO_SHIFTSTAT_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTSTAT bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTSTAT, field SSF[3:0] (W1C)
 *
 * The shifter status flag is updated when one of the following events occurs:
 * For SMOD=Receive, the status flag is set when SHIFTBUF has been loaded with
 * data from Shifter (SHIFTBUF is full), and the status flag is cleared when
 * SHIFTBUF register is read. For SMOD=Transmit, the status flag is set when SHIFTBUF
 * data has been transferred to the Shifter (SHIFTBUF is empty) or when initially
 * configured for SMOD=Transmit, and the status flag is cleared when the SHIFTBUF
 * register is written. For SMOD=Match Store, the status flag is set when a match
 * has occured between SHIFTBUF and Shifter, and the status flag is cleared when
 * the SHIFTBUF register is read. For SMOD=Match Continuous, returns the current
 * match result between the SHIFTBUF and Shifter. The status flag can also be
 * cleared by writing a logic one to the flag for all modes except Match Continuous.
 *
 * Values:
 * - 0 - Status flag is clear
 * - 1 - Status flag is set
 */
/*@{*/
#define BP_FLEXIO_SHIFTSTAT_SSF (0U)       /*!< Bit position for FLEXIO_SHIFTSTAT_SSF. */
#define BM_FLEXIO_SHIFTSTAT_SSF (0x0000000FU) /*!< Bit mask for FLEXIO_SHIFTSTAT_SSF. */
#define BS_FLEXIO_SHIFTSTAT_SSF (4U)       /*!< Bit field size in bits for FLEXIO_SHIFTSTAT_SSF. */

/*! @brief Read current value of the FLEXIO_SHIFTSTAT_SSF field. */
#define BR_FLEXIO_SHIFTSTAT_SSF(x) (BME_UBFX32(HW_FLEXIO_SHIFTSTAT_ADDR(x), BP_FLEXIO_SHIFTSTAT_SSF, BS_FLEXIO_SHIFTSTAT_SSF))

/*! @brief Format value for bitfield FLEXIO_SHIFTSTAT_SSF. */
#define BF_FLEXIO_SHIFTSTAT_SSF(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_SHIFTSTAT_SSF) & BM_FLEXIO_SHIFTSTAT_SSF)

/*! @brief Set the SSF field to a new value. */
#define BW_FLEXIO_SHIFTSTAT_SSF(x, v) (BME_BFI32(HW_FLEXIO_SHIFTSTAT_ADDR(x), ((uint32_t)(v) << BP_FLEXIO_SHIFTSTAT_SSF), BP_FLEXIO_SHIFTSTAT_SSF, 4))
/*@}*/

/*******************************************************************************
 * HW_FLEXIO_SHIFTERR - Shifter Error Register
 ******************************************************************************/

/*!
 * @brief HW_FLEXIO_SHIFTERR - Shifter Error Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
typedef union _hw_flexio_shifterr
{
    uint32_t U;
    struct _hw_flexio_shifterr_bitfields
    {
        uint32_t SEF : 4;              /*!< [3:0] Shifter Error Flags */
        uint32_t RESERVED0 : 28;       /*!< [31:4]  */
    } B;
} hw_flexio_shifterr_t;

/*!
 * @name Constants and macros for entire FLEXIO_SHIFTERR register
 */
/*@{*/
#define HW_FLEXIO_SHIFTERR_ADDR(x) ((uint32_t)(x) + 0x14U)

#define HW_FLEXIO_SHIFTERR(x)    (*(__IO hw_flexio_shifterr_t *) HW_FLEXIO_SHIFTERR_ADDR(x))
#define HW_FLEXIO_SHIFTERR_RD(x) (HW_FLEXIO_SHIFTERR(x).U)
#define HW_FLEXIO_SHIFTERR_WR(x, v) (HW_FLEXIO_SHIFTERR(x).U = (v))
#define HW_FLEXIO_SHIFTERR_SET(x, v) (BME_OR32(HW_FLEXIO_SHIFTERR_ADDR(x), (uint32_t)(v)))
#define HW_FLEXIO_SHIFTERR_CLR(x, v) (BME_AND32(HW_FLEXIO_SHIFTERR_ADDR(x), (uint32_t)(~(v))))
#define HW_FLEXIO_SHIFTERR_TOG(x, v) (BME_XOR32(HW_FLEXIO_SHIFTERR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTERR bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTERR, field SEF[3:0] (W1C)
 *
 * The shifter error flag is set when one of the following events occurs: For
 * SMOD=Receive, indicates Shifter was ready to store new data into SHIFTBUF before
 * the previous data was read from SHIFTBUF (SHIFTBUF Overrun), or indicates
 * that the received start or stop bit does not match the expected value. For
 * SMOD=Transmit, indicates Shifter was ready to load new data from SHIFTBUF before new
 * data had been written into SHIFTBUF (SHIFTBUF Underrun). For SMOD=Match
 * Store, indicates a match event occured before the previous match data was read from
 * SHIFTBUF (SHIFTBUF Overrun). For SMOD=Match Continuous, the error flag is set
 * when a match has occured between SHIFTBUF and Shifter. Can be cleared by
 * writing logic one to the flag. For SMOD=Match Continuous, can also be cleared when
 * the SHIFTBUF register is read.
 *
 * Values:
 * - 0 - Shifter Error Flag is clear
 * - 1 - Shifter Error Flag is set
 */
/*@{*/
#define BP_FLEXIO_SHIFTERR_SEF (0U)        /*!< Bit position for FLEXIO_SHIFTERR_SEF. */
#define BM_FLEXIO_SHIFTERR_SEF (0x0000000FU) /*!< Bit mask for FLEXIO_SHIFTERR_SEF. */
#define BS_FLEXIO_SHIFTERR_SEF (4U)        /*!< Bit field size in bits for FLEXIO_SHIFTERR_SEF. */

/*! @brief Read current value of the FLEXIO_SHIFTERR_SEF field. */
#define BR_FLEXIO_SHIFTERR_SEF(x) (BME_UBFX32(HW_FLEXIO_SHIFTERR_ADDR(x), BP_FLEXIO_SHIFTERR_SEF, BS_FLEXIO_SHIFTERR_SEF))

/*! @brief Format value for bitfield FLEXIO_SHIFTERR_SEF. */
#define BF_FLEXIO_SHIFTERR_SEF(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_SHIFTERR_SEF) & BM_FLEXIO_SHIFTERR_SEF)

/*! @brief Set the SEF field to a new value. */
#define BW_FLEXIO_SHIFTERR_SEF(x, v) (BME_BFI32(HW_FLEXIO_SHIFTERR_ADDR(x), ((uint32_t)(v) << BP_FLEXIO_SHIFTERR_SEF), BP_FLEXIO_SHIFTERR_SEF, 4))
/*@}*/

/*******************************************************************************
 * HW_FLEXIO_TIMSTAT - Timer Status Register
 ******************************************************************************/

/*!
 * @brief HW_FLEXIO_TIMSTAT - Timer Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
typedef union _hw_flexio_timstat
{
    uint32_t U;
    struct _hw_flexio_timstat_bitfields
    {
        uint32_t TSF : 4;              /*!< [3:0] Timer Status Flags */
        uint32_t RESERVED0 : 28;       /*!< [31:4]  */
    } B;
} hw_flexio_timstat_t;

/*!
 * @name Constants and macros for entire FLEXIO_TIMSTAT register
 */
/*@{*/
#define HW_FLEXIO_TIMSTAT_ADDR(x) ((uint32_t)(x) + 0x18U)

#define HW_FLEXIO_TIMSTAT(x)     (*(__IO hw_flexio_timstat_t *) HW_FLEXIO_TIMSTAT_ADDR(x))
#define HW_FLEXIO_TIMSTAT_RD(x)  (HW_FLEXIO_TIMSTAT(x).U)
#define HW_FLEXIO_TIMSTAT_WR(x, v) (HW_FLEXIO_TIMSTAT(x).U = (v))
#define HW_FLEXIO_TIMSTAT_SET(x, v) (BME_OR32(HW_FLEXIO_TIMSTAT_ADDR(x), (uint32_t)(v)))
#define HW_FLEXIO_TIMSTAT_CLR(x, v) (BME_AND32(HW_FLEXIO_TIMSTAT_ADDR(x), (uint32_t)(~(v))))
#define HW_FLEXIO_TIMSTAT_TOG(x, v) (BME_XOR32(HW_FLEXIO_TIMSTAT_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_TIMSTAT bitfields
 */

/*!
 * @name Register FLEXIO_TIMSTAT, field TSF[3:0] (W1C)
 *
 * The timer status flag sets depending on the timer mode, and can be cleared by
 * writing logic one to the flag. In 8-bit counter mode, the timer status flag
 * is set when the upper 8-bit counter equals zero and decrements, this also
 * causes the counter to reload with the value in the compare register. In 8-bit PWM
 * mode, the timer status flag is set when the upper 8-bit counter equals zero and
 * decrements, this also causes the counter to reload with the value in the
 * compare register.. In 16-bit counter mode, the timer status flag is set when the
 * 16-bit counter equals zero and decrements, this also causes the counter to
 * reload with the value in the compare register..
 *
 * Values:
 * - 0 - Timer Status Flag is clear
 * - 1 - Timer Status Flag is set
 */
/*@{*/
#define BP_FLEXIO_TIMSTAT_TSF (0U)         /*!< Bit position for FLEXIO_TIMSTAT_TSF. */
#define BM_FLEXIO_TIMSTAT_TSF (0x0000000FU) /*!< Bit mask for FLEXIO_TIMSTAT_TSF. */
#define BS_FLEXIO_TIMSTAT_TSF (4U)         /*!< Bit field size in bits for FLEXIO_TIMSTAT_TSF. */

/*! @brief Read current value of the FLEXIO_TIMSTAT_TSF field. */
#define BR_FLEXIO_TIMSTAT_TSF(x) (BME_UBFX32(HW_FLEXIO_TIMSTAT_ADDR(x), BP_FLEXIO_TIMSTAT_TSF, BS_FLEXIO_TIMSTAT_TSF))

/*! @brief Format value for bitfield FLEXIO_TIMSTAT_TSF. */
#define BF_FLEXIO_TIMSTAT_TSF(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_TIMSTAT_TSF) & BM_FLEXIO_TIMSTAT_TSF)

/*! @brief Set the TSF field to a new value. */
#define BW_FLEXIO_TIMSTAT_TSF(x, v) (BME_BFI32(HW_FLEXIO_TIMSTAT_ADDR(x), ((uint32_t)(v) << BP_FLEXIO_TIMSTAT_TSF), BP_FLEXIO_TIMSTAT_TSF, 4))
/*@}*/

/*******************************************************************************
 * HW_FLEXIO_SHIFTSIEN - Shifter Status Interrupt Enable
 ******************************************************************************/

/*!
 * @brief HW_FLEXIO_SHIFTSIEN - Shifter Status Interrupt Enable (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
typedef union _hw_flexio_shiftsien
{
    uint32_t U;
    struct _hw_flexio_shiftsien_bitfields
    {
        uint32_t SSIE : 4;             /*!< [3:0] Shifter Status Interrupt Enable */
        uint32_t RESERVED0 : 28;       /*!< [31:4]  */
    } B;
} hw_flexio_shiftsien_t;

/*!
 * @name Constants and macros for entire FLEXIO_SHIFTSIEN register
 */
/*@{*/
#define HW_FLEXIO_SHIFTSIEN_ADDR(x) ((uint32_t)(x) + 0x20U)

#define HW_FLEXIO_SHIFTSIEN(x)   (*(__IO hw_flexio_shiftsien_t *) HW_FLEXIO_SHIFTSIEN_ADDR(x))
#define HW_FLEXIO_SHIFTSIEN_RD(x) (HW_FLEXIO_SHIFTSIEN(x).U)
#define HW_FLEXIO_SHIFTSIEN_WR(x, v) (HW_FLEXIO_SHIFTSIEN(x).U = (v))
#define HW_FLEXIO_SHIFTSIEN_SET(x, v) (BME_OR32(HW_FLEXIO_SHIFTSIEN_ADDR(x), (uint32_t)(v)))
#define HW_FLEXIO_SHIFTSIEN_CLR(x, v) (BME_AND32(HW_FLEXIO_SHIFTSIEN_ADDR(x), (uint32_t)(~(v))))
#define HW_FLEXIO_SHIFTSIEN_TOG(x, v) (BME_XOR32(HW_FLEXIO_SHIFTSIEN_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTSIEN bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTSIEN, field SSIE[3:0] (RW)
 *
 * Enables interrupt generation when corresponding SSF is set.
 *
 * Values:
 * - 0 - Shifter Status Flag interrupt disabled
 * - 1 - Shifter Status Flag interrupt enabled
 */
/*@{*/
#define BP_FLEXIO_SHIFTSIEN_SSIE (0U)      /*!< Bit position for FLEXIO_SHIFTSIEN_SSIE. */
#define BM_FLEXIO_SHIFTSIEN_SSIE (0x0000000FU) /*!< Bit mask for FLEXIO_SHIFTSIEN_SSIE. */
#define BS_FLEXIO_SHIFTSIEN_SSIE (4U)      /*!< Bit field size in bits for FLEXIO_SHIFTSIEN_SSIE. */

/*! @brief Read current value of the FLEXIO_SHIFTSIEN_SSIE field. */
#define BR_FLEXIO_SHIFTSIEN_SSIE(x) (BME_UBFX32(HW_FLEXIO_SHIFTSIEN_ADDR(x), BP_FLEXIO_SHIFTSIEN_SSIE, BS_FLEXIO_SHIFTSIEN_SSIE))

/*! @brief Format value for bitfield FLEXIO_SHIFTSIEN_SSIE. */
#define BF_FLEXIO_SHIFTSIEN_SSIE(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_SHIFTSIEN_SSIE) & BM_FLEXIO_SHIFTSIEN_SSIE)

/*! @brief Set the SSIE field to a new value. */
#define BW_FLEXIO_SHIFTSIEN_SSIE(x, v) (BME_BFI32(HW_FLEXIO_SHIFTSIEN_ADDR(x), ((uint32_t)(v) << BP_FLEXIO_SHIFTSIEN_SSIE), BP_FLEXIO_SHIFTSIEN_SSIE, 4))
/*@}*/

/*******************************************************************************
 * HW_FLEXIO_SHIFTEIEN - Shifter Error Interrupt Enable
 ******************************************************************************/

/*!
 * @brief HW_FLEXIO_SHIFTEIEN - Shifter Error Interrupt Enable (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
typedef union _hw_flexio_shifteien
{
    uint32_t U;
    struct _hw_flexio_shifteien_bitfields
    {
        uint32_t SEIE : 4;             /*!< [3:0] Shifter Error Interrupt Enable */
        uint32_t RESERVED0 : 28;       /*!< [31:4]  */
    } B;
} hw_flexio_shifteien_t;

/*!
 * @name Constants and macros for entire FLEXIO_SHIFTEIEN register
 */
/*@{*/
#define HW_FLEXIO_SHIFTEIEN_ADDR(x) ((uint32_t)(x) + 0x24U)

#define HW_FLEXIO_SHIFTEIEN(x)   (*(__IO hw_flexio_shifteien_t *) HW_FLEXIO_SHIFTEIEN_ADDR(x))
#define HW_FLEXIO_SHIFTEIEN_RD(x) (HW_FLEXIO_SHIFTEIEN(x).U)
#define HW_FLEXIO_SHIFTEIEN_WR(x, v) (HW_FLEXIO_SHIFTEIEN(x).U = (v))
#define HW_FLEXIO_SHIFTEIEN_SET(x, v) (BME_OR32(HW_FLEXIO_SHIFTEIEN_ADDR(x), (uint32_t)(v)))
#define HW_FLEXIO_SHIFTEIEN_CLR(x, v) (BME_AND32(HW_FLEXIO_SHIFTEIEN_ADDR(x), (uint32_t)(~(v))))
#define HW_FLEXIO_SHIFTEIEN_TOG(x, v) (BME_XOR32(HW_FLEXIO_SHIFTEIEN_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTEIEN bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTEIEN, field SEIE[3:0] (RW)
 *
 * Enables interrupt generation when corresponding SEF is set.
 *
 * Values:
 * - 0 - Shifter Error Flag interrupt disabled
 * - 1 - Shifter Error Flag interrupt enabled
 */
/*@{*/
#define BP_FLEXIO_SHIFTEIEN_SEIE (0U)      /*!< Bit position for FLEXIO_SHIFTEIEN_SEIE. */
#define BM_FLEXIO_SHIFTEIEN_SEIE (0x0000000FU) /*!< Bit mask for FLEXIO_SHIFTEIEN_SEIE. */
#define BS_FLEXIO_SHIFTEIEN_SEIE (4U)      /*!< Bit field size in bits for FLEXIO_SHIFTEIEN_SEIE. */

/*! @brief Read current value of the FLEXIO_SHIFTEIEN_SEIE field. */
#define BR_FLEXIO_SHIFTEIEN_SEIE(x) (BME_UBFX32(HW_FLEXIO_SHIFTEIEN_ADDR(x), BP_FLEXIO_SHIFTEIEN_SEIE, BS_FLEXIO_SHIFTEIEN_SEIE))

/*! @brief Format value for bitfield FLEXIO_SHIFTEIEN_SEIE. */
#define BF_FLEXIO_SHIFTEIEN_SEIE(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_SHIFTEIEN_SEIE) & BM_FLEXIO_SHIFTEIEN_SEIE)

/*! @brief Set the SEIE field to a new value. */
#define BW_FLEXIO_SHIFTEIEN_SEIE(x, v) (BME_BFI32(HW_FLEXIO_SHIFTEIEN_ADDR(x), ((uint32_t)(v) << BP_FLEXIO_SHIFTEIEN_SEIE), BP_FLEXIO_SHIFTEIEN_SEIE, 4))
/*@}*/

/*******************************************************************************
 * HW_FLEXIO_TIMIEN - Timer Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief HW_FLEXIO_TIMIEN - Timer Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
typedef union _hw_flexio_timien
{
    uint32_t U;
    struct _hw_flexio_timien_bitfields
    {
        uint32_t TEIE : 4;             /*!< [3:0] Timer Status Interrupt Enable */
        uint32_t RESERVED0 : 28;       /*!< [31:4]  */
    } B;
} hw_flexio_timien_t;

/*!
 * @name Constants and macros for entire FLEXIO_TIMIEN register
 */
/*@{*/
#define HW_FLEXIO_TIMIEN_ADDR(x) ((uint32_t)(x) + 0x28U)

#define HW_FLEXIO_TIMIEN(x)      (*(__IO hw_flexio_timien_t *) HW_FLEXIO_TIMIEN_ADDR(x))
#define HW_FLEXIO_TIMIEN_RD(x)   (HW_FLEXIO_TIMIEN(x).U)
#define HW_FLEXIO_TIMIEN_WR(x, v) (HW_FLEXIO_TIMIEN(x).U = (v))
#define HW_FLEXIO_TIMIEN_SET(x, v) (BME_OR32(HW_FLEXIO_TIMIEN_ADDR(x), (uint32_t)(v)))
#define HW_FLEXIO_TIMIEN_CLR(x, v) (BME_AND32(HW_FLEXIO_TIMIEN_ADDR(x), (uint32_t)(~(v))))
#define HW_FLEXIO_TIMIEN_TOG(x, v) (BME_XOR32(HW_FLEXIO_TIMIEN_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_TIMIEN bitfields
 */

/*!
 * @name Register FLEXIO_TIMIEN, field TEIE[3:0] (RW)
 *
 * Enables interrupt generation when corresponding TSF is set.
 *
 * Values:
 * - 0 - Timer Status Flag interrupt is disabled
 * - 1 - Timer Status Flag interrupt is enabled
 */
/*@{*/
#define BP_FLEXIO_TIMIEN_TEIE (0U)         /*!< Bit position for FLEXIO_TIMIEN_TEIE. */
#define BM_FLEXIO_TIMIEN_TEIE (0x0000000FU) /*!< Bit mask for FLEXIO_TIMIEN_TEIE. */
#define BS_FLEXIO_TIMIEN_TEIE (4U)         /*!< Bit field size in bits for FLEXIO_TIMIEN_TEIE. */

/*! @brief Read current value of the FLEXIO_TIMIEN_TEIE field. */
#define BR_FLEXIO_TIMIEN_TEIE(x) (BME_UBFX32(HW_FLEXIO_TIMIEN_ADDR(x), BP_FLEXIO_TIMIEN_TEIE, BS_FLEXIO_TIMIEN_TEIE))

/*! @brief Format value for bitfield FLEXIO_TIMIEN_TEIE. */
#define BF_FLEXIO_TIMIEN_TEIE(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_TIMIEN_TEIE) & BM_FLEXIO_TIMIEN_TEIE)

/*! @brief Set the TEIE field to a new value. */
#define BW_FLEXIO_TIMIEN_TEIE(x, v) (BME_BFI32(HW_FLEXIO_TIMIEN_ADDR(x), ((uint32_t)(v) << BP_FLEXIO_TIMIEN_TEIE), BP_FLEXIO_TIMIEN_TEIE, 4))
/*@}*/

/*******************************************************************************
 * HW_FLEXIO_SHIFTSDEN - Shifter Status DMA Enable
 ******************************************************************************/

/*!
 * @brief HW_FLEXIO_SHIFTSDEN - Shifter Status DMA Enable (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
typedef union _hw_flexio_shiftsden
{
    uint32_t U;
    struct _hw_flexio_shiftsden_bitfields
    {
        uint32_t SSDE : 4;             /*!< [3:0] Shifter Status DMA Enable */
        uint32_t RESERVED0 : 28;       /*!< [31:4]  */
    } B;
} hw_flexio_shiftsden_t;

/*!
 * @name Constants and macros for entire FLEXIO_SHIFTSDEN register
 */
/*@{*/
#define HW_FLEXIO_SHIFTSDEN_ADDR(x) ((uint32_t)(x) + 0x30U)

#define HW_FLEXIO_SHIFTSDEN(x)   (*(__IO hw_flexio_shiftsden_t *) HW_FLEXIO_SHIFTSDEN_ADDR(x))
#define HW_FLEXIO_SHIFTSDEN_RD(x) (HW_FLEXIO_SHIFTSDEN(x).U)
#define HW_FLEXIO_SHIFTSDEN_WR(x, v) (HW_FLEXIO_SHIFTSDEN(x).U = (v))
#define HW_FLEXIO_SHIFTSDEN_SET(x, v) (BME_OR32(HW_FLEXIO_SHIFTSDEN_ADDR(x), (uint32_t)(v)))
#define HW_FLEXIO_SHIFTSDEN_CLR(x, v) (BME_AND32(HW_FLEXIO_SHIFTSDEN_ADDR(x), (uint32_t)(~(v))))
#define HW_FLEXIO_SHIFTSDEN_TOG(x, v) (BME_XOR32(HW_FLEXIO_SHIFTSDEN_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTSDEN bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTSDEN, field SSDE[3:0] (RW)
 *
 * Enables DMA request generation when corresponding SSF is set.
 *
 * Values:
 * - 0 - Shifter Status Flag DMA request is disabled
 * - 1 - Shifter Status Flag DMA request is enabled
 */
/*@{*/
#define BP_FLEXIO_SHIFTSDEN_SSDE (0U)      /*!< Bit position for FLEXIO_SHIFTSDEN_SSDE. */
#define BM_FLEXIO_SHIFTSDEN_SSDE (0x0000000FU) /*!< Bit mask for FLEXIO_SHIFTSDEN_SSDE. */
#define BS_FLEXIO_SHIFTSDEN_SSDE (4U)      /*!< Bit field size in bits for FLEXIO_SHIFTSDEN_SSDE. */

/*! @brief Read current value of the FLEXIO_SHIFTSDEN_SSDE field. */
#define BR_FLEXIO_SHIFTSDEN_SSDE(x) (BME_UBFX32(HW_FLEXIO_SHIFTSDEN_ADDR(x), BP_FLEXIO_SHIFTSDEN_SSDE, BS_FLEXIO_SHIFTSDEN_SSDE))

/*! @brief Format value for bitfield FLEXIO_SHIFTSDEN_SSDE. */
#define BF_FLEXIO_SHIFTSDEN_SSDE(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_SHIFTSDEN_SSDE) & BM_FLEXIO_SHIFTSDEN_SSDE)

/*! @brief Set the SSDE field to a new value. */
#define BW_FLEXIO_SHIFTSDEN_SSDE(x, v) (BME_BFI32(HW_FLEXIO_SHIFTSDEN_ADDR(x), ((uint32_t)(v) << BP_FLEXIO_SHIFTSDEN_SSDE), BP_FLEXIO_SHIFTSDEN_SSDE, 4))
/*@}*/

/*******************************************************************************
 * HW_FLEXIO_SHIFTCTLn - Shifter Control N Register
 ******************************************************************************/

/*!
 * @brief HW_FLEXIO_SHIFTCTLn - Shifter Control N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
typedef union _hw_flexio_shiftctln
{
    uint32_t U;
    struct _hw_flexio_shiftctln_bitfields
    {
        uint32_t SMOD : 3;             /*!< [2:0] Shifter Mode */
        uint32_t RESERVED0 : 4;        /*!< [6:3]  */
        uint32_t PINPOL : 1;           /*!< [7] Shifter Pin Polarity */
        uint32_t PINSEL : 3;           /*!< [10:8] Shifter Pin Select */
        uint32_t RESERVED1 : 5;        /*!< [15:11]  */
        uint32_t PINCFG : 2;           /*!< [17:16] Shifter Pin Configuration */
        uint32_t RESERVED2 : 5;        /*!< [22:18]  */
        uint32_t TIMPOL : 1;           /*!< [23] Timer Polarity */
        uint32_t TIMSEL : 2;           /*!< [25:24] Timer Select */
        uint32_t RESERVED3 : 6;        /*!< [31:26]  */
    } B;
} hw_flexio_shiftctln_t;

/*!
 * @name Constants and macros for entire FLEXIO_SHIFTCTLn register
 */
/*@{*/
#define HW_FLEXIO_SHIFTCTLn_COUNT (4U)

#define HW_FLEXIO_SHIFTCTLn_ADDR(x, n) ((uint32_t)(x) + 0x80U + (0x4U * (n)))

#define HW_FLEXIO_SHIFTCTLn(x, n) (*(__IO hw_flexio_shiftctln_t *) HW_FLEXIO_SHIFTCTLn_ADDR(x, n))
#define HW_FLEXIO_SHIFTCTLn_RD(x, n) (HW_FLEXIO_SHIFTCTLn(x, n).U)
#define HW_FLEXIO_SHIFTCTLn_WR(x, n, v) (HW_FLEXIO_SHIFTCTLn(x, n).U = (v))
#define HW_FLEXIO_SHIFTCTLn_SET(x, n, v) (BME_OR32(HW_FLEXIO_SHIFTCTLn_ADDR(x, n), (uint32_t)(v)))
#define HW_FLEXIO_SHIFTCTLn_CLR(x, n, v) (BME_AND32(HW_FLEXIO_SHIFTCTLn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_FLEXIO_SHIFTCTLn_TOG(x, n, v) (BME_XOR32(HW_FLEXIO_SHIFTCTLn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTCTLn bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTCTLn, field SMOD[2:0] (RW)
 *
 * Configures the mode of the Shifter.
 *
 * Values:
 * - 000 - Disabled.
 * - 001 - Receive mode. Captures the current Shifter content into the SHIFTBUF
 *     on expiration of the Timer.
 * - 010 - Transmit mode. Load SHIFTBUF contents into the Shifter on expiration
 *     of the Timer.
 * - 011 - Reserved.
 * - 100 - Match Store mode. Shifter data is compared to SHIFTBUF content on
 *     expiration of the Timer.
 * - 101 - Match Continuous mode. Shifter data is continuously compared to
 *     SHIFTBUF contents.
 * - 110 - Reserved.
 * - 111 - Reserved.
 */
/*@{*/
#define BP_FLEXIO_SHIFTCTLn_SMOD (0U)      /*!< Bit position for FLEXIO_SHIFTCTLn_SMOD. */
#define BM_FLEXIO_SHIFTCTLn_SMOD (0x00000007U) /*!< Bit mask for FLEXIO_SHIFTCTLn_SMOD. */
#define BS_FLEXIO_SHIFTCTLn_SMOD (3U)      /*!< Bit field size in bits for FLEXIO_SHIFTCTLn_SMOD. */

/*! @brief Read current value of the FLEXIO_SHIFTCTLn_SMOD field. */
#define BR_FLEXIO_SHIFTCTLn_SMOD(x, n) (BME_UBFX32(HW_FLEXIO_SHIFTCTLn_ADDR(x, n), BP_FLEXIO_SHIFTCTLn_SMOD, BS_FLEXIO_SHIFTCTLn_SMOD))

/*! @brief Format value for bitfield FLEXIO_SHIFTCTLn_SMOD. */
#define BF_FLEXIO_SHIFTCTLn_SMOD(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_SHIFTCTLn_SMOD) & BM_FLEXIO_SHIFTCTLn_SMOD)

/*! @brief Set the SMOD field to a new value. */
#define BW_FLEXIO_SHIFTCTLn_SMOD(x, n, v) (BME_BFI32(HW_FLEXIO_SHIFTCTLn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_SHIFTCTLn_SMOD), BP_FLEXIO_SHIFTCTLn_SMOD, 3))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCTLn, field PINPOL[7] (RW)
 *
 * Values:
 * - 0 - Pin is active high
 * - 1 - Pin is active low
 */
/*@{*/
#define BP_FLEXIO_SHIFTCTLn_PINPOL (7U)    /*!< Bit position for FLEXIO_SHIFTCTLn_PINPOL. */
#define BM_FLEXIO_SHIFTCTLn_PINPOL (0x00000080U) /*!< Bit mask for FLEXIO_SHIFTCTLn_PINPOL. */
#define BS_FLEXIO_SHIFTCTLn_PINPOL (1U)    /*!< Bit field size in bits for FLEXIO_SHIFTCTLn_PINPOL. */

/*! @brief Read current value of the FLEXIO_SHIFTCTLn_PINPOL field. */
#define BR_FLEXIO_SHIFTCTLn_PINPOL(x, n) (BME_UBFX32(HW_FLEXIO_SHIFTCTLn_ADDR(x, n), BP_FLEXIO_SHIFTCTLn_PINPOL, BS_FLEXIO_SHIFTCTLn_PINPOL))

/*! @brief Format value for bitfield FLEXIO_SHIFTCTLn_PINPOL. */
#define BF_FLEXIO_SHIFTCTLn_PINPOL(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_SHIFTCTLn_PINPOL) & BM_FLEXIO_SHIFTCTLn_PINPOL)

/*! @brief Set the PINPOL field to a new value. */
#define BW_FLEXIO_SHIFTCTLn_PINPOL(x, n, v) (BME_BFI32(HW_FLEXIO_SHIFTCTLn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_SHIFTCTLn_PINPOL), BP_FLEXIO_SHIFTCTLn_PINPOL, 1))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCTLn, field PINSEL[10:8] (RW)
 *
 * Selects which pin is used by the Shifter input or output.
 */
/*@{*/
#define BP_FLEXIO_SHIFTCTLn_PINSEL (8U)    /*!< Bit position for FLEXIO_SHIFTCTLn_PINSEL. */
#define BM_FLEXIO_SHIFTCTLn_PINSEL (0x00000700U) /*!< Bit mask for FLEXIO_SHIFTCTLn_PINSEL. */
#define BS_FLEXIO_SHIFTCTLn_PINSEL (3U)    /*!< Bit field size in bits for FLEXIO_SHIFTCTLn_PINSEL. */

/*! @brief Read current value of the FLEXIO_SHIFTCTLn_PINSEL field. */
#define BR_FLEXIO_SHIFTCTLn_PINSEL(x, n) (BME_UBFX32(HW_FLEXIO_SHIFTCTLn_ADDR(x, n), BP_FLEXIO_SHIFTCTLn_PINSEL, BS_FLEXIO_SHIFTCTLn_PINSEL))

/*! @brief Format value for bitfield FLEXIO_SHIFTCTLn_PINSEL. */
#define BF_FLEXIO_SHIFTCTLn_PINSEL(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_SHIFTCTLn_PINSEL) & BM_FLEXIO_SHIFTCTLn_PINSEL)

/*! @brief Set the PINSEL field to a new value. */
#define BW_FLEXIO_SHIFTCTLn_PINSEL(x, n, v) (BME_BFI32(HW_FLEXIO_SHIFTCTLn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_SHIFTCTLn_PINSEL), BP_FLEXIO_SHIFTCTLn_PINSEL, 3))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCTLn, field PINCFG[17:16] (RW)
 *
 * Values:
 * - 00 - Shifter pin output disabled
 * - 01 - Shifter pin open drain or bidirectional output enable
 * - 10 - Shifter pin bidirectional output data
 * - 11 - Shifter pin output
 */
/*@{*/
#define BP_FLEXIO_SHIFTCTLn_PINCFG (16U)   /*!< Bit position for FLEXIO_SHIFTCTLn_PINCFG. */
#define BM_FLEXIO_SHIFTCTLn_PINCFG (0x00030000U) /*!< Bit mask for FLEXIO_SHIFTCTLn_PINCFG. */
#define BS_FLEXIO_SHIFTCTLn_PINCFG (2U)    /*!< Bit field size in bits for FLEXIO_SHIFTCTLn_PINCFG. */

/*! @brief Read current value of the FLEXIO_SHIFTCTLn_PINCFG field. */
#define BR_FLEXIO_SHIFTCTLn_PINCFG(x, n) (BME_UBFX32(HW_FLEXIO_SHIFTCTLn_ADDR(x, n), BP_FLEXIO_SHIFTCTLn_PINCFG, BS_FLEXIO_SHIFTCTLn_PINCFG))

/*! @brief Format value for bitfield FLEXIO_SHIFTCTLn_PINCFG. */
#define BF_FLEXIO_SHIFTCTLn_PINCFG(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_SHIFTCTLn_PINCFG) & BM_FLEXIO_SHIFTCTLn_PINCFG)

/*! @brief Set the PINCFG field to a new value. */
#define BW_FLEXIO_SHIFTCTLn_PINCFG(x, n, v) (BME_BFI32(HW_FLEXIO_SHIFTCTLn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_SHIFTCTLn_PINCFG), BP_FLEXIO_SHIFTCTLn_PINCFG, 2))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCTLn, field TIMPOL[23] (RW)
 *
 * Values:
 * - 0 - Shift on posedge of Shift clock
 * - 1 - Shift on negedge of Shift clock
 */
/*@{*/
#define BP_FLEXIO_SHIFTCTLn_TIMPOL (23U)   /*!< Bit position for FLEXIO_SHIFTCTLn_TIMPOL. */
#define BM_FLEXIO_SHIFTCTLn_TIMPOL (0x00800000U) /*!< Bit mask for FLEXIO_SHIFTCTLn_TIMPOL. */
#define BS_FLEXIO_SHIFTCTLn_TIMPOL (1U)    /*!< Bit field size in bits for FLEXIO_SHIFTCTLn_TIMPOL. */

/*! @brief Read current value of the FLEXIO_SHIFTCTLn_TIMPOL field. */
#define BR_FLEXIO_SHIFTCTLn_TIMPOL(x, n) (BME_UBFX32(HW_FLEXIO_SHIFTCTLn_ADDR(x, n), BP_FLEXIO_SHIFTCTLn_TIMPOL, BS_FLEXIO_SHIFTCTLn_TIMPOL))

/*! @brief Format value for bitfield FLEXIO_SHIFTCTLn_TIMPOL. */
#define BF_FLEXIO_SHIFTCTLn_TIMPOL(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_SHIFTCTLn_TIMPOL) & BM_FLEXIO_SHIFTCTLn_TIMPOL)

/*! @brief Set the TIMPOL field to a new value. */
#define BW_FLEXIO_SHIFTCTLn_TIMPOL(x, n, v) (BME_BFI32(HW_FLEXIO_SHIFTCTLn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_SHIFTCTLn_TIMPOL), BP_FLEXIO_SHIFTCTLn_TIMPOL, 1))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCTLn, field TIMSEL[25:24] (RW)
 *
 * Selects which Timer is used for controlling the logic/shift register and
 * generating the Shift clock.
 */
/*@{*/
#define BP_FLEXIO_SHIFTCTLn_TIMSEL (24U)   /*!< Bit position for FLEXIO_SHIFTCTLn_TIMSEL. */
#define BM_FLEXIO_SHIFTCTLn_TIMSEL (0x03000000U) /*!< Bit mask for FLEXIO_SHIFTCTLn_TIMSEL. */
#define BS_FLEXIO_SHIFTCTLn_TIMSEL (2U)    /*!< Bit field size in bits for FLEXIO_SHIFTCTLn_TIMSEL. */

/*! @brief Read current value of the FLEXIO_SHIFTCTLn_TIMSEL field. */
#define BR_FLEXIO_SHIFTCTLn_TIMSEL(x, n) (BME_UBFX32(HW_FLEXIO_SHIFTCTLn_ADDR(x, n), BP_FLEXIO_SHIFTCTLn_TIMSEL, BS_FLEXIO_SHIFTCTLn_TIMSEL))

/*! @brief Format value for bitfield FLEXIO_SHIFTCTLn_TIMSEL. */
#define BF_FLEXIO_SHIFTCTLn_TIMSEL(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_SHIFTCTLn_TIMSEL) & BM_FLEXIO_SHIFTCTLn_TIMSEL)

/*! @brief Set the TIMSEL field to a new value. */
#define BW_FLEXIO_SHIFTCTLn_TIMSEL(x, n, v) (BME_BFI32(HW_FLEXIO_SHIFTCTLn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_SHIFTCTLn_TIMSEL), BP_FLEXIO_SHIFTCTLn_TIMSEL, 2))
/*@}*/

/*******************************************************************************
 * HW_FLEXIO_SHIFTCFGn - Shifter Configuration N Register
 ******************************************************************************/

/*!
 * @brief HW_FLEXIO_SHIFTCFGn - Shifter Configuration N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
typedef union _hw_flexio_shiftcfgn
{
    uint32_t U;
    struct _hw_flexio_shiftcfgn_bitfields
    {
        uint32_t SSTART : 2;           /*!< [1:0] Shifter Start bit */
        uint32_t RESERVED0 : 2;        /*!< [3:2]  */
        uint32_t SSTOP : 2;            /*!< [5:4] Shifter Stop bit */
        uint32_t RESERVED1 : 2;        /*!< [7:6]  */
        uint32_t INSRC : 1;            /*!< [8] Input Source */
        uint32_t RESERVED2 : 23;       /*!< [31:9]  */
    } B;
} hw_flexio_shiftcfgn_t;

/*!
 * @name Constants and macros for entire FLEXIO_SHIFTCFGn register
 */
/*@{*/
#define HW_FLEXIO_SHIFTCFGn_COUNT (4U)

#define HW_FLEXIO_SHIFTCFGn_ADDR(x, n) ((uint32_t)(x) + 0x100U + (0x4U * (n)))

#define HW_FLEXIO_SHIFTCFGn(x, n) (*(__IO hw_flexio_shiftcfgn_t *) HW_FLEXIO_SHIFTCFGn_ADDR(x, n))
#define HW_FLEXIO_SHIFTCFGn_RD(x, n) (HW_FLEXIO_SHIFTCFGn(x, n).U)
#define HW_FLEXIO_SHIFTCFGn_WR(x, n, v) (HW_FLEXIO_SHIFTCFGn(x, n).U = (v))
#define HW_FLEXIO_SHIFTCFGn_SET(x, n, v) (BME_OR32(HW_FLEXIO_SHIFTCFGn_ADDR(x, n), (uint32_t)(v)))
#define HW_FLEXIO_SHIFTCFGn_CLR(x, n, v) (BME_AND32(HW_FLEXIO_SHIFTCFGn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_FLEXIO_SHIFTCFGn_TOG(x, n, v) (BME_XOR32(HW_FLEXIO_SHIFTCFGn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTCFGn bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTCFGn, field SSTART[1:0] (RW)
 *
 * For SMOD=Transmit, this field allows automatic start bit insertion if the
 * selected timer has also enabled a start bit. For SMOD=Receive or Match Store,
 * this field allows automatic start bit checking if the selected timer has also
 * enabled a start bit.
 *
 * Values:
 * - 00 - Start bit disabled for transmitter/receiver/match store, transmitter
 *     loads data on enable
 * - 01 - Start bit disabled for transmitter/receiver/match store, transmitter
 *     loads data on first shift
 * - 10 - Transmitter outputs start bit value 0 before loading data on first
 *     shift, receiver/match store sets error flag if start bit is not 0
 * - 11 - Transmitter outputs start bit value 1 before loading data on first
 *     shift, receiver/match store sets error flag if start bit is not 1
 */
/*@{*/
#define BP_FLEXIO_SHIFTCFGn_SSTART (0U)    /*!< Bit position for FLEXIO_SHIFTCFGn_SSTART. */
#define BM_FLEXIO_SHIFTCFGn_SSTART (0x00000003U) /*!< Bit mask for FLEXIO_SHIFTCFGn_SSTART. */
#define BS_FLEXIO_SHIFTCFGn_SSTART (2U)    /*!< Bit field size in bits for FLEXIO_SHIFTCFGn_SSTART. */

/*! @brief Read current value of the FLEXIO_SHIFTCFGn_SSTART field. */
#define BR_FLEXIO_SHIFTCFGn_SSTART(x, n) (BME_UBFX32(HW_FLEXIO_SHIFTCFGn_ADDR(x, n), BP_FLEXIO_SHIFTCFGn_SSTART, BS_FLEXIO_SHIFTCFGn_SSTART))

/*! @brief Format value for bitfield FLEXIO_SHIFTCFGn_SSTART. */
#define BF_FLEXIO_SHIFTCFGn_SSTART(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_SHIFTCFGn_SSTART) & BM_FLEXIO_SHIFTCFGn_SSTART)

/*! @brief Set the SSTART field to a new value. */
#define BW_FLEXIO_SHIFTCFGn_SSTART(x, n, v) (BME_BFI32(HW_FLEXIO_SHIFTCFGn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_SHIFTCFGn_SSTART), BP_FLEXIO_SHIFTCFGn_SSTART, 2))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCFGn, field SSTOP[5:4] (RW)
 *
 * For SMOD=Transmit, this field allows automatic stop bit insertion if the
 * selected timer has also enabled a stop bit. For SMOD=Receive or Match Store, this
 * field allows automatic stop bit checking if the selected timer has also
 * enabled a stop bit.
 *
 * Values:
 * - 00 - Stop bit disabled for transmitter/receiver/match store
 * - 01 - Reserved for transmitter/receiver/match store
 * - 10 - Transmitter outputs stop bit value 0 on store, receiver/match store
 *     sets error flag if stop bit is not 0
 * - 11 - Transmitter outputs stop bit value 1 on store, receiver/match store
 *     sets error flag if stop bit is not 1
 */
/*@{*/
#define BP_FLEXIO_SHIFTCFGn_SSTOP (4U)     /*!< Bit position for FLEXIO_SHIFTCFGn_SSTOP. */
#define BM_FLEXIO_SHIFTCFGn_SSTOP (0x00000030U) /*!< Bit mask for FLEXIO_SHIFTCFGn_SSTOP. */
#define BS_FLEXIO_SHIFTCFGn_SSTOP (2U)     /*!< Bit field size in bits for FLEXIO_SHIFTCFGn_SSTOP. */

/*! @brief Read current value of the FLEXIO_SHIFTCFGn_SSTOP field. */
#define BR_FLEXIO_SHIFTCFGn_SSTOP(x, n) (BME_UBFX32(HW_FLEXIO_SHIFTCFGn_ADDR(x, n), BP_FLEXIO_SHIFTCFGn_SSTOP, BS_FLEXIO_SHIFTCFGn_SSTOP))

/*! @brief Format value for bitfield FLEXIO_SHIFTCFGn_SSTOP. */
#define BF_FLEXIO_SHIFTCFGn_SSTOP(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_SHIFTCFGn_SSTOP) & BM_FLEXIO_SHIFTCFGn_SSTOP)

/*! @brief Set the SSTOP field to a new value. */
#define BW_FLEXIO_SHIFTCFGn_SSTOP(x, n, v) (BME_BFI32(HW_FLEXIO_SHIFTCFGn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_SHIFTCFGn_SSTOP), BP_FLEXIO_SHIFTCFGn_SSTOP, 2))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCFGn, field INSRC[8] (RW)
 *
 * Selects the input source for the shifter.
 *
 * Values:
 * - 0 - Pin
 * - 1 - Shifter N+1 Output
 */
/*@{*/
#define BP_FLEXIO_SHIFTCFGn_INSRC (8U)     /*!< Bit position for FLEXIO_SHIFTCFGn_INSRC. */
#define BM_FLEXIO_SHIFTCFGn_INSRC (0x00000100U) /*!< Bit mask for FLEXIO_SHIFTCFGn_INSRC. */
#define BS_FLEXIO_SHIFTCFGn_INSRC (1U)     /*!< Bit field size in bits for FLEXIO_SHIFTCFGn_INSRC. */

/*! @brief Read current value of the FLEXIO_SHIFTCFGn_INSRC field. */
#define BR_FLEXIO_SHIFTCFGn_INSRC(x, n) (BME_UBFX32(HW_FLEXIO_SHIFTCFGn_ADDR(x, n), BP_FLEXIO_SHIFTCFGn_INSRC, BS_FLEXIO_SHIFTCFGn_INSRC))

/*! @brief Format value for bitfield FLEXIO_SHIFTCFGn_INSRC. */
#define BF_FLEXIO_SHIFTCFGn_INSRC(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_SHIFTCFGn_INSRC) & BM_FLEXIO_SHIFTCFGn_INSRC)

/*! @brief Set the INSRC field to a new value. */
#define BW_FLEXIO_SHIFTCFGn_INSRC(x, n, v) (BME_BFI32(HW_FLEXIO_SHIFTCFGn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_SHIFTCFGn_INSRC), BP_FLEXIO_SHIFTCFGn_INSRC, 1))
/*@}*/

/*******************************************************************************
 * HW_FLEXIO_SHIFTBUFn - Shifter Buffer N Register
 ******************************************************************************/

/*!
 * @brief HW_FLEXIO_SHIFTBUFn - Shifter Buffer N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
typedef union _hw_flexio_shiftbufn
{
    uint32_t U;
    struct _hw_flexio_shiftbufn_bitfields
    {
        uint32_t SHIFTBUF : 32;        /*!< [31:0] Shift Buffer */
    } B;
} hw_flexio_shiftbufn_t;

/*!
 * @name Constants and macros for entire FLEXIO_SHIFTBUFn register
 */
/*@{*/
#define HW_FLEXIO_SHIFTBUFn_COUNT (4U)

#define HW_FLEXIO_SHIFTBUFn_ADDR(x, n) ((uint32_t)(x) + 0x200U + (0x4U * (n)))

#define HW_FLEXIO_SHIFTBUFn(x, n) (*(__IO hw_flexio_shiftbufn_t *) HW_FLEXIO_SHIFTBUFn_ADDR(x, n))
#define HW_FLEXIO_SHIFTBUFn_RD(x, n) (HW_FLEXIO_SHIFTBUFn(x, n).U)
#define HW_FLEXIO_SHIFTBUFn_WR(x, n, v) (HW_FLEXIO_SHIFTBUFn(x, n).U = (v))
#define HW_FLEXIO_SHIFTBUFn_SET(x, n, v) (BME_OR32(HW_FLEXIO_SHIFTBUFn_ADDR(x, n), (uint32_t)(v)))
#define HW_FLEXIO_SHIFTBUFn_CLR(x, n, v) (BME_AND32(HW_FLEXIO_SHIFTBUFn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_FLEXIO_SHIFTBUFn_TOG(x, n, v) (BME_XOR32(HW_FLEXIO_SHIFTBUFn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTBUFn bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTBUFn, field SHIFTBUF[31:0] (RW)
 *
 * Shift buffer data is used for a variety of functions depending on the SMOD
 * setting: For SMOD=Receive, Shifter data is transferred into SHIFTBUF at the
 * expiration of Timer. For SMOD=Transmit, SHIFTBUF data is transferred into the
 * Shifter before the Timer begins. For SMOD=Match Store/Continuous, SHIFTBUF[31:16]
 * contains the data to be matched with the Shifter contents. The Match is
 * checked either continuosly (Match Continous mode) or when the Timer expires (Match
 * Store mode). SHIFTBUF[15:0] can be used to mask the match result (1=mask, 0=no
 * mask). In Match Store mode, Shifter data [31:16] is written to SHIFTBUF[31:16]
 * whenever a match event occurs.
 */
/*@{*/
#define BP_FLEXIO_SHIFTBUFn_SHIFTBUF (0U)  /*!< Bit position for FLEXIO_SHIFTBUFn_SHIFTBUF. */
#define BM_FLEXIO_SHIFTBUFn_SHIFTBUF (0xFFFFFFFFU) /*!< Bit mask for FLEXIO_SHIFTBUFn_SHIFTBUF. */
#define BS_FLEXIO_SHIFTBUFn_SHIFTBUF (32U) /*!< Bit field size in bits for FLEXIO_SHIFTBUFn_SHIFTBUF. */

/*! @brief Read current value of the FLEXIO_SHIFTBUFn_SHIFTBUF field. */
#define BR_FLEXIO_SHIFTBUFn_SHIFTBUF(x, n) (HW_FLEXIO_SHIFTBUFn(x, n).U)

/*! @brief Format value for bitfield FLEXIO_SHIFTBUFn_SHIFTBUF. */
#define BF_FLEXIO_SHIFTBUFn_SHIFTBUF(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_SHIFTBUFn_SHIFTBUF) & BM_FLEXIO_SHIFTBUFn_SHIFTBUF)

/*! @brief Set the SHIFTBUF field to a new value. */
#define BW_FLEXIO_SHIFTBUFn_SHIFTBUF(x, n, v) (HW_FLEXIO_SHIFTBUFn_WR(x, n, v))
/*@}*/

/*******************************************************************************
 * HW_FLEXIO_SHIFTBUFBBSn - Shifter Buffer N Bit Byte Swapped Register
 ******************************************************************************/

/*!
 * @brief HW_FLEXIO_SHIFTBUFBBSn - Shifter Buffer N Bit Byte Swapped Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
typedef union _hw_flexio_shiftbufbbsn
{
    uint32_t U;
    struct _hw_flexio_shiftbufbbsn_bitfields
    {
        uint32_t SHIFTBUFBBS : 32;     /*!< [31:0] Shift Buffer */
    } B;
} hw_flexio_shiftbufbbsn_t;

/*!
 * @name Constants and macros for entire FLEXIO_SHIFTBUFBBSn register
 */
/*@{*/
#define HW_FLEXIO_SHIFTBUFBBSn_COUNT (4U)

#define HW_FLEXIO_SHIFTBUFBBSn_ADDR(x, n) ((uint32_t)(x) + 0x280U + (0x4U * (n)))

#define HW_FLEXIO_SHIFTBUFBBSn(x, n) (*(__IO hw_flexio_shiftbufbbsn_t *) HW_FLEXIO_SHIFTBUFBBSn_ADDR(x, n))
#define HW_FLEXIO_SHIFTBUFBBSn_RD(x, n) (HW_FLEXIO_SHIFTBUFBBSn(x, n).U)
#define HW_FLEXIO_SHIFTBUFBBSn_WR(x, n, v) (HW_FLEXIO_SHIFTBUFBBSn(x, n).U = (v))
#define HW_FLEXIO_SHIFTBUFBBSn_SET(x, n, v) (BME_OR32(HW_FLEXIO_SHIFTBUFBBSn_ADDR(x, n), (uint32_t)(v)))
#define HW_FLEXIO_SHIFTBUFBBSn_CLR(x, n, v) (BME_AND32(HW_FLEXIO_SHIFTBUFBBSn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_FLEXIO_SHIFTBUFBBSn_TOG(x, n, v) (BME_XOR32(HW_FLEXIO_SHIFTBUFBBSn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTBUFBBSn bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTBUFBBSn, field SHIFTBUFBBS[31:0] (RW)
 *
 * Alias to SHIFTBUF register, except reads/writes to this register are bit
 * swapped within each byte. Reads return { SHIFTBUF[24:31], SHIFTBUF[16:23],
 * SHIFTBUF[8:15], SHIFTBUF[0:7] }.
 */
/*@{*/
#define BP_FLEXIO_SHIFTBUFBBSn_SHIFTBUFBBS (0U) /*!< Bit position for FLEXIO_SHIFTBUFBBSn_SHIFTBUFBBS. */
#define BM_FLEXIO_SHIFTBUFBBSn_SHIFTBUFBBS (0xFFFFFFFFU) /*!< Bit mask for FLEXIO_SHIFTBUFBBSn_SHIFTBUFBBS. */
#define BS_FLEXIO_SHIFTBUFBBSn_SHIFTBUFBBS (32U) /*!< Bit field size in bits for FLEXIO_SHIFTBUFBBSn_SHIFTBUFBBS. */

/*! @brief Read current value of the FLEXIO_SHIFTBUFBBSn_SHIFTBUFBBS field. */
#define BR_FLEXIO_SHIFTBUFBBSn_SHIFTBUFBBS(x, n) (HW_FLEXIO_SHIFTBUFBBSn(x, n).U)

/*! @brief Format value for bitfield FLEXIO_SHIFTBUFBBSn_SHIFTBUFBBS. */
#define BF_FLEXIO_SHIFTBUFBBSn_SHIFTBUFBBS(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_SHIFTBUFBBSn_SHIFTBUFBBS) & BM_FLEXIO_SHIFTBUFBBSn_SHIFTBUFBBS)

/*! @brief Set the SHIFTBUFBBS field to a new value. */
#define BW_FLEXIO_SHIFTBUFBBSn_SHIFTBUFBBS(x, n, v) (HW_FLEXIO_SHIFTBUFBBSn_WR(x, n, v))
/*@}*/

/*******************************************************************************
 * HW_FLEXIO_SHIFTBUFBYSn - Shifter Buffer N Byte Swapped Register
 ******************************************************************************/

/*!
 * @brief HW_FLEXIO_SHIFTBUFBYSn - Shifter Buffer N Byte Swapped Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
typedef union _hw_flexio_shiftbufbysn
{
    uint32_t U;
    struct _hw_flexio_shiftbufbysn_bitfields
    {
        uint32_t SHIFTBUFBYS : 32;     /*!< [31:0] Shift Buffer */
    } B;
} hw_flexio_shiftbufbysn_t;

/*!
 * @name Constants and macros for entire FLEXIO_SHIFTBUFBYSn register
 */
/*@{*/
#define HW_FLEXIO_SHIFTBUFBYSn_COUNT (4U)

#define HW_FLEXIO_SHIFTBUFBYSn_ADDR(x, n) ((uint32_t)(x) + 0x300U + (0x4U * (n)))

#define HW_FLEXIO_SHIFTBUFBYSn(x, n) (*(__IO hw_flexio_shiftbufbysn_t *) HW_FLEXIO_SHIFTBUFBYSn_ADDR(x, n))
#define HW_FLEXIO_SHIFTBUFBYSn_RD(x, n) (HW_FLEXIO_SHIFTBUFBYSn(x, n).U)
#define HW_FLEXIO_SHIFTBUFBYSn_WR(x, n, v) (HW_FLEXIO_SHIFTBUFBYSn(x, n).U = (v))
#define HW_FLEXIO_SHIFTBUFBYSn_SET(x, n, v) (BME_OR32(HW_FLEXIO_SHIFTBUFBYSn_ADDR(x, n), (uint32_t)(v)))
#define HW_FLEXIO_SHIFTBUFBYSn_CLR(x, n, v) (BME_AND32(HW_FLEXIO_SHIFTBUFBYSn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_FLEXIO_SHIFTBUFBYSn_TOG(x, n, v) (BME_XOR32(HW_FLEXIO_SHIFTBUFBYSn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTBUFBYSn bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTBUFBYSn, field SHIFTBUFBYS[31:0] (RW)
 *
 * Alias to SHIFTBUF register, except reads/writes to this register are byte
 * swapped. Reads return { SHIFTBUF[7:0], SHIFTBUF[15:8], SHIFTBUF[23:16],
 * SHIFTBUF[31:24] }.
 */
/*@{*/
#define BP_FLEXIO_SHIFTBUFBYSn_SHIFTBUFBYS (0U) /*!< Bit position for FLEXIO_SHIFTBUFBYSn_SHIFTBUFBYS. */
#define BM_FLEXIO_SHIFTBUFBYSn_SHIFTBUFBYS (0xFFFFFFFFU) /*!< Bit mask for FLEXIO_SHIFTBUFBYSn_SHIFTBUFBYS. */
#define BS_FLEXIO_SHIFTBUFBYSn_SHIFTBUFBYS (32U) /*!< Bit field size in bits for FLEXIO_SHIFTBUFBYSn_SHIFTBUFBYS. */

/*! @brief Read current value of the FLEXIO_SHIFTBUFBYSn_SHIFTBUFBYS field. */
#define BR_FLEXIO_SHIFTBUFBYSn_SHIFTBUFBYS(x, n) (HW_FLEXIO_SHIFTBUFBYSn(x, n).U)

/*! @brief Format value for bitfield FLEXIO_SHIFTBUFBYSn_SHIFTBUFBYS. */
#define BF_FLEXIO_SHIFTBUFBYSn_SHIFTBUFBYS(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_SHIFTBUFBYSn_SHIFTBUFBYS) & BM_FLEXIO_SHIFTBUFBYSn_SHIFTBUFBYS)

/*! @brief Set the SHIFTBUFBYS field to a new value. */
#define BW_FLEXIO_SHIFTBUFBYSn_SHIFTBUFBYS(x, n, v) (HW_FLEXIO_SHIFTBUFBYSn_WR(x, n, v))
/*@}*/

/*******************************************************************************
 * HW_FLEXIO_SHIFTBUFBISn - Shifter Buffer N Bit Swapped Register
 ******************************************************************************/

/*!
 * @brief HW_FLEXIO_SHIFTBUFBISn - Shifter Buffer N Bit Swapped Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
typedef union _hw_flexio_shiftbufbisn
{
    uint32_t U;
    struct _hw_flexio_shiftbufbisn_bitfields
    {
        uint32_t SHIFTBUFBIS : 32;     /*!< [31:0] Shift Buffer */
    } B;
} hw_flexio_shiftbufbisn_t;

/*!
 * @name Constants and macros for entire FLEXIO_SHIFTBUFBISn register
 */
/*@{*/
#define HW_FLEXIO_SHIFTBUFBISn_COUNT (4U)

#define HW_FLEXIO_SHIFTBUFBISn_ADDR(x, n) ((uint32_t)(x) + 0x380U + (0x4U * (n)))

#define HW_FLEXIO_SHIFTBUFBISn(x, n) (*(__IO hw_flexio_shiftbufbisn_t *) HW_FLEXIO_SHIFTBUFBISn_ADDR(x, n))
#define HW_FLEXIO_SHIFTBUFBISn_RD(x, n) (HW_FLEXIO_SHIFTBUFBISn(x, n).U)
#define HW_FLEXIO_SHIFTBUFBISn_WR(x, n, v) (HW_FLEXIO_SHIFTBUFBISn(x, n).U = (v))
#define HW_FLEXIO_SHIFTBUFBISn_SET(x, n, v) (BME_OR32(HW_FLEXIO_SHIFTBUFBISn_ADDR(x, n), (uint32_t)(v)))
#define HW_FLEXIO_SHIFTBUFBISn_CLR(x, n, v) (BME_AND32(HW_FLEXIO_SHIFTBUFBISn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_FLEXIO_SHIFTBUFBISn_TOG(x, n, v) (BME_XOR32(HW_FLEXIO_SHIFTBUFBISn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTBUFBISn bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTBUFBISn, field SHIFTBUFBIS[31:0] (RW)
 *
 * Alias to SHIFTBUF register, except reads/writes to this register are bit
 * swapped. Reads return SHIFTBUF[0:31].
 */
/*@{*/
#define BP_FLEXIO_SHIFTBUFBISn_SHIFTBUFBIS (0U) /*!< Bit position for FLEXIO_SHIFTBUFBISn_SHIFTBUFBIS. */
#define BM_FLEXIO_SHIFTBUFBISn_SHIFTBUFBIS (0xFFFFFFFFU) /*!< Bit mask for FLEXIO_SHIFTBUFBISn_SHIFTBUFBIS. */
#define BS_FLEXIO_SHIFTBUFBISn_SHIFTBUFBIS (32U) /*!< Bit field size in bits for FLEXIO_SHIFTBUFBISn_SHIFTBUFBIS. */

/*! @brief Read current value of the FLEXIO_SHIFTBUFBISn_SHIFTBUFBIS field. */
#define BR_FLEXIO_SHIFTBUFBISn_SHIFTBUFBIS(x, n) (HW_FLEXIO_SHIFTBUFBISn(x, n).U)

/*! @brief Format value for bitfield FLEXIO_SHIFTBUFBISn_SHIFTBUFBIS. */
#define BF_FLEXIO_SHIFTBUFBISn_SHIFTBUFBIS(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_SHIFTBUFBISn_SHIFTBUFBIS) & BM_FLEXIO_SHIFTBUFBISn_SHIFTBUFBIS)

/*! @brief Set the SHIFTBUFBIS field to a new value. */
#define BW_FLEXIO_SHIFTBUFBISn_SHIFTBUFBIS(x, n, v) (HW_FLEXIO_SHIFTBUFBISn_WR(x, n, v))
/*@}*/

/*******************************************************************************
 * HW_FLEXIO_TIMCTLn - Timer Control N Register
 ******************************************************************************/

/*!
 * @brief HW_FLEXIO_TIMCTLn - Timer Control N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
typedef union _hw_flexio_timctln
{
    uint32_t U;
    struct _hw_flexio_timctln_bitfields
    {
        uint32_t TIMOD : 2;            /*!< [1:0] Timer Mode */
        uint32_t RESERVED0 : 5;        /*!< [6:2]  */
        uint32_t PINPOL : 1;           /*!< [7] Timer Pin Polarity */
        uint32_t PINSEL : 3;           /*!< [10:8] Timer Pin Select */
        uint32_t RESERVED1 : 5;        /*!< [15:11]  */
        uint32_t PINCFG : 2;           /*!< [17:16] Timer Pin Configuration */
        uint32_t RESERVED2 : 4;        /*!< [21:18]  */
        uint32_t TRGSRC : 1;           /*!< [22] Trigger Source */
        uint32_t TRGPOL : 1;           /*!< [23] Trigger Polarity */
        uint32_t TRGSEL : 4;           /*!< [27:24] Trigger Select */
        uint32_t RESERVED3 : 4;        /*!< [31:28]  */
    } B;
} hw_flexio_timctln_t;

/*!
 * @name Constants and macros for entire FLEXIO_TIMCTLn register
 */
/*@{*/
#define HW_FLEXIO_TIMCTLn_COUNT (4U)

#define HW_FLEXIO_TIMCTLn_ADDR(x, n) ((uint32_t)(x) + 0x400U + (0x4U * (n)))

#define HW_FLEXIO_TIMCTLn(x, n)  (*(__IO hw_flexio_timctln_t *) HW_FLEXIO_TIMCTLn_ADDR(x, n))
#define HW_FLEXIO_TIMCTLn_RD(x, n) (HW_FLEXIO_TIMCTLn(x, n).U)
#define HW_FLEXIO_TIMCTLn_WR(x, n, v) (HW_FLEXIO_TIMCTLn(x, n).U = (v))
#define HW_FLEXIO_TIMCTLn_SET(x, n, v) (BME_OR32(HW_FLEXIO_TIMCTLn_ADDR(x, n), (uint32_t)(v)))
#define HW_FLEXIO_TIMCTLn_CLR(x, n, v) (BME_AND32(HW_FLEXIO_TIMCTLn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_FLEXIO_TIMCTLn_TOG(x, n, v) (BME_XOR32(HW_FLEXIO_TIMCTLn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_TIMCTLn bitfields
 */

/*!
 * @name Register FLEXIO_TIMCTLn, field TIMOD[1:0] (RW)
 *
 * In 8-bit counter mode, the lower 8-bits of the counter and compare register
 * are used to configure the baud rate of the timer shift clock and the upper
 * 8-bits are used to configure the shifter bit count. In 8-bit PWM mode, the lower
 * 8-bits of the counter and compare register are used to configure the high
 * period of the timer shift clock and the upper 8-bits are used to configure the low
 * period of the timer shift clock. The shifter bit count is configured using
 * another timer or external signal. In 16-bit counter mode, the full 16-bits of the
 * counter and compare register are used to configure either the baud rate of
 * the shift clock or the shifter bit count.
 *
 * Values:
 * - 00 - Timer Disabled.
 * - 01 - Dual 8-bit counters baud/bit mode.
 * - 10 - Dual 8-bit counters PWM mode.
 * - 11 - Single 16-bit counter mode.
 */
/*@{*/
#define BP_FLEXIO_TIMCTLn_TIMOD (0U)       /*!< Bit position for FLEXIO_TIMCTLn_TIMOD. */
#define BM_FLEXIO_TIMCTLn_TIMOD (0x00000003U) /*!< Bit mask for FLEXIO_TIMCTLn_TIMOD. */
#define BS_FLEXIO_TIMCTLn_TIMOD (2U)       /*!< Bit field size in bits for FLEXIO_TIMCTLn_TIMOD. */

/*! @brief Read current value of the FLEXIO_TIMCTLn_TIMOD field. */
#define BR_FLEXIO_TIMCTLn_TIMOD(x, n) (BME_UBFX32(HW_FLEXIO_TIMCTLn_ADDR(x, n), BP_FLEXIO_TIMCTLn_TIMOD, BS_FLEXIO_TIMCTLn_TIMOD))

/*! @brief Format value for bitfield FLEXIO_TIMCTLn_TIMOD. */
#define BF_FLEXIO_TIMCTLn_TIMOD(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_TIMCTLn_TIMOD) & BM_FLEXIO_TIMCTLn_TIMOD)

/*! @brief Set the TIMOD field to a new value. */
#define BW_FLEXIO_TIMCTLn_TIMOD(x, n, v) (BME_BFI32(HW_FLEXIO_TIMCTLn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_TIMCTLn_TIMOD), BP_FLEXIO_TIMCTLn_TIMOD, 2))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTLn, field PINPOL[7] (RW)
 *
 * Values:
 * - 0 - Pin is active high
 * - 1 - Pin is active low
 */
/*@{*/
#define BP_FLEXIO_TIMCTLn_PINPOL (7U)      /*!< Bit position for FLEXIO_TIMCTLn_PINPOL. */
#define BM_FLEXIO_TIMCTLn_PINPOL (0x00000080U) /*!< Bit mask for FLEXIO_TIMCTLn_PINPOL. */
#define BS_FLEXIO_TIMCTLn_PINPOL (1U)      /*!< Bit field size in bits for FLEXIO_TIMCTLn_PINPOL. */

/*! @brief Read current value of the FLEXIO_TIMCTLn_PINPOL field. */
#define BR_FLEXIO_TIMCTLn_PINPOL(x, n) (BME_UBFX32(HW_FLEXIO_TIMCTLn_ADDR(x, n), BP_FLEXIO_TIMCTLn_PINPOL, BS_FLEXIO_TIMCTLn_PINPOL))

/*! @brief Format value for bitfield FLEXIO_TIMCTLn_PINPOL. */
#define BF_FLEXIO_TIMCTLn_PINPOL(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_TIMCTLn_PINPOL) & BM_FLEXIO_TIMCTLn_PINPOL)

/*! @brief Set the PINPOL field to a new value. */
#define BW_FLEXIO_TIMCTLn_PINPOL(x, n, v) (BME_BFI32(HW_FLEXIO_TIMCTLn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_TIMCTLn_PINPOL), BP_FLEXIO_TIMCTLn_PINPOL, 1))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTLn, field PINSEL[10:8] (RW)
 *
 * Selects which pin is used by the Timer input or output.
 */
/*@{*/
#define BP_FLEXIO_TIMCTLn_PINSEL (8U)      /*!< Bit position for FLEXIO_TIMCTLn_PINSEL. */
#define BM_FLEXIO_TIMCTLn_PINSEL (0x00000700U) /*!< Bit mask for FLEXIO_TIMCTLn_PINSEL. */
#define BS_FLEXIO_TIMCTLn_PINSEL (3U)      /*!< Bit field size in bits for FLEXIO_TIMCTLn_PINSEL. */

/*! @brief Read current value of the FLEXIO_TIMCTLn_PINSEL field. */
#define BR_FLEXIO_TIMCTLn_PINSEL(x, n) (BME_UBFX32(HW_FLEXIO_TIMCTLn_ADDR(x, n), BP_FLEXIO_TIMCTLn_PINSEL, BS_FLEXIO_TIMCTLn_PINSEL))

/*! @brief Format value for bitfield FLEXIO_TIMCTLn_PINSEL. */
#define BF_FLEXIO_TIMCTLn_PINSEL(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_TIMCTLn_PINSEL) & BM_FLEXIO_TIMCTLn_PINSEL)

/*! @brief Set the PINSEL field to a new value. */
#define BW_FLEXIO_TIMCTLn_PINSEL(x, n, v) (BME_BFI32(HW_FLEXIO_TIMCTLn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_TIMCTLn_PINSEL), BP_FLEXIO_TIMCTLn_PINSEL, 3))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTLn, field PINCFG[17:16] (RW)
 *
 * Values:
 * - 00 - Timer pin output disabled
 * - 01 - Timer pin open drain or bidirectional output enable
 * - 10 - Timer pin bidirectional output data
 * - 11 - Timer pin output
 */
/*@{*/
#define BP_FLEXIO_TIMCTLn_PINCFG (16U)     /*!< Bit position for FLEXIO_TIMCTLn_PINCFG. */
#define BM_FLEXIO_TIMCTLn_PINCFG (0x00030000U) /*!< Bit mask for FLEXIO_TIMCTLn_PINCFG. */
#define BS_FLEXIO_TIMCTLn_PINCFG (2U)      /*!< Bit field size in bits for FLEXIO_TIMCTLn_PINCFG. */

/*! @brief Read current value of the FLEXIO_TIMCTLn_PINCFG field. */
#define BR_FLEXIO_TIMCTLn_PINCFG(x, n) (BME_UBFX32(HW_FLEXIO_TIMCTLn_ADDR(x, n), BP_FLEXIO_TIMCTLn_PINCFG, BS_FLEXIO_TIMCTLn_PINCFG))

/*! @brief Format value for bitfield FLEXIO_TIMCTLn_PINCFG. */
#define BF_FLEXIO_TIMCTLn_PINCFG(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_TIMCTLn_PINCFG) & BM_FLEXIO_TIMCTLn_PINCFG)

/*! @brief Set the PINCFG field to a new value. */
#define BW_FLEXIO_TIMCTLn_PINCFG(x, n, v) (BME_BFI32(HW_FLEXIO_TIMCTLn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_TIMCTLn_PINCFG), BP_FLEXIO_TIMCTLn_PINCFG, 2))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTLn, field TRGSRC[22] (RW)
 *
 * Values:
 * - 0 - External trigger selected
 * - 1 - Internal trigger selected
 */
/*@{*/
#define BP_FLEXIO_TIMCTLn_TRGSRC (22U)     /*!< Bit position for FLEXIO_TIMCTLn_TRGSRC. */
#define BM_FLEXIO_TIMCTLn_TRGSRC (0x00400000U) /*!< Bit mask for FLEXIO_TIMCTLn_TRGSRC. */
#define BS_FLEXIO_TIMCTLn_TRGSRC (1U)      /*!< Bit field size in bits for FLEXIO_TIMCTLn_TRGSRC. */

/*! @brief Read current value of the FLEXIO_TIMCTLn_TRGSRC field. */
#define BR_FLEXIO_TIMCTLn_TRGSRC(x, n) (BME_UBFX32(HW_FLEXIO_TIMCTLn_ADDR(x, n), BP_FLEXIO_TIMCTLn_TRGSRC, BS_FLEXIO_TIMCTLn_TRGSRC))

/*! @brief Format value for bitfield FLEXIO_TIMCTLn_TRGSRC. */
#define BF_FLEXIO_TIMCTLn_TRGSRC(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_TIMCTLn_TRGSRC) & BM_FLEXIO_TIMCTLn_TRGSRC)

/*! @brief Set the TRGSRC field to a new value. */
#define BW_FLEXIO_TIMCTLn_TRGSRC(x, n, v) (BME_BFI32(HW_FLEXIO_TIMCTLn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_TIMCTLn_TRGSRC), BP_FLEXIO_TIMCTLn_TRGSRC, 1))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTLn, field TRGPOL[23] (RW)
 *
 * Values:
 * - 0 - Trigger active high
 * - 1 - Trigger active low
 */
/*@{*/
#define BP_FLEXIO_TIMCTLn_TRGPOL (23U)     /*!< Bit position for FLEXIO_TIMCTLn_TRGPOL. */
#define BM_FLEXIO_TIMCTLn_TRGPOL (0x00800000U) /*!< Bit mask for FLEXIO_TIMCTLn_TRGPOL. */
#define BS_FLEXIO_TIMCTLn_TRGPOL (1U)      /*!< Bit field size in bits for FLEXIO_TIMCTLn_TRGPOL. */

/*! @brief Read current value of the FLEXIO_TIMCTLn_TRGPOL field. */
#define BR_FLEXIO_TIMCTLn_TRGPOL(x, n) (BME_UBFX32(HW_FLEXIO_TIMCTLn_ADDR(x, n), BP_FLEXIO_TIMCTLn_TRGPOL, BS_FLEXIO_TIMCTLn_TRGPOL))

/*! @brief Format value for bitfield FLEXIO_TIMCTLn_TRGPOL. */
#define BF_FLEXIO_TIMCTLn_TRGPOL(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_TIMCTLn_TRGPOL) & BM_FLEXIO_TIMCTLn_TRGPOL)

/*! @brief Set the TRGPOL field to a new value. */
#define BW_FLEXIO_TIMCTLn_TRGPOL(x, n, v) (BME_BFI32(HW_FLEXIO_TIMCTLn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_TIMCTLn_TRGPOL), BP_FLEXIO_TIMCTLn_TRGPOL, 1))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTLn, field TRGSEL[27:24] (RW)
 *
 * Refer to the chip configuration section for external trigger selection. The
 * internal trigger selection is configured as follows.
 */
/*@{*/
#define BP_FLEXIO_TIMCTLn_TRGSEL (24U)     /*!< Bit position for FLEXIO_TIMCTLn_TRGSEL. */
#define BM_FLEXIO_TIMCTLn_TRGSEL (0x0F000000U) /*!< Bit mask for FLEXIO_TIMCTLn_TRGSEL. */
#define BS_FLEXIO_TIMCTLn_TRGSEL (4U)      /*!< Bit field size in bits for FLEXIO_TIMCTLn_TRGSEL. */

/*! @brief Read current value of the FLEXIO_TIMCTLn_TRGSEL field. */
#define BR_FLEXIO_TIMCTLn_TRGSEL(x, n) (BME_UBFX32(HW_FLEXIO_TIMCTLn_ADDR(x, n), BP_FLEXIO_TIMCTLn_TRGSEL, BS_FLEXIO_TIMCTLn_TRGSEL))

/*! @brief Format value for bitfield FLEXIO_TIMCTLn_TRGSEL. */
#define BF_FLEXIO_TIMCTLn_TRGSEL(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_TIMCTLn_TRGSEL) & BM_FLEXIO_TIMCTLn_TRGSEL)

/*! @brief Set the TRGSEL field to a new value. */
#define BW_FLEXIO_TIMCTLn_TRGSEL(x, n, v) (BME_BFI32(HW_FLEXIO_TIMCTLn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_TIMCTLn_TRGSEL), BP_FLEXIO_TIMCTLn_TRGSEL, 4))
/*@}*/

/*******************************************************************************
 * HW_FLEXIO_TIMCFGn - Timer Configuration N Register
 ******************************************************************************/

/*!
 * @brief HW_FLEXIO_TIMCFGn - Timer Configuration N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The options to enable or disable the timer using the Timer N-1 enable or
 * disable are reserved when N is evenly divisible by 4 (eg: Timer 0).
 */
typedef union _hw_flexio_timcfgn
{
    uint32_t U;
    struct _hw_flexio_timcfgn_bitfields
    {
        uint32_t RESERVED0 : 1;        /*!< [0]  */
        uint32_t TSTART : 1;           /*!< [1] Timer Start Bit */
        uint32_t RESERVED1 : 2;        /*!< [3:2]  */
        uint32_t TSTOP : 2;            /*!< [5:4] Timer Stop Bit */
        uint32_t RESERVED2 : 2;        /*!< [7:6]  */
        uint32_t TIMENA : 3;           /*!< [10:8] Timer Enable */
        uint32_t RESERVED3 : 1;        /*!< [11]  */
        uint32_t TIMDIS : 3;           /*!< [14:12] Timer Disable */
        uint32_t RESERVED4 : 1;        /*!< [15]  */
        uint32_t TIMRST : 3;           /*!< [18:16] Timer Reset */
        uint32_t RESERVED5 : 1;        /*!< [19]  */
        uint32_t TIMDEC : 2;           /*!< [21:20] Timer Decrement */
        uint32_t RESERVED6 : 2;        /*!< [23:22]  */
        uint32_t TIMOUT : 2;           /*!< [25:24] Timer Output */
        uint32_t RESERVED7 : 6;        /*!< [31:26]  */
    } B;
} hw_flexio_timcfgn_t;

/*!
 * @name Constants and macros for entire FLEXIO_TIMCFGn register
 */
/*@{*/
#define HW_FLEXIO_TIMCFGn_COUNT (4U)

#define HW_FLEXIO_TIMCFGn_ADDR(x, n) ((uint32_t)(x) + 0x480U + (0x4U * (n)))

#define HW_FLEXIO_TIMCFGn(x, n)  (*(__IO hw_flexio_timcfgn_t *) HW_FLEXIO_TIMCFGn_ADDR(x, n))
#define HW_FLEXIO_TIMCFGn_RD(x, n) (HW_FLEXIO_TIMCFGn(x, n).U)
#define HW_FLEXIO_TIMCFGn_WR(x, n, v) (HW_FLEXIO_TIMCFGn(x, n).U = (v))
#define HW_FLEXIO_TIMCFGn_SET(x, n, v) (BME_OR32(HW_FLEXIO_TIMCFGn_ADDR(x, n), (uint32_t)(v)))
#define HW_FLEXIO_TIMCFGn_CLR(x, n, v) (BME_AND32(HW_FLEXIO_TIMCFGn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_FLEXIO_TIMCFGn_TOG(x, n, v) (BME_XOR32(HW_FLEXIO_TIMCFGn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_TIMCFGn bitfields
 */

/*!
 * @name Register FLEXIO_TIMCFGn, field TSTART[1] (RW)
 *
 * When start bit is enabled, configured shifters will output the contents of
 * the start bit when the timer is enabled and the timer counter will reload from
 * the compare register on the first rising edge of the shift clock.
 *
 * Values:
 * - 0 - Start bit disabled
 * - 1 - Start bit enabled
 */
/*@{*/
#define BP_FLEXIO_TIMCFGn_TSTART (1U)      /*!< Bit position for FLEXIO_TIMCFGn_TSTART. */
#define BM_FLEXIO_TIMCFGn_TSTART (0x00000002U) /*!< Bit mask for FLEXIO_TIMCFGn_TSTART. */
#define BS_FLEXIO_TIMCFGn_TSTART (1U)      /*!< Bit field size in bits for FLEXIO_TIMCFGn_TSTART. */

/*! @brief Read current value of the FLEXIO_TIMCFGn_TSTART field. */
#define BR_FLEXIO_TIMCFGn_TSTART(x, n) (BME_UBFX32(HW_FLEXIO_TIMCFGn_ADDR(x, n), BP_FLEXIO_TIMCFGn_TSTART, BS_FLEXIO_TIMCFGn_TSTART))

/*! @brief Format value for bitfield FLEXIO_TIMCFGn_TSTART. */
#define BF_FLEXIO_TIMCFGn_TSTART(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_TIMCFGn_TSTART) & BM_FLEXIO_TIMCFGn_TSTART)

/*! @brief Set the TSTART field to a new value. */
#define BW_FLEXIO_TIMCFGn_TSTART(x, n, v) (BME_BFI32(HW_FLEXIO_TIMCFGn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_TIMCFGn_TSTART), BP_FLEXIO_TIMCFGn_TSTART, 1))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFGn, field TSTOP[5:4] (RW)
 *
 * The stop bit can be added on a timer compare (between each word) or on a
 * timer disable. When stop bit is enabled, configured shifters will output the
 * contents of the stop bit when the timer is disabled. When stop bit is enabled on
 * timer disable, the timer remains disabled until the next rising edge of the
 * shift clock. If configured for both timer compare and timer disable, only one stop
 * bit is inserted on timer disable.
 *
 * Values:
 * - 00 - Stop bit disabled
 * - 01 - Stop bit is enabled on timer compare
 * - 10 - Stop bit is enabled on timer disable
 * - 11 - Stop bit is enabled on timer compare and timer disable
 */
/*@{*/
#define BP_FLEXIO_TIMCFGn_TSTOP (4U)       /*!< Bit position for FLEXIO_TIMCFGn_TSTOP. */
#define BM_FLEXIO_TIMCFGn_TSTOP (0x00000030U) /*!< Bit mask for FLEXIO_TIMCFGn_TSTOP. */
#define BS_FLEXIO_TIMCFGn_TSTOP (2U)       /*!< Bit field size in bits for FLEXIO_TIMCFGn_TSTOP. */

/*! @brief Read current value of the FLEXIO_TIMCFGn_TSTOP field. */
#define BR_FLEXIO_TIMCFGn_TSTOP(x, n) (BME_UBFX32(HW_FLEXIO_TIMCFGn_ADDR(x, n), BP_FLEXIO_TIMCFGn_TSTOP, BS_FLEXIO_TIMCFGn_TSTOP))

/*! @brief Format value for bitfield FLEXIO_TIMCFGn_TSTOP. */
#define BF_FLEXIO_TIMCFGn_TSTOP(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_TIMCFGn_TSTOP) & BM_FLEXIO_TIMCFGn_TSTOP)

/*! @brief Set the TSTOP field to a new value. */
#define BW_FLEXIO_TIMCFGn_TSTOP(x, n, v) (BME_BFI32(HW_FLEXIO_TIMCFGn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_TIMCFGn_TSTOP), BP_FLEXIO_TIMCFGn_TSTOP, 2))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFGn, field TIMENA[10:8] (RW)
 *
 * Configures the condition that causes the Timer to be enabled and start
 * decrementing.
 *
 * Values:
 * - 000 - Timer always enabled
 * - 001 - Timer enabled on Timer N-1 enable
 * - 010 - Timer enabled on Trigger high
 * - 011 - Timer enabled on Trigger high and Pin high
 * - 100 - Timer enabled on Pin rising edge
 * - 101 - Timer enabled on Pin rising edge and Trigger high
 * - 110 - Timer enabled on Trigger rising edge
 * - 111 - Timer enabled on Trigger rising or falling edge
 */
/*@{*/
#define BP_FLEXIO_TIMCFGn_TIMENA (8U)      /*!< Bit position for FLEXIO_TIMCFGn_TIMENA. */
#define BM_FLEXIO_TIMCFGn_TIMENA (0x00000700U) /*!< Bit mask for FLEXIO_TIMCFGn_TIMENA. */
#define BS_FLEXIO_TIMCFGn_TIMENA (3U)      /*!< Bit field size in bits for FLEXIO_TIMCFGn_TIMENA. */

/*! @brief Read current value of the FLEXIO_TIMCFGn_TIMENA field. */
#define BR_FLEXIO_TIMCFGn_TIMENA(x, n) (BME_UBFX32(HW_FLEXIO_TIMCFGn_ADDR(x, n), BP_FLEXIO_TIMCFGn_TIMENA, BS_FLEXIO_TIMCFGn_TIMENA))

/*! @brief Format value for bitfield FLEXIO_TIMCFGn_TIMENA. */
#define BF_FLEXIO_TIMCFGn_TIMENA(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_TIMCFGn_TIMENA) & BM_FLEXIO_TIMCFGn_TIMENA)

/*! @brief Set the TIMENA field to a new value. */
#define BW_FLEXIO_TIMCFGn_TIMENA(x, n, v) (BME_BFI32(HW_FLEXIO_TIMCFGn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_TIMCFGn_TIMENA), BP_FLEXIO_TIMCFGn_TIMENA, 3))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFGn, field TIMDIS[14:12] (RW)
 *
 * Configures the condition that causes the Timer to be disabled and stop
 * decrementing.
 *
 * Values:
 * - 000 - Timer never disabled
 * - 001 - Timer disabled on Timer N-1 disable
 * - 010 - Timer disabled on Timer compare
 * - 011 - Timer disabled on Timer compare and Trigger Low
 * - 100 - Timer disabled on Pin rising or falling edge
 * - 101 - Timer disabled on Pin rising or falling edge provided Trigger is high
 * - 110 - Timer disabled on Trigger falling edge
 * - 111 - Reserved
 */
/*@{*/
#define BP_FLEXIO_TIMCFGn_TIMDIS (12U)     /*!< Bit position for FLEXIO_TIMCFGn_TIMDIS. */
#define BM_FLEXIO_TIMCFGn_TIMDIS (0x00007000U) /*!< Bit mask for FLEXIO_TIMCFGn_TIMDIS. */
#define BS_FLEXIO_TIMCFGn_TIMDIS (3U)      /*!< Bit field size in bits for FLEXIO_TIMCFGn_TIMDIS. */

/*! @brief Read current value of the FLEXIO_TIMCFGn_TIMDIS field. */
#define BR_FLEXIO_TIMCFGn_TIMDIS(x, n) (BME_UBFX32(HW_FLEXIO_TIMCFGn_ADDR(x, n), BP_FLEXIO_TIMCFGn_TIMDIS, BS_FLEXIO_TIMCFGn_TIMDIS))

/*! @brief Format value for bitfield FLEXIO_TIMCFGn_TIMDIS. */
#define BF_FLEXIO_TIMCFGn_TIMDIS(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_TIMCFGn_TIMDIS) & BM_FLEXIO_TIMCFGn_TIMDIS)

/*! @brief Set the TIMDIS field to a new value. */
#define BW_FLEXIO_TIMCFGn_TIMDIS(x, n, v) (BME_BFI32(HW_FLEXIO_TIMCFGn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_TIMCFGn_TIMDIS), BP_FLEXIO_TIMCFGn_TIMDIS, 3))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFGn, field TIMRST[18:16] (RW)
 *
 * Configures the condition that causes the timer counter (and optionally the
 * timer output) to be reset. In 8-bit counter mode, the timer reset will only
 * reset the lower 8-bits that configure the baud rate. In all other modes, the timer
 * reset will reset the full 16-bits of the counter.
 *
 * Values:
 * - 000 - Timer never reset
 * - 001 - Reserved
 * - 010 - Timer reset on Timer Pin equal to Timer Output
 * - 011 - Timer reset on Timer Trigger equal to Timer Output
 * - 100 - Timer reset on Timer Pin rising edge
 * - 101 - Reserved
 * - 110 - Timer reset on Trigger rising edge
 * - 111 - Timer reset on Trigger rising or falling edge
 */
/*@{*/
#define BP_FLEXIO_TIMCFGn_TIMRST (16U)     /*!< Bit position for FLEXIO_TIMCFGn_TIMRST. */
#define BM_FLEXIO_TIMCFGn_TIMRST (0x00070000U) /*!< Bit mask for FLEXIO_TIMCFGn_TIMRST. */
#define BS_FLEXIO_TIMCFGn_TIMRST (3U)      /*!< Bit field size in bits for FLEXIO_TIMCFGn_TIMRST. */

/*! @brief Read current value of the FLEXIO_TIMCFGn_TIMRST field. */
#define BR_FLEXIO_TIMCFGn_TIMRST(x, n) (BME_UBFX32(HW_FLEXIO_TIMCFGn_ADDR(x, n), BP_FLEXIO_TIMCFGn_TIMRST, BS_FLEXIO_TIMCFGn_TIMRST))

/*! @brief Format value for bitfield FLEXIO_TIMCFGn_TIMRST. */
#define BF_FLEXIO_TIMCFGn_TIMRST(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_TIMCFGn_TIMRST) & BM_FLEXIO_TIMCFGn_TIMRST)

/*! @brief Set the TIMRST field to a new value. */
#define BW_FLEXIO_TIMCFGn_TIMRST(x, n, v) (BME_BFI32(HW_FLEXIO_TIMCFGn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_TIMCFGn_TIMRST), BP_FLEXIO_TIMCFGn_TIMRST, 3))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFGn, field TIMDEC[21:20] (RW)
 *
 * Configures the source of the Timer decrement and the source of the Shift
 * clock.
 *
 * Values:
 * - 00 - Decrement counter on FlexIO clock, Shift clock equals Timer output.
 * - 01 - Decrement counter on Trigger input (both edges), Shift clock equals
 *     Timer output.
 * - 10 - Decrement counter on Pin input (both edges), Shift clock equals Pin
 *     input.
 * - 11 - Decrement counter on Trigger input (both edges), Shift clock equals
 *     Trigger input.
 */
/*@{*/
#define BP_FLEXIO_TIMCFGn_TIMDEC (20U)     /*!< Bit position for FLEXIO_TIMCFGn_TIMDEC. */
#define BM_FLEXIO_TIMCFGn_TIMDEC (0x00300000U) /*!< Bit mask for FLEXIO_TIMCFGn_TIMDEC. */
#define BS_FLEXIO_TIMCFGn_TIMDEC (2U)      /*!< Bit field size in bits for FLEXIO_TIMCFGn_TIMDEC. */

/*! @brief Read current value of the FLEXIO_TIMCFGn_TIMDEC field. */
#define BR_FLEXIO_TIMCFGn_TIMDEC(x, n) (BME_UBFX32(HW_FLEXIO_TIMCFGn_ADDR(x, n), BP_FLEXIO_TIMCFGn_TIMDEC, BS_FLEXIO_TIMCFGn_TIMDEC))

/*! @brief Format value for bitfield FLEXIO_TIMCFGn_TIMDEC. */
#define BF_FLEXIO_TIMCFGn_TIMDEC(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_TIMCFGn_TIMDEC) & BM_FLEXIO_TIMCFGn_TIMDEC)

/*! @brief Set the TIMDEC field to a new value. */
#define BW_FLEXIO_TIMCFGn_TIMDEC(x, n, v) (BME_BFI32(HW_FLEXIO_TIMCFGn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_TIMCFGn_TIMDEC), BP_FLEXIO_TIMCFGn_TIMDEC, 2))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFGn, field TIMOUT[25:24] (RW)
 *
 * Configures the initial state of the Timer Output and whether it is affected
 * by the Timer reset.
 *
 * Values:
 * - 00 - Timer output is logic one when enabled and is not affected by timer
 *     reset
 * - 01 - Timer output is logic zero when enabled and is not affected by timer
 *     reset
 * - 10 - Timer output is logic one when enabled and on timer reset
 * - 11 - Timer output is logic zero when enabled and on timer reset
 */
/*@{*/
#define BP_FLEXIO_TIMCFGn_TIMOUT (24U)     /*!< Bit position for FLEXIO_TIMCFGn_TIMOUT. */
#define BM_FLEXIO_TIMCFGn_TIMOUT (0x03000000U) /*!< Bit mask for FLEXIO_TIMCFGn_TIMOUT. */
#define BS_FLEXIO_TIMCFGn_TIMOUT (2U)      /*!< Bit field size in bits for FLEXIO_TIMCFGn_TIMOUT. */

/*! @brief Read current value of the FLEXIO_TIMCFGn_TIMOUT field. */
#define BR_FLEXIO_TIMCFGn_TIMOUT(x, n) (BME_UBFX32(HW_FLEXIO_TIMCFGn_ADDR(x, n), BP_FLEXIO_TIMCFGn_TIMOUT, BS_FLEXIO_TIMCFGn_TIMOUT))

/*! @brief Format value for bitfield FLEXIO_TIMCFGn_TIMOUT. */
#define BF_FLEXIO_TIMCFGn_TIMOUT(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_TIMCFGn_TIMOUT) & BM_FLEXIO_TIMCFGn_TIMOUT)

/*! @brief Set the TIMOUT field to a new value. */
#define BW_FLEXIO_TIMCFGn_TIMOUT(x, n, v) (BME_BFI32(HW_FLEXIO_TIMCFGn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_TIMCFGn_TIMOUT), BP_FLEXIO_TIMCFGn_TIMOUT, 2))
/*@}*/

/*******************************************************************************
 * HW_FLEXIO_TIMCMPn - Timer Compare N Register
 ******************************************************************************/

/*!
 * @brief HW_FLEXIO_TIMCMPn - Timer Compare N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
typedef union _hw_flexio_timcmpn
{
    uint32_t U;
    struct _hw_flexio_timcmpn_bitfields
    {
        uint32_t CMP : 16;             /*!< [15:0] Timer Compare Value */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_flexio_timcmpn_t;

/*!
 * @name Constants and macros for entire FLEXIO_TIMCMPn register
 */
/*@{*/
#define HW_FLEXIO_TIMCMPn_COUNT (4U)

#define HW_FLEXIO_TIMCMPn_ADDR(x, n) ((uint32_t)(x) + 0x500U + (0x4U * (n)))

#define HW_FLEXIO_TIMCMPn(x, n)  (*(__IO hw_flexio_timcmpn_t *) HW_FLEXIO_TIMCMPn_ADDR(x, n))
#define HW_FLEXIO_TIMCMPn_RD(x, n) (HW_FLEXIO_TIMCMPn(x, n).U)
#define HW_FLEXIO_TIMCMPn_WR(x, n, v) (HW_FLEXIO_TIMCMPn(x, n).U = (v))
#define HW_FLEXIO_TIMCMPn_SET(x, n, v) (BME_OR32(HW_FLEXIO_TIMCMPn_ADDR(x, n), (uint32_t)(v)))
#define HW_FLEXIO_TIMCMPn_CLR(x, n, v) (BME_AND32(HW_FLEXIO_TIMCMPn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_FLEXIO_TIMCMPn_TOG(x, n, v) (BME_XOR32(HW_FLEXIO_TIMCMPn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_TIMCMPn bitfields
 */

/*!
 * @name Register FLEXIO_TIMCMPn, field CMP[15:0] (RW)
 *
 * The timer compare value is loaded into the timer counter when the timer is
 * first enabled, when the timer is reset and when the timer decrements down to
 * zero. In dual 8-bit counters baud/bit mode, the lower 8-bits configures the baud
 * rate divider equal to (CMP[7:0] + 1) * 2. The upper 8-bits configure the
 * number of bits in each word equal to (CMP[15:8] + 1) / 2. In dual 8-bit counters
 * PWM mode, the lower 8-bits configure the high period of the output to (CMP[7:0]
 * + 1) * 2. The upper 8-bits configure the low period of the output to
 * (CMP[15:8] + 1) * 2. In 16-bit counter mode, the compare value can be used to generate
 * the baud rate divider (if shift clock source is timer output) to equal
 * (CMP[15:0] + 1) * 2. When the shift clock source is a pin or trigger input, the
 * compare register is used to set the number of bits in each word equal to (CMP[15:0]
 * + 1) / 2.
 */
/*@{*/
#define BP_FLEXIO_TIMCMPn_CMP (0U)         /*!< Bit position for FLEXIO_TIMCMPn_CMP. */
#define BM_FLEXIO_TIMCMPn_CMP (0x0000FFFFU) /*!< Bit mask for FLEXIO_TIMCMPn_CMP. */
#define BS_FLEXIO_TIMCMPn_CMP (16U)        /*!< Bit field size in bits for FLEXIO_TIMCMPn_CMP. */

/*! @brief Read current value of the FLEXIO_TIMCMPn_CMP field. */
#define BR_FLEXIO_TIMCMPn_CMP(x, n) (BME_UBFX32(HW_FLEXIO_TIMCMPn_ADDR(x, n), BP_FLEXIO_TIMCMPn_CMP, BS_FLEXIO_TIMCMPn_CMP))

/*! @brief Format value for bitfield FLEXIO_TIMCMPn_CMP. */
#define BF_FLEXIO_TIMCMPn_CMP(v) ((uint32_t)((uint32_t)(v) << BP_FLEXIO_TIMCMPn_CMP) & BM_FLEXIO_TIMCMPn_CMP)

/*! @brief Set the CMP field to a new value. */
#define BW_FLEXIO_TIMCMPn_CMP(x, n, v) (BME_BFI32(HW_FLEXIO_TIMCMPn_ADDR(x, n), ((uint32_t)(v) << BP_FLEXIO_TIMCMPn_CMP), BP_FLEXIO_TIMCMPn_CMP, 16))
/*@}*/

/*******************************************************************************
 * hw_flexio_t - module struct
 ******************************************************************************/
/*!
 * @brief All FLEXIO module registers.
 */
#pragma pack(1)
typedef struct _hw_flexio
{
    __I hw_flexio_verid_t VERID;           /*!< [0x0] Version ID Register */
    __I hw_flexio_param_t PARAM;           /*!< [0x4] Parameter Register */
    __IO hw_flexio_ctrl_t CTRL;            /*!< [0x8] FlexIO Control Register */
    uint8_t _reserved0[4];
    __IO hw_flexio_shiftstat_t SHIFTSTAT;  /*!< [0x10] Shifter Status Register */
    __IO hw_flexio_shifterr_t SHIFTERR;    /*!< [0x14] Shifter Error Register */
    __IO hw_flexio_timstat_t TIMSTAT;      /*!< [0x18] Timer Status Register */
    uint8_t _reserved1[4];
    __IO hw_flexio_shiftsien_t SHIFTSIEN;  /*!< [0x20] Shifter Status Interrupt Enable */
    __IO hw_flexio_shifteien_t SHIFTEIEN;  /*!< [0x24] Shifter Error Interrupt Enable */
    __IO hw_flexio_timien_t TIMIEN;        /*!< [0x28] Timer Interrupt Enable Register */
    uint8_t _reserved2[4];
    __IO hw_flexio_shiftsden_t SHIFTSDEN;  /*!< [0x30] Shifter Status DMA Enable */
    uint8_t _reserved3[76];
    __IO hw_flexio_shiftctln_t SHIFTCTLn[4]; /*!< [0x80] Shifter Control N Register */
    uint8_t _reserved4[112];
    __IO hw_flexio_shiftcfgn_t SHIFTCFGn[4]; /*!< [0x100] Shifter Configuration N Register */
    uint8_t _reserved5[240];
    __IO hw_flexio_shiftbufn_t SHIFTBUFn[4]; /*!< [0x200] Shifter Buffer N Register */
    uint8_t _reserved6[112];
    __IO hw_flexio_shiftbufbbsn_t SHIFTBUFBBSn[4]; /*!< [0x280] Shifter Buffer N Bit Byte Swapped Register */
    uint8_t _reserved7[112];
    __IO hw_flexio_shiftbufbysn_t SHIFTBUFBYSn[4]; /*!< [0x300] Shifter Buffer N Byte Swapped Register */
    uint8_t _reserved8[112];
    __IO hw_flexio_shiftbufbisn_t SHIFTBUFBISn[4]; /*!< [0x380] Shifter Buffer N Bit Swapped Register */
    uint8_t _reserved9[112];
    __IO hw_flexio_timctln_t TIMCTLn[4];   /*!< [0x400] Timer Control N Register */
    uint8_t _reserved10[112];
    __IO hw_flexio_timcfgn_t TIMCFGn[4];   /*!< [0x480] Timer Configuration N Register */
    uint8_t _reserved11[112];
    __IO hw_flexio_timcmpn_t TIMCMPn[4];   /*!< [0x500] Timer Compare N Register */
} hw_flexio_t;
#pragma pack()

/*! @brief Macro to access all FLEXIO registers. */
/*! @param x FLEXIO module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_FLEXIO_REGS(FLEXIO_BASE)</code>. */
#define HW_FLEXIO_REGS(x) (*(hw_flexio_t *)(x))

/*
 * MKL43Z4 FTFA
 *
 * Flash Memory Interface
 *
 * Registers defined in this header file:
 * - HW_FTFA_FSTAT - Flash Status Register
 * - HW_FTFA_FCNFG - Flash Configuration Register
 * - HW_FTFA_FSEC - Flash Security Register
 * - HW_FTFA_FOPT - Flash Option Register
 * - HW_FTFA_FCCOB3 - Flash Common Command Object Registers
 * - HW_FTFA_FCCOB2 - Flash Common Command Object Registers
 * - HW_FTFA_FCCOB1 - Flash Common Command Object Registers
 * - HW_FTFA_FCCOB0 - Flash Common Command Object Registers
 * - HW_FTFA_FCCOB7 - Flash Common Command Object Registers
 * - HW_FTFA_FCCOB6 - Flash Common Command Object Registers
 * - HW_FTFA_FCCOB5 - Flash Common Command Object Registers
 * - HW_FTFA_FCCOB4 - Flash Common Command Object Registers
 * - HW_FTFA_FCCOBB - Flash Common Command Object Registers
 * - HW_FTFA_FCCOBA - Flash Common Command Object Registers
 * - HW_FTFA_FCCOB9 - Flash Common Command Object Registers
 * - HW_FTFA_FCCOB8 - Flash Common Command Object Registers
 * - HW_FTFA_FPROT3 - Program Flash Protection Registers
 * - HW_FTFA_FPROT2 - Program Flash Protection Registers
 * - HW_FTFA_FPROT1 - Program Flash Protection Registers
 * - HW_FTFA_FPROT0 - Program Flash Protection Registers
 *
 * - hw_ftfa_t - Struct containing all module registers.
 */

#define HW_FTFA_INSTANCE_COUNT (1U) /*!< Number of instances of the FTFA module. */
#define HW_FTFA (0U) /*!< Instance number for FTFA. */

/*******************************************************************************
 * HW_FTFA_FSTAT - Flash Status Register
 ******************************************************************************/

/*!
 * @brief HW_FTFA_FSTAT - Flash Status Register (RW)
 *
 * Reset value: 0x00U
 *
 * The FSTAT register reports the operational status of the flash memory module.
 * The CCIF, RDCOLERR, ACCERR, and FPVIOL bits are readable and writable. The
 * MGSTAT0 bit is read only. The unassigned bits read 0 and are not writable. When
 * set, the Access Error (ACCERR) and Flash Protection Violation (FPVIOL) bits in
 * this register prevent the launch of any more commands until the flag is
 * cleared (by writing a one to it).
 */
typedef union _hw_ftfa_fstat
{
    uint8_t U;
    struct _hw_ftfa_fstat_bitfields
    {
        uint8_t MGSTAT0 : 1;           /*!< [0] Memory Controller Command Completion
                                        * Status Flag */
        uint8_t RESERVED0 : 3;         /*!< [3:1]  */
        uint8_t FPVIOL : 1;            /*!< [4] Flash Protection Violation Flag */
        uint8_t ACCERR : 1;            /*!< [5] Flash Access Error Flag */
        uint8_t RDCOLERR : 1;          /*!< [6] Flash Read Collision Error Flag */
        uint8_t CCIF : 1;              /*!< [7] Command Complete Interrupt Flag */
    } B;
} hw_ftfa_fstat_t;

/*!
 * @name Constants and macros for entire FTFA_FSTAT register
 */
/*@{*/
#define HW_FTFA_FSTAT_ADDR(x)    ((uint32_t)(x) + 0x0U)

#define HW_FTFA_FSTAT(x)         (*(__IO hw_ftfa_fstat_t *) HW_FTFA_FSTAT_ADDR(x))
#define HW_FTFA_FSTAT_RD(x)      (HW_FTFA_FSTAT(x).U)
#define HW_FTFA_FSTAT_WR(x, v)   (HW_FTFA_FSTAT(x).U = (v))
#define HW_FTFA_FSTAT_SET(x, v)  (BME_OR8(HW_FTFA_FSTAT_ADDR(x), (uint8_t)(v)))
#define HW_FTFA_FSTAT_CLR(x, v)  (BME_AND8(HW_FTFA_FSTAT_ADDR(x), (uint8_t)(~(v))))
#define HW_FTFA_FSTAT_TOG(x, v)  (BME_XOR8(HW_FTFA_FSTAT_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FSTAT bitfields
 */

/*!
 * @name Register FTFA_FSTAT, field MGSTAT0[0] (RO)
 *
 * The MGSTAT0 status flag is set if an error is detected during execution of a
 * flash command or during the flash reset sequence. As a status flag, this field
 * cannot (and need not) be cleared by the user like the other error flags in
 * this register. The value of the MGSTAT0 bit for "command-N" is valid only at the
 * end of the "command-N" execution when CCIF=1 and before the next command has
 * been launched. At some point during the execution of "command-N+1," the
 * previous result is discarded and any previous error is cleared.
 */
/*@{*/
#define BP_FTFA_FSTAT_MGSTAT0 (0U)         /*!< Bit position for FTFA_FSTAT_MGSTAT0. */
#define BM_FTFA_FSTAT_MGSTAT0 (0x01U)      /*!< Bit mask for FTFA_FSTAT_MGSTAT0. */
#define BS_FTFA_FSTAT_MGSTAT0 (1U)         /*!< Bit field size in bits for FTFA_FSTAT_MGSTAT0. */

/*! @brief Read current value of the FTFA_FSTAT_MGSTAT0 field. */
#define BR_FTFA_FSTAT_MGSTAT0(x) (BME_UBFX8(HW_FTFA_FSTAT_ADDR(x), BP_FTFA_FSTAT_MGSTAT0, BS_FTFA_FSTAT_MGSTAT0))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field FPVIOL[4] (W1C)
 *
 * Indicates an attempt was made to program or erase an address in a protected
 * area of program flash memory during a command write sequence . While FPVIOL is
 * set, the CCIF flag cannot be cleared to launch a command. The FPVIOL bit is
 * cleared by writing a 1 to it. Writing a 0 to the FPVIOL bit has no effect.
 *
 * Values:
 * - 0 - No protection violation detected
 * - 1 - Protection violation detected
 */
/*@{*/
#define BP_FTFA_FSTAT_FPVIOL (4U)          /*!< Bit position for FTFA_FSTAT_FPVIOL. */
#define BM_FTFA_FSTAT_FPVIOL (0x10U)       /*!< Bit mask for FTFA_FSTAT_FPVIOL. */
#define BS_FTFA_FSTAT_FPVIOL (1U)          /*!< Bit field size in bits for FTFA_FSTAT_FPVIOL. */

/*! @brief Read current value of the FTFA_FSTAT_FPVIOL field. */
#define BR_FTFA_FSTAT_FPVIOL(x) (BME_UBFX8(HW_FTFA_FSTAT_ADDR(x), BP_FTFA_FSTAT_FPVIOL, BS_FTFA_FSTAT_FPVIOL))

/*! @brief Format value for bitfield FTFA_FSTAT_FPVIOL. */
#define BF_FTFA_FSTAT_FPVIOL(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FSTAT_FPVIOL) & BM_FTFA_FSTAT_FPVIOL)

/*! @brief Set the FPVIOL field to a new value. */
#define BW_FTFA_FSTAT_FPVIOL(x, v) (BME_BFI8(HW_FTFA_FSTAT_ADDR(x), ((uint8_t)(v) << BP_FTFA_FSTAT_FPVIOL), BP_FTFA_FSTAT_FPVIOL, 1))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field ACCERR[5] (W1C)
 *
 * Indicates an illegal access has occurred to a flash memory resource caused by
 * a violation of the command write sequence or issuing an illegal flash
 * command. While ACCERR is set, the CCIF flag cannot be cleared to launch a command.
 * The ACCERR bit is cleared by writing a 1 to it. Writing a 0 to the ACCERR bit
 * has no effect.
 *
 * Values:
 * - 0 - No access error detected
 * - 1 - Access error detected
 */
/*@{*/
#define BP_FTFA_FSTAT_ACCERR (5U)          /*!< Bit position for FTFA_FSTAT_ACCERR. */
#define BM_FTFA_FSTAT_ACCERR (0x20U)       /*!< Bit mask for FTFA_FSTAT_ACCERR. */
#define BS_FTFA_FSTAT_ACCERR (1U)          /*!< Bit field size in bits for FTFA_FSTAT_ACCERR. */

/*! @brief Read current value of the FTFA_FSTAT_ACCERR field. */
#define BR_FTFA_FSTAT_ACCERR(x) (BME_UBFX8(HW_FTFA_FSTAT_ADDR(x), BP_FTFA_FSTAT_ACCERR, BS_FTFA_FSTAT_ACCERR))

/*! @brief Format value for bitfield FTFA_FSTAT_ACCERR. */
#define BF_FTFA_FSTAT_ACCERR(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FSTAT_ACCERR) & BM_FTFA_FSTAT_ACCERR)

/*! @brief Set the ACCERR field to a new value. */
#define BW_FTFA_FSTAT_ACCERR(x, v) (BME_BFI8(HW_FTFA_FSTAT_ADDR(x), ((uint8_t)(v) << BP_FTFA_FSTAT_ACCERR), BP_FTFA_FSTAT_ACCERR, 1))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field RDCOLERR[6] (W1C)
 *
 * Indicates that the MCU attempted a read from a flash memory resource that was
 * being manipulated by a flash command (CCIF=0). Any simultaneous access is
 * detected as a collision error by the block arbitration logic. The read data in
 * this case cannot be guaranteed. The RDCOLERR bit is cleared by writing a 1 to
 * it. Writing a 0 to RDCOLERR has no effect.
 *
 * Values:
 * - 0 - No collision error detected
 * - 1 - Collision error detected
 */
/*@{*/
#define BP_FTFA_FSTAT_RDCOLERR (6U)        /*!< Bit position for FTFA_FSTAT_RDCOLERR. */
#define BM_FTFA_FSTAT_RDCOLERR (0x40U)     /*!< Bit mask for FTFA_FSTAT_RDCOLERR. */
#define BS_FTFA_FSTAT_RDCOLERR (1U)        /*!< Bit field size in bits for FTFA_FSTAT_RDCOLERR. */

/*! @brief Read current value of the FTFA_FSTAT_RDCOLERR field. */
#define BR_FTFA_FSTAT_RDCOLERR(x) (BME_UBFX8(HW_FTFA_FSTAT_ADDR(x), BP_FTFA_FSTAT_RDCOLERR, BS_FTFA_FSTAT_RDCOLERR))

/*! @brief Format value for bitfield FTFA_FSTAT_RDCOLERR. */
#define BF_FTFA_FSTAT_RDCOLERR(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FSTAT_RDCOLERR) & BM_FTFA_FSTAT_RDCOLERR)

/*! @brief Set the RDCOLERR field to a new value. */
#define BW_FTFA_FSTAT_RDCOLERR(x, v) (BME_BFI8(HW_FTFA_FSTAT_ADDR(x), ((uint8_t)(v) << BP_FTFA_FSTAT_RDCOLERR), BP_FTFA_FSTAT_RDCOLERR, 1))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field CCIF[7] (W1C)
 *
 * Indicates that a flash command has completed. The CCIF flag is cleared by
 * writing a 1 to CCIF to launch a command, and CCIF stays low until command
 * completion or command violation. CCIF is reset to 0 but is set to 1 by the memory
 * controller at the end of the reset initialization sequence. Depending on how
 * quickly the read occurs after reset release, the user may or may not see the 0
 * hardware reset value.
 *
 * Values:
 * - 0 - Flash command in progress
 * - 1 - Flash command has completed
 */
/*@{*/
#define BP_FTFA_FSTAT_CCIF   (7U)          /*!< Bit position for FTFA_FSTAT_CCIF. */
#define BM_FTFA_FSTAT_CCIF   (0x80U)       /*!< Bit mask for FTFA_FSTAT_CCIF. */
#define BS_FTFA_FSTAT_CCIF   (1U)          /*!< Bit field size in bits for FTFA_FSTAT_CCIF. */

/*! @brief Read current value of the FTFA_FSTAT_CCIF field. */
#define BR_FTFA_FSTAT_CCIF(x) (BME_UBFX8(HW_FTFA_FSTAT_ADDR(x), BP_FTFA_FSTAT_CCIF, BS_FTFA_FSTAT_CCIF))

/*! @brief Format value for bitfield FTFA_FSTAT_CCIF. */
#define BF_FTFA_FSTAT_CCIF(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FSTAT_CCIF) & BM_FTFA_FSTAT_CCIF)

/*! @brief Set the CCIF field to a new value. */
#define BW_FTFA_FSTAT_CCIF(x, v) (BME_BFI8(HW_FTFA_FSTAT_ADDR(x), ((uint8_t)(v) << BP_FTFA_FSTAT_CCIF), BP_FTFA_FSTAT_CCIF, 1))
/*@}*/

/*******************************************************************************
 * HW_FTFA_FCNFG - Flash Configuration Register
 ******************************************************************************/

/*!
 * @brief HW_FTFA_FCNFG - Flash Configuration Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides information on the current functional state of the
 * flash memory module. The erase control bits (ERSAREQ and ERSSUSP) have write
 * restrictions. The unassigned bits read as noted and are not writable.
 */
typedef union _hw_ftfa_fcnfg
{
    uint8_t U;
    struct _hw_ftfa_fcnfg_bitfields
    {
        uint8_t RESERVED0 : 4;         /*!< [3:0]  */
        uint8_t ERSSUSP : 1;           /*!< [4] Erase Suspend */
        uint8_t ERSAREQ : 1;           /*!< [5] Erase All Request */
        uint8_t RDCOLLIE : 1;          /*!< [6] Read Collision Error Interrupt Enable
                                        * */
        uint8_t CCIE : 1;              /*!< [7] Command Complete Interrupt Enable */
    } B;
} hw_ftfa_fcnfg_t;

/*!
 * @name Constants and macros for entire FTFA_FCNFG register
 */
/*@{*/
#define HW_FTFA_FCNFG_ADDR(x)    ((uint32_t)(x) + 0x1U)

#define HW_FTFA_FCNFG(x)         (*(__IO hw_ftfa_fcnfg_t *) HW_FTFA_FCNFG_ADDR(x))
#define HW_FTFA_FCNFG_RD(x)      (HW_FTFA_FCNFG(x).U)
#define HW_FTFA_FCNFG_WR(x, v)   (HW_FTFA_FCNFG(x).U = (v))
#define HW_FTFA_FCNFG_SET(x, v)  (BME_OR8(HW_FTFA_FCNFG_ADDR(x), (uint8_t)(v)))
#define HW_FTFA_FCNFG_CLR(x, v)  (BME_AND8(HW_FTFA_FCNFG_ADDR(x), (uint8_t)(~(v))))
#define HW_FTFA_FCNFG_TOG(x, v)  (BME_XOR8(HW_FTFA_FCNFG_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FCNFG bitfields
 */

/*!
 * @name Register FTFA_FCNFG, field ERSSUSP[4] (RW)
 *
 * Allows the user to suspend (interrupt) the Erase Flash Sector command while
 * it is executing.
 *
 * Values:
 * - 0 - No suspend requested
 * - 1 - Suspend the current Erase Flash Sector command execution.
 */
/*@{*/
#define BP_FTFA_FCNFG_ERSSUSP (4U)         /*!< Bit position for FTFA_FCNFG_ERSSUSP. */
#define BM_FTFA_FCNFG_ERSSUSP (0x10U)      /*!< Bit mask for FTFA_FCNFG_ERSSUSP. */
#define BS_FTFA_FCNFG_ERSSUSP (1U)         /*!< Bit field size in bits for FTFA_FCNFG_ERSSUSP. */

/*! @brief Read current value of the FTFA_FCNFG_ERSSUSP field. */
#define BR_FTFA_FCNFG_ERSSUSP(x) (BME_UBFX8(HW_FTFA_FCNFG_ADDR(x), BP_FTFA_FCNFG_ERSSUSP, BS_FTFA_FCNFG_ERSSUSP))

/*! @brief Format value for bitfield FTFA_FCNFG_ERSSUSP. */
#define BF_FTFA_FCNFG_ERSSUSP(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FCNFG_ERSSUSP) & BM_FTFA_FCNFG_ERSSUSP)

/*! @brief Set the ERSSUSP field to a new value. */
#define BW_FTFA_FCNFG_ERSSUSP(x, v) (BME_BFI8(HW_FTFA_FCNFG_ADDR(x), ((uint8_t)(v) << BP_FTFA_FCNFG_ERSSUSP), BP_FTFA_FCNFG_ERSSUSP, 1))
/*@}*/

/*!
 * @name Register FTFA_FCNFG, field ERSAREQ[5] (RO)
 *
 * Issues a request to the memory controller to execute the Erase All Blocks
 * command and release security. ERSAREQ is not directly writable but is under
 * indirect user control. Refer to the device's Chip Configuration details on how to
 * request this command. ERSAREQ sets when an erase all request is triggered
 * external to the flash memory module and CCIF is set (no command is currently being
 * executed). ERSAREQ is cleared by the flash memory module when the operation
 * completes.
 *
 * Values:
 * - 0 - No request or request complete
 * - 1 - Request to: run the Erase All Blocks command, verify the erased state,
 *     program the security byte in the Flash Configuration Field to the unsecure
 *     state, and release MCU security by setting the FSEC[SEC] field to the
 *     unsecure state.
 */
/*@{*/
#define BP_FTFA_FCNFG_ERSAREQ (5U)         /*!< Bit position for FTFA_FCNFG_ERSAREQ. */
#define BM_FTFA_FCNFG_ERSAREQ (0x20U)      /*!< Bit mask for FTFA_FCNFG_ERSAREQ. */
#define BS_FTFA_FCNFG_ERSAREQ (1U)         /*!< Bit field size in bits for FTFA_FCNFG_ERSAREQ. */

/*! @brief Read current value of the FTFA_FCNFG_ERSAREQ field. */
#define BR_FTFA_FCNFG_ERSAREQ(x) (BME_UBFX8(HW_FTFA_FCNFG_ADDR(x), BP_FTFA_FCNFG_ERSAREQ, BS_FTFA_FCNFG_ERSAREQ))
/*@}*/

/*!
 * @name Register FTFA_FCNFG, field RDCOLLIE[6] (RW)
 *
 * Controls interrupt generation when a flash memory read collision error occurs.
 *
 * Values:
 * - 0 - Read collision error interrupt disabled
 * - 1 - Read collision error interrupt enabled. An interrupt request is
 *     generated whenever a flash memory read collision error is detected (see the
 *     description of FSTAT[RDCOLERR]).
 */
/*@{*/
#define BP_FTFA_FCNFG_RDCOLLIE (6U)        /*!< Bit position for FTFA_FCNFG_RDCOLLIE. */
#define BM_FTFA_FCNFG_RDCOLLIE (0x40U)     /*!< Bit mask for FTFA_FCNFG_RDCOLLIE. */
#define BS_FTFA_FCNFG_RDCOLLIE (1U)        /*!< Bit field size in bits for FTFA_FCNFG_RDCOLLIE. */

/*! @brief Read current value of the FTFA_FCNFG_RDCOLLIE field. */
#define BR_FTFA_FCNFG_RDCOLLIE(x) (BME_UBFX8(HW_FTFA_FCNFG_ADDR(x), BP_FTFA_FCNFG_RDCOLLIE, BS_FTFA_FCNFG_RDCOLLIE))

/*! @brief Format value for bitfield FTFA_FCNFG_RDCOLLIE. */
#define BF_FTFA_FCNFG_RDCOLLIE(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FCNFG_RDCOLLIE) & BM_FTFA_FCNFG_RDCOLLIE)

/*! @brief Set the RDCOLLIE field to a new value. */
#define BW_FTFA_FCNFG_RDCOLLIE(x, v) (BME_BFI8(HW_FTFA_FCNFG_ADDR(x), ((uint8_t)(v) << BP_FTFA_FCNFG_RDCOLLIE), BP_FTFA_FCNFG_RDCOLLIE, 1))
/*@}*/

/*!
 * @name Register FTFA_FCNFG, field CCIE[7] (RW)
 *
 * Controls interrupt generation when a flash command completes.
 *
 * Values:
 * - 0 - Command complete interrupt disabled
 * - 1 - Command complete interrupt enabled. An interrupt request is generated
 *     whenever the FSTAT[CCIF] flag is set.
 */
/*@{*/
#define BP_FTFA_FCNFG_CCIE   (7U)          /*!< Bit position for FTFA_FCNFG_CCIE. */
#define BM_FTFA_FCNFG_CCIE   (0x80U)       /*!< Bit mask for FTFA_FCNFG_CCIE. */
#define BS_FTFA_FCNFG_CCIE   (1U)          /*!< Bit field size in bits for FTFA_FCNFG_CCIE. */

/*! @brief Read current value of the FTFA_FCNFG_CCIE field. */
#define BR_FTFA_FCNFG_CCIE(x) (BME_UBFX8(HW_FTFA_FCNFG_ADDR(x), BP_FTFA_FCNFG_CCIE, BS_FTFA_FCNFG_CCIE))

/*! @brief Format value for bitfield FTFA_FCNFG_CCIE. */
#define BF_FTFA_FCNFG_CCIE(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FCNFG_CCIE) & BM_FTFA_FCNFG_CCIE)

/*! @brief Set the CCIE field to a new value. */
#define BW_FTFA_FCNFG_CCIE(x, v) (BME_BFI8(HW_FTFA_FCNFG_ADDR(x), ((uint8_t)(v) << BP_FTFA_FCNFG_CCIE), BP_FTFA_FCNFG_CCIE, 1))
/*@}*/

/*******************************************************************************
 * HW_FTFA_FSEC - Flash Security Register
 ******************************************************************************/

/*!
 * @brief HW_FTFA_FSEC - Flash Security Register (RO)
 *
 * Reset value: 0x00U
 *
 * This read-only register holds all bits associated with the security of the
 * MCU and flash memory module. During the reset sequence, the register is loaded
 * with the contents of the flash security byte in the Flash Configuration Field
 * located in program flash memory. The flash basis for the values is signified by
 * X in the reset value.
 */
typedef union _hw_ftfa_fsec
{
    uint8_t U;
    struct _hw_ftfa_fsec_bitfields
    {
        uint8_t SEC : 2;               /*!< [1:0] Flash Security */
        uint8_t FSLACC : 2;            /*!< [3:2] Freescale Failure Analysis Access Code
                                        * */
        uint8_t MEEN : 2;              /*!< [5:4] Mass Erase Enable Bits */
        uint8_t KEYEN : 2;             /*!< [7:6] Backdoor Key Security Enable */
    } B;
} hw_ftfa_fsec_t;

/*!
 * @name Constants and macros for entire FTFA_FSEC register
 */
/*@{*/
#define HW_FTFA_FSEC_ADDR(x)     ((uint32_t)(x) + 0x2U)

#define HW_FTFA_FSEC(x)          (*(__I hw_ftfa_fsec_t *) HW_FTFA_FSEC_ADDR(x))
#define HW_FTFA_FSEC_RD(x)       (HW_FTFA_FSEC(x).U)
/*@}*/

/*
 * Constants & macros for individual FTFA_FSEC bitfields
 */

/*!
 * @name Register FTFA_FSEC, field SEC[1:0] (RO)
 *
 * Defines the security state of the MCU. In the secure state, the MCU limits
 * access to flash memory module resources. The limitations are defined per device
 * and are detailed in the Chip Configuration details. If the flash memory module
 * is unsecured using backdoor key access, SEC is forced to 10b.
 *
 * Values:
 * - 00 - MCU security status is secure.
 * - 01 - MCU security status is secure.
 * - 10 - MCU security status is unsecure. (The standard shipping condition of
 *     the flash memory module is unsecure.)
 * - 11 - MCU security status is secure.
 */
/*@{*/
#define BP_FTFA_FSEC_SEC     (0U)          /*!< Bit position for FTFA_FSEC_SEC. */
#define BM_FTFA_FSEC_SEC     (0x03U)       /*!< Bit mask for FTFA_FSEC_SEC. */
#define BS_FTFA_FSEC_SEC     (2U)          /*!< Bit field size in bits for FTFA_FSEC_SEC. */

/*! @brief Read current value of the FTFA_FSEC_SEC field. */
#define BR_FTFA_FSEC_SEC(x)  (BME_UBFX8(HW_FTFA_FSEC_ADDR(x), BP_FTFA_FSEC_SEC, BS_FTFA_FSEC_SEC))
/*@}*/

/*!
 * @name Register FTFA_FSEC, field FSLACC[3:2] (RO)
 *
 * Enables or disables access to the flash memory contents during returned part
 * failure analysis at Freescale. When SEC is secure and FSLACC is denied, access
 * to the program flash contents is denied and any failure analysis performed by
 * Freescale factory test must begin with a full erase to unsecure the part.
 * When access is granted (SEC is unsecure, or SEC is secure and FSLACC is granted),
 * Freescale factory testing has visibility of the current flash contents. The
 * state of the FSLACC bits is only relevant when SEC is set to secure. When SEC
 * is set to unsecure, the FSLACC setting does not matter.
 *
 * Values:
 * - 00 - Freescale factory access granted
 * - 01 - Freescale factory access denied
 * - 10 - Freescale factory access denied
 * - 11 - Freescale factory access granted
 */
/*@{*/
#define BP_FTFA_FSEC_FSLACC  (2U)          /*!< Bit position for FTFA_FSEC_FSLACC. */
#define BM_FTFA_FSEC_FSLACC  (0x0CU)       /*!< Bit mask for FTFA_FSEC_FSLACC. */
#define BS_FTFA_FSEC_FSLACC  (2U)          /*!< Bit field size in bits for FTFA_FSEC_FSLACC. */

/*! @brief Read current value of the FTFA_FSEC_FSLACC field. */
#define BR_FTFA_FSEC_FSLACC(x) (BME_UBFX8(HW_FTFA_FSEC_ADDR(x), BP_FTFA_FSEC_FSLACC, BS_FTFA_FSEC_FSLACC))
/*@}*/

/*!
 * @name Register FTFA_FSEC, field MEEN[5:4] (RO)
 *
 * Enables and disables mass erase capability of the flash memory module. The
 * state of this field is relevant only when SEC is set to secure outside of NVM
 * Normal Mode. When SEC is set to unsecure, the MEEN setting does not matter.
 *
 * Values:
 * - 00 - Mass erase is enabled
 * - 01 - Mass erase is enabled
 * - 10 - Mass erase is disabled
 * - 11 - Mass erase is enabled
 */
/*@{*/
#define BP_FTFA_FSEC_MEEN    (4U)          /*!< Bit position for FTFA_FSEC_MEEN. */
#define BM_FTFA_FSEC_MEEN    (0x30U)       /*!< Bit mask for FTFA_FSEC_MEEN. */
#define BS_FTFA_FSEC_MEEN    (2U)          /*!< Bit field size in bits for FTFA_FSEC_MEEN. */

/*! @brief Read current value of the FTFA_FSEC_MEEN field. */
#define BR_FTFA_FSEC_MEEN(x) (BME_UBFX8(HW_FTFA_FSEC_ADDR(x), BP_FTFA_FSEC_MEEN, BS_FTFA_FSEC_MEEN))
/*@}*/

/*!
 * @name Register FTFA_FSEC, field KEYEN[7:6] (RO)
 *
 * Enables or disables backdoor key access to the flash memory module.
 *
 * Values:
 * - 00 - Backdoor key access disabled
 * - 01 - Backdoor key access disabled (preferred KEYEN state to disable
 *     backdoor key access)
 * - 10 - Backdoor key access enabled
 * - 11 - Backdoor key access disabled
 */
/*@{*/
#define BP_FTFA_FSEC_KEYEN   (6U)          /*!< Bit position for FTFA_FSEC_KEYEN. */
#define BM_FTFA_FSEC_KEYEN   (0xC0U)       /*!< Bit mask for FTFA_FSEC_KEYEN. */
#define BS_FTFA_FSEC_KEYEN   (2U)          /*!< Bit field size in bits for FTFA_FSEC_KEYEN. */

/*! @brief Read current value of the FTFA_FSEC_KEYEN field. */
#define BR_FTFA_FSEC_KEYEN(x) (BME_UBFX8(HW_FTFA_FSEC_ADDR(x), BP_FTFA_FSEC_KEYEN, BS_FTFA_FSEC_KEYEN))
/*@}*/

/*******************************************************************************
 * HW_FTFA_FOPT - Flash Option Register
 ******************************************************************************/

/*!
 * @brief HW_FTFA_FOPT - Flash Option Register (RO)
 *
 * Reset value: 0x00U
 *
 * The flash option register allows the MCU to customize its operations by
 * examining the state of these read-only bits, which are loaded from NVM at reset.
 * The function of the bits is defined in the device's Chip Configuration details.
 * All bits in the register are read-only . During the reset sequence, the
 * register is loaded from the flash nonvolatile option byte in the Flash Configuration
 * Field located in program flash memory. The flash basis for the values is
 * signified by X in the reset value. However, the register is written to 0xFF if the
 * contents of the flash nonvolatile option byte are 0x00.
 */
typedef union _hw_ftfa_fopt
{
    uint8_t U;
    struct _hw_ftfa_fopt_bitfields
    {
        uint8_t OPT : 8;               /*!< [7:0] Nonvolatile Option */
    } B;
} hw_ftfa_fopt_t;

/*!
 * @name Constants and macros for entire FTFA_FOPT register
 */
/*@{*/
#define HW_FTFA_FOPT_ADDR(x)     ((uint32_t)(x) + 0x3U)

#define HW_FTFA_FOPT(x)          (*(__I hw_ftfa_fopt_t *) HW_FTFA_FOPT_ADDR(x))
#define HW_FTFA_FOPT_RD(x)       (HW_FTFA_FOPT(x).U)
/*@}*/

/*
 * Constants & macros for individual FTFA_FOPT bitfields
 */

/*!
 * @name Register FTFA_FOPT, field OPT[7:0] (RO)
 *
 * These bits are loaded from flash to this register at reset. Refer to the
 * device's Chip Configuration details for the definition and use of these bits.
 */
/*@{*/
#define BP_FTFA_FOPT_OPT     (0U)          /*!< Bit position for FTFA_FOPT_OPT. */
#define BM_FTFA_FOPT_OPT     (0xFFU)       /*!< Bit mask for FTFA_FOPT_OPT. */
#define BS_FTFA_FOPT_OPT     (8U)          /*!< Bit field size in bits for FTFA_FOPT_OPT. */

/*! @brief Read current value of the FTFA_FOPT_OPT field. */
#define BR_FTFA_FOPT_OPT(x)  (HW_FTFA_FOPT(x).U)
/*@}*/

/*******************************************************************************
 * HW_FTFA_FCCOB3 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFA_FCCOB3 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfa_fccob3
{
    uint8_t U;
    struct _hw_ftfa_fccob3_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfa_fccob3_t;

/*!
 * @name Constants and macros for entire FTFA_FCCOB3 register
 */
/*@{*/
#define HW_FTFA_FCCOB3_ADDR(x)   ((uint32_t)(x) + 0x4U)

#define HW_FTFA_FCCOB3(x)        (*(__IO hw_ftfa_fccob3_t *) HW_FTFA_FCCOB3_ADDR(x))
#define HW_FTFA_FCCOB3_RD(x)     (HW_FTFA_FCCOB3(x).U)
#define HW_FTFA_FCCOB3_WR(x, v)  (HW_FTFA_FCCOB3(x).U = (v))
#define HW_FTFA_FCCOB3_SET(x, v) (BME_OR8(HW_FTFA_FCCOB3_ADDR(x), (uint8_t)(v)))
#define HW_FTFA_FCCOB3_CLR(x, v) (BME_AND8(HW_FTFA_FCCOB3_ADDR(x), (uint8_t)(~(v))))
#define HW_FTFA_FCCOB3_TOG(x, v) (BME_XOR8(HW_FTFA_FCCOB3_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FCCOB3 bitfields
 */

/*!
 * @name Register FTFA_FCCOB3, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic flash command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific flash
 * command, typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register
 * address. FCCOB Number Typical Command Parameter Contents [7:0] 0 FCMD (a code that
 * defines the flash command) 1 Flash address [23:16] 2 Flash address [15:8] 3
 * Flash address [7:0] 4 Data Byte 0 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8
 * Data Byte 4 9 Data Byte 5 A Data Byte 6 B Data Byte 7 FCCOB Endianness and
 * Multi-Byte Access : The FCCOB register group uses a big endian addressing
 * convention. For all command parameter fields larger than 1 byte, the most significant
 * data resides in the lowest FCCOB register number. The FCCOB register group may
 * be read and written as individual bytes, aligned words (2 bytes) or aligned
 * longwords (4 bytes).
 */
/*@{*/
#define BP_FTFA_FCCOB3_CCOBn (0U)          /*!< Bit position for FTFA_FCCOB3_CCOBn. */
#define BM_FTFA_FCCOB3_CCOBn (0xFFU)       /*!< Bit mask for FTFA_FCCOB3_CCOBn. */
#define BS_FTFA_FCCOB3_CCOBn (8U)          /*!< Bit field size in bits for FTFA_FCCOB3_CCOBn. */

/*! @brief Read current value of the FTFA_FCCOB3_CCOBn field. */
#define BR_FTFA_FCCOB3_CCOBn(x) (HW_FTFA_FCCOB3(x).U)

/*! @brief Format value for bitfield FTFA_FCCOB3_CCOBn. */
#define BF_FTFA_FCCOB3_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FCCOB3_CCOBn) & BM_FTFA_FCCOB3_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFA_FCCOB3_CCOBn(x, v) (HW_FTFA_FCCOB3_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFA_FCCOB2 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFA_FCCOB2 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfa_fccob2
{
    uint8_t U;
    struct _hw_ftfa_fccob2_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfa_fccob2_t;

/*!
 * @name Constants and macros for entire FTFA_FCCOB2 register
 */
/*@{*/
#define HW_FTFA_FCCOB2_ADDR(x)   ((uint32_t)(x) + 0x5U)

#define HW_FTFA_FCCOB2(x)        (*(__IO hw_ftfa_fccob2_t *) HW_FTFA_FCCOB2_ADDR(x))
#define HW_FTFA_FCCOB2_RD(x)     (HW_FTFA_FCCOB2(x).U)
#define HW_FTFA_FCCOB2_WR(x, v)  (HW_FTFA_FCCOB2(x).U = (v))
#define HW_FTFA_FCCOB2_SET(x, v) (BME_OR8(HW_FTFA_FCCOB2_ADDR(x), (uint8_t)(v)))
#define HW_FTFA_FCCOB2_CLR(x, v) (BME_AND8(HW_FTFA_FCCOB2_ADDR(x), (uint8_t)(~(v))))
#define HW_FTFA_FCCOB2_TOG(x, v) (BME_XOR8(HW_FTFA_FCCOB2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FCCOB2 bitfields
 */

/*!
 * @name Register FTFA_FCCOB2, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic flash command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific flash
 * command, typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register
 * address. FCCOB Number Typical Command Parameter Contents [7:0] 0 FCMD (a code that
 * defines the flash command) 1 Flash address [23:16] 2 Flash address [15:8] 3
 * Flash address [7:0] 4 Data Byte 0 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8
 * Data Byte 4 9 Data Byte 5 A Data Byte 6 B Data Byte 7 FCCOB Endianness and
 * Multi-Byte Access : The FCCOB register group uses a big endian addressing
 * convention. For all command parameter fields larger than 1 byte, the most significant
 * data resides in the lowest FCCOB register number. The FCCOB register group may
 * be read and written as individual bytes, aligned words (2 bytes) or aligned
 * longwords (4 bytes).
 */
/*@{*/
#define BP_FTFA_FCCOB2_CCOBn (0U)          /*!< Bit position for FTFA_FCCOB2_CCOBn. */
#define BM_FTFA_FCCOB2_CCOBn (0xFFU)       /*!< Bit mask for FTFA_FCCOB2_CCOBn. */
#define BS_FTFA_FCCOB2_CCOBn (8U)          /*!< Bit field size in bits for FTFA_FCCOB2_CCOBn. */

/*! @brief Read current value of the FTFA_FCCOB2_CCOBn field. */
#define BR_FTFA_FCCOB2_CCOBn(x) (HW_FTFA_FCCOB2(x).U)

/*! @brief Format value for bitfield FTFA_FCCOB2_CCOBn. */
#define BF_FTFA_FCCOB2_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FCCOB2_CCOBn) & BM_FTFA_FCCOB2_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFA_FCCOB2_CCOBn(x, v) (HW_FTFA_FCCOB2_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFA_FCCOB1 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFA_FCCOB1 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfa_fccob1
{
    uint8_t U;
    struct _hw_ftfa_fccob1_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfa_fccob1_t;

/*!
 * @name Constants and macros for entire FTFA_FCCOB1 register
 */
/*@{*/
#define HW_FTFA_FCCOB1_ADDR(x)   ((uint32_t)(x) + 0x6U)

#define HW_FTFA_FCCOB1(x)        (*(__IO hw_ftfa_fccob1_t *) HW_FTFA_FCCOB1_ADDR(x))
#define HW_FTFA_FCCOB1_RD(x)     (HW_FTFA_FCCOB1(x).U)
#define HW_FTFA_FCCOB1_WR(x, v)  (HW_FTFA_FCCOB1(x).U = (v))
#define HW_FTFA_FCCOB1_SET(x, v) (BME_OR8(HW_FTFA_FCCOB1_ADDR(x), (uint8_t)(v)))
#define HW_FTFA_FCCOB1_CLR(x, v) (BME_AND8(HW_FTFA_FCCOB1_ADDR(x), (uint8_t)(~(v))))
#define HW_FTFA_FCCOB1_TOG(x, v) (BME_XOR8(HW_FTFA_FCCOB1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FCCOB1 bitfields
 */

/*!
 * @name Register FTFA_FCCOB1, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic flash command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific flash
 * command, typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register
 * address. FCCOB Number Typical Command Parameter Contents [7:0] 0 FCMD (a code that
 * defines the flash command) 1 Flash address [23:16] 2 Flash address [15:8] 3
 * Flash address [7:0] 4 Data Byte 0 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8
 * Data Byte 4 9 Data Byte 5 A Data Byte 6 B Data Byte 7 FCCOB Endianness and
 * Multi-Byte Access : The FCCOB register group uses a big endian addressing
 * convention. For all command parameter fields larger than 1 byte, the most significant
 * data resides in the lowest FCCOB register number. The FCCOB register group may
 * be read and written as individual bytes, aligned words (2 bytes) or aligned
 * longwords (4 bytes).
 */
/*@{*/
#define BP_FTFA_FCCOB1_CCOBn (0U)          /*!< Bit position for FTFA_FCCOB1_CCOBn. */
#define BM_FTFA_FCCOB1_CCOBn (0xFFU)       /*!< Bit mask for FTFA_FCCOB1_CCOBn. */
#define BS_FTFA_FCCOB1_CCOBn (8U)          /*!< Bit field size in bits for FTFA_FCCOB1_CCOBn. */

/*! @brief Read current value of the FTFA_FCCOB1_CCOBn field. */
#define BR_FTFA_FCCOB1_CCOBn(x) (HW_FTFA_FCCOB1(x).U)

/*! @brief Format value for bitfield FTFA_FCCOB1_CCOBn. */
#define BF_FTFA_FCCOB1_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FCCOB1_CCOBn) & BM_FTFA_FCCOB1_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFA_FCCOB1_CCOBn(x, v) (HW_FTFA_FCCOB1_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFA_FCCOB0 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFA_FCCOB0 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfa_fccob0
{
    uint8_t U;
    struct _hw_ftfa_fccob0_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfa_fccob0_t;

/*!
 * @name Constants and macros for entire FTFA_FCCOB0 register
 */
/*@{*/
#define HW_FTFA_FCCOB0_ADDR(x)   ((uint32_t)(x) + 0x7U)

#define HW_FTFA_FCCOB0(x)        (*(__IO hw_ftfa_fccob0_t *) HW_FTFA_FCCOB0_ADDR(x))
#define HW_FTFA_FCCOB0_RD(x)     (HW_FTFA_FCCOB0(x).U)
#define HW_FTFA_FCCOB0_WR(x, v)  (HW_FTFA_FCCOB0(x).U = (v))
#define HW_FTFA_FCCOB0_SET(x, v) (BME_OR8(HW_FTFA_FCCOB0_ADDR(x), (uint8_t)(v)))
#define HW_FTFA_FCCOB0_CLR(x, v) (BME_AND8(HW_FTFA_FCCOB0_ADDR(x), (uint8_t)(~(v))))
#define HW_FTFA_FCCOB0_TOG(x, v) (BME_XOR8(HW_FTFA_FCCOB0_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FCCOB0 bitfields
 */

/*!
 * @name Register FTFA_FCCOB0, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic flash command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific flash
 * command, typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register
 * address. FCCOB Number Typical Command Parameter Contents [7:0] 0 FCMD (a code that
 * defines the flash command) 1 Flash address [23:16] 2 Flash address [15:8] 3
 * Flash address [7:0] 4 Data Byte 0 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8
 * Data Byte 4 9 Data Byte 5 A Data Byte 6 B Data Byte 7 FCCOB Endianness and
 * Multi-Byte Access : The FCCOB register group uses a big endian addressing
 * convention. For all command parameter fields larger than 1 byte, the most significant
 * data resides in the lowest FCCOB register number. The FCCOB register group may
 * be read and written as individual bytes, aligned words (2 bytes) or aligned
 * longwords (4 bytes).
 */
/*@{*/
#define BP_FTFA_FCCOB0_CCOBn (0U)          /*!< Bit position for FTFA_FCCOB0_CCOBn. */
#define BM_FTFA_FCCOB0_CCOBn (0xFFU)       /*!< Bit mask for FTFA_FCCOB0_CCOBn. */
#define BS_FTFA_FCCOB0_CCOBn (8U)          /*!< Bit field size in bits for FTFA_FCCOB0_CCOBn. */

/*! @brief Read current value of the FTFA_FCCOB0_CCOBn field. */
#define BR_FTFA_FCCOB0_CCOBn(x) (HW_FTFA_FCCOB0(x).U)

/*! @brief Format value for bitfield FTFA_FCCOB0_CCOBn. */
#define BF_FTFA_FCCOB0_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FCCOB0_CCOBn) & BM_FTFA_FCCOB0_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFA_FCCOB0_CCOBn(x, v) (HW_FTFA_FCCOB0_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFA_FCCOB7 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFA_FCCOB7 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfa_fccob7
{
    uint8_t U;
    struct _hw_ftfa_fccob7_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfa_fccob7_t;

/*!
 * @name Constants and macros for entire FTFA_FCCOB7 register
 */
/*@{*/
#define HW_FTFA_FCCOB7_ADDR(x)   ((uint32_t)(x) + 0x8U)

#define HW_FTFA_FCCOB7(x)        (*(__IO hw_ftfa_fccob7_t *) HW_FTFA_FCCOB7_ADDR(x))
#define HW_FTFA_FCCOB7_RD(x)     (HW_FTFA_FCCOB7(x).U)
#define HW_FTFA_FCCOB7_WR(x, v)  (HW_FTFA_FCCOB7(x).U = (v))
#define HW_FTFA_FCCOB7_SET(x, v) (BME_OR8(HW_FTFA_FCCOB7_ADDR(x), (uint8_t)(v)))
#define HW_FTFA_FCCOB7_CLR(x, v) (BME_AND8(HW_FTFA_FCCOB7_ADDR(x), (uint8_t)(~(v))))
#define HW_FTFA_FCCOB7_TOG(x, v) (BME_XOR8(HW_FTFA_FCCOB7_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FCCOB7 bitfields
 */

/*!
 * @name Register FTFA_FCCOB7, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic flash command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific flash
 * command, typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register
 * address. FCCOB Number Typical Command Parameter Contents [7:0] 0 FCMD (a code that
 * defines the flash command) 1 Flash address [23:16] 2 Flash address [15:8] 3
 * Flash address [7:0] 4 Data Byte 0 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8
 * Data Byte 4 9 Data Byte 5 A Data Byte 6 B Data Byte 7 FCCOB Endianness and
 * Multi-Byte Access : The FCCOB register group uses a big endian addressing
 * convention. For all command parameter fields larger than 1 byte, the most significant
 * data resides in the lowest FCCOB register number. The FCCOB register group may
 * be read and written as individual bytes, aligned words (2 bytes) or aligned
 * longwords (4 bytes).
 */
/*@{*/
#define BP_FTFA_FCCOB7_CCOBn (0U)          /*!< Bit position for FTFA_FCCOB7_CCOBn. */
#define BM_FTFA_FCCOB7_CCOBn (0xFFU)       /*!< Bit mask for FTFA_FCCOB7_CCOBn. */
#define BS_FTFA_FCCOB7_CCOBn (8U)          /*!< Bit field size in bits for FTFA_FCCOB7_CCOBn. */

/*! @brief Read current value of the FTFA_FCCOB7_CCOBn field. */
#define BR_FTFA_FCCOB7_CCOBn(x) (HW_FTFA_FCCOB7(x).U)

/*! @brief Format value for bitfield FTFA_FCCOB7_CCOBn. */
#define BF_FTFA_FCCOB7_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FCCOB7_CCOBn) & BM_FTFA_FCCOB7_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFA_FCCOB7_CCOBn(x, v) (HW_FTFA_FCCOB7_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFA_FCCOB6 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFA_FCCOB6 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfa_fccob6
{
    uint8_t U;
    struct _hw_ftfa_fccob6_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfa_fccob6_t;

/*!
 * @name Constants and macros for entire FTFA_FCCOB6 register
 */
/*@{*/
#define HW_FTFA_FCCOB6_ADDR(x)   ((uint32_t)(x) + 0x9U)

#define HW_FTFA_FCCOB6(x)        (*(__IO hw_ftfa_fccob6_t *) HW_FTFA_FCCOB6_ADDR(x))
#define HW_FTFA_FCCOB6_RD(x)     (HW_FTFA_FCCOB6(x).U)
#define HW_FTFA_FCCOB6_WR(x, v)  (HW_FTFA_FCCOB6(x).U = (v))
#define HW_FTFA_FCCOB6_SET(x, v) (BME_OR8(HW_FTFA_FCCOB6_ADDR(x), (uint8_t)(v)))
#define HW_FTFA_FCCOB6_CLR(x, v) (BME_AND8(HW_FTFA_FCCOB6_ADDR(x), (uint8_t)(~(v))))
#define HW_FTFA_FCCOB6_TOG(x, v) (BME_XOR8(HW_FTFA_FCCOB6_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FCCOB6 bitfields
 */

/*!
 * @name Register FTFA_FCCOB6, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic flash command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific flash
 * command, typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register
 * address. FCCOB Number Typical Command Parameter Contents [7:0] 0 FCMD (a code that
 * defines the flash command) 1 Flash address [23:16] 2 Flash address [15:8] 3
 * Flash address [7:0] 4 Data Byte 0 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8
 * Data Byte 4 9 Data Byte 5 A Data Byte 6 B Data Byte 7 FCCOB Endianness and
 * Multi-Byte Access : The FCCOB register group uses a big endian addressing
 * convention. For all command parameter fields larger than 1 byte, the most significant
 * data resides in the lowest FCCOB register number. The FCCOB register group may
 * be read and written as individual bytes, aligned words (2 bytes) or aligned
 * longwords (4 bytes).
 */
/*@{*/
#define BP_FTFA_FCCOB6_CCOBn (0U)          /*!< Bit position for FTFA_FCCOB6_CCOBn. */
#define BM_FTFA_FCCOB6_CCOBn (0xFFU)       /*!< Bit mask for FTFA_FCCOB6_CCOBn. */
#define BS_FTFA_FCCOB6_CCOBn (8U)          /*!< Bit field size in bits for FTFA_FCCOB6_CCOBn. */

/*! @brief Read current value of the FTFA_FCCOB6_CCOBn field. */
#define BR_FTFA_FCCOB6_CCOBn(x) (HW_FTFA_FCCOB6(x).U)

/*! @brief Format value for bitfield FTFA_FCCOB6_CCOBn. */
#define BF_FTFA_FCCOB6_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FCCOB6_CCOBn) & BM_FTFA_FCCOB6_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFA_FCCOB6_CCOBn(x, v) (HW_FTFA_FCCOB6_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFA_FCCOB5 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFA_FCCOB5 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfa_fccob5
{
    uint8_t U;
    struct _hw_ftfa_fccob5_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfa_fccob5_t;

/*!
 * @name Constants and macros for entire FTFA_FCCOB5 register
 */
/*@{*/
#define HW_FTFA_FCCOB5_ADDR(x)   ((uint32_t)(x) + 0xAU)

#define HW_FTFA_FCCOB5(x)        (*(__IO hw_ftfa_fccob5_t *) HW_FTFA_FCCOB5_ADDR(x))
#define HW_FTFA_FCCOB5_RD(x)     (HW_FTFA_FCCOB5(x).U)
#define HW_FTFA_FCCOB5_WR(x, v)  (HW_FTFA_FCCOB5(x).U = (v))
#define HW_FTFA_FCCOB5_SET(x, v) (BME_OR8(HW_FTFA_FCCOB5_ADDR(x), (uint8_t)(v)))
#define HW_FTFA_FCCOB5_CLR(x, v) (BME_AND8(HW_FTFA_FCCOB5_ADDR(x), (uint8_t)(~(v))))
#define HW_FTFA_FCCOB5_TOG(x, v) (BME_XOR8(HW_FTFA_FCCOB5_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FCCOB5 bitfields
 */

/*!
 * @name Register FTFA_FCCOB5, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic flash command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific flash
 * command, typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register
 * address. FCCOB Number Typical Command Parameter Contents [7:0] 0 FCMD (a code that
 * defines the flash command) 1 Flash address [23:16] 2 Flash address [15:8] 3
 * Flash address [7:0] 4 Data Byte 0 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8
 * Data Byte 4 9 Data Byte 5 A Data Byte 6 B Data Byte 7 FCCOB Endianness and
 * Multi-Byte Access : The FCCOB register group uses a big endian addressing
 * convention. For all command parameter fields larger than 1 byte, the most significant
 * data resides in the lowest FCCOB register number. The FCCOB register group may
 * be read and written as individual bytes, aligned words (2 bytes) or aligned
 * longwords (4 bytes).
 */
/*@{*/
#define BP_FTFA_FCCOB5_CCOBn (0U)          /*!< Bit position for FTFA_FCCOB5_CCOBn. */
#define BM_FTFA_FCCOB5_CCOBn (0xFFU)       /*!< Bit mask for FTFA_FCCOB5_CCOBn. */
#define BS_FTFA_FCCOB5_CCOBn (8U)          /*!< Bit field size in bits for FTFA_FCCOB5_CCOBn. */

/*! @brief Read current value of the FTFA_FCCOB5_CCOBn field. */
#define BR_FTFA_FCCOB5_CCOBn(x) (HW_FTFA_FCCOB5(x).U)

/*! @brief Format value for bitfield FTFA_FCCOB5_CCOBn. */
#define BF_FTFA_FCCOB5_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FCCOB5_CCOBn) & BM_FTFA_FCCOB5_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFA_FCCOB5_CCOBn(x, v) (HW_FTFA_FCCOB5_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFA_FCCOB4 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFA_FCCOB4 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfa_fccob4
{
    uint8_t U;
    struct _hw_ftfa_fccob4_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfa_fccob4_t;

/*!
 * @name Constants and macros for entire FTFA_FCCOB4 register
 */
/*@{*/
#define HW_FTFA_FCCOB4_ADDR(x)   ((uint32_t)(x) + 0xBU)

#define HW_FTFA_FCCOB4(x)        (*(__IO hw_ftfa_fccob4_t *) HW_FTFA_FCCOB4_ADDR(x))
#define HW_FTFA_FCCOB4_RD(x)     (HW_FTFA_FCCOB4(x).U)
#define HW_FTFA_FCCOB4_WR(x, v)  (HW_FTFA_FCCOB4(x).U = (v))
#define HW_FTFA_FCCOB4_SET(x, v) (BME_OR8(HW_FTFA_FCCOB4_ADDR(x), (uint8_t)(v)))
#define HW_FTFA_FCCOB4_CLR(x, v) (BME_AND8(HW_FTFA_FCCOB4_ADDR(x), (uint8_t)(~(v))))
#define HW_FTFA_FCCOB4_TOG(x, v) (BME_XOR8(HW_FTFA_FCCOB4_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FCCOB4 bitfields
 */

/*!
 * @name Register FTFA_FCCOB4, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic flash command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific flash
 * command, typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register
 * address. FCCOB Number Typical Command Parameter Contents [7:0] 0 FCMD (a code that
 * defines the flash command) 1 Flash address [23:16] 2 Flash address [15:8] 3
 * Flash address [7:0] 4 Data Byte 0 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8
 * Data Byte 4 9 Data Byte 5 A Data Byte 6 B Data Byte 7 FCCOB Endianness and
 * Multi-Byte Access : The FCCOB register group uses a big endian addressing
 * convention. For all command parameter fields larger than 1 byte, the most significant
 * data resides in the lowest FCCOB register number. The FCCOB register group may
 * be read and written as individual bytes, aligned words (2 bytes) or aligned
 * longwords (4 bytes).
 */
/*@{*/
#define BP_FTFA_FCCOB4_CCOBn (0U)          /*!< Bit position for FTFA_FCCOB4_CCOBn. */
#define BM_FTFA_FCCOB4_CCOBn (0xFFU)       /*!< Bit mask for FTFA_FCCOB4_CCOBn. */
#define BS_FTFA_FCCOB4_CCOBn (8U)          /*!< Bit field size in bits for FTFA_FCCOB4_CCOBn. */

/*! @brief Read current value of the FTFA_FCCOB4_CCOBn field. */
#define BR_FTFA_FCCOB4_CCOBn(x) (HW_FTFA_FCCOB4(x).U)

/*! @brief Format value for bitfield FTFA_FCCOB4_CCOBn. */
#define BF_FTFA_FCCOB4_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FCCOB4_CCOBn) & BM_FTFA_FCCOB4_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFA_FCCOB4_CCOBn(x, v) (HW_FTFA_FCCOB4_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFA_FCCOBB - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFA_FCCOBB - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfa_fccobb
{
    uint8_t U;
    struct _hw_ftfa_fccobb_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfa_fccobb_t;

/*!
 * @name Constants and macros for entire FTFA_FCCOBB register
 */
/*@{*/
#define HW_FTFA_FCCOBB_ADDR(x)   ((uint32_t)(x) + 0xCU)

#define HW_FTFA_FCCOBB(x)        (*(__IO hw_ftfa_fccobb_t *) HW_FTFA_FCCOBB_ADDR(x))
#define HW_FTFA_FCCOBB_RD(x)     (HW_FTFA_FCCOBB(x).U)
#define HW_FTFA_FCCOBB_WR(x, v)  (HW_FTFA_FCCOBB(x).U = (v))
#define HW_FTFA_FCCOBB_SET(x, v) (BME_OR8(HW_FTFA_FCCOBB_ADDR(x), (uint8_t)(v)))
#define HW_FTFA_FCCOBB_CLR(x, v) (BME_AND8(HW_FTFA_FCCOBB_ADDR(x), (uint8_t)(~(v))))
#define HW_FTFA_FCCOBB_TOG(x, v) (BME_XOR8(HW_FTFA_FCCOBB_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FCCOBB bitfields
 */

/*!
 * @name Register FTFA_FCCOBB, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic flash command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific flash
 * command, typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register
 * address. FCCOB Number Typical Command Parameter Contents [7:0] 0 FCMD (a code that
 * defines the flash command) 1 Flash address [23:16] 2 Flash address [15:8] 3
 * Flash address [7:0] 4 Data Byte 0 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8
 * Data Byte 4 9 Data Byte 5 A Data Byte 6 B Data Byte 7 FCCOB Endianness and
 * Multi-Byte Access : The FCCOB register group uses a big endian addressing
 * convention. For all command parameter fields larger than 1 byte, the most significant
 * data resides in the lowest FCCOB register number. The FCCOB register group may
 * be read and written as individual bytes, aligned words (2 bytes) or aligned
 * longwords (4 bytes).
 */
/*@{*/
#define BP_FTFA_FCCOBB_CCOBn (0U)          /*!< Bit position for FTFA_FCCOBB_CCOBn. */
#define BM_FTFA_FCCOBB_CCOBn (0xFFU)       /*!< Bit mask for FTFA_FCCOBB_CCOBn. */
#define BS_FTFA_FCCOBB_CCOBn (8U)          /*!< Bit field size in bits for FTFA_FCCOBB_CCOBn. */

/*! @brief Read current value of the FTFA_FCCOBB_CCOBn field. */
#define BR_FTFA_FCCOBB_CCOBn(x) (HW_FTFA_FCCOBB(x).U)

/*! @brief Format value for bitfield FTFA_FCCOBB_CCOBn. */
#define BF_FTFA_FCCOBB_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FCCOBB_CCOBn) & BM_FTFA_FCCOBB_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFA_FCCOBB_CCOBn(x, v) (HW_FTFA_FCCOBB_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFA_FCCOBA - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFA_FCCOBA - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfa_fccoba
{
    uint8_t U;
    struct _hw_ftfa_fccoba_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfa_fccoba_t;

/*!
 * @name Constants and macros for entire FTFA_FCCOBA register
 */
/*@{*/
#define HW_FTFA_FCCOBA_ADDR(x)   ((uint32_t)(x) + 0xDU)

#define HW_FTFA_FCCOBA(x)        (*(__IO hw_ftfa_fccoba_t *) HW_FTFA_FCCOBA_ADDR(x))
#define HW_FTFA_FCCOBA_RD(x)     (HW_FTFA_FCCOBA(x).U)
#define HW_FTFA_FCCOBA_WR(x, v)  (HW_FTFA_FCCOBA(x).U = (v))
#define HW_FTFA_FCCOBA_SET(x, v) (BME_OR8(HW_FTFA_FCCOBA_ADDR(x), (uint8_t)(v)))
#define HW_FTFA_FCCOBA_CLR(x, v) (BME_AND8(HW_FTFA_FCCOBA_ADDR(x), (uint8_t)(~(v))))
#define HW_FTFA_FCCOBA_TOG(x, v) (BME_XOR8(HW_FTFA_FCCOBA_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FCCOBA bitfields
 */

/*!
 * @name Register FTFA_FCCOBA, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic flash command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific flash
 * command, typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register
 * address. FCCOB Number Typical Command Parameter Contents [7:0] 0 FCMD (a code that
 * defines the flash command) 1 Flash address [23:16] 2 Flash address [15:8] 3
 * Flash address [7:0] 4 Data Byte 0 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8
 * Data Byte 4 9 Data Byte 5 A Data Byte 6 B Data Byte 7 FCCOB Endianness and
 * Multi-Byte Access : The FCCOB register group uses a big endian addressing
 * convention. For all command parameter fields larger than 1 byte, the most significant
 * data resides in the lowest FCCOB register number. The FCCOB register group may
 * be read and written as individual bytes, aligned words (2 bytes) or aligned
 * longwords (4 bytes).
 */
/*@{*/
#define BP_FTFA_FCCOBA_CCOBn (0U)          /*!< Bit position for FTFA_FCCOBA_CCOBn. */
#define BM_FTFA_FCCOBA_CCOBn (0xFFU)       /*!< Bit mask for FTFA_FCCOBA_CCOBn. */
#define BS_FTFA_FCCOBA_CCOBn (8U)          /*!< Bit field size in bits for FTFA_FCCOBA_CCOBn. */

/*! @brief Read current value of the FTFA_FCCOBA_CCOBn field. */
#define BR_FTFA_FCCOBA_CCOBn(x) (HW_FTFA_FCCOBA(x).U)

/*! @brief Format value for bitfield FTFA_FCCOBA_CCOBn. */
#define BF_FTFA_FCCOBA_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FCCOBA_CCOBn) & BM_FTFA_FCCOBA_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFA_FCCOBA_CCOBn(x, v) (HW_FTFA_FCCOBA_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFA_FCCOB9 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFA_FCCOB9 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfa_fccob9
{
    uint8_t U;
    struct _hw_ftfa_fccob9_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfa_fccob9_t;

/*!
 * @name Constants and macros for entire FTFA_FCCOB9 register
 */
/*@{*/
#define HW_FTFA_FCCOB9_ADDR(x)   ((uint32_t)(x) + 0xEU)

#define HW_FTFA_FCCOB9(x)        (*(__IO hw_ftfa_fccob9_t *) HW_FTFA_FCCOB9_ADDR(x))
#define HW_FTFA_FCCOB9_RD(x)     (HW_FTFA_FCCOB9(x).U)
#define HW_FTFA_FCCOB9_WR(x, v)  (HW_FTFA_FCCOB9(x).U = (v))
#define HW_FTFA_FCCOB9_SET(x, v) (BME_OR8(HW_FTFA_FCCOB9_ADDR(x), (uint8_t)(v)))
#define HW_FTFA_FCCOB9_CLR(x, v) (BME_AND8(HW_FTFA_FCCOB9_ADDR(x), (uint8_t)(~(v))))
#define HW_FTFA_FCCOB9_TOG(x, v) (BME_XOR8(HW_FTFA_FCCOB9_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FCCOB9 bitfields
 */

/*!
 * @name Register FTFA_FCCOB9, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic flash command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific flash
 * command, typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register
 * address. FCCOB Number Typical Command Parameter Contents [7:0] 0 FCMD (a code that
 * defines the flash command) 1 Flash address [23:16] 2 Flash address [15:8] 3
 * Flash address [7:0] 4 Data Byte 0 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8
 * Data Byte 4 9 Data Byte 5 A Data Byte 6 B Data Byte 7 FCCOB Endianness and
 * Multi-Byte Access : The FCCOB register group uses a big endian addressing
 * convention. For all command parameter fields larger than 1 byte, the most significant
 * data resides in the lowest FCCOB register number. The FCCOB register group may
 * be read and written as individual bytes, aligned words (2 bytes) or aligned
 * longwords (4 bytes).
 */
/*@{*/
#define BP_FTFA_FCCOB9_CCOBn (0U)          /*!< Bit position for FTFA_FCCOB9_CCOBn. */
#define BM_FTFA_FCCOB9_CCOBn (0xFFU)       /*!< Bit mask for FTFA_FCCOB9_CCOBn. */
#define BS_FTFA_FCCOB9_CCOBn (8U)          /*!< Bit field size in bits for FTFA_FCCOB9_CCOBn. */

/*! @brief Read current value of the FTFA_FCCOB9_CCOBn field. */
#define BR_FTFA_FCCOB9_CCOBn(x) (HW_FTFA_FCCOB9(x).U)

/*! @brief Format value for bitfield FTFA_FCCOB9_CCOBn. */
#define BF_FTFA_FCCOB9_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FCCOB9_CCOBn) & BM_FTFA_FCCOB9_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFA_FCCOB9_CCOBn(x, v) (HW_FTFA_FCCOB9_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFA_FCCOB8 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFA_FCCOB8 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfa_fccob8
{
    uint8_t U;
    struct _hw_ftfa_fccob8_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfa_fccob8_t;

/*!
 * @name Constants and macros for entire FTFA_FCCOB8 register
 */
/*@{*/
#define HW_FTFA_FCCOB8_ADDR(x)   ((uint32_t)(x) + 0xFU)

#define HW_FTFA_FCCOB8(x)        (*(__IO hw_ftfa_fccob8_t *) HW_FTFA_FCCOB8_ADDR(x))
#define HW_FTFA_FCCOB8_RD(x)     (HW_FTFA_FCCOB8(x).U)
#define HW_FTFA_FCCOB8_WR(x, v)  (HW_FTFA_FCCOB8(x).U = (v))
#define HW_FTFA_FCCOB8_SET(x, v) (BME_OR8(HW_FTFA_FCCOB8_ADDR(x), (uint8_t)(v)))
#define HW_FTFA_FCCOB8_CLR(x, v) (BME_AND8(HW_FTFA_FCCOB8_ADDR(x), (uint8_t)(~(v))))
#define HW_FTFA_FCCOB8_TOG(x, v) (BME_XOR8(HW_FTFA_FCCOB8_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FCCOB8 bitfields
 */

/*!
 * @name Register FTFA_FCCOB8, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic flash command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific flash
 * command, typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register
 * address. FCCOB Number Typical Command Parameter Contents [7:0] 0 FCMD (a code that
 * defines the flash command) 1 Flash address [23:16] 2 Flash address [15:8] 3
 * Flash address [7:0] 4 Data Byte 0 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8
 * Data Byte 4 9 Data Byte 5 A Data Byte 6 B Data Byte 7 FCCOB Endianness and
 * Multi-Byte Access : The FCCOB register group uses a big endian addressing
 * convention. For all command parameter fields larger than 1 byte, the most significant
 * data resides in the lowest FCCOB register number. The FCCOB register group may
 * be read and written as individual bytes, aligned words (2 bytes) or aligned
 * longwords (4 bytes).
 */
/*@{*/
#define BP_FTFA_FCCOB8_CCOBn (0U)          /*!< Bit position for FTFA_FCCOB8_CCOBn. */
#define BM_FTFA_FCCOB8_CCOBn (0xFFU)       /*!< Bit mask for FTFA_FCCOB8_CCOBn. */
#define BS_FTFA_FCCOB8_CCOBn (8U)          /*!< Bit field size in bits for FTFA_FCCOB8_CCOBn. */

/*! @brief Read current value of the FTFA_FCCOB8_CCOBn field. */
#define BR_FTFA_FCCOB8_CCOBn(x) (HW_FTFA_FCCOB8(x).U)

/*! @brief Format value for bitfield FTFA_FCCOB8_CCOBn. */
#define BF_FTFA_FCCOB8_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FCCOB8_CCOBn) & BM_FTFA_FCCOB8_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFA_FCCOB8_CCOBn(x, v) (HW_FTFA_FCCOB8_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFA_FPROT3 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFA_FPROT3 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 32 KB of program flash where each assigned bit protects 1
 * KB . For configurations with 24 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 16 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 8 KB of program flash memory, FPROT2 is
 * not used. The bitfields are defined in each register as follows: Program
 * flash protection register Program flash protection bits FPROT0 PROT[31:24] FPROT1
 * PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset sequence, the
 * FPROT registers are loaded with the contents of the program flash protection
 * bytes in the Flash Configuration Field as indicated in the following table.
 * Program flash protection register Flash Configuration Field offset address FPROT0
 * 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program flash
 * protection that is loaded during the reset sequence, unprotect the sector of
 * program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
typedef union _hw_ftfa_fprot3
{
    uint8_t U;
    struct _hw_ftfa_fprot3_bitfields
    {
        uint8_t PROT : 8;              /*!< [7:0] Program Flash Region Protect */
    } B;
} hw_ftfa_fprot3_t;

/*!
 * @name Constants and macros for entire FTFA_FPROT3 register
 */
/*@{*/
#define HW_FTFA_FPROT3_ADDR(x)   ((uint32_t)(x) + 0x10U)

#define HW_FTFA_FPROT3(x)        (*(__IO hw_ftfa_fprot3_t *) HW_FTFA_FPROT3_ADDR(x))
#define HW_FTFA_FPROT3_RD(x)     (HW_FTFA_FPROT3(x).U)
#define HW_FTFA_FPROT3_WR(x, v)  (HW_FTFA_FPROT3(x).U = (v))
#define HW_FTFA_FPROT3_SET(x, v) (BME_OR8(HW_FTFA_FPROT3_ADDR(x), (uint8_t)(v)))
#define HW_FTFA_FPROT3_CLR(x, v) (BME_AND8(HW_FTFA_FPROT3_ADDR(x), (uint8_t)(~(v))))
#define HW_FTFA_FPROT3_TOG(x, v) (BME_XOR8(HW_FTFA_FPROT3_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FPROT3 bitfields
 */

/*!
 * @name Register FTFA_FPROT3, field PROT[7:0] (RW)
 *
 * Each program flash region can be protected from program and erase operations
 * by setting the associated PROT bit. In NVM Normal mode: The protection can
 * only be increased, meaning that currently unprotected memory can be protected,
 * but currently protected memory cannot be unprotected. Since unprotected regions
 * are marked with a 1 and protected regions use a 0, only writes changing 1s to
 * 0s are accepted. This 1-to-0 transition check is performed on a bit-by-bit
 * basis. Those FPROT bits with 1-to-0 transitions are accepted while all bits with
 * 0-to-1 transitions are ignored. In NVM Special mode: All bits of FPROT are
 * writable without restriction. Unprotected areas can be protected and protected
 * areas can be unprotected. The user must never write to any FPROT register while
 * a command is running (CCIF=0). Trying to alter data in any protected area in
 * the program flash memory results in a protection violation error and sets the
 * FSTAT[FPVIOL] bit. A full block erase of a program flash block is not possible
 * if it contains any protected region. Each bit in the 32-bit protection
 * register represents 1/32 of the total program flash except for configurations where
 * program flash memory is less than 32 KB. For configurations with less than 32
 * KB of program flash memory, each assigned bit represents 1 KB.
 *
 * Values:
 * - 0 - Program flash region is protected.
 * - 1 - Program flash region is not protected
 */
/*@{*/
#define BP_FTFA_FPROT3_PROT  (0U)          /*!< Bit position for FTFA_FPROT3_PROT. */
#define BM_FTFA_FPROT3_PROT  (0xFFU)       /*!< Bit mask for FTFA_FPROT3_PROT. */
#define BS_FTFA_FPROT3_PROT  (8U)          /*!< Bit field size in bits for FTFA_FPROT3_PROT. */

/*! @brief Read current value of the FTFA_FPROT3_PROT field. */
#define BR_FTFA_FPROT3_PROT(x) (HW_FTFA_FPROT3(x).U)

/*! @brief Format value for bitfield FTFA_FPROT3_PROT. */
#define BF_FTFA_FPROT3_PROT(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FPROT3_PROT) & BM_FTFA_FPROT3_PROT)

/*! @brief Set the PROT field to a new value. */
#define BW_FTFA_FPROT3_PROT(x, v) (HW_FTFA_FPROT3_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFA_FPROT2 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFA_FPROT2 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 32 KB of program flash where each assigned bit protects 1
 * KB . For configurations with 24 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 16 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 8 KB of program flash memory, FPROT2 is
 * not used. The bitfields are defined in each register as follows: Program
 * flash protection register Program flash protection bits FPROT0 PROT[31:24] FPROT1
 * PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset sequence, the
 * FPROT registers are loaded with the contents of the program flash protection
 * bytes in the Flash Configuration Field as indicated in the following table.
 * Program flash protection register Flash Configuration Field offset address FPROT0
 * 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program flash
 * protection that is loaded during the reset sequence, unprotect the sector of
 * program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
typedef union _hw_ftfa_fprot2
{
    uint8_t U;
    struct _hw_ftfa_fprot2_bitfields
    {
        uint8_t PROT : 8;              /*!< [7:0] Program Flash Region Protect */
    } B;
} hw_ftfa_fprot2_t;

/*!
 * @name Constants and macros for entire FTFA_FPROT2 register
 */
/*@{*/
#define HW_FTFA_FPROT2_ADDR(x)   ((uint32_t)(x) + 0x11U)

#define HW_FTFA_FPROT2(x)        (*(__IO hw_ftfa_fprot2_t *) HW_FTFA_FPROT2_ADDR(x))
#define HW_FTFA_FPROT2_RD(x)     (HW_FTFA_FPROT2(x).U)
#define HW_FTFA_FPROT2_WR(x, v)  (HW_FTFA_FPROT2(x).U = (v))
#define HW_FTFA_FPROT2_SET(x, v) (BME_OR8(HW_FTFA_FPROT2_ADDR(x), (uint8_t)(v)))
#define HW_FTFA_FPROT2_CLR(x, v) (BME_AND8(HW_FTFA_FPROT2_ADDR(x), (uint8_t)(~(v))))
#define HW_FTFA_FPROT2_TOG(x, v) (BME_XOR8(HW_FTFA_FPROT2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FPROT2 bitfields
 */

/*!
 * @name Register FTFA_FPROT2, field PROT[7:0] (RW)
 *
 * Each program flash region can be protected from program and erase operations
 * by setting the associated PROT bit. In NVM Normal mode: The protection can
 * only be increased, meaning that currently unprotected memory can be protected,
 * but currently protected memory cannot be unprotected. Since unprotected regions
 * are marked with a 1 and protected regions use a 0, only writes changing 1s to
 * 0s are accepted. This 1-to-0 transition check is performed on a bit-by-bit
 * basis. Those FPROT bits with 1-to-0 transitions are accepted while all bits with
 * 0-to-1 transitions are ignored. In NVM Special mode: All bits of FPROT are
 * writable without restriction. Unprotected areas can be protected and protected
 * areas can be unprotected. The user must never write to any FPROT register while
 * a command is running (CCIF=0). Trying to alter data in any protected area in
 * the program flash memory results in a protection violation error and sets the
 * FSTAT[FPVIOL] bit. A full block erase of a program flash block is not possible
 * if it contains any protected region. Each bit in the 32-bit protection
 * register represents 1/32 of the total program flash except for configurations where
 * program flash memory is less than 32 KB. For configurations with less than 32
 * KB of program flash memory, each assigned bit represents 1 KB.
 *
 * Values:
 * - 0 - Program flash region is protected.
 * - 1 - Program flash region is not protected
 */
/*@{*/
#define BP_FTFA_FPROT2_PROT  (0U)          /*!< Bit position for FTFA_FPROT2_PROT. */
#define BM_FTFA_FPROT2_PROT  (0xFFU)       /*!< Bit mask for FTFA_FPROT2_PROT. */
#define BS_FTFA_FPROT2_PROT  (8U)          /*!< Bit field size in bits for FTFA_FPROT2_PROT. */

/*! @brief Read current value of the FTFA_FPROT2_PROT field. */
#define BR_FTFA_FPROT2_PROT(x) (HW_FTFA_FPROT2(x).U)

/*! @brief Format value for bitfield FTFA_FPROT2_PROT. */
#define BF_FTFA_FPROT2_PROT(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FPROT2_PROT) & BM_FTFA_FPROT2_PROT)

/*! @brief Set the PROT field to a new value. */
#define BW_FTFA_FPROT2_PROT(x, v) (HW_FTFA_FPROT2_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFA_FPROT1 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFA_FPROT1 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 32 KB of program flash where each assigned bit protects 1
 * KB . For configurations with 24 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 16 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 8 KB of program flash memory, FPROT2 is
 * not used. The bitfields are defined in each register as follows: Program
 * flash protection register Program flash protection bits FPROT0 PROT[31:24] FPROT1
 * PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset sequence, the
 * FPROT registers are loaded with the contents of the program flash protection
 * bytes in the Flash Configuration Field as indicated in the following table.
 * Program flash protection register Flash Configuration Field offset address FPROT0
 * 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program flash
 * protection that is loaded during the reset sequence, unprotect the sector of
 * program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
typedef union _hw_ftfa_fprot1
{
    uint8_t U;
    struct _hw_ftfa_fprot1_bitfields
    {
        uint8_t PROT : 8;              /*!< [7:0] Program Flash Region Protect */
    } B;
} hw_ftfa_fprot1_t;

/*!
 * @name Constants and macros for entire FTFA_FPROT1 register
 */
/*@{*/
#define HW_FTFA_FPROT1_ADDR(x)   ((uint32_t)(x) + 0x12U)

#define HW_FTFA_FPROT1(x)        (*(__IO hw_ftfa_fprot1_t *) HW_FTFA_FPROT1_ADDR(x))
#define HW_FTFA_FPROT1_RD(x)     (HW_FTFA_FPROT1(x).U)
#define HW_FTFA_FPROT1_WR(x, v)  (HW_FTFA_FPROT1(x).U = (v))
#define HW_FTFA_FPROT1_SET(x, v) (BME_OR8(HW_FTFA_FPROT1_ADDR(x), (uint8_t)(v)))
#define HW_FTFA_FPROT1_CLR(x, v) (BME_AND8(HW_FTFA_FPROT1_ADDR(x), (uint8_t)(~(v))))
#define HW_FTFA_FPROT1_TOG(x, v) (BME_XOR8(HW_FTFA_FPROT1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FPROT1 bitfields
 */

/*!
 * @name Register FTFA_FPROT1, field PROT[7:0] (RW)
 *
 * Each program flash region can be protected from program and erase operations
 * by setting the associated PROT bit. In NVM Normal mode: The protection can
 * only be increased, meaning that currently unprotected memory can be protected,
 * but currently protected memory cannot be unprotected. Since unprotected regions
 * are marked with a 1 and protected regions use a 0, only writes changing 1s to
 * 0s are accepted. This 1-to-0 transition check is performed on a bit-by-bit
 * basis. Those FPROT bits with 1-to-0 transitions are accepted while all bits with
 * 0-to-1 transitions are ignored. In NVM Special mode: All bits of FPROT are
 * writable without restriction. Unprotected areas can be protected and protected
 * areas can be unprotected. The user must never write to any FPROT register while
 * a command is running (CCIF=0). Trying to alter data in any protected area in
 * the program flash memory results in a protection violation error and sets the
 * FSTAT[FPVIOL] bit. A full block erase of a program flash block is not possible
 * if it contains any protected region. Each bit in the 32-bit protection
 * register represents 1/32 of the total program flash except for configurations where
 * program flash memory is less than 32 KB. For configurations with less than 32
 * KB of program flash memory, each assigned bit represents 1 KB.
 *
 * Values:
 * - 0 - Program flash region is protected.
 * - 1 - Program flash region is not protected
 */
/*@{*/
#define BP_FTFA_FPROT1_PROT  (0U)          /*!< Bit position for FTFA_FPROT1_PROT. */
#define BM_FTFA_FPROT1_PROT  (0xFFU)       /*!< Bit mask for FTFA_FPROT1_PROT. */
#define BS_FTFA_FPROT1_PROT  (8U)          /*!< Bit field size in bits for FTFA_FPROT1_PROT. */

/*! @brief Read current value of the FTFA_FPROT1_PROT field. */
#define BR_FTFA_FPROT1_PROT(x) (HW_FTFA_FPROT1(x).U)

/*! @brief Format value for bitfield FTFA_FPROT1_PROT. */
#define BF_FTFA_FPROT1_PROT(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FPROT1_PROT) & BM_FTFA_FPROT1_PROT)

/*! @brief Set the PROT field to a new value. */
#define BW_FTFA_FPROT1_PROT(x, v) (HW_FTFA_FPROT1_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFA_FPROT0 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFA_FPROT0 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 32 KB of program flash where each assigned bit protects 1
 * KB . For configurations with 24 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 16 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 8 KB of program flash memory, FPROT2 is
 * not used. The bitfields are defined in each register as follows: Program
 * flash protection register Program flash protection bits FPROT0 PROT[31:24] FPROT1
 * PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset sequence, the
 * FPROT registers are loaded with the contents of the program flash protection
 * bytes in the Flash Configuration Field as indicated in the following table.
 * Program flash protection register Flash Configuration Field offset address FPROT0
 * 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program flash
 * protection that is loaded during the reset sequence, unprotect the sector of
 * program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
typedef union _hw_ftfa_fprot0
{
    uint8_t U;
    struct _hw_ftfa_fprot0_bitfields
    {
        uint8_t PROT : 8;              /*!< [7:0] Program Flash Region Protect */
    } B;
} hw_ftfa_fprot0_t;

/*!
 * @name Constants and macros for entire FTFA_FPROT0 register
 */
/*@{*/
#define HW_FTFA_FPROT0_ADDR(x)   ((uint32_t)(x) + 0x13U)

#define HW_FTFA_FPROT0(x)        (*(__IO hw_ftfa_fprot0_t *) HW_FTFA_FPROT0_ADDR(x))
#define HW_FTFA_FPROT0_RD(x)     (HW_FTFA_FPROT0(x).U)
#define HW_FTFA_FPROT0_WR(x, v)  (HW_FTFA_FPROT0(x).U = (v))
#define HW_FTFA_FPROT0_SET(x, v) (BME_OR8(HW_FTFA_FPROT0_ADDR(x), (uint8_t)(v)))
#define HW_FTFA_FPROT0_CLR(x, v) (BME_AND8(HW_FTFA_FPROT0_ADDR(x), (uint8_t)(~(v))))
#define HW_FTFA_FPROT0_TOG(x, v) (BME_XOR8(HW_FTFA_FPROT0_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FPROT0 bitfields
 */

/*!
 * @name Register FTFA_FPROT0, field PROT[7:0] (RW)
 *
 * Each program flash region can be protected from program and erase operations
 * by setting the associated PROT bit. In NVM Normal mode: The protection can
 * only be increased, meaning that currently unprotected memory can be protected,
 * but currently protected memory cannot be unprotected. Since unprotected regions
 * are marked with a 1 and protected regions use a 0, only writes changing 1s to
 * 0s are accepted. This 1-to-0 transition check is performed on a bit-by-bit
 * basis. Those FPROT bits with 1-to-0 transitions are accepted while all bits with
 * 0-to-1 transitions are ignored. In NVM Special mode: All bits of FPROT are
 * writable without restriction. Unprotected areas can be protected and protected
 * areas can be unprotected. The user must never write to any FPROT register while
 * a command is running (CCIF=0). Trying to alter data in any protected area in
 * the program flash memory results in a protection violation error and sets the
 * FSTAT[FPVIOL] bit. A full block erase of a program flash block is not possible
 * if it contains any protected region. Each bit in the 32-bit protection
 * register represents 1/32 of the total program flash except for configurations where
 * program flash memory is less than 32 KB. For configurations with less than 32
 * KB of program flash memory, each assigned bit represents 1 KB.
 *
 * Values:
 * - 0 - Program flash region is protected.
 * - 1 - Program flash region is not protected
 */
/*@{*/
#define BP_FTFA_FPROT0_PROT  (0U)          /*!< Bit position for FTFA_FPROT0_PROT. */
#define BM_FTFA_FPROT0_PROT  (0xFFU)       /*!< Bit mask for FTFA_FPROT0_PROT. */
#define BS_FTFA_FPROT0_PROT  (8U)          /*!< Bit field size in bits for FTFA_FPROT0_PROT. */

/*! @brief Read current value of the FTFA_FPROT0_PROT field. */
#define BR_FTFA_FPROT0_PROT(x) (HW_FTFA_FPROT0(x).U)

/*! @brief Format value for bitfield FTFA_FPROT0_PROT. */
#define BF_FTFA_FPROT0_PROT(v) ((uint8_t)((uint8_t)(v) << BP_FTFA_FPROT0_PROT) & BM_FTFA_FPROT0_PROT)

/*! @brief Set the PROT field to a new value. */
#define BW_FTFA_FPROT0_PROT(x, v) (HW_FTFA_FPROT0_WR(x, v))
/*@}*/

/*******************************************************************************
 * hw_ftfa_t - module struct
 ******************************************************************************/
/*!
 * @brief All FTFA module registers.
 */
#pragma pack(1)
typedef struct _hw_ftfa
{
    __IO hw_ftfa_fstat_t FSTAT;            /*!< [0x0] Flash Status Register */
    __IO hw_ftfa_fcnfg_t FCNFG;            /*!< [0x1] Flash Configuration Register */
    __I hw_ftfa_fsec_t FSEC;               /*!< [0x2] Flash Security Register */
    __I hw_ftfa_fopt_t FOPT;               /*!< [0x3] Flash Option Register */
    __IO hw_ftfa_fccob3_t FCCOB3;          /*!< [0x4] Flash Common Command Object Registers */
    __IO hw_ftfa_fccob2_t FCCOB2;          /*!< [0x5] Flash Common Command Object Registers */
    __IO hw_ftfa_fccob1_t FCCOB1;          /*!< [0x6] Flash Common Command Object Registers */
    __IO hw_ftfa_fccob0_t FCCOB0;          /*!< [0x7] Flash Common Command Object Registers */
    __IO hw_ftfa_fccob7_t FCCOB7;          /*!< [0x8] Flash Common Command Object Registers */
    __IO hw_ftfa_fccob6_t FCCOB6;          /*!< [0x9] Flash Common Command Object Registers */
    __IO hw_ftfa_fccob5_t FCCOB5;          /*!< [0xA] Flash Common Command Object Registers */
    __IO hw_ftfa_fccob4_t FCCOB4;          /*!< [0xB] Flash Common Command Object Registers */
    __IO hw_ftfa_fccobb_t FCCOBB;          /*!< [0xC] Flash Common Command Object Registers */
    __IO hw_ftfa_fccoba_t FCCOBA;          /*!< [0xD] Flash Common Command Object Registers */
    __IO hw_ftfa_fccob9_t FCCOB9;          /*!< [0xE] Flash Common Command Object Registers */
    __IO hw_ftfa_fccob8_t FCCOB8;          /*!< [0xF] Flash Common Command Object Registers */
    __IO hw_ftfa_fprot3_t FPROT3;          /*!< [0x10] Program Flash Protection Registers */
    __IO hw_ftfa_fprot2_t FPROT2;          /*!< [0x11] Program Flash Protection Registers */
    __IO hw_ftfa_fprot1_t FPROT1;          /*!< [0x12] Program Flash Protection Registers */
    __IO hw_ftfa_fprot0_t FPROT0;          /*!< [0x13] Program Flash Protection Registers */
} hw_ftfa_t;
#pragma pack()

/*! @brief Macro to access all FTFA registers. */
/*! @param x FTFA module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_FTFA_REGS(FTFA_BASE)</code>. */
#define HW_FTFA_REGS(x) (*(hw_ftfa_t *)(x))

/*
 * MKL43Z4 GPIO
 *
 * General Purpose Input/Output
 *
 * Registers defined in this header file:
 * - HW_GPIO_PDOR - Port Data Output Register
 * - HW_GPIO_PSOR - Port Set Output Register
 * - HW_GPIO_PCOR - Port Clear Output Register
 * - HW_GPIO_PTOR - Port Toggle Output Register
 * - HW_GPIO_PDIR - Port Data Input Register
 * - HW_GPIO_PDDR - Port Data Direction Register
 *
 * - hw_gpio_t - Struct containing all module registers.
 */

#define HW_GPIO_INSTANCE_COUNT (5U) /*!< Number of instances of the GPIO module. */
#define HW_GPIOA (0U) /*!< Instance number for GPIOA. */
#define HW_GPIOB (1U) /*!< Instance number for GPIOB. */
#define HW_GPIOC (2U) /*!< Instance number for GPIOC. */
#define HW_GPIOD (3U) /*!< Instance number for GPIOD. */
#define HW_GPIOE (4U) /*!< Instance number for GPIOE. */

/*******************************************************************************
 * HW_GPIO_PDOR - Port Data Output Register
 ******************************************************************************/

/*!
 * @brief HW_GPIO_PDOR - Port Data Output Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register configures the logic levels that are driven on each
 * general-purpose output pins. Do not modify pin configuration registers associated with
 * pins not available in your selected package. All unbonded pins not available in
 * your package will default to DISABLE state for lowest power consumption.
 */
typedef union _hw_gpio_pdor
{
    uint32_t U;
    struct _hw_gpio_pdor_bitfields
    {
        uint32_t PDO : 32;             /*!< [31:0] Port Data Output */
    } B;
} hw_gpio_pdor_t;

/*!
 * @name Constants and macros for entire GPIO_PDOR register
 */
/*@{*/
#define HW_GPIO_PDOR_ADDR(x)     ((uint32_t)(x) + 0x0U)

#define HW_GPIO_PDOR(x)          (*(__IO hw_gpio_pdor_t *) HW_GPIO_PDOR_ADDR(x))
#define HW_GPIO_PDOR_RD(x)       (HW_GPIO_PDOR(x).U)
#define HW_GPIO_PDOR_WR(x, v)    (HW_GPIO_PDOR(x).U = (v))
#define HW_GPIO_PDOR_SET(x, v)   (BME_OR32(HW_GPIO_PDOR_ADDR(x), (uint32_t)(v)))
#define HW_GPIO_PDOR_CLR(x, v)   (BME_AND32(HW_GPIO_PDOR_ADDR(x), (uint32_t)(~(v))))
#define HW_GPIO_PDOR_TOG(x, v)   (BME_XOR32(HW_GPIO_PDOR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual GPIO_PDOR bitfields
 */

/*!
 * @name Register GPIO_PDOR, field PDO[31:0] (RW)
 *
 * Register bits for unbonded pins return a undefined value when read.
 *
 * Values:
 * - 0 - Logic level 0 is driven on pin, provided pin is configured for
 *     general-purpose output.
 * - 1 - Logic level 1 is driven on pin, provided pin is configured for
 *     general-purpose output.
 */
/*@{*/
#define BP_GPIO_PDOR_PDO     (0U)          /*!< Bit position for GPIO_PDOR_PDO. */
#define BM_GPIO_PDOR_PDO     (0xFFFFFFFFU) /*!< Bit mask for GPIO_PDOR_PDO. */
#define BS_GPIO_PDOR_PDO     (32U)         /*!< Bit field size in bits for GPIO_PDOR_PDO. */

/*! @brief Read current value of the GPIO_PDOR_PDO field. */
#define BR_GPIO_PDOR_PDO(x)  (HW_GPIO_PDOR(x).U)

/*! @brief Format value for bitfield GPIO_PDOR_PDO. */
#define BF_GPIO_PDOR_PDO(v)  ((uint32_t)((uint32_t)(v) << BP_GPIO_PDOR_PDO) & BM_GPIO_PDOR_PDO)

/*! @brief Set the PDO field to a new value. */
#define BW_GPIO_PDOR_PDO(x, v) (HW_GPIO_PDOR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_GPIO_PSOR - Port Set Output Register
 ******************************************************************************/

/*!
 * @brief HW_GPIO_PSOR - Port Set Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to set the fields of the PDOR.
 */
typedef union _hw_gpio_psor
{
    uint32_t U;
    struct _hw_gpio_psor_bitfields
    {
        uint32_t PTSO : 32;            /*!< [31:0] Port Set Output */
    } B;
} hw_gpio_psor_t;

/*!
 * @name Constants and macros for entire GPIO_PSOR register
 */
/*@{*/
#define HW_GPIO_PSOR_ADDR(x)     ((uint32_t)(x) + 0x4U)

#define HW_GPIO_PSOR(x)          (*(__O hw_gpio_psor_t *) HW_GPIO_PSOR_ADDR(x))
#define HW_GPIO_PSOR_RD(x)       (HW_GPIO_PSOR(x).U)
#define HW_GPIO_PSOR_WR(x, v)    (HW_GPIO_PSOR(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual GPIO_PSOR bitfields
 */

/*!
 * @name Register GPIO_PSOR, field PTSO[31:0] (WORZ)
 *
 * Writing to this register will update the contents of the corresponding bit in
 * the PDOR as follows:
 *
 * Values:
 * - 0 - Corresponding bit in PDORn does not change.
 * - 1 - Corresponding bit in PDORn is set to logic 1.
 */
/*@{*/
#define BP_GPIO_PSOR_PTSO    (0U)          /*!< Bit position for GPIO_PSOR_PTSO. */
#define BM_GPIO_PSOR_PTSO    (0xFFFFFFFFU) /*!< Bit mask for GPIO_PSOR_PTSO. */
#define BS_GPIO_PSOR_PTSO    (32U)         /*!< Bit field size in bits for GPIO_PSOR_PTSO. */

/*! @brief Format value for bitfield GPIO_PSOR_PTSO. */
#define BF_GPIO_PSOR_PTSO(v) ((uint32_t)((uint32_t)(v) << BP_GPIO_PSOR_PTSO) & BM_GPIO_PSOR_PTSO)

/*! @brief Set the PTSO field to a new value. */
#define BW_GPIO_PSOR_PTSO(x, v) (HW_GPIO_PSOR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_GPIO_PCOR - Port Clear Output Register
 ******************************************************************************/

/*!
 * @brief HW_GPIO_PCOR - Port Clear Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to clear the fields of PDOR.
 */
typedef union _hw_gpio_pcor
{
    uint32_t U;
    struct _hw_gpio_pcor_bitfields
    {
        uint32_t PTCO : 32;            /*!< [31:0] Port Clear Output */
    } B;
} hw_gpio_pcor_t;

/*!
 * @name Constants and macros for entire GPIO_PCOR register
 */
/*@{*/
#define HW_GPIO_PCOR_ADDR(x)     ((uint32_t)(x) + 0x8U)

#define HW_GPIO_PCOR(x)          (*(__O hw_gpio_pcor_t *) HW_GPIO_PCOR_ADDR(x))
#define HW_GPIO_PCOR_RD(x)       (HW_GPIO_PCOR(x).U)
#define HW_GPIO_PCOR_WR(x, v)    (HW_GPIO_PCOR(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual GPIO_PCOR bitfields
 */

/*!
 * @name Register GPIO_PCOR, field PTCO[31:0] (WORZ)
 *
 * Writing to this register will update the contents of the corresponding bit in
 * the Port Data Output Register (PDOR) as follows:
 *
 * Values:
 * - 0 - Corresponding bit in PDORn does not change.
 * - 1 - Corresponding bit in PDORn is cleared to logic 0.
 */
/*@{*/
#define BP_GPIO_PCOR_PTCO    (0U)          /*!< Bit position for GPIO_PCOR_PTCO. */
#define BM_GPIO_PCOR_PTCO    (0xFFFFFFFFU) /*!< Bit mask for GPIO_PCOR_PTCO. */
#define BS_GPIO_PCOR_PTCO    (32U)         /*!< Bit field size in bits for GPIO_PCOR_PTCO. */

/*! @brief Format value for bitfield GPIO_PCOR_PTCO. */
#define BF_GPIO_PCOR_PTCO(v) ((uint32_t)((uint32_t)(v) << BP_GPIO_PCOR_PTCO) & BM_GPIO_PCOR_PTCO)

/*! @brief Set the PTCO field to a new value. */
#define BW_GPIO_PCOR_PTCO(x, v) (HW_GPIO_PCOR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_GPIO_PTOR - Port Toggle Output Register
 ******************************************************************************/

/*!
 * @brief HW_GPIO_PTOR - Port Toggle Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_gpio_ptor
{
    uint32_t U;
    struct _hw_gpio_ptor_bitfields
    {
        uint32_t PTTO : 32;            /*!< [31:0] Port Toggle Output */
    } B;
} hw_gpio_ptor_t;

/*!
 * @name Constants and macros for entire GPIO_PTOR register
 */
/*@{*/
#define HW_GPIO_PTOR_ADDR(x)     ((uint32_t)(x) + 0xCU)

#define HW_GPIO_PTOR(x)          (*(__O hw_gpio_ptor_t *) HW_GPIO_PTOR_ADDR(x))
#define HW_GPIO_PTOR_RD(x)       (HW_GPIO_PTOR(x).U)
#define HW_GPIO_PTOR_WR(x, v)    (HW_GPIO_PTOR(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual GPIO_PTOR bitfields
 */

/*!
 * @name Register GPIO_PTOR, field PTTO[31:0] (WORZ)
 *
 * Writing to this register will update the contents of the corresponding bit in
 * the PDOR as follows:
 *
 * Values:
 * - 0 - Corresponding bit in PDORn does not change.
 * - 1 - Corresponding bit in PDORn is set to the inverse of its existing logic
 *     state.
 */
/*@{*/
#define BP_GPIO_PTOR_PTTO    (0U)          /*!< Bit position for GPIO_PTOR_PTTO. */
#define BM_GPIO_PTOR_PTTO    (0xFFFFFFFFU) /*!< Bit mask for GPIO_PTOR_PTTO. */
#define BS_GPIO_PTOR_PTTO    (32U)         /*!< Bit field size in bits for GPIO_PTOR_PTTO. */

/*! @brief Format value for bitfield GPIO_PTOR_PTTO. */
#define BF_GPIO_PTOR_PTTO(v) ((uint32_t)((uint32_t)(v) << BP_GPIO_PTOR_PTTO) & BM_GPIO_PTOR_PTTO)

/*! @brief Set the PTTO field to a new value. */
#define BW_GPIO_PTOR_PTTO(x, v) (HW_GPIO_PTOR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_GPIO_PDIR - Port Data Input Register
 ******************************************************************************/

/*!
 * @brief HW_GPIO_PDIR - Port Data Input Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Do not modify pin configuration registers associated with pins not available
 * in your selected package. All unbonded pins not available in your package will
 * default to DISABLE state for lowest power consumption.
 */
typedef union _hw_gpio_pdir
{
    uint32_t U;
    struct _hw_gpio_pdir_bitfields
    {
        uint32_t PDI : 32;             /*!< [31:0] Port Data Input */
    } B;
} hw_gpio_pdir_t;

/*!
 * @name Constants and macros for entire GPIO_PDIR register
 */
/*@{*/
#define HW_GPIO_PDIR_ADDR(x)     ((uint32_t)(x) + 0x10U)

#define HW_GPIO_PDIR(x)          (*(__I hw_gpio_pdir_t *) HW_GPIO_PDIR_ADDR(x))
#define HW_GPIO_PDIR_RD(x)       (HW_GPIO_PDIR(x).U)
/*@}*/

/*
 * Constants & macros for individual GPIO_PDIR bitfields
 */

/*!
 * @name Register GPIO_PDIR, field PDI[31:0] (RO)
 *
 * Reads 0 at the unimplemented pins for a particular device. Pins that are not
 * configured for a digital function read 0. If the Port Control and Interrupt
 * module is disabled, then the corresponding bit in PDIR does not update.
 *
 * Values:
 * - 0 - Pin logic level is logic 0, or is not configured for use by digital
 *     function.
 * - 1 - Pin logic level is logic 1.
 */
/*@{*/
#define BP_GPIO_PDIR_PDI     (0U)          /*!< Bit position for GPIO_PDIR_PDI. */
#define BM_GPIO_PDIR_PDI     (0xFFFFFFFFU) /*!< Bit mask for GPIO_PDIR_PDI. */
#define BS_GPIO_PDIR_PDI     (32U)         /*!< Bit field size in bits for GPIO_PDIR_PDI. */

/*! @brief Read current value of the GPIO_PDIR_PDI field. */
#define BR_GPIO_PDIR_PDI(x)  (HW_GPIO_PDIR(x).U)
/*@}*/

/*******************************************************************************
 * HW_GPIO_PDDR - Port Data Direction Register
 ******************************************************************************/

/*!
 * @brief HW_GPIO_PDDR - Port Data Direction Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The PDDR configures the individual port pins for input or output.
 */
typedef union _hw_gpio_pddr
{
    uint32_t U;
    struct _hw_gpio_pddr_bitfields
    {
        uint32_t PDD : 32;             /*!< [31:0] Port Data Direction */
    } B;
} hw_gpio_pddr_t;

/*!
 * @name Constants and macros for entire GPIO_PDDR register
 */
/*@{*/
#define HW_GPIO_PDDR_ADDR(x)     ((uint32_t)(x) + 0x14U)

#define HW_GPIO_PDDR(x)          (*(__IO hw_gpio_pddr_t *) HW_GPIO_PDDR_ADDR(x))
#define HW_GPIO_PDDR_RD(x)       (HW_GPIO_PDDR(x).U)
#define HW_GPIO_PDDR_WR(x, v)    (HW_GPIO_PDDR(x).U = (v))
#define HW_GPIO_PDDR_SET(x, v)   (BME_OR32(HW_GPIO_PDDR_ADDR(x), (uint32_t)(v)))
#define HW_GPIO_PDDR_CLR(x, v)   (BME_AND32(HW_GPIO_PDDR_ADDR(x), (uint32_t)(~(v))))
#define HW_GPIO_PDDR_TOG(x, v)   (BME_XOR32(HW_GPIO_PDDR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual GPIO_PDDR bitfields
 */

/*!
 * @name Register GPIO_PDDR, field PDD[31:0] (RW)
 *
 * Configures individual port pins for input or output.
 *
 * Values:
 * - 0 - Pin is configured as general-purpose input, for the GPIO function.
 * - 1 - Pin is configured as general-purpose output, for the GPIO function.
 */
/*@{*/
#define BP_GPIO_PDDR_PDD     (0U)          /*!< Bit position for GPIO_PDDR_PDD. */
#define BM_GPIO_PDDR_PDD     (0xFFFFFFFFU) /*!< Bit mask for GPIO_PDDR_PDD. */
#define BS_GPIO_PDDR_PDD     (32U)         /*!< Bit field size in bits for GPIO_PDDR_PDD. */

/*! @brief Read current value of the GPIO_PDDR_PDD field. */
#define BR_GPIO_PDDR_PDD(x)  (HW_GPIO_PDDR(x).U)

/*! @brief Format value for bitfield GPIO_PDDR_PDD. */
#define BF_GPIO_PDDR_PDD(v)  ((uint32_t)((uint32_t)(v) << BP_GPIO_PDDR_PDD) & BM_GPIO_PDDR_PDD)

/*! @brief Set the PDD field to a new value. */
#define BW_GPIO_PDDR_PDD(x, v) (HW_GPIO_PDDR_WR(x, v))
/*@}*/

/*******************************************************************************
 * hw_gpio_t - module struct
 ******************************************************************************/
/*!
 * @brief All GPIO module registers.
 */
#pragma pack(1)
typedef struct _hw_gpio
{
    __IO hw_gpio_pdor_t PDOR;              /*!< [0x0] Port Data Output Register */
    __O hw_gpio_psor_t PSOR;               /*!< [0x4] Port Set Output Register */
    __O hw_gpio_pcor_t PCOR;               /*!< [0x8] Port Clear Output Register */
    __O hw_gpio_ptor_t PTOR;               /*!< [0xC] Port Toggle Output Register */
    __I hw_gpio_pdir_t PDIR;               /*!< [0x10] Port Data Input Register */
    __IO hw_gpio_pddr_t PDDR;              /*!< [0x14] Port Data Direction Register */
} hw_gpio_t;
#pragma pack()

/*! @brief Macro to access all GPIO registers. */
/*! @param x GPIO module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_GPIO_REGS(GPIOA_BASE)</code>. */
#define HW_GPIO_REGS(x) (*(hw_gpio_t *)(x))

/*
 * MKL43Z4 I2C
 *
 * Inter-Integrated Circuit
 *
 * Registers defined in this header file:
 * - HW_I2C_A1 - I2C Address Register 1
 * - HW_I2C_F - I2C Frequency Divider register
 * - HW_I2C_C1 - I2C Control Register 1
 * - HW_I2C_S - I2C Status register
 * - HW_I2C_D - I2C Data I/O register
 * - HW_I2C_C2 - I2C Control Register 2
 * - HW_I2C_FLT - I2C Programmable Input Glitch Filter Register
 * - HW_I2C_RA - I2C Range Address register
 * - HW_I2C_SMB - I2C SMBus Control and Status register
 * - HW_I2C_A2 - I2C Address Register 2
 * - HW_I2C_SLTH - I2C SCL Low Timeout Register High
 * - HW_I2C_SLTL - I2C SCL Low Timeout Register Low
 * - HW_I2C_S2 - I2C Status register 2
 *
 * - hw_i2c_t - Struct containing all module registers.
 */

#define HW_I2C_INSTANCE_COUNT (2U) /*!< Number of instances of the I2C module. */
#define HW_I2C0 (0U) /*!< Instance number for I2C0. */
#define HW_I2C1 (1U) /*!< Instance number for I2C1. */

/*******************************************************************************
 * HW_I2C_A1 - I2C Address Register 1
 ******************************************************************************/

/*!
 * @brief HW_I2C_A1 - I2C Address Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains the slave address to be used by the I2C module.
 */
typedef union _hw_i2c_a1
{
    uint8_t U;
    struct _hw_i2c_a1_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t AD : 7;                /*!< [7:1] Address */
    } B;
} hw_i2c_a1_t;

/*!
 * @name Constants and macros for entire I2C_A1 register
 */
/*@{*/
#define HW_I2C_A1_ADDR(x)        ((uint32_t)(x) + 0x0U)

#define HW_I2C_A1(x)             (*(__IO hw_i2c_a1_t *) HW_I2C_A1_ADDR(x))
#define HW_I2C_A1_RD(x)          (HW_I2C_A1(x).U)
#define HW_I2C_A1_WR(x, v)       (HW_I2C_A1(x).U = (v))
#define HW_I2C_A1_SET(x, v)      (BME_OR8(HW_I2C_A1_ADDR(x), (uint8_t)(v)))
#define HW_I2C_A1_CLR(x, v)      (BME_AND8(HW_I2C_A1_ADDR(x), (uint8_t)(~(v))))
#define HW_I2C_A1_TOG(x, v)      (BME_XOR8(HW_I2C_A1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2C_A1 bitfields
 */

/*!
 * @name Register I2C_A1, field AD[7:1] (RW)
 *
 * Contains the primary slave address used by the I2C module when it is
 * addressed as a slave. This field is used in the 7-bit address scheme and the lower
 * seven bits in the 10-bit address scheme.
 */
/*@{*/
#define BP_I2C_A1_AD         (1U)          /*!< Bit position for I2C_A1_AD. */
#define BM_I2C_A1_AD         (0xFEU)       /*!< Bit mask for I2C_A1_AD. */
#define BS_I2C_A1_AD         (7U)          /*!< Bit field size in bits for I2C_A1_AD. */

/*! @brief Read current value of the I2C_A1_AD field. */
#define BR_I2C_A1_AD(x)      (BME_UBFX8(HW_I2C_A1_ADDR(x), BP_I2C_A1_AD, BS_I2C_A1_AD))

/*! @brief Format value for bitfield I2C_A1_AD. */
#define BF_I2C_A1_AD(v)      ((uint8_t)((uint8_t)(v) << BP_I2C_A1_AD) & BM_I2C_A1_AD)

/*! @brief Set the AD field to a new value. */
#define BW_I2C_A1_AD(x, v)   (BME_BFI8(HW_I2C_A1_ADDR(x), ((uint8_t)(v) << BP_I2C_A1_AD), BP_I2C_A1_AD, 7))
/*@}*/

/*******************************************************************************
 * HW_I2C_F - I2C Frequency Divider register
 ******************************************************************************/

/*!
 * @brief HW_I2C_F - I2C Frequency Divider register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_f
{
    uint8_t U;
    struct _hw_i2c_f_bitfields
    {
        uint8_t ICR : 6;               /*!< [5:0] ClockRate */
        uint8_t MULT : 2;              /*!< [7:6] Multiplier Factor */
    } B;
} hw_i2c_f_t;

/*!
 * @name Constants and macros for entire I2C_F register
 */
/*@{*/
#define HW_I2C_F_ADDR(x)         ((uint32_t)(x) + 0x1U)

#define HW_I2C_F(x)              (*(__IO hw_i2c_f_t *) HW_I2C_F_ADDR(x))
#define HW_I2C_F_RD(x)           (HW_I2C_F(x).U)
#define HW_I2C_F_WR(x, v)        (HW_I2C_F(x).U = (v))
#define HW_I2C_F_SET(x, v)       (BME_OR8(HW_I2C_F_ADDR(x), (uint8_t)(v)))
#define HW_I2C_F_CLR(x, v)       (BME_AND8(HW_I2C_F_ADDR(x), (uint8_t)(~(v))))
#define HW_I2C_F_TOG(x, v)       (BME_XOR8(HW_I2C_F_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2C_F bitfields
 */

/*!
 * @name Register I2C_F, field ICR[5:0] (RW)
 *
 * Prescales the I2C module clock for bit rate selection. This field and the
 * MULT field determine the I2C baud rate, the SDA hold time, the SCL start hold
 * time, and the SCL stop hold time. For a list of values corresponding to each ICR
 * setting, see I2C divider and hold values. The SCL divider multiplied by
 * multiplier factor (mul) determines the I2C baud rate. I2C baud rate = I2C module
 * clock speed (Hz)/(mul * SCL divider) The SDA hold time is the delay from the
 * falling edge of SCL (I2C clock) to the changing of SDA (I2C data). SDA hold time =
 * I2C module clock period (s) * mul * SDA hold value The SCL start hold time is
 * the delay from the falling edge of SDA (I2C data) while SCL is high (start
 * condition) to the falling edge of SCL (I2C clock). SCL start hold time = I2C
 * module clock period (s) * mul * SCL start hold value The SCL stop hold time is
 * the delay from the rising edge of SCL (I2C clock) to the rising edge of SDA (I2C
 * data) while SCL is high (stop condition). SCL stop hold time = I2C module
 * clock period (s) * mul * SCL stop hold value For example, if the I2C module clock
 * speed is 8 MHz, the following table shows the possible hold time values with
 * different ICR and MULT selections to achieve an I2C baud rate of 100 kbit/s.
 * MULT ICR Hold times (us) SDA SCL Start SCL Stop 2h 00h 3.500 3.000 5.500 1h 07h
 * 2.500 4.000 5.250 1h 0Bh 2.250 4.000 5.250 0h 14h 2.125 4.250 5.125 0h 18h
 * 1.125 4.750 5.125
 */
/*@{*/
#define BP_I2C_F_ICR         (0U)          /*!< Bit position for I2C_F_ICR. */
#define BM_I2C_F_ICR         (0x3FU)       /*!< Bit mask for I2C_F_ICR. */
#define BS_I2C_F_ICR         (6U)          /*!< Bit field size in bits for I2C_F_ICR. */

/*! @brief Read current value of the I2C_F_ICR field. */
#define BR_I2C_F_ICR(x)      (BME_UBFX8(HW_I2C_F_ADDR(x), BP_I2C_F_ICR, BS_I2C_F_ICR))

/*! @brief Format value for bitfield I2C_F_ICR. */
#define BF_I2C_F_ICR(v)      ((uint8_t)((uint8_t)(v) << BP_I2C_F_ICR) & BM_I2C_F_ICR)

/*! @brief Set the ICR field to a new value. */
#define BW_I2C_F_ICR(x, v)   (BME_BFI8(HW_I2C_F_ADDR(x), ((uint8_t)(v) << BP_I2C_F_ICR), BP_I2C_F_ICR, 6))
/*@}*/

/*!
 * @name Register I2C_F, field MULT[7:6] (RW)
 *
 * Defines the multiplier factor (mul). This factor is used along with the SCL
 * divider to generate the I2C baud rate.
 *
 * Values:
 * - 00 - mul = 1
 * - 01 - mul = 2
 * - 10 - mul = 4
 * - 11 - Reserved
 */
/*@{*/
#define BP_I2C_F_MULT        (6U)          /*!< Bit position for I2C_F_MULT. */
#define BM_I2C_F_MULT        (0xC0U)       /*!< Bit mask for I2C_F_MULT. */
#define BS_I2C_F_MULT        (2U)          /*!< Bit field size in bits for I2C_F_MULT. */

/*! @brief Read current value of the I2C_F_MULT field. */
#define BR_I2C_F_MULT(x)     (BME_UBFX8(HW_I2C_F_ADDR(x), BP_I2C_F_MULT, BS_I2C_F_MULT))

/*! @brief Format value for bitfield I2C_F_MULT. */
#define BF_I2C_F_MULT(v)     ((uint8_t)((uint8_t)(v) << BP_I2C_F_MULT) & BM_I2C_F_MULT)

/*! @brief Set the MULT field to a new value. */
#define BW_I2C_F_MULT(x, v)  (BME_BFI8(HW_I2C_F_ADDR(x), ((uint8_t)(v) << BP_I2C_F_MULT), BP_I2C_F_MULT, 2))
/*@}*/

/*******************************************************************************
 * HW_I2C_C1 - I2C Control Register 1
 ******************************************************************************/

/*!
 * @brief HW_I2C_C1 - I2C Control Register 1 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_c1
{
    uint8_t U;
    struct _hw_i2c_c1_bitfields
    {
        uint8_t DMAEN : 1;             /*!< [0] DMA Enable */
        uint8_t WUEN : 1;              /*!< [1] Wakeup Enable */
        uint8_t RSTA : 1;              /*!< [2] Repeat START */
        uint8_t TXAK : 1;              /*!< [3] Transmit Acknowledge Enable */
        uint8_t TX : 1;                /*!< [4] Transmit Mode Select */
        uint8_t MST : 1;               /*!< [5] Master Mode Select */
        uint8_t IICIE : 1;             /*!< [6] I2C Interrupt Enable */
        uint8_t IICEN : 1;             /*!< [7] I2C Enable */
    } B;
} hw_i2c_c1_t;

/*!
 * @name Constants and macros for entire I2C_C1 register
 */
/*@{*/
#define HW_I2C_C1_ADDR(x)        ((uint32_t)(x) + 0x2U)

#define HW_I2C_C1(x)             (*(__IO hw_i2c_c1_t *) HW_I2C_C1_ADDR(x))
#define HW_I2C_C1_RD(x)          (HW_I2C_C1(x).U)
#define HW_I2C_C1_WR(x, v)       (HW_I2C_C1(x).U = (v))
#define HW_I2C_C1_SET(x, v)      (BME_OR8(HW_I2C_C1_ADDR(x), (uint8_t)(v)))
#define HW_I2C_C1_CLR(x, v)      (BME_AND8(HW_I2C_C1_ADDR(x), (uint8_t)(~(v))))
#define HW_I2C_C1_TOG(x, v)      (BME_XOR8(HW_I2C_C1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2C_C1 bitfields
 */

/*!
 * @name Register I2C_C1, field DMAEN[0] (RW)
 *
 * Enables or disables the DMA function.
 *
 * Values:
 * - 0 - All DMA signalling disabled.
 * - 1 - DMA transfer is enabled. While SMB[FACK] = 0, the following conditions
 *     trigger the DMA request: a data byte is received, and either address or
 *     data is transmitted. (ACK/NACK is automatic) the first byte received matches
 *     the A1 register or is a general call address. If any address matching
 *     occurs, S[IAAS] and S[TCF] are set. If the direction of transfer is known
 *     from master to slave, then it is not required to check S[SRW]. With this
 *     assumption, DMA can also be used in this case. In other cases, if the master
 *     reads data from the slave, then it is required to rewrite the C1 register
 *     operation. With this assumption, DMA cannot be used. When FACK = 1, an
 *     address or a data byte is transmitted.
 */
/*@{*/
#define BP_I2C_C1_DMAEN      (0U)          /*!< Bit position for I2C_C1_DMAEN. */
#define BM_I2C_C1_DMAEN      (0x01U)       /*!< Bit mask for I2C_C1_DMAEN. */
#define BS_I2C_C1_DMAEN      (1U)          /*!< Bit field size in bits for I2C_C1_DMAEN. */

/*! @brief Read current value of the I2C_C1_DMAEN field. */
#define BR_I2C_C1_DMAEN(x)   (BME_UBFX8(HW_I2C_C1_ADDR(x), BP_I2C_C1_DMAEN, BS_I2C_C1_DMAEN))

/*! @brief Format value for bitfield I2C_C1_DMAEN. */
#define BF_I2C_C1_DMAEN(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_C1_DMAEN) & BM_I2C_C1_DMAEN)

/*! @brief Set the DMAEN field to a new value. */
#define BW_I2C_C1_DMAEN(x, v) (BME_BFI8(HW_I2C_C1_ADDR(x), ((uint8_t)(v) << BP_I2C_C1_DMAEN), BP_I2C_C1_DMAEN, 1))
/*@}*/

/*!
 * @name Register I2C_C1, field WUEN[1] (RW)
 *
 * The I2C module can wake the MCU from low power mode with no peripheral bus
 * running when slave address matching occurs.
 *
 * Values:
 * - 0 - Normal operation. No interrupt generated when address matching in low
 *     power mode.
 * - 1 - Enables the wakeup function in low power mode.
 */
/*@{*/
#define BP_I2C_C1_WUEN       (1U)          /*!< Bit position for I2C_C1_WUEN. */
#define BM_I2C_C1_WUEN       (0x02U)       /*!< Bit mask for I2C_C1_WUEN. */
#define BS_I2C_C1_WUEN       (1U)          /*!< Bit field size in bits for I2C_C1_WUEN. */

/*! @brief Read current value of the I2C_C1_WUEN field. */
#define BR_I2C_C1_WUEN(x)    (BME_UBFX8(HW_I2C_C1_ADDR(x), BP_I2C_C1_WUEN, BS_I2C_C1_WUEN))

/*! @brief Format value for bitfield I2C_C1_WUEN. */
#define BF_I2C_C1_WUEN(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_C1_WUEN) & BM_I2C_C1_WUEN)

/*! @brief Set the WUEN field to a new value. */
#define BW_I2C_C1_WUEN(x, v) (BME_BFI8(HW_I2C_C1_ADDR(x), ((uint8_t)(v) << BP_I2C_C1_WUEN), BP_I2C_C1_WUEN, 1))
/*@}*/

/*!
 * @name Register I2C_C1, field RSTA[2] (WORZ)
 *
 * Writing 1 to this bit generates a repeated START condition provided it is the
 * current master. This bit will always be read as 0. Attempting a repeat at the
 * wrong time results in loss of arbitration.
 */
/*@{*/
#define BP_I2C_C1_RSTA       (2U)          /*!< Bit position for I2C_C1_RSTA. */
#define BM_I2C_C1_RSTA       (0x04U)       /*!< Bit mask for I2C_C1_RSTA. */
#define BS_I2C_C1_RSTA       (1U)          /*!< Bit field size in bits for I2C_C1_RSTA. */

/*! @brief Format value for bitfield I2C_C1_RSTA. */
#define BF_I2C_C1_RSTA(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_C1_RSTA) & BM_I2C_C1_RSTA)

/*! @brief Set the RSTA field to a new value. */
#define BW_I2C_C1_RSTA(x, v) (BME_BFI8(HW_I2C_C1_ADDR(x), ((uint8_t)(v) << BP_I2C_C1_RSTA), BP_I2C_C1_RSTA, 1))
/*@}*/

/*!
 * @name Register I2C_C1, field TXAK[3] (RW)
 *
 * Specifies the value driven onto the SDA during data acknowledge cycles for
 * both master and slave receivers. The value of SMB[FACK] affects NACK/ACK
 * generation. SCL is held low until TXAK is written.
 *
 * Values:
 * - 0 - An acknowledge signal is sent to the bus on the following receiving
 *     byte (if FACK is cleared) or the current receiving byte (if FACK is set).
 * - 1 - No acknowledge signal is sent to the bus on the following receiving
 *     data byte (if FACK is cleared) or the current receiving data byte (if FACK is
 *     set).
 */
/*@{*/
#define BP_I2C_C1_TXAK       (3U)          /*!< Bit position for I2C_C1_TXAK. */
#define BM_I2C_C1_TXAK       (0x08U)       /*!< Bit mask for I2C_C1_TXAK. */
#define BS_I2C_C1_TXAK       (1U)          /*!< Bit field size in bits for I2C_C1_TXAK. */

/*! @brief Read current value of the I2C_C1_TXAK field. */
#define BR_I2C_C1_TXAK(x)    (BME_UBFX8(HW_I2C_C1_ADDR(x), BP_I2C_C1_TXAK, BS_I2C_C1_TXAK))

/*! @brief Format value for bitfield I2C_C1_TXAK. */
#define BF_I2C_C1_TXAK(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_C1_TXAK) & BM_I2C_C1_TXAK)

/*! @brief Set the TXAK field to a new value. */
#define BW_I2C_C1_TXAK(x, v) (BME_BFI8(HW_I2C_C1_ADDR(x), ((uint8_t)(v) << BP_I2C_C1_TXAK), BP_I2C_C1_TXAK, 1))
/*@}*/

/*!
 * @name Register I2C_C1, field TX[4] (RW)
 *
 * Selects the direction of master and slave transfers. In master mode this bit
 * must be set according to the type of transfer required. Therefore, for address
 * cycles, this bit is always set. When addressed as a slave this bit must be
 * set by software according to the SRW bit in the status register.
 *
 * Values:
 * - 0 - Receive
 * - 1 - Transmit
 */
/*@{*/
#define BP_I2C_C1_TX         (4U)          /*!< Bit position for I2C_C1_TX. */
#define BM_I2C_C1_TX         (0x10U)       /*!< Bit mask for I2C_C1_TX. */
#define BS_I2C_C1_TX         (1U)          /*!< Bit field size in bits for I2C_C1_TX. */

/*! @brief Read current value of the I2C_C1_TX field. */
#define BR_I2C_C1_TX(x)      (BME_UBFX8(HW_I2C_C1_ADDR(x), BP_I2C_C1_TX, BS_I2C_C1_TX))

/*! @brief Format value for bitfield I2C_C1_TX. */
#define BF_I2C_C1_TX(v)      ((uint8_t)((uint8_t)(v) << BP_I2C_C1_TX) & BM_I2C_C1_TX)

/*! @brief Set the TX field to a new value. */
#define BW_I2C_C1_TX(x, v)   (BME_BFI8(HW_I2C_C1_ADDR(x), ((uint8_t)(v) << BP_I2C_C1_TX), BP_I2C_C1_TX, 1))
/*@}*/

/*!
 * @name Register I2C_C1, field MST[5] (RW)
 *
 * When MST is changed from 0 to 1, a START signal is generated on the bus and
 * master mode is selected. When this bit changes from 1 to 0, a STOP signal is
 * generated and the mode of operation changes from master to slave.
 *
 * Values:
 * - 0 - Slave mode
 * - 1 - Master mode
 */
/*@{*/
#define BP_I2C_C1_MST        (5U)          /*!< Bit position for I2C_C1_MST. */
#define BM_I2C_C1_MST        (0x20U)       /*!< Bit mask for I2C_C1_MST. */
#define BS_I2C_C1_MST        (1U)          /*!< Bit field size in bits for I2C_C1_MST. */

/*! @brief Read current value of the I2C_C1_MST field. */
#define BR_I2C_C1_MST(x)     (BME_UBFX8(HW_I2C_C1_ADDR(x), BP_I2C_C1_MST, BS_I2C_C1_MST))

/*! @brief Format value for bitfield I2C_C1_MST. */
#define BF_I2C_C1_MST(v)     ((uint8_t)((uint8_t)(v) << BP_I2C_C1_MST) & BM_I2C_C1_MST)

/*! @brief Set the MST field to a new value. */
#define BW_I2C_C1_MST(x, v)  (BME_BFI8(HW_I2C_C1_ADDR(x), ((uint8_t)(v) << BP_I2C_C1_MST), BP_I2C_C1_MST, 1))
/*@}*/

/*!
 * @name Register I2C_C1, field IICIE[6] (RW)
 *
 * Enables I2C interrupt requests.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_I2C_C1_IICIE      (6U)          /*!< Bit position for I2C_C1_IICIE. */
#define BM_I2C_C1_IICIE      (0x40U)       /*!< Bit mask for I2C_C1_IICIE. */
#define BS_I2C_C1_IICIE      (1U)          /*!< Bit field size in bits for I2C_C1_IICIE. */

/*! @brief Read current value of the I2C_C1_IICIE field. */
#define BR_I2C_C1_IICIE(x)   (BME_UBFX8(HW_I2C_C1_ADDR(x), BP_I2C_C1_IICIE, BS_I2C_C1_IICIE))

/*! @brief Format value for bitfield I2C_C1_IICIE. */
#define BF_I2C_C1_IICIE(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_C1_IICIE) & BM_I2C_C1_IICIE)

/*! @brief Set the IICIE field to a new value. */
#define BW_I2C_C1_IICIE(x, v) (BME_BFI8(HW_I2C_C1_ADDR(x), ((uint8_t)(v) << BP_I2C_C1_IICIE), BP_I2C_C1_IICIE, 1))
/*@}*/

/*!
 * @name Register I2C_C1, field IICEN[7] (RW)
 *
 * Enables I2C module operation.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_I2C_C1_IICEN      (7U)          /*!< Bit position for I2C_C1_IICEN. */
#define BM_I2C_C1_IICEN      (0x80U)       /*!< Bit mask for I2C_C1_IICEN. */
#define BS_I2C_C1_IICEN      (1U)          /*!< Bit field size in bits for I2C_C1_IICEN. */

/*! @brief Read current value of the I2C_C1_IICEN field. */
#define BR_I2C_C1_IICEN(x)   (BME_UBFX8(HW_I2C_C1_ADDR(x), BP_I2C_C1_IICEN, BS_I2C_C1_IICEN))

/*! @brief Format value for bitfield I2C_C1_IICEN. */
#define BF_I2C_C1_IICEN(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_C1_IICEN) & BM_I2C_C1_IICEN)

/*! @brief Set the IICEN field to a new value. */
#define BW_I2C_C1_IICEN(x, v) (BME_BFI8(HW_I2C_C1_ADDR(x), ((uint8_t)(v) << BP_I2C_C1_IICEN), BP_I2C_C1_IICEN, 1))
/*@}*/

/*******************************************************************************
 * HW_I2C_S - I2C Status register
 ******************************************************************************/

/*!
 * @brief HW_I2C_S - I2C Status register (RW)
 *
 * Reset value: 0x80U
 */
typedef union _hw_i2c_s
{
    uint8_t U;
    struct _hw_i2c_s_bitfields
    {
        uint8_t RXAK : 1;              /*!< [0] Receive Acknowledge */
        uint8_t IICIF : 1;             /*!< [1] Interrupt Flag */
        uint8_t SRW : 1;               /*!< [2] Slave Read/Write */
        uint8_t RAM : 1;               /*!< [3] Range Address Match */
        uint8_t ARBL : 1;              /*!< [4] Arbitration Lost */
        uint8_t BUSY : 1;              /*!< [5] Bus Busy */
        uint8_t IAAS : 1;              /*!< [6] Addressed As A Slave */
        uint8_t TCF : 1;               /*!< [7] Transfer Complete Flag */
    } B;
} hw_i2c_s_t;

/*!
 * @name Constants and macros for entire I2C_S register
 */
/*@{*/
#define HW_I2C_S_ADDR(x)         ((uint32_t)(x) + 0x3U)

#define HW_I2C_S(x)              (*(__IO hw_i2c_s_t *) HW_I2C_S_ADDR(x))
#define HW_I2C_S_RD(x)           (HW_I2C_S(x).U)
#define HW_I2C_S_WR(x, v)        (HW_I2C_S(x).U = (v))
#define HW_I2C_S_SET(x, v)       (BME_OR8(HW_I2C_S_ADDR(x), (uint8_t)(v)))
#define HW_I2C_S_CLR(x, v)       (BME_AND8(HW_I2C_S_ADDR(x), (uint8_t)(~(v))))
#define HW_I2C_S_TOG(x, v)       (BME_XOR8(HW_I2C_S_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2C_S bitfields
 */

/*!
 * @name Register I2C_S, field RXAK[0] (RO)
 *
 * Values:
 * - 0 - Acknowledge signal was received after the completion of one byte of
 *     data transmission on the bus
 * - 1 - No acknowledge signal detected
 */
/*@{*/
#define BP_I2C_S_RXAK        (0U)          /*!< Bit position for I2C_S_RXAK. */
#define BM_I2C_S_RXAK        (0x01U)       /*!< Bit mask for I2C_S_RXAK. */
#define BS_I2C_S_RXAK        (1U)          /*!< Bit field size in bits for I2C_S_RXAK. */

/*! @brief Read current value of the I2C_S_RXAK field. */
#define BR_I2C_S_RXAK(x)     (BME_UBFX8(HW_I2C_S_ADDR(x), BP_I2C_S_RXAK, BS_I2C_S_RXAK))
/*@}*/

/*!
 * @name Register I2C_S, field IICIF[1] (W1C)
 *
 * This bit sets when an interrupt is pending. This bit must be cleared by
 * software by writing 1 to it, such as in the interrupt routine. One of the following
 * events can set this bit: One byte transfer, including ACK/NACK bit, completes
 * if FACK is 0. An ACK or NACK is sent on the bus by writing 0 or 1 to TXAK
 * after this bit is set in receive mode. One byte transfer, excluding ACK/NACK bit,
 * completes if FACK is 1. Match of slave address to calling address including
 * primary slave address, range slave address , alert response address, second
 * slave address, or general call address. Arbitration lost In SMBus mode, any
 * timeouts except SCL and SDA high timeouts I2C bus stop or start detection if the
 * SSIE bit in the Input Glitch Filter register is 1 To clear the I2C bus stop or
 * start detection interrupt: In the interrupt service routine, first clear the
 * STOPF or STARTF bit in the Input Glitch Filter register by writing 1 to it, and
 * then clear the IICIF bit. If this sequence is reversed, the IICIF bit is
 * asserted again.
 *
 * Values:
 * - 0 - No interrupt pending
 * - 1 - Interrupt pending
 */
/*@{*/
#define BP_I2C_S_IICIF       (1U)          /*!< Bit position for I2C_S_IICIF. */
#define BM_I2C_S_IICIF       (0x02U)       /*!< Bit mask for I2C_S_IICIF. */
#define BS_I2C_S_IICIF       (1U)          /*!< Bit field size in bits for I2C_S_IICIF. */

/*! @brief Read current value of the I2C_S_IICIF field. */
#define BR_I2C_S_IICIF(x)    (BME_UBFX8(HW_I2C_S_ADDR(x), BP_I2C_S_IICIF, BS_I2C_S_IICIF))

/*! @brief Format value for bitfield I2C_S_IICIF. */
#define BF_I2C_S_IICIF(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_S_IICIF) & BM_I2C_S_IICIF)

/*! @brief Set the IICIF field to a new value. */
#define BW_I2C_S_IICIF(x, v) (BME_BFI8(HW_I2C_S_ADDR(x), ((uint8_t)(v) << BP_I2C_S_IICIF), BP_I2C_S_IICIF, 1))
/*@}*/

/*!
 * @name Register I2C_S, field SRW[2] (RO)
 *
 * When addressed as a slave, SRW indicates the value of the R/W command bit of
 * the calling address sent to the master.
 *
 * Values:
 * - 0 - Slave receive, master writing to slave
 * - 1 - Slave transmit, master reading from slave
 */
/*@{*/
#define BP_I2C_S_SRW         (2U)          /*!< Bit position for I2C_S_SRW. */
#define BM_I2C_S_SRW         (0x04U)       /*!< Bit mask for I2C_S_SRW. */
#define BS_I2C_S_SRW         (1U)          /*!< Bit field size in bits for I2C_S_SRW. */

/*! @brief Read current value of the I2C_S_SRW field. */
#define BR_I2C_S_SRW(x)      (BME_UBFX8(HW_I2C_S_ADDR(x), BP_I2C_S_SRW, BS_I2C_S_SRW))
/*@}*/

/*!
 * @name Register I2C_S, field RAM[3] (RW)
 *
 * This bit is set to 1 by any of the following conditions, if I2C_C2[RMEN] = 1:
 * Any nonzero calling address is received that matches the address in the RA
 * register. The calling address is within the range of values of the A1 and RA
 * registers. For the RAM bit to be set to 1 correctly, C1[IICIE] must be set to 1.
 * Writing the C1 register with any value clears this bit to 0.
 *
 * Values:
 * - 0 - Not addressed
 * - 1 - Addressed as a slave
 */
/*@{*/
#define BP_I2C_S_RAM         (3U)          /*!< Bit position for I2C_S_RAM. */
#define BM_I2C_S_RAM         (0x08U)       /*!< Bit mask for I2C_S_RAM. */
#define BS_I2C_S_RAM         (1U)          /*!< Bit field size in bits for I2C_S_RAM. */

/*! @brief Read current value of the I2C_S_RAM field. */
#define BR_I2C_S_RAM(x)      (BME_UBFX8(HW_I2C_S_ADDR(x), BP_I2C_S_RAM, BS_I2C_S_RAM))

/*! @brief Format value for bitfield I2C_S_RAM. */
#define BF_I2C_S_RAM(v)      ((uint8_t)((uint8_t)(v) << BP_I2C_S_RAM) & BM_I2C_S_RAM)

/*! @brief Set the RAM field to a new value. */
#define BW_I2C_S_RAM(x, v)   (BME_BFI8(HW_I2C_S_ADDR(x), ((uint8_t)(v) << BP_I2C_S_RAM), BP_I2C_S_RAM, 1))
/*@}*/

/*!
 * @name Register I2C_S, field ARBL[4] (W1C)
 *
 * This bit is set by hardware when the arbitration procedure is lost. The ARBL
 * bit must be cleared by software, by writing 1 to it.
 *
 * Values:
 * - 0 - Standard bus operation.
 * - 1 - Loss of arbitration.
 */
/*@{*/
#define BP_I2C_S_ARBL        (4U)          /*!< Bit position for I2C_S_ARBL. */
#define BM_I2C_S_ARBL        (0x10U)       /*!< Bit mask for I2C_S_ARBL. */
#define BS_I2C_S_ARBL        (1U)          /*!< Bit field size in bits for I2C_S_ARBL. */

/*! @brief Read current value of the I2C_S_ARBL field. */
#define BR_I2C_S_ARBL(x)     (BME_UBFX8(HW_I2C_S_ADDR(x), BP_I2C_S_ARBL, BS_I2C_S_ARBL))

/*! @brief Format value for bitfield I2C_S_ARBL. */
#define BF_I2C_S_ARBL(v)     ((uint8_t)((uint8_t)(v) << BP_I2C_S_ARBL) & BM_I2C_S_ARBL)

/*! @brief Set the ARBL field to a new value. */
#define BW_I2C_S_ARBL(x, v)  (BME_BFI8(HW_I2C_S_ADDR(x), ((uint8_t)(v) << BP_I2C_S_ARBL), BP_I2C_S_ARBL, 1))
/*@}*/

/*!
 * @name Register I2C_S, field BUSY[5] (RO)
 *
 * Indicates the status of the bus regardless of slave or master mode. This bit
 * is set when a START signal is detected and cleared when a STOP signal is
 * detected.
 *
 * Values:
 * - 0 - Bus is idle
 * - 1 - Bus is busy
 */
/*@{*/
#define BP_I2C_S_BUSY        (5U)          /*!< Bit position for I2C_S_BUSY. */
#define BM_I2C_S_BUSY        (0x20U)       /*!< Bit mask for I2C_S_BUSY. */
#define BS_I2C_S_BUSY        (1U)          /*!< Bit field size in bits for I2C_S_BUSY. */

/*! @brief Read current value of the I2C_S_BUSY field. */
#define BR_I2C_S_BUSY(x)     (BME_UBFX8(HW_I2C_S_ADDR(x), BP_I2C_S_BUSY, BS_I2C_S_BUSY))
/*@}*/

/*!
 * @name Register I2C_S, field IAAS[6] (RW)
 *
 * This bit is set by one of the following conditions: The calling address
 * matches the programmed primary slave address in the A1 register, or matches the
 * range address in the RA register (which must be set to a nonzero value and under
 * the condition I2C_C2[RMEN] = 1). C2[GCAEN] is set and a general call is
 * received. SMB[SIICAEN] is set and the calling address matches the second programmed
 * slave address. ALERTEN is set and an SMBus alert response address is received
 * RMEN is set and an address is received that is within the range between the
 * values of the A1 and RA registers. IAAS sets before the ACK bit. The CPU must
 * check the SRW bit and set TX/RX accordingly. Writing the C1 register with any
 * value clears this bit.
 *
 * Values:
 * - 0 - Not addressed
 * - 1 - Addressed as a slave
 */
/*@{*/
#define BP_I2C_S_IAAS        (6U)          /*!< Bit position for I2C_S_IAAS. */
#define BM_I2C_S_IAAS        (0x40U)       /*!< Bit mask for I2C_S_IAAS. */
#define BS_I2C_S_IAAS        (1U)          /*!< Bit field size in bits for I2C_S_IAAS. */

/*! @brief Read current value of the I2C_S_IAAS field. */
#define BR_I2C_S_IAAS(x)     (BME_UBFX8(HW_I2C_S_ADDR(x), BP_I2C_S_IAAS, BS_I2C_S_IAAS))

/*! @brief Format value for bitfield I2C_S_IAAS. */
#define BF_I2C_S_IAAS(v)     ((uint8_t)((uint8_t)(v) << BP_I2C_S_IAAS) & BM_I2C_S_IAAS)

/*! @brief Set the IAAS field to a new value. */
#define BW_I2C_S_IAAS(x, v)  (BME_BFI8(HW_I2C_S_ADDR(x), ((uint8_t)(v) << BP_I2C_S_IAAS), BP_I2C_S_IAAS, 1))
/*@}*/

/*!
 * @name Register I2C_S, field TCF[7] (RO)
 *
 * Acknowledges a byte transfer; TCF is set on the completion of a byte
 * transfer. This bit is valid only during or immediately following a transfer to or from
 * the I2C module. TCF is cleared by reading the I2C data register in receive
 * mode or by writing to the I2C data register in transmit mode.In the buffer mode,
 * TCF is cleared automatically by internal reading or writing the data register
 * I2C_D, with no need waiting for manually reading/writing the I2C data
 * register in Rx/Tx mode.
 *
 * Values:
 * - 0 - Transfer in progress
 * - 1 - Transfer complete
 */
/*@{*/
#define BP_I2C_S_TCF         (7U)          /*!< Bit position for I2C_S_TCF. */
#define BM_I2C_S_TCF         (0x80U)       /*!< Bit mask for I2C_S_TCF. */
#define BS_I2C_S_TCF         (1U)          /*!< Bit field size in bits for I2C_S_TCF. */

/*! @brief Read current value of the I2C_S_TCF field. */
#define BR_I2C_S_TCF(x)      (BME_UBFX8(HW_I2C_S_ADDR(x), BP_I2C_S_TCF, BS_I2C_S_TCF))
/*@}*/

/*******************************************************************************
 * HW_I2C_D - I2C Data I/O register
 ******************************************************************************/

/*!
 * @brief HW_I2C_D - I2C Data I/O register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_d
{
    uint8_t U;
    struct _hw_i2c_d_bitfields
    {
        uint8_t DATA : 8;              /*!< [7:0] Data */
    } B;
} hw_i2c_d_t;

/*!
 * @name Constants and macros for entire I2C_D register
 */
/*@{*/
#define HW_I2C_D_ADDR(x)         ((uint32_t)(x) + 0x4U)

#define HW_I2C_D(x)              (*(__IO hw_i2c_d_t *) HW_I2C_D_ADDR(x))
#define HW_I2C_D_RD(x)           (HW_I2C_D(x).U)
#define HW_I2C_D_WR(x, v)        (HW_I2C_D(x).U = (v))
#define HW_I2C_D_SET(x, v)       (BME_OR8(HW_I2C_D_ADDR(x), (uint8_t)(v)))
#define HW_I2C_D_CLR(x, v)       (BME_AND8(HW_I2C_D_ADDR(x), (uint8_t)(~(v))))
#define HW_I2C_D_TOG(x, v)       (BME_XOR8(HW_I2C_D_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2C_D bitfields
 */

/*!
 * @name Register I2C_D, field DATA[7:0] (RW)
 *
 * In master transmit mode, when data is written to this register, a data
 * transfer is initiated. The most significant bit is sent first. In master receive
 * mode, reading this register initiates receiving of the next byte of data. When
 * making the transition out of master receive mode, switch the I2C mode before
 * reading the Data register to prevent an inadvertent initiation of a master
 * receive data transfer. In slave mode, the same functions are available after an
 * address match occurs. The C1[TX] bit must correctly reflect the desired direction
 * of transfer in master and slave modes for the transmission to begin. For
 * example, if the I2C module is configured for master transmit but a master receive
 * is desired, reading the Data register does not initiate the receive. Reading
 * the Data register returns the last byte received while the I2C module is
 * configured in master receive or slave receive mode. The Data register does not
 * reflect every byte that is transmitted on the I2C bus, and neither can software
 * verify that a byte has been written to the Data register correctly by reading it
 * back. In master transmit mode, the first byte of data written to the Data
 * register following assertion of MST (start bit) or assertion of RSTA (repeated
 * start bit) is used for the address transfer and must consist of the calling
 * address (in bits 7-1) concatenated with the required R/W bit (in position bit 0).
 */
/*@{*/
#define BP_I2C_D_DATA        (0U)          /*!< Bit position for I2C_D_DATA. */
#define BM_I2C_D_DATA        (0xFFU)       /*!< Bit mask for I2C_D_DATA. */
#define BS_I2C_D_DATA        (8U)          /*!< Bit field size in bits for I2C_D_DATA. */

/*! @brief Read current value of the I2C_D_DATA field. */
#define BR_I2C_D_DATA(x)     (HW_I2C_D(x).U)

/*! @brief Format value for bitfield I2C_D_DATA. */
#define BF_I2C_D_DATA(v)     ((uint8_t)((uint8_t)(v) << BP_I2C_D_DATA) & BM_I2C_D_DATA)

/*! @brief Set the DATA field to a new value. */
#define BW_I2C_D_DATA(x, v)  (HW_I2C_D_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_I2C_C2 - I2C Control Register 2
 ******************************************************************************/

/*!
 * @brief HW_I2C_C2 - I2C Control Register 2 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_c2
{
    uint8_t U;
    struct _hw_i2c_c2_bitfields
    {
        uint8_t AD : 3;                /*!< [2:0] Slave Address */
        uint8_t RMEN : 1;              /*!< [3] Range Address Matching Enable */
        uint8_t SBRC : 1;              /*!< [4] Slave Baud Rate Control */
        uint8_t HDRS : 1;              /*!< [5] High Drive Select */
        uint8_t ADEXT : 1;             /*!< [6] Address Extension */
        uint8_t GCAEN : 1;             /*!< [7] General Call Address Enable */
    } B;
} hw_i2c_c2_t;

/*!
 * @name Constants and macros for entire I2C_C2 register
 */
/*@{*/
#define HW_I2C_C2_ADDR(x)        ((uint32_t)(x) + 0x5U)

#define HW_I2C_C2(x)             (*(__IO hw_i2c_c2_t *) HW_I2C_C2_ADDR(x))
#define HW_I2C_C2_RD(x)          (HW_I2C_C2(x).U)
#define HW_I2C_C2_WR(x, v)       (HW_I2C_C2(x).U = (v))
#define HW_I2C_C2_SET(x, v)      (BME_OR8(HW_I2C_C2_ADDR(x), (uint8_t)(v)))
#define HW_I2C_C2_CLR(x, v)      (BME_AND8(HW_I2C_C2_ADDR(x), (uint8_t)(~(v))))
#define HW_I2C_C2_TOG(x, v)      (BME_XOR8(HW_I2C_C2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2C_C2 bitfields
 */

/*!
 * @name Register I2C_C2, field AD[2:0] (RW)
 *
 * Contains the upper three bits of the slave address in the 10-bit address
 * scheme. This field is valid only while the ADEXT bit is set.
 */
/*@{*/
#define BP_I2C_C2_AD         (0U)          /*!< Bit position for I2C_C2_AD. */
#define BM_I2C_C2_AD         (0x07U)       /*!< Bit mask for I2C_C2_AD. */
#define BS_I2C_C2_AD         (3U)          /*!< Bit field size in bits for I2C_C2_AD. */

/*! @brief Read current value of the I2C_C2_AD field. */
#define BR_I2C_C2_AD(x)      (BME_UBFX8(HW_I2C_C2_ADDR(x), BP_I2C_C2_AD, BS_I2C_C2_AD))

/*! @brief Format value for bitfield I2C_C2_AD. */
#define BF_I2C_C2_AD(v)      ((uint8_t)((uint8_t)(v) << BP_I2C_C2_AD) & BM_I2C_C2_AD)

/*! @brief Set the AD field to a new value. */
#define BW_I2C_C2_AD(x, v)   (BME_BFI8(HW_I2C_C2_ADDR(x), ((uint8_t)(v) << BP_I2C_C2_AD), BP_I2C_C2_AD, 3))
/*@}*/

/*!
 * @name Register I2C_C2, field RMEN[3] (RW)
 *
 * This bit controls the slave address matching for addresses between the values
 * of the A1 and RA registers. When this bit is set, a slave address matching
 * occurs for any address greater than the value of the A1 register and less than
 * or equal to the value of the RA register.
 *
 * Values:
 * - 0 - Range mode disabled. No address matching occurs for an address within
 *     the range of values of the A1 and RA registers.
 * - 1 - Range mode enabled. Address matching occurs when a slave receives an
 *     address within the range of values of the A1 and RA registers.
 */
/*@{*/
#define BP_I2C_C2_RMEN       (3U)          /*!< Bit position for I2C_C2_RMEN. */
#define BM_I2C_C2_RMEN       (0x08U)       /*!< Bit mask for I2C_C2_RMEN. */
#define BS_I2C_C2_RMEN       (1U)          /*!< Bit field size in bits for I2C_C2_RMEN. */

/*! @brief Read current value of the I2C_C2_RMEN field. */
#define BR_I2C_C2_RMEN(x)    (BME_UBFX8(HW_I2C_C2_ADDR(x), BP_I2C_C2_RMEN, BS_I2C_C2_RMEN))

/*! @brief Format value for bitfield I2C_C2_RMEN. */
#define BF_I2C_C2_RMEN(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_C2_RMEN) & BM_I2C_C2_RMEN)

/*! @brief Set the RMEN field to a new value. */
#define BW_I2C_C2_RMEN(x, v) (BME_BFI8(HW_I2C_C2_ADDR(x), ((uint8_t)(v) << BP_I2C_C2_RMEN), BP_I2C_C2_RMEN, 1))
/*@}*/

/*!
 * @name Register I2C_C2, field SBRC[4] (RW)
 *
 * Enables independent slave mode baud rate at maximum frequency, which forces
 * clock stretching on SCL in very fast I2C modes. To a slave, an example of a
 * "very fast" mode is when the master transfers at 40 kbit/s but the slave can
 * capture the master's data at only 10 kbit/s.
 *
 * Values:
 * - 0 - The slave baud rate follows the master baud rate and clock stretching
 *     may occur
 * - 1 - Slave baud rate is independent of the master baud rate
 */
/*@{*/
#define BP_I2C_C2_SBRC       (4U)          /*!< Bit position for I2C_C2_SBRC. */
#define BM_I2C_C2_SBRC       (0x10U)       /*!< Bit mask for I2C_C2_SBRC. */
#define BS_I2C_C2_SBRC       (1U)          /*!< Bit field size in bits for I2C_C2_SBRC. */

/*! @brief Read current value of the I2C_C2_SBRC field. */
#define BR_I2C_C2_SBRC(x)    (BME_UBFX8(HW_I2C_C2_ADDR(x), BP_I2C_C2_SBRC, BS_I2C_C2_SBRC))

/*! @brief Format value for bitfield I2C_C2_SBRC. */
#define BF_I2C_C2_SBRC(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_C2_SBRC) & BM_I2C_C2_SBRC)

/*! @brief Set the SBRC field to a new value. */
#define BW_I2C_C2_SBRC(x, v) (BME_BFI8(HW_I2C_C2_ADDR(x), ((uint8_t)(v) << BP_I2C_C2_SBRC), BP_I2C_C2_SBRC, 1))
/*@}*/

/*!
 * @name Register I2C_C2, field HDRS[5] (RW)
 *
 * Controls the drive capability of the I2C pads.
 *
 * Values:
 * - 0 - Normal drive mode
 * - 1 - High drive mode
 */
/*@{*/
#define BP_I2C_C2_HDRS       (5U)          /*!< Bit position for I2C_C2_HDRS. */
#define BM_I2C_C2_HDRS       (0x20U)       /*!< Bit mask for I2C_C2_HDRS. */
#define BS_I2C_C2_HDRS       (1U)          /*!< Bit field size in bits for I2C_C2_HDRS. */

/*! @brief Read current value of the I2C_C2_HDRS field. */
#define BR_I2C_C2_HDRS(x)    (BME_UBFX8(HW_I2C_C2_ADDR(x), BP_I2C_C2_HDRS, BS_I2C_C2_HDRS))

/*! @brief Format value for bitfield I2C_C2_HDRS. */
#define BF_I2C_C2_HDRS(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_C2_HDRS) & BM_I2C_C2_HDRS)

/*! @brief Set the HDRS field to a new value. */
#define BW_I2C_C2_HDRS(x, v) (BME_BFI8(HW_I2C_C2_ADDR(x), ((uint8_t)(v) << BP_I2C_C2_HDRS), BP_I2C_C2_HDRS, 1))
/*@}*/

/*!
 * @name Register I2C_C2, field ADEXT[6] (RW)
 *
 * Controls the number of bits used for the slave address.
 *
 * Values:
 * - 0 - 7-bit address scheme
 * - 1 - 10-bit address scheme
 */
/*@{*/
#define BP_I2C_C2_ADEXT      (6U)          /*!< Bit position for I2C_C2_ADEXT. */
#define BM_I2C_C2_ADEXT      (0x40U)       /*!< Bit mask for I2C_C2_ADEXT. */
#define BS_I2C_C2_ADEXT      (1U)          /*!< Bit field size in bits for I2C_C2_ADEXT. */

/*! @brief Read current value of the I2C_C2_ADEXT field. */
#define BR_I2C_C2_ADEXT(x)   (BME_UBFX8(HW_I2C_C2_ADDR(x), BP_I2C_C2_ADEXT, BS_I2C_C2_ADEXT))

/*! @brief Format value for bitfield I2C_C2_ADEXT. */
#define BF_I2C_C2_ADEXT(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_C2_ADEXT) & BM_I2C_C2_ADEXT)

/*! @brief Set the ADEXT field to a new value. */
#define BW_I2C_C2_ADEXT(x, v) (BME_BFI8(HW_I2C_C2_ADDR(x), ((uint8_t)(v) << BP_I2C_C2_ADEXT), BP_I2C_C2_ADEXT, 1))
/*@}*/

/*!
 * @name Register I2C_C2, field GCAEN[7] (RW)
 *
 * Enables general call address.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_I2C_C2_GCAEN      (7U)          /*!< Bit position for I2C_C2_GCAEN. */
#define BM_I2C_C2_GCAEN      (0x80U)       /*!< Bit mask for I2C_C2_GCAEN. */
#define BS_I2C_C2_GCAEN      (1U)          /*!< Bit field size in bits for I2C_C2_GCAEN. */

/*! @brief Read current value of the I2C_C2_GCAEN field. */
#define BR_I2C_C2_GCAEN(x)   (BME_UBFX8(HW_I2C_C2_ADDR(x), BP_I2C_C2_GCAEN, BS_I2C_C2_GCAEN))

/*! @brief Format value for bitfield I2C_C2_GCAEN. */
#define BF_I2C_C2_GCAEN(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_C2_GCAEN) & BM_I2C_C2_GCAEN)

/*! @brief Set the GCAEN field to a new value. */
#define BW_I2C_C2_GCAEN(x, v) (BME_BFI8(HW_I2C_C2_ADDR(x), ((uint8_t)(v) << BP_I2C_C2_GCAEN), BP_I2C_C2_GCAEN, 1))
/*@}*/

/*******************************************************************************
 * HW_I2C_FLT - I2C Programmable Input Glitch Filter Register
 ******************************************************************************/

/*!
 * @brief HW_I2C_FLT - I2C Programmable Input Glitch Filter Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_flt
{
    uint8_t U;
    struct _hw_i2c_flt_bitfields
    {
        uint8_t FLT : 4;               /*!< [3:0] I2C Programmable Filter Factor */
        uint8_t STARTF : 1;            /*!< [4] I2C Bus Start Detect Flag */
        uint8_t SSIE : 1;              /*!< [5] I2C Bus Stop or Start Interrupt Enable */
        uint8_t STOPF : 1;             /*!< [6] I2C Bus Stop Detect Flag */
        uint8_t SHEN : 1;              /*!< [7] Stop Hold Enable */
    } B;
} hw_i2c_flt_t;

/*!
 * @name Constants and macros for entire I2C_FLT register
 */
/*@{*/
#define HW_I2C_FLT_ADDR(x)       ((uint32_t)(x) + 0x6U)

#define HW_I2C_FLT(x)            (*(__IO hw_i2c_flt_t *) HW_I2C_FLT_ADDR(x))
#define HW_I2C_FLT_RD(x)         (HW_I2C_FLT(x).U)
#define HW_I2C_FLT_WR(x, v)      (HW_I2C_FLT(x).U = (v))
#define HW_I2C_FLT_SET(x, v)     (BME_OR8(HW_I2C_FLT_ADDR(x), (uint8_t)(v)))
#define HW_I2C_FLT_CLR(x, v)     (BME_AND8(HW_I2C_FLT_ADDR(x), (uint8_t)(~(v))))
#define HW_I2C_FLT_TOG(x, v)     (BME_XOR8(HW_I2C_FLT_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2C_FLT bitfields
 */

/*!
 * @name Register I2C_FLT, field FLT[3:0] (RW)
 *
 * Controls the width of the glitch, in terms of I2C module clock cycles, that
 * the filter must absorb. For any glitch whose size is less than or equal to this
 * width setting, the filter does not allow the glitch to pass.
 *
 * Values:
 * - 0 - No filter/bypass
 */
/*@{*/
#define BP_I2C_FLT_FLT       (0U)          /*!< Bit position for I2C_FLT_FLT. */
#define BM_I2C_FLT_FLT       (0x0FU)       /*!< Bit mask for I2C_FLT_FLT. */
#define BS_I2C_FLT_FLT       (4U)          /*!< Bit field size in bits for I2C_FLT_FLT. */

/*! @brief Read current value of the I2C_FLT_FLT field. */
#define BR_I2C_FLT_FLT(x)    (BME_UBFX8(HW_I2C_FLT_ADDR(x), BP_I2C_FLT_FLT, BS_I2C_FLT_FLT))

/*! @brief Format value for bitfield I2C_FLT_FLT. */
#define BF_I2C_FLT_FLT(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_FLT_FLT) & BM_I2C_FLT_FLT)

/*! @brief Set the FLT field to a new value. */
#define BW_I2C_FLT_FLT(x, v) (BME_BFI8(HW_I2C_FLT_ADDR(x), ((uint8_t)(v) << BP_I2C_FLT_FLT), BP_I2C_FLT_FLT, 4))
/*@}*/

/*!
 * @name Register I2C_FLT, field STARTF[4] (W1C)
 *
 * Hardware sets this bit when the I2C bus's start status is detected. The
 * STARTF bit must be cleared by writing 1 to it.
 *
 * Values:
 * - 0 - No start happens on I2C bus
 * - 1 - Start detected on I2C bus
 */
/*@{*/
#define BP_I2C_FLT_STARTF    (4U)          /*!< Bit position for I2C_FLT_STARTF. */
#define BM_I2C_FLT_STARTF    (0x10U)       /*!< Bit mask for I2C_FLT_STARTF. */
#define BS_I2C_FLT_STARTF    (1U)          /*!< Bit field size in bits for I2C_FLT_STARTF. */

/*! @brief Read current value of the I2C_FLT_STARTF field. */
#define BR_I2C_FLT_STARTF(x) (BME_UBFX8(HW_I2C_FLT_ADDR(x), BP_I2C_FLT_STARTF, BS_I2C_FLT_STARTF))

/*! @brief Format value for bitfield I2C_FLT_STARTF. */
#define BF_I2C_FLT_STARTF(v) ((uint8_t)((uint8_t)(v) << BP_I2C_FLT_STARTF) & BM_I2C_FLT_STARTF)

/*! @brief Set the STARTF field to a new value. */
#define BW_I2C_FLT_STARTF(x, v) (BME_BFI8(HW_I2C_FLT_ADDR(x), ((uint8_t)(v) << BP_I2C_FLT_STARTF), BP_I2C_FLT_STARTF, 1))
/*@}*/

/*!
 * @name Register I2C_FLT, field SSIE[5] (RW)
 *
 * This bit enables the interrupt for I2C bus stop or start detection. To clear
 * the I2C bus stop or start detection interrupt: In the interrupt service
 * routine, first clear the STOPF or STARTF bit by writing 1 to it, and then clear the
 * IICIF bit in the status register. If this sequence is reversed, the IICIF bit
 * is asserted again.
 *
 * Values:
 * - 0 - Stop or start detection interrupt is disabled
 * - 1 - Stop or start detection interrupt is enabled
 */
/*@{*/
#define BP_I2C_FLT_SSIE      (5U)          /*!< Bit position for I2C_FLT_SSIE. */
#define BM_I2C_FLT_SSIE      (0x20U)       /*!< Bit mask for I2C_FLT_SSIE. */
#define BS_I2C_FLT_SSIE      (1U)          /*!< Bit field size in bits for I2C_FLT_SSIE. */

/*! @brief Read current value of the I2C_FLT_SSIE field. */
#define BR_I2C_FLT_SSIE(x)   (BME_UBFX8(HW_I2C_FLT_ADDR(x), BP_I2C_FLT_SSIE, BS_I2C_FLT_SSIE))

/*! @brief Format value for bitfield I2C_FLT_SSIE. */
#define BF_I2C_FLT_SSIE(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_FLT_SSIE) & BM_I2C_FLT_SSIE)

/*! @brief Set the SSIE field to a new value. */
#define BW_I2C_FLT_SSIE(x, v) (BME_BFI8(HW_I2C_FLT_ADDR(x), ((uint8_t)(v) << BP_I2C_FLT_SSIE), BP_I2C_FLT_SSIE, 1))
/*@}*/

/*!
 * @name Register I2C_FLT, field STOPF[6] (W1C)
 *
 * Hardware sets this bit when the I2C bus's stop status is detected. The STOPF
 * bit must be cleared by writing 1 to it.
 *
 * Values:
 * - 0 - No stop happens on I2C bus
 * - 1 - Stop detected on I2C bus
 */
/*@{*/
#define BP_I2C_FLT_STOPF     (6U)          /*!< Bit position for I2C_FLT_STOPF. */
#define BM_I2C_FLT_STOPF     (0x40U)       /*!< Bit mask for I2C_FLT_STOPF. */
#define BS_I2C_FLT_STOPF     (1U)          /*!< Bit field size in bits for I2C_FLT_STOPF. */

/*! @brief Read current value of the I2C_FLT_STOPF field. */
#define BR_I2C_FLT_STOPF(x)  (BME_UBFX8(HW_I2C_FLT_ADDR(x), BP_I2C_FLT_STOPF, BS_I2C_FLT_STOPF))

/*! @brief Format value for bitfield I2C_FLT_STOPF. */
#define BF_I2C_FLT_STOPF(v)  ((uint8_t)((uint8_t)(v) << BP_I2C_FLT_STOPF) & BM_I2C_FLT_STOPF)

/*! @brief Set the STOPF field to a new value. */
#define BW_I2C_FLT_STOPF(x, v) (BME_BFI8(HW_I2C_FLT_ADDR(x), ((uint8_t)(v) << BP_I2C_FLT_STOPF), BP_I2C_FLT_STOPF, 1))
/*@}*/

/*!
 * @name Register I2C_FLT, field SHEN[7] (RW)
 *
 * Set this bit to hold off entry to stop mode when any data transmission or
 * reception is occurring. The following scenario explains the holdoff
 * functionality: The I2C module is configured for a basic transfer, and the SHEN bit is set
 * to 1. A transfer begins. The MCU signals the I2C module to enter stop mode. The
 * byte currently being transferred, including both address and data, completes
 * its transfer. The I2C slave or master acknowledges that the in-transfer byte
 * completed its transfer and acknowledges the request to enter stop mode. After
 * receiving the I2C module's acknowledgment of the request to enter stop mode,
 * the MCU determines whether to shut off the I2C module's clock. If the SHEN bit
 * is set to 1 and the I2C module is in an idle or disabled state when the MCU
 * signals to enter stop mode, the module immediately acknowledges the request to
 * enter stop mode. If SHEN is cleared to 0 and the overall data transmission or
 * reception that was suspended by stop mode entry was incomplete: To resume the
 * overall transmission or reception after the MCU exits stop mode, software must
 * reinitialize the transfer by resending the address of the slave. If the I2C
 * Control Register 1's IICIE bit was set to 1 before the MCU entered stop mode,
 * system software will receive the interrupt triggered by the I2C Status Register's
 * TCF bit after the MCU wakes from the stop mode.
 *
 * Values:
 * - 0 - Stop holdoff is disabled. The MCU's entry to stop mode is not gated.
 * - 1 - Stop holdoff is enabled.
 */
/*@{*/
#define BP_I2C_FLT_SHEN      (7U)          /*!< Bit position for I2C_FLT_SHEN. */
#define BM_I2C_FLT_SHEN      (0x80U)       /*!< Bit mask for I2C_FLT_SHEN. */
#define BS_I2C_FLT_SHEN      (1U)          /*!< Bit field size in bits for I2C_FLT_SHEN. */

/*! @brief Read current value of the I2C_FLT_SHEN field. */
#define BR_I2C_FLT_SHEN(x)   (BME_UBFX8(HW_I2C_FLT_ADDR(x), BP_I2C_FLT_SHEN, BS_I2C_FLT_SHEN))

/*! @brief Format value for bitfield I2C_FLT_SHEN. */
#define BF_I2C_FLT_SHEN(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_FLT_SHEN) & BM_I2C_FLT_SHEN)

/*! @brief Set the SHEN field to a new value. */
#define BW_I2C_FLT_SHEN(x, v) (BME_BFI8(HW_I2C_FLT_ADDR(x), ((uint8_t)(v) << BP_I2C_FLT_SHEN), BP_I2C_FLT_SHEN, 1))
/*@}*/

/*******************************************************************************
 * HW_I2C_RA - I2C Range Address register
 ******************************************************************************/

/*!
 * @brief HW_I2C_RA - I2C Range Address register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_ra
{
    uint8_t U;
    struct _hw_i2c_ra_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t RAD : 7;               /*!< [7:1] Range Slave Address */
    } B;
} hw_i2c_ra_t;

/*!
 * @name Constants and macros for entire I2C_RA register
 */
/*@{*/
#define HW_I2C_RA_ADDR(x)        ((uint32_t)(x) + 0x7U)

#define HW_I2C_RA(x)             (*(__IO hw_i2c_ra_t *) HW_I2C_RA_ADDR(x))
#define HW_I2C_RA_RD(x)          (HW_I2C_RA(x).U)
#define HW_I2C_RA_WR(x, v)       (HW_I2C_RA(x).U = (v))
#define HW_I2C_RA_SET(x, v)      (BME_OR8(HW_I2C_RA_ADDR(x), (uint8_t)(v)))
#define HW_I2C_RA_CLR(x, v)      (BME_AND8(HW_I2C_RA_ADDR(x), (uint8_t)(~(v))))
#define HW_I2C_RA_TOG(x, v)      (BME_XOR8(HW_I2C_RA_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2C_RA bitfields
 */

/*!
 * @name Register I2C_RA, field RAD[7:1] (RW)
 *
 * This field contains the slave address to be used by the I2C module. The field
 * is used in the 7-bit address scheme. If I2C_C2[RMEN] is set to 1, any nonzero
 * value write enables this register. This register value can be considered as a
 * maximum boundary in the range matching mode.
 */
/*@{*/
#define BP_I2C_RA_RAD        (1U)          /*!< Bit position for I2C_RA_RAD. */
#define BM_I2C_RA_RAD        (0xFEU)       /*!< Bit mask for I2C_RA_RAD. */
#define BS_I2C_RA_RAD        (7U)          /*!< Bit field size in bits for I2C_RA_RAD. */

/*! @brief Read current value of the I2C_RA_RAD field. */
#define BR_I2C_RA_RAD(x)     (BME_UBFX8(HW_I2C_RA_ADDR(x), BP_I2C_RA_RAD, BS_I2C_RA_RAD))

/*! @brief Format value for bitfield I2C_RA_RAD. */
#define BF_I2C_RA_RAD(v)     ((uint8_t)((uint8_t)(v) << BP_I2C_RA_RAD) & BM_I2C_RA_RAD)

/*! @brief Set the RAD field to a new value. */
#define BW_I2C_RA_RAD(x, v)  (BME_BFI8(HW_I2C_RA_ADDR(x), ((uint8_t)(v) << BP_I2C_RA_RAD), BP_I2C_RA_RAD, 7))
/*@}*/

/*******************************************************************************
 * HW_I2C_SMB - I2C SMBus Control and Status register
 ******************************************************************************/

/*!
 * @brief HW_I2C_SMB - I2C SMBus Control and Status register (RW)
 *
 * Reset value: 0x00U
 *
 * When the SCL and SDA signals are held high for a length of time greater than
 * the high timeout period, the SHTF1 flag sets. Before reaching this threshold,
 * while the system is detecting how long these signals are being held high, a
 * master assumes that the bus is free. However, the SHTF1 bit is set to 1 in the
 * bus transmission process with the idle bus state. When the TCKSEL bit is set,
 * there is no need to monitor the SHTF1 bit because the bus speed is too high to
 * match the protocol of SMBus.
 */
typedef union _hw_i2c_smb
{
    uint8_t U;
    struct _hw_i2c_smb_bitfields
    {
        uint8_t SHTF2IE : 1;           /*!< [0] SHTF2 Interrupt Enable */
        uint8_t SHTF2 : 1;             /*!< [1] SCL High Timeout Flag 2 */
        uint8_t SHTF1 : 1;             /*!< [2] SCL High Timeout Flag 1 */
        uint8_t SLTF : 1;              /*!< [3] SCL Low Timeout Flag */
        uint8_t TCKSEL : 1;            /*!< [4] Timeout Counter Clock Select */
        uint8_t SIICAEN : 1;           /*!< [5] Second I2C Address Enable */
        uint8_t ALERTEN : 1;           /*!< [6] SMBus Alert Response Address Enable */
        uint8_t FACK : 1;              /*!< [7] Fast NACK/ACK Enable */
    } B;
} hw_i2c_smb_t;

/*!
 * @name Constants and macros for entire I2C_SMB register
 */
/*@{*/
#define HW_I2C_SMB_ADDR(x)       ((uint32_t)(x) + 0x8U)

#define HW_I2C_SMB(x)            (*(__IO hw_i2c_smb_t *) HW_I2C_SMB_ADDR(x))
#define HW_I2C_SMB_RD(x)         (HW_I2C_SMB(x).U)
#define HW_I2C_SMB_WR(x, v)      (HW_I2C_SMB(x).U = (v))
#define HW_I2C_SMB_SET(x, v)     (BME_OR8(HW_I2C_SMB_ADDR(x), (uint8_t)(v)))
#define HW_I2C_SMB_CLR(x, v)     (BME_AND8(HW_I2C_SMB_ADDR(x), (uint8_t)(~(v))))
#define HW_I2C_SMB_TOG(x, v)     (BME_XOR8(HW_I2C_SMB_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2C_SMB bitfields
 */

/*!
 * @name Register I2C_SMB, field SHTF2IE[0] (RW)
 *
 * Enables SCL high and SDA low timeout interrupt.
 *
 * Values:
 * - 0 - SHTF2 interrupt is disabled
 * - 1 - SHTF2 interrupt is enabled
 */
/*@{*/
#define BP_I2C_SMB_SHTF2IE   (0U)          /*!< Bit position for I2C_SMB_SHTF2IE. */
#define BM_I2C_SMB_SHTF2IE   (0x01U)       /*!< Bit mask for I2C_SMB_SHTF2IE. */
#define BS_I2C_SMB_SHTF2IE   (1U)          /*!< Bit field size in bits for I2C_SMB_SHTF2IE. */

/*! @brief Read current value of the I2C_SMB_SHTF2IE field. */
#define BR_I2C_SMB_SHTF2IE(x) (BME_UBFX8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_SHTF2IE, BS_I2C_SMB_SHTF2IE))

/*! @brief Format value for bitfield I2C_SMB_SHTF2IE. */
#define BF_I2C_SMB_SHTF2IE(v) ((uint8_t)((uint8_t)(v) << BP_I2C_SMB_SHTF2IE) & BM_I2C_SMB_SHTF2IE)

/*! @brief Set the SHTF2IE field to a new value. */
#define BW_I2C_SMB_SHTF2IE(x, v) (BME_BFI8(HW_I2C_SMB_ADDR(x), ((uint8_t)(v) << BP_I2C_SMB_SHTF2IE), BP_I2C_SMB_SHTF2IE, 1))
/*@}*/

/*!
 * @name Register I2C_SMB, field SHTF2[1] (W1C)
 *
 * This bit sets when SCL is held high and SDA is held low more than clock *
 * LoValue / 512. Software clears this bit by writing 1 to it.
 *
 * Values:
 * - 0 - No SCL high and SDA low timeout occurs
 * - 1 - SCL high and SDA low timeout occurs
 */
/*@{*/
#define BP_I2C_SMB_SHTF2     (1U)          /*!< Bit position for I2C_SMB_SHTF2. */
#define BM_I2C_SMB_SHTF2     (0x02U)       /*!< Bit mask for I2C_SMB_SHTF2. */
#define BS_I2C_SMB_SHTF2     (1U)          /*!< Bit field size in bits for I2C_SMB_SHTF2. */

/*! @brief Read current value of the I2C_SMB_SHTF2 field. */
#define BR_I2C_SMB_SHTF2(x)  (BME_UBFX8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_SHTF2, BS_I2C_SMB_SHTF2))

/*! @brief Format value for bitfield I2C_SMB_SHTF2. */
#define BF_I2C_SMB_SHTF2(v)  ((uint8_t)((uint8_t)(v) << BP_I2C_SMB_SHTF2) & BM_I2C_SMB_SHTF2)

/*! @brief Set the SHTF2 field to a new value. */
#define BW_I2C_SMB_SHTF2(x, v) (BME_BFI8(HW_I2C_SMB_ADDR(x), ((uint8_t)(v) << BP_I2C_SMB_SHTF2), BP_I2C_SMB_SHTF2, 1))
/*@}*/

/*!
 * @name Register I2C_SMB, field SHTF1[2] (RO)
 *
 * This read-only bit sets when SCL and SDA are held high more than clock *
 * LoValue / 512, which indicates the bus is free. This bit is cleared automatically.
 *
 * Values:
 * - 0 - No SCL high and SDA high timeout occurs
 * - 1 - SCL high and SDA high timeout occurs
 */
/*@{*/
#define BP_I2C_SMB_SHTF1     (2U)          /*!< Bit position for I2C_SMB_SHTF1. */
#define BM_I2C_SMB_SHTF1     (0x04U)       /*!< Bit mask for I2C_SMB_SHTF1. */
#define BS_I2C_SMB_SHTF1     (1U)          /*!< Bit field size in bits for I2C_SMB_SHTF1. */

/*! @brief Read current value of the I2C_SMB_SHTF1 field. */
#define BR_I2C_SMB_SHTF1(x)  (BME_UBFX8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_SHTF1, BS_I2C_SMB_SHTF1))
/*@}*/

/*!
 * @name Register I2C_SMB, field SLTF[3] (W1C)
 *
 * This bit is set when the SLT register (consisting of the SLTH and SLTL
 * registers) is loaded with a non-zero value (LoValue) and an SCL low timeout occurs.
 * Software clears this bit by writing a logic 1 to it. The low timeout function
 * is disabled when the SLT register's value is 0.
 *
 * Values:
 * - 0 - No low timeout occurs
 * - 1 - Low timeout occurs
 */
/*@{*/
#define BP_I2C_SMB_SLTF      (3U)          /*!< Bit position for I2C_SMB_SLTF. */
#define BM_I2C_SMB_SLTF      (0x08U)       /*!< Bit mask for I2C_SMB_SLTF. */
#define BS_I2C_SMB_SLTF      (1U)          /*!< Bit field size in bits for I2C_SMB_SLTF. */

/*! @brief Read current value of the I2C_SMB_SLTF field. */
#define BR_I2C_SMB_SLTF(x)   (BME_UBFX8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_SLTF, BS_I2C_SMB_SLTF))

/*! @brief Format value for bitfield I2C_SMB_SLTF. */
#define BF_I2C_SMB_SLTF(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_SMB_SLTF) & BM_I2C_SMB_SLTF)

/*! @brief Set the SLTF field to a new value. */
#define BW_I2C_SMB_SLTF(x, v) (BME_BFI8(HW_I2C_SMB_ADDR(x), ((uint8_t)(v) << BP_I2C_SMB_SLTF), BP_I2C_SMB_SLTF, 1))
/*@}*/

/*!
 * @name Register I2C_SMB, field TCKSEL[4] (RW)
 *
 * Selects the clock source of the timeout counter.
 *
 * Values:
 * - 0 - Timeout counter counts at the frequency of the I2C module clock / 64
 * - 1 - Timeout counter counts at the frequency of the I2C module clock
 */
/*@{*/
#define BP_I2C_SMB_TCKSEL    (4U)          /*!< Bit position for I2C_SMB_TCKSEL. */
#define BM_I2C_SMB_TCKSEL    (0x10U)       /*!< Bit mask for I2C_SMB_TCKSEL. */
#define BS_I2C_SMB_TCKSEL    (1U)          /*!< Bit field size in bits for I2C_SMB_TCKSEL. */

/*! @brief Read current value of the I2C_SMB_TCKSEL field. */
#define BR_I2C_SMB_TCKSEL(x) (BME_UBFX8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_TCKSEL, BS_I2C_SMB_TCKSEL))

/*! @brief Format value for bitfield I2C_SMB_TCKSEL. */
#define BF_I2C_SMB_TCKSEL(v) ((uint8_t)((uint8_t)(v) << BP_I2C_SMB_TCKSEL) & BM_I2C_SMB_TCKSEL)

/*! @brief Set the TCKSEL field to a new value. */
#define BW_I2C_SMB_TCKSEL(x, v) (BME_BFI8(HW_I2C_SMB_ADDR(x), ((uint8_t)(v) << BP_I2C_SMB_TCKSEL), BP_I2C_SMB_TCKSEL, 1))
/*@}*/

/*!
 * @name Register I2C_SMB, field SIICAEN[5] (RW)
 *
 * Enables or disables SMBus device default address.
 *
 * Values:
 * - 0 - I2C address register 2 matching is disabled
 * - 1 - I2C address register 2 matching is enabled
 */
/*@{*/
#define BP_I2C_SMB_SIICAEN   (5U)          /*!< Bit position for I2C_SMB_SIICAEN. */
#define BM_I2C_SMB_SIICAEN   (0x20U)       /*!< Bit mask for I2C_SMB_SIICAEN. */
#define BS_I2C_SMB_SIICAEN   (1U)          /*!< Bit field size in bits for I2C_SMB_SIICAEN. */

/*! @brief Read current value of the I2C_SMB_SIICAEN field. */
#define BR_I2C_SMB_SIICAEN(x) (BME_UBFX8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_SIICAEN, BS_I2C_SMB_SIICAEN))

/*! @brief Format value for bitfield I2C_SMB_SIICAEN. */
#define BF_I2C_SMB_SIICAEN(v) ((uint8_t)((uint8_t)(v) << BP_I2C_SMB_SIICAEN) & BM_I2C_SMB_SIICAEN)

/*! @brief Set the SIICAEN field to a new value. */
#define BW_I2C_SMB_SIICAEN(x, v) (BME_BFI8(HW_I2C_SMB_ADDR(x), ((uint8_t)(v) << BP_I2C_SMB_SIICAEN), BP_I2C_SMB_SIICAEN, 1))
/*@}*/

/*!
 * @name Register I2C_SMB, field ALERTEN[6] (RW)
 *
 * Enables or disables SMBus alert response address matching. After the host
 * responds to a device that used the alert response address, you must use software
 * to put the device's address on the bus. The alert protocol is described in the
 * SMBus specification.
 *
 * Values:
 * - 0 - SMBus alert response address matching is disabled
 * - 1 - SMBus alert response address matching is enabled
 */
/*@{*/
#define BP_I2C_SMB_ALERTEN   (6U)          /*!< Bit position for I2C_SMB_ALERTEN. */
#define BM_I2C_SMB_ALERTEN   (0x40U)       /*!< Bit mask for I2C_SMB_ALERTEN. */
#define BS_I2C_SMB_ALERTEN   (1U)          /*!< Bit field size in bits for I2C_SMB_ALERTEN. */

/*! @brief Read current value of the I2C_SMB_ALERTEN field. */
#define BR_I2C_SMB_ALERTEN(x) (BME_UBFX8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_ALERTEN, BS_I2C_SMB_ALERTEN))

/*! @brief Format value for bitfield I2C_SMB_ALERTEN. */
#define BF_I2C_SMB_ALERTEN(v) ((uint8_t)((uint8_t)(v) << BP_I2C_SMB_ALERTEN) & BM_I2C_SMB_ALERTEN)

/*! @brief Set the ALERTEN field to a new value. */
#define BW_I2C_SMB_ALERTEN(x, v) (BME_BFI8(HW_I2C_SMB_ADDR(x), ((uint8_t)(v) << BP_I2C_SMB_ALERTEN), BP_I2C_SMB_ALERTEN, 1))
/*@}*/

/*!
 * @name Register I2C_SMB, field FACK[7] (RW)
 *
 * For SMBus packet error checking, the CPU must be able to issue an ACK or NACK
 * according to the result of receiving data byte.
 *
 * Values:
 * - 0 - An ACK or NACK is sent on the following receiving data byte
 * - 1 - Writing 0 to TXAK after receiving a data byte generates an ACK. Writing
 *     1 to TXAK after receiving a data byte generates a NACK.
 */
/*@{*/
#define BP_I2C_SMB_FACK      (7U)          /*!< Bit position for I2C_SMB_FACK. */
#define BM_I2C_SMB_FACK      (0x80U)       /*!< Bit mask for I2C_SMB_FACK. */
#define BS_I2C_SMB_FACK      (1U)          /*!< Bit field size in bits for I2C_SMB_FACK. */

/*! @brief Read current value of the I2C_SMB_FACK field. */
#define BR_I2C_SMB_FACK(x)   (BME_UBFX8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_FACK, BS_I2C_SMB_FACK))

/*! @brief Format value for bitfield I2C_SMB_FACK. */
#define BF_I2C_SMB_FACK(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_SMB_FACK) & BM_I2C_SMB_FACK)

/*! @brief Set the FACK field to a new value. */
#define BW_I2C_SMB_FACK(x, v) (BME_BFI8(HW_I2C_SMB_ADDR(x), ((uint8_t)(v) << BP_I2C_SMB_FACK), BP_I2C_SMB_FACK, 1))
/*@}*/

/*******************************************************************************
 * HW_I2C_A2 - I2C Address Register 2
 ******************************************************************************/

/*!
 * @brief HW_I2C_A2 - I2C Address Register 2 (RW)
 *
 * Reset value: 0xC2U
 */
typedef union _hw_i2c_a2
{
    uint8_t U;
    struct _hw_i2c_a2_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t SAD : 7;               /*!< [7:1] SMBus Address */
    } B;
} hw_i2c_a2_t;

/*!
 * @name Constants and macros for entire I2C_A2 register
 */
/*@{*/
#define HW_I2C_A2_ADDR(x)        ((uint32_t)(x) + 0x9U)

#define HW_I2C_A2(x)             (*(__IO hw_i2c_a2_t *) HW_I2C_A2_ADDR(x))
#define HW_I2C_A2_RD(x)          (HW_I2C_A2(x).U)
#define HW_I2C_A2_WR(x, v)       (HW_I2C_A2(x).U = (v))
#define HW_I2C_A2_SET(x, v)      (BME_OR8(HW_I2C_A2_ADDR(x), (uint8_t)(v)))
#define HW_I2C_A2_CLR(x, v)      (BME_AND8(HW_I2C_A2_ADDR(x), (uint8_t)(~(v))))
#define HW_I2C_A2_TOG(x, v)      (BME_XOR8(HW_I2C_A2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2C_A2 bitfields
 */

/*!
 * @name Register I2C_A2, field SAD[7:1] (RW)
 *
 * Contains the slave address used by the SMBus. This field is used on the
 * device default address or other related addresses.
 */
/*@{*/
#define BP_I2C_A2_SAD        (1U)          /*!< Bit position for I2C_A2_SAD. */
#define BM_I2C_A2_SAD        (0xFEU)       /*!< Bit mask for I2C_A2_SAD. */
#define BS_I2C_A2_SAD        (7U)          /*!< Bit field size in bits for I2C_A2_SAD. */

/*! @brief Read current value of the I2C_A2_SAD field. */
#define BR_I2C_A2_SAD(x)     (BME_UBFX8(HW_I2C_A2_ADDR(x), BP_I2C_A2_SAD, BS_I2C_A2_SAD))

/*! @brief Format value for bitfield I2C_A2_SAD. */
#define BF_I2C_A2_SAD(v)     ((uint8_t)((uint8_t)(v) << BP_I2C_A2_SAD) & BM_I2C_A2_SAD)

/*! @brief Set the SAD field to a new value. */
#define BW_I2C_A2_SAD(x, v)  (BME_BFI8(HW_I2C_A2_ADDR(x), ((uint8_t)(v) << BP_I2C_A2_SAD), BP_I2C_A2_SAD, 7))
/*@}*/

/*******************************************************************************
 * HW_I2C_SLTH - I2C SCL Low Timeout Register High
 ******************************************************************************/

/*!
 * @brief HW_I2C_SLTH - I2C SCL Low Timeout Register High (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_slth
{
    uint8_t U;
    struct _hw_i2c_slth_bitfields
    {
        uint8_t SSLT : 8;              /*!< [7:0] SSLT[15:8] */
    } B;
} hw_i2c_slth_t;

/*!
 * @name Constants and macros for entire I2C_SLTH register
 */
/*@{*/
#define HW_I2C_SLTH_ADDR(x)      ((uint32_t)(x) + 0xAU)

#define HW_I2C_SLTH(x)           (*(__IO hw_i2c_slth_t *) HW_I2C_SLTH_ADDR(x))
#define HW_I2C_SLTH_RD(x)        (HW_I2C_SLTH(x).U)
#define HW_I2C_SLTH_WR(x, v)     (HW_I2C_SLTH(x).U = (v))
#define HW_I2C_SLTH_SET(x, v)    (BME_OR8(HW_I2C_SLTH_ADDR(x), (uint8_t)(v)))
#define HW_I2C_SLTH_CLR(x, v)    (BME_AND8(HW_I2C_SLTH_ADDR(x), (uint8_t)(~(v))))
#define HW_I2C_SLTH_TOG(x, v)    (BME_XOR8(HW_I2C_SLTH_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2C_SLTH bitfields
 */

/*!
 * @name Register I2C_SLTH, field SSLT[7:0] (RW)
 *
 * Most significant byte of SCL low timeout value that determines the timeout
 * period of SCL low.
 */
/*@{*/
#define BP_I2C_SLTH_SSLT     (0U)          /*!< Bit position for I2C_SLTH_SSLT. */
#define BM_I2C_SLTH_SSLT     (0xFFU)       /*!< Bit mask for I2C_SLTH_SSLT. */
#define BS_I2C_SLTH_SSLT     (8U)          /*!< Bit field size in bits for I2C_SLTH_SSLT. */

/*! @brief Read current value of the I2C_SLTH_SSLT field. */
#define BR_I2C_SLTH_SSLT(x)  (HW_I2C_SLTH(x).U)

/*! @brief Format value for bitfield I2C_SLTH_SSLT. */
#define BF_I2C_SLTH_SSLT(v)  ((uint8_t)((uint8_t)(v) << BP_I2C_SLTH_SSLT) & BM_I2C_SLTH_SSLT)

/*! @brief Set the SSLT field to a new value. */
#define BW_I2C_SLTH_SSLT(x, v) (HW_I2C_SLTH_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_I2C_SLTL - I2C SCL Low Timeout Register Low
 ******************************************************************************/

/*!
 * @brief HW_I2C_SLTL - I2C SCL Low Timeout Register Low (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_sltl
{
    uint8_t U;
    struct _hw_i2c_sltl_bitfields
    {
        uint8_t SSLT : 8;              /*!< [7:0] SSLT[7:0] */
    } B;
} hw_i2c_sltl_t;

/*!
 * @name Constants and macros for entire I2C_SLTL register
 */
/*@{*/
#define HW_I2C_SLTL_ADDR(x)      ((uint32_t)(x) + 0xBU)

#define HW_I2C_SLTL(x)           (*(__IO hw_i2c_sltl_t *) HW_I2C_SLTL_ADDR(x))
#define HW_I2C_SLTL_RD(x)        (HW_I2C_SLTL(x).U)
#define HW_I2C_SLTL_WR(x, v)     (HW_I2C_SLTL(x).U = (v))
#define HW_I2C_SLTL_SET(x, v)    (BME_OR8(HW_I2C_SLTL_ADDR(x), (uint8_t)(v)))
#define HW_I2C_SLTL_CLR(x, v)    (BME_AND8(HW_I2C_SLTL_ADDR(x), (uint8_t)(~(v))))
#define HW_I2C_SLTL_TOG(x, v)    (BME_XOR8(HW_I2C_SLTL_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2C_SLTL bitfields
 */

/*!
 * @name Register I2C_SLTL, field SSLT[7:0] (RW)
 *
 * Least significant byte of SCL low timeout value that determines the timeout
 * period of SCL low.
 */
/*@{*/
#define BP_I2C_SLTL_SSLT     (0U)          /*!< Bit position for I2C_SLTL_SSLT. */
#define BM_I2C_SLTL_SSLT     (0xFFU)       /*!< Bit mask for I2C_SLTL_SSLT. */
#define BS_I2C_SLTL_SSLT     (8U)          /*!< Bit field size in bits for I2C_SLTL_SSLT. */

/*! @brief Read current value of the I2C_SLTL_SSLT field. */
#define BR_I2C_SLTL_SSLT(x)  (HW_I2C_SLTL(x).U)

/*! @brief Format value for bitfield I2C_SLTL_SSLT. */
#define BF_I2C_SLTL_SSLT(v)  ((uint8_t)((uint8_t)(v) << BP_I2C_SLTL_SSLT) & BM_I2C_SLTL_SSLT)

/*! @brief Set the SSLT field to a new value. */
#define BW_I2C_SLTL_SSLT(x, v) (HW_I2C_SLTL_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_I2C_S2 - I2C Status register 2
 ******************************************************************************/

/*!
 * @brief HW_I2C_S2 - I2C Status register 2 (RW)
 *
 * Reset value: 0x01U
 */
typedef union _hw_i2c_s2
{
    uint8_t U;
    struct _hw_i2c_s2_bitfields
    {
        uint8_t EMPTY : 1;             /*!< [0] Empty flag */
        uint8_t ERROR : 1;             /*!< [1] Error flag */
        uint8_t RESERVED0 : 6;         /*!< [7:2]  */
    } B;
} hw_i2c_s2_t;

/*!
 * @name Constants and macros for entire I2C_S2 register
 */
/*@{*/
#define HW_I2C_S2_ADDR(x)        ((uint32_t)(x) + 0xCU)

#define HW_I2C_S2(x)             (*(__IO hw_i2c_s2_t *) HW_I2C_S2_ADDR(x))
#define HW_I2C_S2_RD(x)          (HW_I2C_S2(x).U)
#define HW_I2C_S2_WR(x, v)       (HW_I2C_S2(x).U = (v))
#define HW_I2C_S2_SET(x, v)      (BME_OR8(HW_I2C_S2_ADDR(x), (uint8_t)(v)))
#define HW_I2C_S2_CLR(x, v)      (BME_AND8(HW_I2C_S2_ADDR(x), (uint8_t)(~(v))))
#define HW_I2C_S2_TOG(x, v)      (BME_XOR8(HW_I2C_S2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2C_S2 bitfields
 */

/*!
 * @name Register I2C_S2, field EMPTY[0] (RO)
 *
 * Indicates if the Tx or Rx buffer is empty.
 *
 * Values:
 * - 0 - Tx or Rx buffer is not empty and cannot be written to, that is new data
 *     cannot be loaded into the buffer.
 * - 1 - Tx or Rx buffer is empty and can be written to, that is new data can be
 *     loaded into the buffer.
 */
/*@{*/
#define BP_I2C_S2_EMPTY      (0U)          /*!< Bit position for I2C_S2_EMPTY. */
#define BM_I2C_S2_EMPTY      (0x01U)       /*!< Bit mask for I2C_S2_EMPTY. */
#define BS_I2C_S2_EMPTY      (1U)          /*!< Bit field size in bits for I2C_S2_EMPTY. */

/*! @brief Read current value of the I2C_S2_EMPTY field. */
#define BR_I2C_S2_EMPTY(x)   (BME_UBFX8(HW_I2C_S2_ADDR(x), BP_I2C_S2_EMPTY, BS_I2C_S2_EMPTY))
/*@}*/

/*!
 * @name Register I2C_S2, field ERROR[1] (W1C)
 *
 * Indicates if there are read or write errors with the Tx and Rx buffers.
 *
 * Values:
 * - 0 - The buffer is not full and all write/read operations have no errors.
 * - 1 - There are 3 or more write/read errors during the data transfer phase
 *     (when the Empty flag is not set and the buffer is busy).
 */
/*@{*/
#define BP_I2C_S2_ERROR      (1U)          /*!< Bit position for I2C_S2_ERROR. */
#define BM_I2C_S2_ERROR      (0x02U)       /*!< Bit mask for I2C_S2_ERROR. */
#define BS_I2C_S2_ERROR      (1U)          /*!< Bit field size in bits for I2C_S2_ERROR. */

/*! @brief Read current value of the I2C_S2_ERROR field. */
#define BR_I2C_S2_ERROR(x)   (BME_UBFX8(HW_I2C_S2_ADDR(x), BP_I2C_S2_ERROR, BS_I2C_S2_ERROR))

/*! @brief Format value for bitfield I2C_S2_ERROR. */
#define BF_I2C_S2_ERROR(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_S2_ERROR) & BM_I2C_S2_ERROR)

/*! @brief Set the ERROR field to a new value. */
#define BW_I2C_S2_ERROR(x, v) (BME_BFI8(HW_I2C_S2_ADDR(x), ((uint8_t)(v) << BP_I2C_S2_ERROR), BP_I2C_S2_ERROR, 1))
/*@}*/

/*******************************************************************************
 * hw_i2c_t - module struct
 ******************************************************************************/
/*!
 * @brief All I2C module registers.
 */
#pragma pack(1)
typedef struct _hw_i2c
{
    __IO hw_i2c_a1_t A1;                   /*!< [0x0] I2C Address Register 1 */
    __IO hw_i2c_f_t F;                     /*!< [0x1] I2C Frequency Divider register */
    __IO hw_i2c_c1_t C1;                   /*!< [0x2] I2C Control Register 1 */
    __IO hw_i2c_s_t S;                     /*!< [0x3] I2C Status register */
    __IO hw_i2c_d_t D;                     /*!< [0x4] I2C Data I/O register */
    __IO hw_i2c_c2_t C2;                   /*!< [0x5] I2C Control Register 2 */
    __IO hw_i2c_flt_t FLT;                 /*!< [0x6] I2C Programmable Input Glitch Filter Register */
    __IO hw_i2c_ra_t RA;                   /*!< [0x7] I2C Range Address register */
    __IO hw_i2c_smb_t SMB;                 /*!< [0x8] I2C SMBus Control and Status register */
    __IO hw_i2c_a2_t A2;                   /*!< [0x9] I2C Address Register 2 */
    __IO hw_i2c_slth_t SLTH;               /*!< [0xA] I2C SCL Low Timeout Register High */
    __IO hw_i2c_sltl_t SLTL;               /*!< [0xB] I2C SCL Low Timeout Register Low */
    __IO hw_i2c_s2_t S2;                   /*!< [0xC] I2C Status register 2 */
} hw_i2c_t;
#pragma pack()

/*! @brief Macro to access all I2C registers. */
/*! @param x I2C module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_I2C_REGS(I2C0_BASE)</code>. */
#define HW_I2C_REGS(x) (*(hw_i2c_t *)(x))

/*
 * MKL43Z4 I2S
 *
 * Inter-IC Sound / Synchronous Audio Interface
 *
 * Registers defined in this header file:
 * - HW_I2S_TCSR - SAI Transmit Control Register
 * - HW_I2S_TCR2 - SAI Transmit Configuration 2 Register
 * - HW_I2S_TCR3 - SAI Transmit Configuration 3 Register
 * - HW_I2S_TCR4 - SAI Transmit Configuration 4 Register
 * - HW_I2S_TCR5 - SAI Transmit Configuration 5 Register
 * - HW_I2S_TDRn - SAI Transmit Data Register
 * - HW_I2S_TMR - SAI Transmit Mask Register
 * - HW_I2S_RCSR - SAI Receive Control Register
 * - HW_I2S_RCR2 - SAI Receive Configuration 2 Register
 * - HW_I2S_RCR3 - SAI Receive Configuration 3 Register
 * - HW_I2S_RCR4 - SAI Receive Configuration 4 Register
 * - HW_I2S_RCR5 - SAI Receive Configuration 5 Register
 * - HW_I2S_RDRn - SAI Receive Data Register
 * - HW_I2S_RMR - SAI Receive Mask Register
 * - HW_I2S_MCR - SAI MCLK Control Register
 *
 * - hw_i2s_t - Struct containing all module registers.
 */

#define HW_I2S_INSTANCE_COUNT (1U) /*!< Number of instances of the I2S module. */
#define HW_I2S0 (0U) /*!< Instance number for I2S0. */

/*******************************************************************************
 * HW_I2S_TCSR - SAI Transmit Control Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_TCSR - SAI Transmit Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_i2s_tcsr
{
    uint32_t U;
    struct _hw_i2s_tcsr_bitfields
    {
        uint32_t RESERVED0 : 1;        /*!< [0]  */
        uint32_t FWDE : 1;             /*!< [1] FIFO Warning DMA Enable */
        uint32_t RESERVED1 : 7;        /*!< [8:2]  */
        uint32_t FWIE : 1;             /*!< [9] FIFO Warning Interrupt Enable */
        uint32_t FEIE : 1;             /*!< [10] FIFO Error Interrupt Enable */
        uint32_t SEIE : 1;             /*!< [11] Sync Error Interrupt Enable */
        uint32_t WSIE : 1;             /*!< [12] Word Start Interrupt Enable */
        uint32_t RESERVED2 : 4;        /*!< [16:13]  */
        uint32_t FWF : 1;              /*!< [17] FIFO Warning Flag */
        uint32_t FEF : 1;              /*!< [18] FIFO Error Flag */
        uint32_t SEF : 1;              /*!< [19] Sync Error Flag */
        uint32_t WSF : 1;              /*!< [20] Word Start Flag */
        uint32_t RESERVED3 : 3;        /*!< [23:21]  */
        uint32_t SR : 1;               /*!< [24] Software Reset */
        uint32_t FR : 1;               /*!< [25] FIFO Reset */
        uint32_t RESERVED4 : 2;        /*!< [27:26]  */
        uint32_t BCE : 1;              /*!< [28] Bit Clock Enable */
        uint32_t DBGE : 1;             /*!< [29] Debug Enable */
        uint32_t STOPE : 1;            /*!< [30] Stop Enable */
        uint32_t TE : 1;               /*!< [31] Transmitter Enable */
    } B;
} hw_i2s_tcsr_t;

/*!
 * @name Constants and macros for entire I2S_TCSR register
 */
/*@{*/
#define HW_I2S_TCSR_ADDR(x)      ((uint32_t)(x) + 0x0U)

#define HW_I2S_TCSR(x)           (*(__IO hw_i2s_tcsr_t *) HW_I2S_TCSR_ADDR(x))
#define HW_I2S_TCSR_RD(x)        (HW_I2S_TCSR(x).U)
#define HW_I2S_TCSR_WR(x, v)     (HW_I2S_TCSR(x).U = (v))
#define HW_I2S_TCSR_SET(x, v)    (BME_OR32(HW_I2S_TCSR_ADDR(x), (uint32_t)(v)))
#define HW_I2S_TCSR_CLR(x, v)    (BME_AND32(HW_I2S_TCSR_ADDR(x), (uint32_t)(~(v))))
#define HW_I2S_TCSR_TOG(x, v)    (BME_XOR32(HW_I2S_TCSR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCSR bitfields
 */

/*!
 * @name Register I2S_TCSR, field FWDE[1] (RW)
 *
 * Enables/disables DMA requests.
 *
 * Values:
 * - 0 - Disables the DMA request.
 * - 1 - Enables the DMA request.
 */
/*@{*/
#define BP_I2S_TCSR_FWDE     (1U)          /*!< Bit position for I2S_TCSR_FWDE. */
#define BM_I2S_TCSR_FWDE     (0x00000002U) /*!< Bit mask for I2S_TCSR_FWDE. */
#define BS_I2S_TCSR_FWDE     (1U)          /*!< Bit field size in bits for I2S_TCSR_FWDE. */

/*! @brief Read current value of the I2S_TCSR_FWDE field. */
#define BR_I2S_TCSR_FWDE(x)  (BME_UBFX32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_FWDE, BS_I2S_TCSR_FWDE))

/*! @brief Format value for bitfield I2S_TCSR_FWDE. */
#define BF_I2S_TCSR_FWDE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_FWDE) & BM_I2S_TCSR_FWDE)

/*! @brief Set the FWDE field to a new value. */
#define BW_I2S_TCSR_FWDE(x, v) (BME_BFI32(HW_I2S_TCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_TCSR_FWDE), BP_I2S_TCSR_FWDE, 1))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FWIE[9] (RW)
 *
 * Enables/disables FIFO warning interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt.
 * - 1 - Enables the interrupt.
 */
/*@{*/
#define BP_I2S_TCSR_FWIE     (9U)          /*!< Bit position for I2S_TCSR_FWIE. */
#define BM_I2S_TCSR_FWIE     (0x00000200U) /*!< Bit mask for I2S_TCSR_FWIE. */
#define BS_I2S_TCSR_FWIE     (1U)          /*!< Bit field size in bits for I2S_TCSR_FWIE. */

/*! @brief Read current value of the I2S_TCSR_FWIE field. */
#define BR_I2S_TCSR_FWIE(x)  (BME_UBFX32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_FWIE, BS_I2S_TCSR_FWIE))

/*! @brief Format value for bitfield I2S_TCSR_FWIE. */
#define BF_I2S_TCSR_FWIE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_FWIE) & BM_I2S_TCSR_FWIE)

/*! @brief Set the FWIE field to a new value. */
#define BW_I2S_TCSR_FWIE(x, v) (BME_BFI32(HW_I2S_TCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_TCSR_FWIE), BP_I2S_TCSR_FWIE, 1))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FEIE[10] (RW)
 *
 * Enables/disables FIFO error interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt.
 * - 1 - Enables the interrupt.
 */
/*@{*/
#define BP_I2S_TCSR_FEIE     (10U)         /*!< Bit position for I2S_TCSR_FEIE. */
#define BM_I2S_TCSR_FEIE     (0x00000400U) /*!< Bit mask for I2S_TCSR_FEIE. */
#define BS_I2S_TCSR_FEIE     (1U)          /*!< Bit field size in bits for I2S_TCSR_FEIE. */

/*! @brief Read current value of the I2S_TCSR_FEIE field. */
#define BR_I2S_TCSR_FEIE(x)  (BME_UBFX32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_FEIE, BS_I2S_TCSR_FEIE))

/*! @brief Format value for bitfield I2S_TCSR_FEIE. */
#define BF_I2S_TCSR_FEIE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_FEIE) & BM_I2S_TCSR_FEIE)

/*! @brief Set the FEIE field to a new value. */
#define BW_I2S_TCSR_FEIE(x, v) (BME_BFI32(HW_I2S_TCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_TCSR_FEIE), BP_I2S_TCSR_FEIE, 1))
/*@}*/

/*!
 * @name Register I2S_TCSR, field SEIE[11] (RW)
 *
 * Enables/disables sync error interrupts.
 *
 * Values:
 * - 0 - Disables interrupt.
 * - 1 - Enables interrupt.
 */
/*@{*/
#define BP_I2S_TCSR_SEIE     (11U)         /*!< Bit position for I2S_TCSR_SEIE. */
#define BM_I2S_TCSR_SEIE     (0x00000800U) /*!< Bit mask for I2S_TCSR_SEIE. */
#define BS_I2S_TCSR_SEIE     (1U)          /*!< Bit field size in bits for I2S_TCSR_SEIE. */

/*! @brief Read current value of the I2S_TCSR_SEIE field. */
#define BR_I2S_TCSR_SEIE(x)  (BME_UBFX32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_SEIE, BS_I2S_TCSR_SEIE))

/*! @brief Format value for bitfield I2S_TCSR_SEIE. */
#define BF_I2S_TCSR_SEIE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_SEIE) & BM_I2S_TCSR_SEIE)

/*! @brief Set the SEIE field to a new value. */
#define BW_I2S_TCSR_SEIE(x, v) (BME_BFI32(HW_I2S_TCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_TCSR_SEIE), BP_I2S_TCSR_SEIE, 1))
/*@}*/

/*!
 * @name Register I2S_TCSR, field WSIE[12] (RW)
 *
 * Enables/disables word start interrupts.
 *
 * Values:
 * - 0 - Disables interrupt.
 * - 1 - Enables interrupt.
 */
/*@{*/
#define BP_I2S_TCSR_WSIE     (12U)         /*!< Bit position for I2S_TCSR_WSIE. */
#define BM_I2S_TCSR_WSIE     (0x00001000U) /*!< Bit mask for I2S_TCSR_WSIE. */
#define BS_I2S_TCSR_WSIE     (1U)          /*!< Bit field size in bits for I2S_TCSR_WSIE. */

/*! @brief Read current value of the I2S_TCSR_WSIE field. */
#define BR_I2S_TCSR_WSIE(x)  (BME_UBFX32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_WSIE, BS_I2S_TCSR_WSIE))

/*! @brief Format value for bitfield I2S_TCSR_WSIE. */
#define BF_I2S_TCSR_WSIE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_WSIE) & BM_I2S_TCSR_WSIE)

/*! @brief Set the WSIE field to a new value. */
#define BW_I2S_TCSR_WSIE(x, v) (BME_BFI32(HW_I2S_TCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_TCSR_WSIE), BP_I2S_TCSR_WSIE, 1))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FWF[17] (RO)
 *
 * Indicates that an enabled transmit FIFO is empty.
 *
 * Values:
 * - 0 - No enabled transmit FIFO is empty.
 * - 1 - Enabled transmit FIFO is empty.
 */
/*@{*/
#define BP_I2S_TCSR_FWF      (17U)         /*!< Bit position for I2S_TCSR_FWF. */
#define BM_I2S_TCSR_FWF      (0x00020000U) /*!< Bit mask for I2S_TCSR_FWF. */
#define BS_I2S_TCSR_FWF      (1U)          /*!< Bit field size in bits for I2S_TCSR_FWF. */

/*! @brief Read current value of the I2S_TCSR_FWF field. */
#define BR_I2S_TCSR_FWF(x)   (BME_UBFX32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_FWF, BS_I2S_TCSR_FWF))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FEF[18] (W1C)
 *
 * Indicates that an enabled transmit FIFO has underrun. Write a logic 1 to this
 * field to clear this flag.
 *
 * Values:
 * - 0 - Transmit underrun not detected.
 * - 1 - Transmit underrun detected.
 */
/*@{*/
#define BP_I2S_TCSR_FEF      (18U)         /*!< Bit position for I2S_TCSR_FEF. */
#define BM_I2S_TCSR_FEF      (0x00040000U) /*!< Bit mask for I2S_TCSR_FEF. */
#define BS_I2S_TCSR_FEF      (1U)          /*!< Bit field size in bits for I2S_TCSR_FEF. */

/*! @brief Read current value of the I2S_TCSR_FEF field. */
#define BR_I2S_TCSR_FEF(x)   (BME_UBFX32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_FEF, BS_I2S_TCSR_FEF))

/*! @brief Format value for bitfield I2S_TCSR_FEF. */
#define BF_I2S_TCSR_FEF(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_FEF) & BM_I2S_TCSR_FEF)

/*! @brief Set the FEF field to a new value. */
#define BW_I2S_TCSR_FEF(x, v) (BME_BFI32(HW_I2S_TCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_TCSR_FEF), BP_I2S_TCSR_FEF, 1))
/*@}*/

/*!
 * @name Register I2S_TCSR, field SEF[19] (W1C)
 *
 * Indicates that an error in the externally-generated frame sync has been
 * detected. Write a logic 1 to this field to clear this flag.
 *
 * Values:
 * - 0 - Sync error not detected.
 * - 1 - Frame sync error detected.
 */
/*@{*/
#define BP_I2S_TCSR_SEF      (19U)         /*!< Bit position for I2S_TCSR_SEF. */
#define BM_I2S_TCSR_SEF      (0x00080000U) /*!< Bit mask for I2S_TCSR_SEF. */
#define BS_I2S_TCSR_SEF      (1U)          /*!< Bit field size in bits for I2S_TCSR_SEF. */

/*! @brief Read current value of the I2S_TCSR_SEF field. */
#define BR_I2S_TCSR_SEF(x)   (BME_UBFX32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_SEF, BS_I2S_TCSR_SEF))

/*! @brief Format value for bitfield I2S_TCSR_SEF. */
#define BF_I2S_TCSR_SEF(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_SEF) & BM_I2S_TCSR_SEF)

/*! @brief Set the SEF field to a new value. */
#define BW_I2S_TCSR_SEF(x, v) (BME_BFI32(HW_I2S_TCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_TCSR_SEF), BP_I2S_TCSR_SEF, 1))
/*@}*/

/*!
 * @name Register I2S_TCSR, field WSF[20] (W1C)
 *
 * Indicates that the start of the configured word has been detected. Write a
 * logic 1 to this field to clear this flag.
 *
 * Values:
 * - 0 - Start of word not detected.
 * - 1 - Start of word detected.
 */
/*@{*/
#define BP_I2S_TCSR_WSF      (20U)         /*!< Bit position for I2S_TCSR_WSF. */
#define BM_I2S_TCSR_WSF      (0x00100000U) /*!< Bit mask for I2S_TCSR_WSF. */
#define BS_I2S_TCSR_WSF      (1U)          /*!< Bit field size in bits for I2S_TCSR_WSF. */

/*! @brief Read current value of the I2S_TCSR_WSF field. */
#define BR_I2S_TCSR_WSF(x)   (BME_UBFX32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_WSF, BS_I2S_TCSR_WSF))

/*! @brief Format value for bitfield I2S_TCSR_WSF. */
#define BF_I2S_TCSR_WSF(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_WSF) & BM_I2S_TCSR_WSF)

/*! @brief Set the WSF field to a new value. */
#define BW_I2S_TCSR_WSF(x, v) (BME_BFI32(HW_I2S_TCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_TCSR_WSF), BP_I2S_TCSR_WSF, 1))
/*@}*/

/*!
 * @name Register I2S_TCSR, field SR[24] (RW)
 *
 * When set, resets the internal transmitter logic including the FIFO pointers.
 * Software-visible registers are not affected, except for the status registers.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Software reset.
 */
/*@{*/
#define BP_I2S_TCSR_SR       (24U)         /*!< Bit position for I2S_TCSR_SR. */
#define BM_I2S_TCSR_SR       (0x01000000U) /*!< Bit mask for I2S_TCSR_SR. */
#define BS_I2S_TCSR_SR       (1U)          /*!< Bit field size in bits for I2S_TCSR_SR. */

/*! @brief Read current value of the I2S_TCSR_SR field. */
#define BR_I2S_TCSR_SR(x)    (BME_UBFX32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_SR, BS_I2S_TCSR_SR))

/*! @brief Format value for bitfield I2S_TCSR_SR. */
#define BF_I2S_TCSR_SR(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_SR) & BM_I2S_TCSR_SR)

/*! @brief Set the SR field to a new value. */
#define BW_I2S_TCSR_SR(x, v) (BME_BFI32(HW_I2S_TCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_TCSR_SR), BP_I2S_TCSR_SR, 1))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FR[25] (WORZ)
 *
 * Resets the FIFO pointers. Reading this field will always return zero. FIFO
 * pointers should only be reset when the transmitter is disabled or the FIFO error
 * flag is set.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - FIFO reset.
 */
/*@{*/
#define BP_I2S_TCSR_FR       (25U)         /*!< Bit position for I2S_TCSR_FR. */
#define BM_I2S_TCSR_FR       (0x02000000U) /*!< Bit mask for I2S_TCSR_FR. */
#define BS_I2S_TCSR_FR       (1U)          /*!< Bit field size in bits for I2S_TCSR_FR. */

/*! @brief Format value for bitfield I2S_TCSR_FR. */
#define BF_I2S_TCSR_FR(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_FR) & BM_I2S_TCSR_FR)

/*! @brief Set the FR field to a new value. */
#define BW_I2S_TCSR_FR(x, v) (BME_BFI32(HW_I2S_TCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_TCSR_FR), BP_I2S_TCSR_FR, 1))
/*@}*/

/*!
 * @name Register I2S_TCSR, field BCE[28] (RW)
 *
 * Enables the transmit bit clock, separately from the TE. This field is
 * automatically set whenever TE is set. When software clears this field, the transmit
 * bit clock remains enabled, and this bit remains set, until the end of the
 * current frame.
 *
 * Values:
 * - 0 - Transmit bit clock is disabled.
 * - 1 - Transmit bit clock is enabled.
 */
/*@{*/
#define BP_I2S_TCSR_BCE      (28U)         /*!< Bit position for I2S_TCSR_BCE. */
#define BM_I2S_TCSR_BCE      (0x10000000U) /*!< Bit mask for I2S_TCSR_BCE. */
#define BS_I2S_TCSR_BCE      (1U)          /*!< Bit field size in bits for I2S_TCSR_BCE. */

/*! @brief Read current value of the I2S_TCSR_BCE field. */
#define BR_I2S_TCSR_BCE(x)   (BME_UBFX32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_BCE, BS_I2S_TCSR_BCE))

/*! @brief Format value for bitfield I2S_TCSR_BCE. */
#define BF_I2S_TCSR_BCE(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_BCE) & BM_I2S_TCSR_BCE)

/*! @brief Set the BCE field to a new value. */
#define BW_I2S_TCSR_BCE(x, v) (BME_BFI32(HW_I2S_TCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_TCSR_BCE), BP_I2S_TCSR_BCE, 1))
/*@}*/

/*!
 * @name Register I2S_TCSR, field DBGE[29] (RW)
 *
 * Enables/disables transmitter operation in Debug mode. The transmit bit clock
 * is not affected by debug mode.
 *
 * Values:
 * - 0 - Transmitter is disabled in Debug mode, after completing the current
 *     frame.
 * - 1 - Transmitter is enabled in Debug mode.
 */
/*@{*/
#define BP_I2S_TCSR_DBGE     (29U)         /*!< Bit position for I2S_TCSR_DBGE. */
#define BM_I2S_TCSR_DBGE     (0x20000000U) /*!< Bit mask for I2S_TCSR_DBGE. */
#define BS_I2S_TCSR_DBGE     (1U)          /*!< Bit field size in bits for I2S_TCSR_DBGE. */

/*! @brief Read current value of the I2S_TCSR_DBGE field. */
#define BR_I2S_TCSR_DBGE(x)  (BME_UBFX32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_DBGE, BS_I2S_TCSR_DBGE))

/*! @brief Format value for bitfield I2S_TCSR_DBGE. */
#define BF_I2S_TCSR_DBGE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_DBGE) & BM_I2S_TCSR_DBGE)

/*! @brief Set the DBGE field to a new value. */
#define BW_I2S_TCSR_DBGE(x, v) (BME_BFI32(HW_I2S_TCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_TCSR_DBGE), BP_I2S_TCSR_DBGE, 1))
/*@}*/

/*!
 * @name Register I2S_TCSR, field STOPE[30] (RW)
 *
 * Configures transmitter operation in Stop mode. This field is ignored and the
 * transmitter is disabled in all low-leakage stop modes.
 *
 * Values:
 * - 0 - Transmitter disabled in Stop mode.
 * - 1 - Transmitter enabled in Stop mode.
 */
/*@{*/
#define BP_I2S_TCSR_STOPE    (30U)         /*!< Bit position for I2S_TCSR_STOPE. */
#define BM_I2S_TCSR_STOPE    (0x40000000U) /*!< Bit mask for I2S_TCSR_STOPE. */
#define BS_I2S_TCSR_STOPE    (1U)          /*!< Bit field size in bits for I2S_TCSR_STOPE. */

/*! @brief Read current value of the I2S_TCSR_STOPE field. */
#define BR_I2S_TCSR_STOPE(x) (BME_UBFX32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_STOPE, BS_I2S_TCSR_STOPE))

/*! @brief Format value for bitfield I2S_TCSR_STOPE. */
#define BF_I2S_TCSR_STOPE(v) ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_STOPE) & BM_I2S_TCSR_STOPE)

/*! @brief Set the STOPE field to a new value. */
#define BW_I2S_TCSR_STOPE(x, v) (BME_BFI32(HW_I2S_TCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_TCSR_STOPE), BP_I2S_TCSR_STOPE, 1))
/*@}*/

/*!
 * @name Register I2S_TCSR, field TE[31] (RW)
 *
 * Enables/disables the transmitter. When software clears this field, the
 * transmitter remains enabled, and this bit remains set, until the end of the current
 * frame.
 *
 * Values:
 * - 0 - Transmitter is disabled.
 * - 1 - Transmitter is enabled, or transmitter has been disabled and has not
 *     yet reached end of frame.
 */
/*@{*/
#define BP_I2S_TCSR_TE       (31U)         /*!< Bit position for I2S_TCSR_TE. */
#define BM_I2S_TCSR_TE       (0x80000000U) /*!< Bit mask for I2S_TCSR_TE. */
#define BS_I2S_TCSR_TE       (1U)          /*!< Bit field size in bits for I2S_TCSR_TE. */

/*! @brief Read current value of the I2S_TCSR_TE field. */
#define BR_I2S_TCSR_TE(x)    (BME_UBFX32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_TE, BS_I2S_TCSR_TE))

/*! @brief Format value for bitfield I2S_TCSR_TE. */
#define BF_I2S_TCSR_TE(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_TE) & BM_I2S_TCSR_TE)

/*! @brief Set the TE field to a new value. */
#define BW_I2S_TCSR_TE(x, v) (BME_BFI32(HW_I2S_TCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_TCSR_TE), BP_I2S_TCSR_TE, 1))
/*@}*/

/*******************************************************************************
 * HW_I2S_TCR2 - SAI Transmit Configuration 2 Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_TCR2 - SAI Transmit Configuration 2 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when TCSR[TE] is set.
 */
typedef union _hw_i2s_tcr2
{
    uint32_t U;
    struct _hw_i2s_tcr2_bitfields
    {
        uint32_t DIV : 8;              /*!< [7:0] Bit Clock Divide */
        uint32_t RESERVED0 : 16;       /*!< [23:8]  */
        uint32_t BCD : 1;              /*!< [24] Bit Clock Direction */
        uint32_t BCP : 1;              /*!< [25] Bit Clock Polarity */
        uint32_t MSEL : 2;             /*!< [27:26] MCLK Select */
        uint32_t BCI : 1;              /*!< [28] Bit Clock Input */
        uint32_t BCS : 1;              /*!< [29] Bit Clock Swap */
        uint32_t SYNC : 2;             /*!< [31:30] Synchronous Mode */
    } B;
} hw_i2s_tcr2_t;

/*!
 * @name Constants and macros for entire I2S_TCR2 register
 */
/*@{*/
#define HW_I2S_TCR2_ADDR(x)      ((uint32_t)(x) + 0x8U)

#define HW_I2S_TCR2(x)           (*(__IO hw_i2s_tcr2_t *) HW_I2S_TCR2_ADDR(x))
#define HW_I2S_TCR2_RD(x)        (HW_I2S_TCR2(x).U)
#define HW_I2S_TCR2_WR(x, v)     (HW_I2S_TCR2(x).U = (v))
#define HW_I2S_TCR2_SET(x, v)    (BME_OR32(HW_I2S_TCR2_ADDR(x), (uint32_t)(v)))
#define HW_I2S_TCR2_CLR(x, v)    (BME_AND32(HW_I2S_TCR2_ADDR(x), (uint32_t)(~(v))))
#define HW_I2S_TCR2_TOG(x, v)    (BME_XOR32(HW_I2S_TCR2_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR2 bitfields
 */

/*!
 * @name Register I2S_TCR2, field DIV[7:0] (RW)
 *
 * Divides down the audio master clock to generate the bit clock when configured
 * for an internal bit clock. The division value is (DIV + 1) * 2.
 */
/*@{*/
#define BP_I2S_TCR2_DIV      (0U)          /*!< Bit position for I2S_TCR2_DIV. */
#define BM_I2S_TCR2_DIV      (0x000000FFU) /*!< Bit mask for I2S_TCR2_DIV. */
#define BS_I2S_TCR2_DIV      (8U)          /*!< Bit field size in bits for I2S_TCR2_DIV. */

/*! @brief Read current value of the I2S_TCR2_DIV field. */
#define BR_I2S_TCR2_DIV(x)   (BME_UBFX32(HW_I2S_TCR2_ADDR(x), BP_I2S_TCR2_DIV, BS_I2S_TCR2_DIV))

/*! @brief Format value for bitfield I2S_TCR2_DIV. */
#define BF_I2S_TCR2_DIV(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR2_DIV) & BM_I2S_TCR2_DIV)

/*! @brief Set the DIV field to a new value. */
#define BW_I2S_TCR2_DIV(x, v) (BME_BFI32(HW_I2S_TCR2_ADDR(x), ((uint32_t)(v) << BP_I2S_TCR2_DIV), BP_I2S_TCR2_DIV, 8))
/*@}*/

/*!
 * @name Register I2S_TCR2, field BCD[24] (RW)
 *
 * Configures the direction of the bit clock.
 *
 * Values:
 * - 0 - Bit clock is generated externally in Slave mode.
 * - 1 - Bit clock is generated internally in Master mode.
 */
/*@{*/
#define BP_I2S_TCR2_BCD      (24U)         /*!< Bit position for I2S_TCR2_BCD. */
#define BM_I2S_TCR2_BCD      (0x01000000U) /*!< Bit mask for I2S_TCR2_BCD. */
#define BS_I2S_TCR2_BCD      (1U)          /*!< Bit field size in bits for I2S_TCR2_BCD. */

/*! @brief Read current value of the I2S_TCR2_BCD field. */
#define BR_I2S_TCR2_BCD(x)   (BME_UBFX32(HW_I2S_TCR2_ADDR(x), BP_I2S_TCR2_BCD, BS_I2S_TCR2_BCD))

/*! @brief Format value for bitfield I2S_TCR2_BCD. */
#define BF_I2S_TCR2_BCD(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR2_BCD) & BM_I2S_TCR2_BCD)

/*! @brief Set the BCD field to a new value. */
#define BW_I2S_TCR2_BCD(x, v) (BME_BFI32(HW_I2S_TCR2_ADDR(x), ((uint32_t)(v) << BP_I2S_TCR2_BCD), BP_I2S_TCR2_BCD, 1))
/*@}*/

/*!
 * @name Register I2S_TCR2, field BCP[25] (RW)
 *
 * Configures the polarity of the bit clock.
 *
 * Values:
 * - 0 - Bit clock is active high with drive outputs on rising edge and sample
 *     inputs on falling edge.
 * - 1 - Bit clock is active low with drive outputs on falling edge and sample
 *     inputs on rising edge.
 */
/*@{*/
#define BP_I2S_TCR2_BCP      (25U)         /*!< Bit position for I2S_TCR2_BCP. */
#define BM_I2S_TCR2_BCP      (0x02000000U) /*!< Bit mask for I2S_TCR2_BCP. */
#define BS_I2S_TCR2_BCP      (1U)          /*!< Bit field size in bits for I2S_TCR2_BCP. */

/*! @brief Read current value of the I2S_TCR2_BCP field. */
#define BR_I2S_TCR2_BCP(x)   (BME_UBFX32(HW_I2S_TCR2_ADDR(x), BP_I2S_TCR2_BCP, BS_I2S_TCR2_BCP))

/*! @brief Format value for bitfield I2S_TCR2_BCP. */
#define BF_I2S_TCR2_BCP(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR2_BCP) & BM_I2S_TCR2_BCP)

/*! @brief Set the BCP field to a new value. */
#define BW_I2S_TCR2_BCP(x, v) (BME_BFI32(HW_I2S_TCR2_ADDR(x), ((uint32_t)(v) << BP_I2S_TCR2_BCP), BP_I2S_TCR2_BCP, 1))
/*@}*/

/*!
 * @name Register I2S_TCR2, field MSEL[27:26] (RW)
 *
 * Selects the audio Master Clock option used to generate an internally
 * generated bit clock. This field has no effect when configured for an externally
 * generated bit clock. Depending on the device, some Master Clock options might not be
 * available. See the chip configuration details for the availability and
 * chip-specific meaning of each option.
 *
 * Values:
 * - 00 - Bus Clock selected.
 * - 01 - Master Clock (MCLK) 1 option selected.
 * - 10 - Master Clock (MCLK) 2 option selected.
 * - 11 - Master Clock (MCLK) 3 option selected.
 */
/*@{*/
#define BP_I2S_TCR2_MSEL     (26U)         /*!< Bit position for I2S_TCR2_MSEL. */
#define BM_I2S_TCR2_MSEL     (0x0C000000U) /*!< Bit mask for I2S_TCR2_MSEL. */
#define BS_I2S_TCR2_MSEL     (2U)          /*!< Bit field size in bits for I2S_TCR2_MSEL. */

/*! @brief Read current value of the I2S_TCR2_MSEL field. */
#define BR_I2S_TCR2_MSEL(x)  (BME_UBFX32(HW_I2S_TCR2_ADDR(x), BP_I2S_TCR2_MSEL, BS_I2S_TCR2_MSEL))

/*! @brief Format value for bitfield I2S_TCR2_MSEL. */
#define BF_I2S_TCR2_MSEL(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCR2_MSEL) & BM_I2S_TCR2_MSEL)

/*! @brief Set the MSEL field to a new value. */
#define BW_I2S_TCR2_MSEL(x, v) (BME_BFI32(HW_I2S_TCR2_ADDR(x), ((uint32_t)(v) << BP_I2S_TCR2_MSEL), BP_I2S_TCR2_MSEL, 2))
/*@}*/

/*!
 * @name Register I2S_TCR2, field BCI[28] (RW)
 *
 * When this field is set and using an internally generated bit clock in either
 * synchronous or asynchronous mode, the bit clock actually used by the
 * transmitter is delayed by the pad output delay (the transmitter is clocked by the pad
 * input as if the clock was externally generated). This has the effect of
 * decreasing the data input setup time, but increasing the data output valid time. The
 * slave mode timing from the datasheet should be used for the transmitter when
 * this bit is set. In synchronous mode, this bit allows the transmitter to use
 * the slave mode timing from the datasheet, while the receiver uses the master
 * mode timing. This field has no effect when configured for an externally generated
 * bit clock .
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Internal logic is clocked as if bit clock was externally generated.
 */
/*@{*/
#define BP_I2S_TCR2_BCI      (28U)         /*!< Bit position for I2S_TCR2_BCI. */
#define BM_I2S_TCR2_BCI      (0x10000000U) /*!< Bit mask for I2S_TCR2_BCI. */
#define BS_I2S_TCR2_BCI      (1U)          /*!< Bit field size in bits for I2S_TCR2_BCI. */

/*! @brief Read current value of the I2S_TCR2_BCI field. */
#define BR_I2S_TCR2_BCI(x)   (BME_UBFX32(HW_I2S_TCR2_ADDR(x), BP_I2S_TCR2_BCI, BS_I2S_TCR2_BCI))

/*! @brief Format value for bitfield I2S_TCR2_BCI. */
#define BF_I2S_TCR2_BCI(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR2_BCI) & BM_I2S_TCR2_BCI)

/*! @brief Set the BCI field to a new value. */
#define BW_I2S_TCR2_BCI(x, v) (BME_BFI32(HW_I2S_TCR2_ADDR(x), ((uint32_t)(v) << BP_I2S_TCR2_BCI), BP_I2S_TCR2_BCI, 1))
/*@}*/

/*!
 * @name Register I2S_TCR2, field BCS[29] (RW)
 *
 * This field swaps the bit clock used by the transmitter. When the transmitter
 * is configured in asynchronous mode and this bit is set, the transmitter is
 * clocked by the receiver bit clock (SAI_RX_BCLK). This allows the transmitter and
 * receiver to share the same bit clock, but the transmitter continues to use the
 * transmit frame sync (SAI_TX_SYNC). When the transmitter is configured in
 * synchronous mode, the transmitter BCS field and receiver BCS field must be set to
 * the same value. When both are set, the transmitter and receiver are both
 * clocked by the transmitter bit clock (SAI_TX_BCLK) but use the receiver frame sync
 * (SAI_RX_SYNC).
 *
 * Values:
 * - 0 - Use the normal bit clock source.
 * - 1 - Swap the bit clock source.
 */
/*@{*/
#define BP_I2S_TCR2_BCS      (29U)         /*!< Bit position for I2S_TCR2_BCS. */
#define BM_I2S_TCR2_BCS      (0x20000000U) /*!< Bit mask for I2S_TCR2_BCS. */
#define BS_I2S_TCR2_BCS      (1U)          /*!< Bit field size in bits for I2S_TCR2_BCS. */

/*! @brief Read current value of the I2S_TCR2_BCS field. */
#define BR_I2S_TCR2_BCS(x)   (BME_UBFX32(HW_I2S_TCR2_ADDR(x), BP_I2S_TCR2_BCS, BS_I2S_TCR2_BCS))

/*! @brief Format value for bitfield I2S_TCR2_BCS. */
#define BF_I2S_TCR2_BCS(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR2_BCS) & BM_I2S_TCR2_BCS)

/*! @brief Set the BCS field to a new value. */
#define BW_I2S_TCR2_BCS(x, v) (BME_BFI32(HW_I2S_TCR2_ADDR(x), ((uint32_t)(v) << BP_I2S_TCR2_BCS), BP_I2S_TCR2_BCS, 1))
/*@}*/

/*!
 * @name Register I2S_TCR2, field SYNC[31:30] (RW)
 *
 * Configures between asynchronous and synchronous modes of operation. When
 * configured for a synchronous mode of operation, the receiver must be configured
 * for asynchronous operation.
 *
 * Values:
 * - 00 - Asynchronous mode.
 * - 01 - Synchronous with receiver.
 * - 10 - Synchronous with another SAI transmitter.
 * - 11 - Synchronous with another SAI receiver.
 */
/*@{*/
#define BP_I2S_TCR2_SYNC     (30U)         /*!< Bit position for I2S_TCR2_SYNC. */
#define BM_I2S_TCR2_SYNC     (0xC0000000U) /*!< Bit mask for I2S_TCR2_SYNC. */
#define BS_I2S_TCR2_SYNC     (2U)          /*!< Bit field size in bits for I2S_TCR2_SYNC. */

/*! @brief Read current value of the I2S_TCR2_SYNC field. */
#define BR_I2S_TCR2_SYNC(x)  (BME_UBFX32(HW_I2S_TCR2_ADDR(x), BP_I2S_TCR2_SYNC, BS_I2S_TCR2_SYNC))

/*! @brief Format value for bitfield I2S_TCR2_SYNC. */
#define BF_I2S_TCR2_SYNC(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCR2_SYNC) & BM_I2S_TCR2_SYNC)

/*! @brief Set the SYNC field to a new value. */
#define BW_I2S_TCR2_SYNC(x, v) (BME_BFI32(HW_I2S_TCR2_ADDR(x), ((uint32_t)(v) << BP_I2S_TCR2_SYNC), BP_I2S_TCR2_SYNC, 2))
/*@}*/

/*******************************************************************************
 * HW_I2S_TCR3 - SAI Transmit Configuration 3 Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_TCR3 - SAI Transmit Configuration 3 Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_i2s_tcr3
{
    uint32_t U;
    struct _hw_i2s_tcr3_bitfields
    {
        uint32_t WDFL : 1;             /*!< [0] Word Flag Configuration */
        uint32_t RESERVED0 : 15;       /*!< [15:1]  */
        uint32_t TCE : 1;              /*!< [16] Transmit Channel Enable */
        uint32_t RESERVED1 : 15;       /*!< [31:17]  */
    } B;
} hw_i2s_tcr3_t;

/*!
 * @name Constants and macros for entire I2S_TCR3 register
 */
/*@{*/
#define HW_I2S_TCR3_ADDR(x)      ((uint32_t)(x) + 0xCU)

#define HW_I2S_TCR3(x)           (*(__IO hw_i2s_tcr3_t *) HW_I2S_TCR3_ADDR(x))
#define HW_I2S_TCR3_RD(x)        (HW_I2S_TCR3(x).U)
#define HW_I2S_TCR3_WR(x, v)     (HW_I2S_TCR3(x).U = (v))
#define HW_I2S_TCR3_SET(x, v)    (BME_OR32(HW_I2S_TCR3_ADDR(x), (uint32_t)(v)))
#define HW_I2S_TCR3_CLR(x, v)    (BME_AND32(HW_I2S_TCR3_ADDR(x), (uint32_t)(~(v))))
#define HW_I2S_TCR3_TOG(x, v)    (BME_XOR32(HW_I2S_TCR3_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR3 bitfields
 */

/*!
 * @name Register I2S_TCR3, field WDFL[0] (RW)
 *
 * Configures which word sets the start of word flag. The value written must be
 * one less than the word number. For example, writing 0 configures the first
 * word in the frame. When configured to a value greater than TCR4[FRSZ], then the
 * start of word flag is never set.
 */
/*@{*/
#define BP_I2S_TCR3_WDFL     (0U)          /*!< Bit position for I2S_TCR3_WDFL. */
#define BM_I2S_TCR3_WDFL     (0x00000001U) /*!< Bit mask for I2S_TCR3_WDFL. */
#define BS_I2S_TCR3_WDFL     (1U)          /*!< Bit field size in bits for I2S_TCR3_WDFL. */

/*! @brief Read current value of the I2S_TCR3_WDFL field. */
#define BR_I2S_TCR3_WDFL(x)  (BME_UBFX32(HW_I2S_TCR3_ADDR(x), BP_I2S_TCR3_WDFL, BS_I2S_TCR3_WDFL))

/*! @brief Format value for bitfield I2S_TCR3_WDFL. */
#define BF_I2S_TCR3_WDFL(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCR3_WDFL) & BM_I2S_TCR3_WDFL)

/*! @brief Set the WDFL field to a new value. */
#define BW_I2S_TCR3_WDFL(x, v) (BME_BFI32(HW_I2S_TCR3_ADDR(x), ((uint32_t)(v) << BP_I2S_TCR3_WDFL), BP_I2S_TCR3_WDFL, 1))
/*@}*/

/*!
 * @name Register I2S_TCR3, field TCE[16] (RW)
 *
 * Enables the corresponding data channel for transmit operation. A channel must
 * be enabled before its FIFO is accessed. Changing this field will take effect
 * immediately for generating the FIFO request and warning flags, but at the end
 * of each frame for transmit operation.
 *
 * Values:
 * - 0 - Transmit data channel N is disabled.
 * - 1 - Transmit data channel N is enabled.
 */
/*@{*/
#define BP_I2S_TCR3_TCE      (16U)         /*!< Bit position for I2S_TCR3_TCE. */
#define BM_I2S_TCR3_TCE      (0x00010000U) /*!< Bit mask for I2S_TCR3_TCE. */
#define BS_I2S_TCR3_TCE      (1U)          /*!< Bit field size in bits for I2S_TCR3_TCE. */

/*! @brief Read current value of the I2S_TCR3_TCE field. */
#define BR_I2S_TCR3_TCE(x)   (BME_UBFX32(HW_I2S_TCR3_ADDR(x), BP_I2S_TCR3_TCE, BS_I2S_TCR3_TCE))

/*! @brief Format value for bitfield I2S_TCR3_TCE. */
#define BF_I2S_TCR3_TCE(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR3_TCE) & BM_I2S_TCR3_TCE)

/*! @brief Set the TCE field to a new value. */
#define BW_I2S_TCR3_TCE(x, v) (BME_BFI32(HW_I2S_TCR3_ADDR(x), ((uint32_t)(v) << BP_I2S_TCR3_TCE), BP_I2S_TCR3_TCE, 1))
/*@}*/

/*******************************************************************************
 * HW_I2S_TCR4 - SAI Transmit Configuration 4 Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_TCR4 - SAI Transmit Configuration 4 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when TCSR[TE] is set.
 */
typedef union _hw_i2s_tcr4
{
    uint32_t U;
    struct _hw_i2s_tcr4_bitfields
    {
        uint32_t FSD : 1;              /*!< [0] Frame Sync Direction */
        uint32_t FSP : 1;              /*!< [1] Frame Sync Polarity */
        uint32_t ONDEM : 1;            /*!< [2] On Demand Mode */
        uint32_t FSE : 1;              /*!< [3] Frame Sync Early */
        uint32_t MF : 1;               /*!< [4] MSB First */
        uint32_t RESERVED0 : 3;        /*!< [7:5]  */
        uint32_t SYWD : 5;             /*!< [12:8] Sync Width */
        uint32_t RESERVED1 : 3;        /*!< [15:13]  */
        uint32_t FRSZ : 1;             /*!< [16] Frame size */
        uint32_t RESERVED2 : 7;        /*!< [23:17]  */
        uint32_t FPACK : 2;            /*!< [25:24] FIFO Packing Mode */
        uint32_t RESERVED3 : 2;        /*!< [27:26]  */
        uint32_t FCONT : 1;            /*!< [28] FIFO Continue on Error */
        uint32_t RESERVED4 : 3;        /*!< [31:29]  */
    } B;
} hw_i2s_tcr4_t;

/*!
 * @name Constants and macros for entire I2S_TCR4 register
 */
/*@{*/
#define HW_I2S_TCR4_ADDR(x)      ((uint32_t)(x) + 0x10U)

#define HW_I2S_TCR4(x)           (*(__IO hw_i2s_tcr4_t *) HW_I2S_TCR4_ADDR(x))
#define HW_I2S_TCR4_RD(x)        (HW_I2S_TCR4(x).U)
#define HW_I2S_TCR4_WR(x, v)     (HW_I2S_TCR4(x).U = (v))
#define HW_I2S_TCR4_SET(x, v)    (BME_OR32(HW_I2S_TCR4_ADDR(x), (uint32_t)(v)))
#define HW_I2S_TCR4_CLR(x, v)    (BME_AND32(HW_I2S_TCR4_ADDR(x), (uint32_t)(~(v))))
#define HW_I2S_TCR4_TOG(x, v)    (BME_XOR32(HW_I2S_TCR4_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR4 bitfields
 */

/*!
 * @name Register I2S_TCR4, field FSD[0] (RW)
 *
 * Configures the direction of the frame sync.
 *
 * Values:
 * - 0 - Frame sync is generated externally in Slave mode.
 * - 1 - Frame sync is generated internally in Master mode.
 */
/*@{*/
#define BP_I2S_TCR4_FSD      (0U)          /*!< Bit position for I2S_TCR4_FSD. */
#define BM_I2S_TCR4_FSD      (0x00000001U) /*!< Bit mask for I2S_TCR4_FSD. */
#define BS_I2S_TCR4_FSD      (1U)          /*!< Bit field size in bits for I2S_TCR4_FSD. */

/*! @brief Read current value of the I2S_TCR4_FSD field. */
#define BR_I2S_TCR4_FSD(x)   (BME_UBFX32(HW_I2S_TCR4_ADDR(x), BP_I2S_TCR4_FSD, BS_I2S_TCR4_FSD))

/*! @brief Format value for bitfield I2S_TCR4_FSD. */
#define BF_I2S_TCR4_FSD(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR4_FSD) & BM_I2S_TCR4_FSD)

/*! @brief Set the FSD field to a new value. */
#define BW_I2S_TCR4_FSD(x, v) (BME_BFI32(HW_I2S_TCR4_ADDR(x), ((uint32_t)(v) << BP_I2S_TCR4_FSD), BP_I2S_TCR4_FSD, 1))
/*@}*/

/*!
 * @name Register I2S_TCR4, field FSP[1] (RW)
 *
 * Configures the polarity of the frame sync.
 *
 * Values:
 * - 0 - Frame sync is active high.
 * - 1 - Frame sync is active low.
 */
/*@{*/
#define BP_I2S_TCR4_FSP      (1U)          /*!< Bit position for I2S_TCR4_FSP. */
#define BM_I2S_TCR4_FSP      (0x00000002U) /*!< Bit mask for I2S_TCR4_FSP. */
#define BS_I2S_TCR4_FSP      (1U)          /*!< Bit field size in bits for I2S_TCR4_FSP. */

/*! @brief Read current value of the I2S_TCR4_FSP field. */
#define BR_I2S_TCR4_FSP(x)   (BME_UBFX32(HW_I2S_TCR4_ADDR(x), BP_I2S_TCR4_FSP, BS_I2S_TCR4_FSP))

/*! @brief Format value for bitfield I2S_TCR4_FSP. */
#define BF_I2S_TCR4_FSP(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR4_FSP) & BM_I2S_TCR4_FSP)

/*! @brief Set the FSP field to a new value. */
#define BW_I2S_TCR4_FSP(x, v) (BME_BFI32(HW_I2S_TCR4_ADDR(x), ((uint32_t)(v) << BP_I2S_TCR4_FSP), BP_I2S_TCR4_FSP, 1))
/*@}*/

/*!
 * @name Register I2S_TCR4, field ONDEM[2] (RW)
 *
 * When set, and the frame sync is generated internally, a frame sync is only
 * generated when the FIFO warning flag is clear.
 *
 * Values:
 * - 0 - Internal frame sync is generated continuously.
 * - 1 - Internal frame sync is generated when the FIFO warning flag is clear.
 */
/*@{*/
#define BP_I2S_TCR4_ONDEM    (2U)          /*!< Bit position for I2S_TCR4_ONDEM. */
#define BM_I2S_TCR4_ONDEM    (0x00000004U) /*!< Bit mask for I2S_TCR4_ONDEM. */
#define BS_I2S_TCR4_ONDEM    (1U)          /*!< Bit field size in bits for I2S_TCR4_ONDEM. */

/*! @brief Read current value of the I2S_TCR4_ONDEM field. */
#define BR_I2S_TCR4_ONDEM(x) (BME_UBFX32(HW_I2S_TCR4_ADDR(x), BP_I2S_TCR4_ONDEM, BS_I2S_TCR4_ONDEM))

/*! @brief Format value for bitfield I2S_TCR4_ONDEM. */
#define BF_I2S_TCR4_ONDEM(v) ((uint32_t)((uint32_t)(v) << BP_I2S_TCR4_ONDEM) & BM_I2S_TCR4_ONDEM)

/*! @brief Set the ONDEM field to a new value. */
#define BW_I2S_TCR4_ONDEM(x, v) (BME_BFI32(HW_I2S_TCR4_ADDR(x), ((uint32_t)(v) << BP_I2S_TCR4_ONDEM), BP_I2S_TCR4_ONDEM, 1))
/*@}*/

/*!
 * @name Register I2S_TCR4, field FSE[3] (RW)
 *
 * Values:
 * - 0 - Frame sync asserts with the first bit of the frame.
 * - 1 - Frame sync asserts one bit before the first bit of the frame.
 */
/*@{*/
#define BP_I2S_TCR4_FSE      (3U)          /*!< Bit position for I2S_TCR4_FSE. */
#define BM_I2S_TCR4_FSE      (0x00000008U) /*!< Bit mask for I2S_TCR4_FSE. */
#define BS_I2S_TCR4_FSE      (1U)          /*!< Bit field size in bits for I2S_TCR4_FSE. */

/*! @brief Read current value of the I2S_TCR4_FSE field. */
#define BR_I2S_TCR4_FSE(x)   (BME_UBFX32(HW_I2S_TCR4_ADDR(x), BP_I2S_TCR4_FSE, BS_I2S_TCR4_FSE))

/*! @brief Format value for bitfield I2S_TCR4_FSE. */
#define BF_I2S_TCR4_FSE(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR4_FSE) & BM_I2S_TCR4_FSE)

/*! @brief Set the FSE field to a new value. */
#define BW_I2S_TCR4_FSE(x, v) (BME_BFI32(HW_I2S_TCR4_ADDR(x), ((uint32_t)(v) << BP_I2S_TCR4_FSE), BP_I2S_TCR4_FSE, 1))
/*@}*/

/*!
 * @name Register I2S_TCR4, field MF[4] (RW)
 *
 * Configures whether the LSB or the MSB is transmitted first.
 *
 * Values:
 * - 0 - LSB is transmitted first.
 * - 1 - MSB is transmitted first.
 */
/*@{*/
#define BP_I2S_TCR4_MF       (4U)          /*!< Bit position for I2S_TCR4_MF. */
#define BM_I2S_TCR4_MF       (0x00000010U) /*!< Bit mask for I2S_TCR4_MF. */
#define BS_I2S_TCR4_MF       (1U)          /*!< Bit field size in bits for I2S_TCR4_MF. */

/*! @brief Read current value of the I2S_TCR4_MF field. */
#define BR_I2S_TCR4_MF(x)    (BME_UBFX32(HW_I2S_TCR4_ADDR(x), BP_I2S_TCR4_MF, BS_I2S_TCR4_MF))

/*! @brief Format value for bitfield I2S_TCR4_MF. */
#define BF_I2S_TCR4_MF(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_TCR4_MF) & BM_I2S_TCR4_MF)

/*! @brief Set the MF field to a new value. */
#define BW_I2S_TCR4_MF(x, v) (BME_BFI32(HW_I2S_TCR4_ADDR(x), ((uint32_t)(v) << BP_I2S_TCR4_MF), BP_I2S_TCR4_MF, 1))
/*@}*/

/*!
 * @name Register I2S_TCR4, field SYWD[12:8] (RW)
 *
 * Configures the length of the frame sync in number of bit clocks. The value
 * written must be one less than the number of bit clocks. For example, write 0 for
 * the frame sync to assert for one bit clock only. The sync width cannot be
 * configured longer than the first word of the frame.
 */
/*@{*/
#define BP_I2S_TCR4_SYWD     (8U)          /*!< Bit position for I2S_TCR4_SYWD. */
#define BM_I2S_TCR4_SYWD     (0x00001F00U) /*!< Bit mask for I2S_TCR4_SYWD. */
#define BS_I2S_TCR4_SYWD     (5U)          /*!< Bit field size in bits for I2S_TCR4_SYWD. */

/*! @brief Read current value of the I2S_TCR4_SYWD field. */
#define BR_I2S_TCR4_SYWD(x)  (BME_UBFX32(HW_I2S_TCR4_ADDR(x), BP_I2S_TCR4_SYWD, BS_I2S_TCR4_SYWD))

/*! @brief Format value for bitfield I2S_TCR4_SYWD. */
#define BF_I2S_TCR4_SYWD(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCR4_SYWD) & BM_I2S_TCR4_SYWD)

/*! @brief Set the SYWD field to a new value. */
#define BW_I2S_TCR4_SYWD(x, v) (BME_BFI32(HW_I2S_TCR4_ADDR(x), ((uint32_t)(v) << BP_I2S_TCR4_SYWD), BP_I2S_TCR4_SYWD, 5))
/*@}*/

/*!
 * @name Register I2S_TCR4, field FRSZ[16] (RW)
 *
 * Configures the number of words in each frame. The value written must be one
 * less than the number of words in the frame. For example, write 0 for one word
 * per frame. The maximum supported frame size is 2 words.
 */
/*@{*/
#define BP_I2S_TCR4_FRSZ     (16U)         /*!< Bit position for I2S_TCR4_FRSZ. */
#define BM_I2S_TCR4_FRSZ     (0x00010000U) /*!< Bit mask for I2S_TCR4_FRSZ. */
#define BS_I2S_TCR4_FRSZ     (1U)          /*!< Bit field size in bits for I2S_TCR4_FRSZ. */

/*! @brief Read current value of the I2S_TCR4_FRSZ field. */
#define BR_I2S_TCR4_FRSZ(x)  (BME_UBFX32(HW_I2S_TCR4_ADDR(x), BP_I2S_TCR4_FRSZ, BS_I2S_TCR4_FRSZ))

/*! @brief Format value for bitfield I2S_TCR4_FRSZ. */
#define BF_I2S_TCR4_FRSZ(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCR4_FRSZ) & BM_I2S_TCR4_FRSZ)

/*! @brief Set the FRSZ field to a new value. */
#define BW_I2S_TCR4_FRSZ(x, v) (BME_BFI32(HW_I2S_TCR4_ADDR(x), ((uint32_t)(v) << BP_I2S_TCR4_FRSZ), BP_I2S_TCR4_FRSZ, 1))
/*@}*/

/*!
 * @name Register I2S_TCR4, field FPACK[25:24] (RW)
 *
 * Enables packing of 8-bit data or 16-bit data into each 32-bit FIFO word. If
 * the word size is greater than 8-bit or 16-bit then only the first 8-bit or
 * 16-bits are loaded from the FIFO. The first word in each frame always starts with
 * a new 32-bit FIFO word and the first bit shifted must be configured within the
 * first packed word. When FIFO packing is enabled, the FIFO write pointer will
 * only increment when the full 32-bit FIFO word has been written by software.
 *
 * Values:
 * - 00 - FIFO packing is disabled
 * - 01 - Reserved
 * - 10 - 8-bit FIFO packing is enabled
 * - 11 - 16-bit FIFO packing is enabled
 */
/*@{*/
#define BP_I2S_TCR4_FPACK    (24U)         /*!< Bit position for I2S_TCR4_FPACK. */
#define BM_I2S_TCR4_FPACK    (0x03000000U) /*!< Bit mask for I2S_TCR4_FPACK. */
#define BS_I2S_TCR4_FPACK    (2U)          /*!< Bit field size in bits for I2S_TCR4_FPACK. */

/*! @brief Read current value of the I2S_TCR4_FPACK field. */
#define BR_I2S_TCR4_FPACK(x) (BME_UBFX32(HW_I2S_TCR4_ADDR(x), BP_I2S_TCR4_FPACK, BS_I2S_TCR4_FPACK))

/*! @brief Format value for bitfield I2S_TCR4_FPACK. */
#define BF_I2S_TCR4_FPACK(v) ((uint32_t)((uint32_t)(v) << BP_I2S_TCR4_FPACK) & BM_I2S_TCR4_FPACK)

/*! @brief Set the FPACK field to a new value. */
#define BW_I2S_TCR4_FPACK(x, v) (BME_BFI32(HW_I2S_TCR4_ADDR(x), ((uint32_t)(v) << BP_I2S_TCR4_FPACK), BP_I2S_TCR4_FPACK, 2))
/*@}*/

/*!
 * @name Register I2S_TCR4, field FCONT[28] (RW)
 *
 * Configures when the SAI will continue transmitting after a FIFO error has
 * been detected.
 *
 * Values:
 * - 0 - On FIFO error, the SAI will continue from the start of the next frame
 *     after the FIFO error flag has been cleared.
 * - 1 - On FIFO error, the SAI will continue from the same word that caused the
 *     FIFO error to set after the FIFO warning flag has been cleared.
 */
/*@{*/
#define BP_I2S_TCR4_FCONT    (28U)         /*!< Bit position for I2S_TCR4_FCONT. */
#define BM_I2S_TCR4_FCONT    (0x10000000U) /*!< Bit mask for I2S_TCR4_FCONT. */
#define BS_I2S_TCR4_FCONT    (1U)          /*!< Bit field size in bits for I2S_TCR4_FCONT. */

/*! @brief Read current value of the I2S_TCR4_FCONT field. */
#define BR_I2S_TCR4_FCONT(x) (BME_UBFX32(HW_I2S_TCR4_ADDR(x), BP_I2S_TCR4_FCONT, BS_I2S_TCR4_FCONT))

/*! @brief Format value for bitfield I2S_TCR4_FCONT. */
#define BF_I2S_TCR4_FCONT(v) ((uint32_t)((uint32_t)(v) << BP_I2S_TCR4_FCONT) & BM_I2S_TCR4_FCONT)

/*! @brief Set the FCONT field to a new value. */
#define BW_I2S_TCR4_FCONT(x, v) (BME_BFI32(HW_I2S_TCR4_ADDR(x), ((uint32_t)(v) << BP_I2S_TCR4_FCONT), BP_I2S_TCR4_FCONT, 1))
/*@}*/

/*******************************************************************************
 * HW_I2S_TCR5 - SAI Transmit Configuration 5 Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_TCR5 - SAI Transmit Configuration 5 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when TCSR[TE] is set.
 */
typedef union _hw_i2s_tcr5
{
    uint32_t U;
    struct _hw_i2s_tcr5_bitfields
    {
        uint32_t RESERVED0 : 8;        /*!< [7:0]  */
        uint32_t FBT : 5;              /*!< [12:8] First Bit Shifted */
        uint32_t RESERVED1 : 3;        /*!< [15:13]  */
        uint32_t W0W : 5;              /*!< [20:16] Word 0 Width */
        uint32_t RESERVED2 : 3;        /*!< [23:21]  */
        uint32_t WNW : 5;              /*!< [28:24] Word N Width */
        uint32_t RESERVED3 : 3;        /*!< [31:29]  */
    } B;
} hw_i2s_tcr5_t;

/*!
 * @name Constants and macros for entire I2S_TCR5 register
 */
/*@{*/
#define HW_I2S_TCR5_ADDR(x)      ((uint32_t)(x) + 0x14U)

#define HW_I2S_TCR5(x)           (*(__IO hw_i2s_tcr5_t *) HW_I2S_TCR5_ADDR(x))
#define HW_I2S_TCR5_RD(x)        (HW_I2S_TCR5(x).U)
#define HW_I2S_TCR5_WR(x, v)     (HW_I2S_TCR5(x).U = (v))
#define HW_I2S_TCR5_SET(x, v)    (BME_OR32(HW_I2S_TCR5_ADDR(x), (uint32_t)(v)))
#define HW_I2S_TCR5_CLR(x, v)    (BME_AND32(HW_I2S_TCR5_ADDR(x), (uint32_t)(~(v))))
#define HW_I2S_TCR5_TOG(x, v)    (BME_XOR32(HW_I2S_TCR5_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR5 bitfields
 */

/*!
 * @name Register I2S_TCR5, field FBT[12:8] (RW)
 *
 * Configures the bit index for the first bit transmitted for each word in the
 * frame. If configured for MSB First, the index of the next bit transmitted is
 * one less than the current bit transmitted. If configured for LSB First, the
 * index of the next bit transmitted is one more than the current bit transmitted.
 * The value written must be greater than or equal to the word width when
 * configured for MSB First. The value written must be less than or equal to 31-word width
 * when configured for LSB First.
 */
/*@{*/
#define BP_I2S_TCR5_FBT      (8U)          /*!< Bit position for I2S_TCR5_FBT. */
#define BM_I2S_TCR5_FBT      (0x00001F00U) /*!< Bit mask for I2S_TCR5_FBT. */
#define BS_I2S_TCR5_FBT      (5U)          /*!< Bit field size in bits for I2S_TCR5_FBT. */

/*! @brief Read current value of the I2S_TCR5_FBT field. */
#define BR_I2S_TCR5_FBT(x)   (BME_UBFX32(HW_I2S_TCR5_ADDR(x), BP_I2S_TCR5_FBT, BS_I2S_TCR5_FBT))

/*! @brief Format value for bitfield I2S_TCR5_FBT. */
#define BF_I2S_TCR5_FBT(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR5_FBT) & BM_I2S_TCR5_FBT)

/*! @brief Set the FBT field to a new value. */
#define BW_I2S_TCR5_FBT(x, v) (BME_BFI32(HW_I2S_TCR5_ADDR(x), ((uint32_t)(v) << BP_I2S_TCR5_FBT), BP_I2S_TCR5_FBT, 5))
/*@}*/

/*!
 * @name Register I2S_TCR5, field W0W[20:16] (RW)
 *
 * Configures the number of bits in the first word in each frame. The value
 * written must be one less than the number of bits in the first word. Word width of
 * less than 8 bits is not supported if there is only one word per frame.
 */
/*@{*/
#define BP_I2S_TCR5_W0W      (16U)         /*!< Bit position for I2S_TCR5_W0W. */
#define BM_I2S_TCR5_W0W      (0x001F0000U) /*!< Bit mask for I2S_TCR5_W0W. */
#define BS_I2S_TCR5_W0W      (5U)          /*!< Bit field size in bits for I2S_TCR5_W0W. */

/*! @brief Read current value of the I2S_TCR5_W0W field. */
#define BR_I2S_TCR5_W0W(x)   (BME_UBFX32(HW_I2S_TCR5_ADDR(x), BP_I2S_TCR5_W0W, BS_I2S_TCR5_W0W))

/*! @brief Format value for bitfield I2S_TCR5_W0W. */
#define BF_I2S_TCR5_W0W(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR5_W0W) & BM_I2S_TCR5_W0W)

/*! @brief Set the W0W field to a new value. */
#define BW_I2S_TCR5_W0W(x, v) (BME_BFI32(HW_I2S_TCR5_ADDR(x), ((uint32_t)(v) << BP_I2S_TCR5_W0W), BP_I2S_TCR5_W0W, 5))
/*@}*/

/*!
 * @name Register I2S_TCR5, field WNW[28:24] (RW)
 *
 * Configures the number of bits in each word, for each word except the first in
 * the frame. The value written must be one less than the number of bits per
 * word. Word width of less than 8 bits is not supported.
 */
/*@{*/
#define BP_I2S_TCR5_WNW      (24U)         /*!< Bit position for I2S_TCR5_WNW. */
#define BM_I2S_TCR5_WNW      (0x1F000000U) /*!< Bit mask for I2S_TCR5_WNW. */
#define BS_I2S_TCR5_WNW      (5U)          /*!< Bit field size in bits for I2S_TCR5_WNW. */

/*! @brief Read current value of the I2S_TCR5_WNW field. */
#define BR_I2S_TCR5_WNW(x)   (BME_UBFX32(HW_I2S_TCR5_ADDR(x), BP_I2S_TCR5_WNW, BS_I2S_TCR5_WNW))

/*! @brief Format value for bitfield I2S_TCR5_WNW. */
#define BF_I2S_TCR5_WNW(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR5_WNW) & BM_I2S_TCR5_WNW)

/*! @brief Set the WNW field to a new value. */
#define BW_I2S_TCR5_WNW(x, v) (BME_BFI32(HW_I2S_TCR5_ADDR(x), ((uint32_t)(v) << BP_I2S_TCR5_WNW), BP_I2S_TCR5_WNW, 5))
/*@}*/

/*******************************************************************************
 * HW_I2S_TDRn - SAI Transmit Data Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_TDRn - SAI Transmit Data Register (WORZ)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_i2s_tdrn
{
    uint32_t U;
    struct _hw_i2s_tdrn_bitfields
    {
        uint32_t TDR : 32;             /*!< [31:0] Transmit Data Register */
    } B;
} hw_i2s_tdrn_t;

/*!
 * @name Constants and macros for entire I2S_TDRn register
 */
/*@{*/
#define HW_I2S_TDRn_COUNT (1U)

#define HW_I2S_TDRn_ADDR(x, n)   ((uint32_t)(x) + 0x20U + (0x4U * (n)))

#define HW_I2S_TDRn(x, n)        (*(__O hw_i2s_tdrn_t *) HW_I2S_TDRn_ADDR(x, n))
#define HW_I2S_TDRn_RD(x, n)     (HW_I2S_TDRn(x, n).U)
#define HW_I2S_TDRn_WR(x, n, v)  (HW_I2S_TDRn(x, n).U = (v))
/*@}*/

/*
 * Constants & macros for individual I2S_TDRn bitfields
 */

/*!
 * @name Register I2S_TDRn, field TDR[31:0] (WORZ)
 *
 * The corresponding TCR3[TCE] bit must be set before accessing the channel's
 * transmit data register. Writes to this register when the transmit FIFO is not
 * full will push the data written into the transmit data FIFO. Writes to this
 * register when the transmit FIFO is full are ignored.
 */
/*@{*/
#define BP_I2S_TDRn_TDR      (0U)          /*!< Bit position for I2S_TDRn_TDR. */
#define BM_I2S_TDRn_TDR      (0xFFFFFFFFU) /*!< Bit mask for I2S_TDRn_TDR. */
#define BS_I2S_TDRn_TDR      (32U)         /*!< Bit field size in bits for I2S_TDRn_TDR. */

/*! @brief Format value for bitfield I2S_TDRn_TDR. */
#define BF_I2S_TDRn_TDR(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TDRn_TDR) & BM_I2S_TDRn_TDR)

/*! @brief Set the TDR field to a new value. */
#define BW_I2S_TDRn_TDR(x, n, v) (HW_I2S_TDRn_WR(x, n, v))
/*@}*/

/*******************************************************************************
 * HW_I2S_TMR - SAI Transmit Mask Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_TMR - SAI Transmit Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is double-buffered and updates: When TCSR[TE] is first set At
 * the end of each frame. This allows the masked words in each frame to change
 * from frame to frame.
 */
typedef union _hw_i2s_tmr
{
    uint32_t U;
    struct _hw_i2s_tmr_bitfields
    {
        uint32_t TWM : 2;              /*!< [1:0] Transmit Word Mask */
        uint32_t RESERVED0 : 30;       /*!< [31:2]  */
    } B;
} hw_i2s_tmr_t;

/*!
 * @name Constants and macros for entire I2S_TMR register
 */
/*@{*/
#define HW_I2S_TMR_ADDR(x)       ((uint32_t)(x) + 0x60U)

#define HW_I2S_TMR(x)            (*(__IO hw_i2s_tmr_t *) HW_I2S_TMR_ADDR(x))
#define HW_I2S_TMR_RD(x)         (HW_I2S_TMR(x).U)
#define HW_I2S_TMR_WR(x, v)      (HW_I2S_TMR(x).U = (v))
#define HW_I2S_TMR_SET(x, v)     (BME_OR32(HW_I2S_TMR_ADDR(x), (uint32_t)(v)))
#define HW_I2S_TMR_CLR(x, v)     (BME_AND32(HW_I2S_TMR_ADDR(x), (uint32_t)(~(v))))
#define HW_I2S_TMR_TOG(x, v)     (BME_XOR32(HW_I2S_TMR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2S_TMR bitfields
 */

/*!
 * @name Register I2S_TMR, field TWM[1:0] (RW)
 *
 * Configures whether the transmit word is masked (transmit data pin tristated
 * and transmit data not read from FIFO) for the corresponding word in the frame.
 *
 * Values:
 * - 0 - Word N is enabled.
 * - 1 - Word N is masked. The transmit data pins are tri-stated when masked.
 */
/*@{*/
#define BP_I2S_TMR_TWM       (0U)          /*!< Bit position for I2S_TMR_TWM. */
#define BM_I2S_TMR_TWM       (0x00000003U) /*!< Bit mask for I2S_TMR_TWM. */
#define BS_I2S_TMR_TWM       (2U)          /*!< Bit field size in bits for I2S_TMR_TWM. */

/*! @brief Read current value of the I2S_TMR_TWM field. */
#define BR_I2S_TMR_TWM(x)    (BME_UBFX32(HW_I2S_TMR_ADDR(x), BP_I2S_TMR_TWM, BS_I2S_TMR_TWM))

/*! @brief Format value for bitfield I2S_TMR_TWM. */
#define BF_I2S_TMR_TWM(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_TMR_TWM) & BM_I2S_TMR_TWM)

/*! @brief Set the TWM field to a new value. */
#define BW_I2S_TMR_TWM(x, v) (BME_BFI32(HW_I2S_TMR_ADDR(x), ((uint32_t)(v) << BP_I2S_TMR_TWM), BP_I2S_TMR_TWM, 2))
/*@}*/

/*******************************************************************************
 * HW_I2S_RCSR - SAI Receive Control Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_RCSR - SAI Receive Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_i2s_rcsr
{
    uint32_t U;
    struct _hw_i2s_rcsr_bitfields
    {
        uint32_t RESERVED0 : 1;        /*!< [0]  */
        uint32_t FWDE : 1;             /*!< [1] FIFO Warning DMA Enable */
        uint32_t RESERVED1 : 7;        /*!< [8:2]  */
        uint32_t FWIE : 1;             /*!< [9] FIFO Warning Interrupt Enable */
        uint32_t FEIE : 1;             /*!< [10] FIFO Error Interrupt Enable */
        uint32_t SEIE : 1;             /*!< [11] Sync Error Interrupt Enable */
        uint32_t WSIE : 1;             /*!< [12] Word Start Interrupt Enable */
        uint32_t RESERVED2 : 4;        /*!< [16:13]  */
        uint32_t FWF : 1;              /*!< [17] FIFO Warning Flag */
        uint32_t FEF : 1;              /*!< [18] FIFO Error Flag */
        uint32_t SEF : 1;              /*!< [19] Sync Error Flag */
        uint32_t WSF : 1;              /*!< [20] Word Start Flag */
        uint32_t RESERVED3 : 3;        /*!< [23:21]  */
        uint32_t SR : 1;               /*!< [24] Software Reset */
        uint32_t FR : 1;               /*!< [25] FIFO Reset */
        uint32_t RESERVED4 : 2;        /*!< [27:26]  */
        uint32_t BCE : 1;              /*!< [28] Bit Clock Enable */
        uint32_t DBGE : 1;             /*!< [29] Debug Enable */
        uint32_t STOPE : 1;            /*!< [30] Stop Enable */
        uint32_t RE : 1;               /*!< [31] Receiver Enable */
    } B;
} hw_i2s_rcsr_t;

/*!
 * @name Constants and macros for entire I2S_RCSR register
 */
/*@{*/
#define HW_I2S_RCSR_ADDR(x)      ((uint32_t)(x) + 0x80U)

#define HW_I2S_RCSR(x)           (*(__IO hw_i2s_rcsr_t *) HW_I2S_RCSR_ADDR(x))
#define HW_I2S_RCSR_RD(x)        (HW_I2S_RCSR(x).U)
#define HW_I2S_RCSR_WR(x, v)     (HW_I2S_RCSR(x).U = (v))
#define HW_I2S_RCSR_SET(x, v)    (BME_OR32(HW_I2S_RCSR_ADDR(x), (uint32_t)(v)))
#define HW_I2S_RCSR_CLR(x, v)    (BME_AND32(HW_I2S_RCSR_ADDR(x), (uint32_t)(~(v))))
#define HW_I2S_RCSR_TOG(x, v)    (BME_XOR32(HW_I2S_RCSR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCSR bitfields
 */

/*!
 * @name Register I2S_RCSR, field FWDE[1] (RW)
 *
 * Enables/disables DMA requests.
 *
 * Values:
 * - 0 - Disables the DMA request.
 * - 1 - Enables the DMA request.
 */
/*@{*/
#define BP_I2S_RCSR_FWDE     (1U)          /*!< Bit position for I2S_RCSR_FWDE. */
#define BM_I2S_RCSR_FWDE     (0x00000002U) /*!< Bit mask for I2S_RCSR_FWDE. */
#define BS_I2S_RCSR_FWDE     (1U)          /*!< Bit field size in bits for I2S_RCSR_FWDE. */

/*! @brief Read current value of the I2S_RCSR_FWDE field. */
#define BR_I2S_RCSR_FWDE(x)  (BME_UBFX32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_FWDE, BS_I2S_RCSR_FWDE))

/*! @brief Format value for bitfield I2S_RCSR_FWDE. */
#define BF_I2S_RCSR_FWDE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_FWDE) & BM_I2S_RCSR_FWDE)

/*! @brief Set the FWDE field to a new value. */
#define BW_I2S_RCSR_FWDE(x, v) (BME_BFI32(HW_I2S_RCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_RCSR_FWDE), BP_I2S_RCSR_FWDE, 1))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FWIE[9] (RW)
 *
 * Enables/disables FIFO warning interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt.
 * - 1 - Enables the interrupt.
 */
/*@{*/
#define BP_I2S_RCSR_FWIE     (9U)          /*!< Bit position for I2S_RCSR_FWIE. */
#define BM_I2S_RCSR_FWIE     (0x00000200U) /*!< Bit mask for I2S_RCSR_FWIE. */
#define BS_I2S_RCSR_FWIE     (1U)          /*!< Bit field size in bits for I2S_RCSR_FWIE. */

/*! @brief Read current value of the I2S_RCSR_FWIE field. */
#define BR_I2S_RCSR_FWIE(x)  (BME_UBFX32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_FWIE, BS_I2S_RCSR_FWIE))

/*! @brief Format value for bitfield I2S_RCSR_FWIE. */
#define BF_I2S_RCSR_FWIE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_FWIE) & BM_I2S_RCSR_FWIE)

/*! @brief Set the FWIE field to a new value. */
#define BW_I2S_RCSR_FWIE(x, v) (BME_BFI32(HW_I2S_RCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_RCSR_FWIE), BP_I2S_RCSR_FWIE, 1))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FEIE[10] (RW)
 *
 * Enables/disables FIFO error interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt.
 * - 1 - Enables the interrupt.
 */
/*@{*/
#define BP_I2S_RCSR_FEIE     (10U)         /*!< Bit position for I2S_RCSR_FEIE. */
#define BM_I2S_RCSR_FEIE     (0x00000400U) /*!< Bit mask for I2S_RCSR_FEIE. */
#define BS_I2S_RCSR_FEIE     (1U)          /*!< Bit field size in bits for I2S_RCSR_FEIE. */

/*! @brief Read current value of the I2S_RCSR_FEIE field. */
#define BR_I2S_RCSR_FEIE(x)  (BME_UBFX32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_FEIE, BS_I2S_RCSR_FEIE))

/*! @brief Format value for bitfield I2S_RCSR_FEIE. */
#define BF_I2S_RCSR_FEIE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_FEIE) & BM_I2S_RCSR_FEIE)

/*! @brief Set the FEIE field to a new value. */
#define BW_I2S_RCSR_FEIE(x, v) (BME_BFI32(HW_I2S_RCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_RCSR_FEIE), BP_I2S_RCSR_FEIE, 1))
/*@}*/

/*!
 * @name Register I2S_RCSR, field SEIE[11] (RW)
 *
 * Enables/disables sync error interrupts.
 *
 * Values:
 * - 0 - Disables interrupt.
 * - 1 - Enables interrupt.
 */
/*@{*/
#define BP_I2S_RCSR_SEIE     (11U)         /*!< Bit position for I2S_RCSR_SEIE. */
#define BM_I2S_RCSR_SEIE     (0x00000800U) /*!< Bit mask for I2S_RCSR_SEIE. */
#define BS_I2S_RCSR_SEIE     (1U)          /*!< Bit field size in bits for I2S_RCSR_SEIE. */

/*! @brief Read current value of the I2S_RCSR_SEIE field. */
#define BR_I2S_RCSR_SEIE(x)  (BME_UBFX32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_SEIE, BS_I2S_RCSR_SEIE))

/*! @brief Format value for bitfield I2S_RCSR_SEIE. */
#define BF_I2S_RCSR_SEIE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_SEIE) & BM_I2S_RCSR_SEIE)

/*! @brief Set the SEIE field to a new value. */
#define BW_I2S_RCSR_SEIE(x, v) (BME_BFI32(HW_I2S_RCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_RCSR_SEIE), BP_I2S_RCSR_SEIE, 1))
/*@}*/

/*!
 * @name Register I2S_RCSR, field WSIE[12] (RW)
 *
 * Enables/disables word start interrupts.
 *
 * Values:
 * - 0 - Disables interrupt.
 * - 1 - Enables interrupt.
 */
/*@{*/
#define BP_I2S_RCSR_WSIE     (12U)         /*!< Bit position for I2S_RCSR_WSIE. */
#define BM_I2S_RCSR_WSIE     (0x00001000U) /*!< Bit mask for I2S_RCSR_WSIE. */
#define BS_I2S_RCSR_WSIE     (1U)          /*!< Bit field size in bits for I2S_RCSR_WSIE. */

/*! @brief Read current value of the I2S_RCSR_WSIE field. */
#define BR_I2S_RCSR_WSIE(x)  (BME_UBFX32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_WSIE, BS_I2S_RCSR_WSIE))

/*! @brief Format value for bitfield I2S_RCSR_WSIE. */
#define BF_I2S_RCSR_WSIE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_WSIE) & BM_I2S_RCSR_WSIE)

/*! @brief Set the WSIE field to a new value. */
#define BW_I2S_RCSR_WSIE(x, v) (BME_BFI32(HW_I2S_RCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_RCSR_WSIE), BP_I2S_RCSR_WSIE, 1))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FWF[17] (RO)
 *
 * Indicates that an enabled receive FIFO is full.
 *
 * Values:
 * - 0 - No enabled receive FIFO is full.
 * - 1 - Enabled receive FIFO is full.
 */
/*@{*/
#define BP_I2S_RCSR_FWF      (17U)         /*!< Bit position for I2S_RCSR_FWF. */
#define BM_I2S_RCSR_FWF      (0x00020000U) /*!< Bit mask for I2S_RCSR_FWF. */
#define BS_I2S_RCSR_FWF      (1U)          /*!< Bit field size in bits for I2S_RCSR_FWF. */

/*! @brief Read current value of the I2S_RCSR_FWF field. */
#define BR_I2S_RCSR_FWF(x)   (BME_UBFX32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_FWF, BS_I2S_RCSR_FWF))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FEF[18] (W1C)
 *
 * Indicates that an enabled receive FIFO has overflowed. Write a logic 1 to
 * this field to clear this flag.
 *
 * Values:
 * - 0 - Receive overflow not detected.
 * - 1 - Receive overflow detected.
 */
/*@{*/
#define BP_I2S_RCSR_FEF      (18U)         /*!< Bit position for I2S_RCSR_FEF. */
#define BM_I2S_RCSR_FEF      (0x00040000U) /*!< Bit mask for I2S_RCSR_FEF. */
#define BS_I2S_RCSR_FEF      (1U)          /*!< Bit field size in bits for I2S_RCSR_FEF. */

/*! @brief Read current value of the I2S_RCSR_FEF field. */
#define BR_I2S_RCSR_FEF(x)   (BME_UBFX32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_FEF, BS_I2S_RCSR_FEF))

/*! @brief Format value for bitfield I2S_RCSR_FEF. */
#define BF_I2S_RCSR_FEF(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_FEF) & BM_I2S_RCSR_FEF)

/*! @brief Set the FEF field to a new value. */
#define BW_I2S_RCSR_FEF(x, v) (BME_BFI32(HW_I2S_RCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_RCSR_FEF), BP_I2S_RCSR_FEF, 1))
/*@}*/

/*!
 * @name Register I2S_RCSR, field SEF[19] (W1C)
 *
 * Indicates that an error in the externally-generated frame sync has been
 * detected. Write a logic 1 to this field to clear this flag.
 *
 * Values:
 * - 0 - Sync error not detected.
 * - 1 - Frame sync error detected.
 */
/*@{*/
#define BP_I2S_RCSR_SEF      (19U)         /*!< Bit position for I2S_RCSR_SEF. */
#define BM_I2S_RCSR_SEF      (0x00080000U) /*!< Bit mask for I2S_RCSR_SEF. */
#define BS_I2S_RCSR_SEF      (1U)          /*!< Bit field size in bits for I2S_RCSR_SEF. */

/*! @brief Read current value of the I2S_RCSR_SEF field. */
#define BR_I2S_RCSR_SEF(x)   (BME_UBFX32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_SEF, BS_I2S_RCSR_SEF))

/*! @brief Format value for bitfield I2S_RCSR_SEF. */
#define BF_I2S_RCSR_SEF(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_SEF) & BM_I2S_RCSR_SEF)

/*! @brief Set the SEF field to a new value. */
#define BW_I2S_RCSR_SEF(x, v) (BME_BFI32(HW_I2S_RCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_RCSR_SEF), BP_I2S_RCSR_SEF, 1))
/*@}*/

/*!
 * @name Register I2S_RCSR, field WSF[20] (W1C)
 *
 * Indicates that the start of the configured word has been detected. Write a
 * logic 1 to this field to clear this flag.
 *
 * Values:
 * - 0 - Start of word not detected.
 * - 1 - Start of word detected.
 */
/*@{*/
#define BP_I2S_RCSR_WSF      (20U)         /*!< Bit position for I2S_RCSR_WSF. */
#define BM_I2S_RCSR_WSF      (0x00100000U) /*!< Bit mask for I2S_RCSR_WSF. */
#define BS_I2S_RCSR_WSF      (1U)          /*!< Bit field size in bits for I2S_RCSR_WSF. */

/*! @brief Read current value of the I2S_RCSR_WSF field. */
#define BR_I2S_RCSR_WSF(x)   (BME_UBFX32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_WSF, BS_I2S_RCSR_WSF))

/*! @brief Format value for bitfield I2S_RCSR_WSF. */
#define BF_I2S_RCSR_WSF(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_WSF) & BM_I2S_RCSR_WSF)

/*! @brief Set the WSF field to a new value. */
#define BW_I2S_RCSR_WSF(x, v) (BME_BFI32(HW_I2S_RCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_RCSR_WSF), BP_I2S_RCSR_WSF, 1))
/*@}*/

/*!
 * @name Register I2S_RCSR, field SR[24] (RW)
 *
 * Resets the internal receiver logic including the FIFO pointers.
 * Software-visible registers are not affected, except for the status registers.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Software reset.
 */
/*@{*/
#define BP_I2S_RCSR_SR       (24U)         /*!< Bit position for I2S_RCSR_SR. */
#define BM_I2S_RCSR_SR       (0x01000000U) /*!< Bit mask for I2S_RCSR_SR. */
#define BS_I2S_RCSR_SR       (1U)          /*!< Bit field size in bits for I2S_RCSR_SR. */

/*! @brief Read current value of the I2S_RCSR_SR field. */
#define BR_I2S_RCSR_SR(x)    (BME_UBFX32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_SR, BS_I2S_RCSR_SR))

/*! @brief Format value for bitfield I2S_RCSR_SR. */
#define BF_I2S_RCSR_SR(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_SR) & BM_I2S_RCSR_SR)

/*! @brief Set the SR field to a new value. */
#define BW_I2S_RCSR_SR(x, v) (BME_BFI32(HW_I2S_RCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_RCSR_SR), BP_I2S_RCSR_SR, 1))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FR[25] (WORZ)
 *
 * Resets the FIFO pointers. Reading this field will always return zero. FIFO
 * pointers should only be reset when the receiver is disabled or the FIFO error
 * flag is set.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - FIFO reset.
 */
/*@{*/
#define BP_I2S_RCSR_FR       (25U)         /*!< Bit position for I2S_RCSR_FR. */
#define BM_I2S_RCSR_FR       (0x02000000U) /*!< Bit mask for I2S_RCSR_FR. */
#define BS_I2S_RCSR_FR       (1U)          /*!< Bit field size in bits for I2S_RCSR_FR. */

/*! @brief Format value for bitfield I2S_RCSR_FR. */
#define BF_I2S_RCSR_FR(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_FR) & BM_I2S_RCSR_FR)

/*! @brief Set the FR field to a new value. */
#define BW_I2S_RCSR_FR(x, v) (BME_BFI32(HW_I2S_RCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_RCSR_FR), BP_I2S_RCSR_FR, 1))
/*@}*/

/*!
 * @name Register I2S_RCSR, field BCE[28] (RW)
 *
 * Enables the receive bit clock, separately from RE. This field is
 * automatically set whenever RE is set. When software clears this field, the receive bit
 * clock remains enabled, and this field remains set, until the end of the current
 * frame.
 *
 * Values:
 * - 0 - Receive bit clock is disabled.
 * - 1 - Receive bit clock is enabled.
 */
/*@{*/
#define BP_I2S_RCSR_BCE      (28U)         /*!< Bit position for I2S_RCSR_BCE. */
#define BM_I2S_RCSR_BCE      (0x10000000U) /*!< Bit mask for I2S_RCSR_BCE. */
#define BS_I2S_RCSR_BCE      (1U)          /*!< Bit field size in bits for I2S_RCSR_BCE. */

/*! @brief Read current value of the I2S_RCSR_BCE field. */
#define BR_I2S_RCSR_BCE(x)   (BME_UBFX32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_BCE, BS_I2S_RCSR_BCE))

/*! @brief Format value for bitfield I2S_RCSR_BCE. */
#define BF_I2S_RCSR_BCE(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_BCE) & BM_I2S_RCSR_BCE)

/*! @brief Set the BCE field to a new value. */
#define BW_I2S_RCSR_BCE(x, v) (BME_BFI32(HW_I2S_RCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_RCSR_BCE), BP_I2S_RCSR_BCE, 1))
/*@}*/

/*!
 * @name Register I2S_RCSR, field DBGE[29] (RW)
 *
 * Enables/disables receiver operation in Debug mode. The receive bit clock is
 * not affected by Debug mode.
 *
 * Values:
 * - 0 - Receiver is disabled in Debug mode, after completing the current frame.
 * - 1 - Receiver is enabled in Debug mode.
 */
/*@{*/
#define BP_I2S_RCSR_DBGE     (29U)         /*!< Bit position for I2S_RCSR_DBGE. */
#define BM_I2S_RCSR_DBGE     (0x20000000U) /*!< Bit mask for I2S_RCSR_DBGE. */
#define BS_I2S_RCSR_DBGE     (1U)          /*!< Bit field size in bits for I2S_RCSR_DBGE. */

/*! @brief Read current value of the I2S_RCSR_DBGE field. */
#define BR_I2S_RCSR_DBGE(x)  (BME_UBFX32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_DBGE, BS_I2S_RCSR_DBGE))

/*! @brief Format value for bitfield I2S_RCSR_DBGE. */
#define BF_I2S_RCSR_DBGE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_DBGE) & BM_I2S_RCSR_DBGE)

/*! @brief Set the DBGE field to a new value. */
#define BW_I2S_RCSR_DBGE(x, v) (BME_BFI32(HW_I2S_RCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_RCSR_DBGE), BP_I2S_RCSR_DBGE, 1))
/*@}*/

/*!
 * @name Register I2S_RCSR, field STOPE[30] (RW)
 *
 * Configures receiver operation in Stop mode. This bit is ignored and the
 * receiver is disabled in all low-leakage stop modes.
 *
 * Values:
 * - 0 - Receiver disabled in Stop mode.
 * - 1 - Receiver enabled in Stop mode.
 */
/*@{*/
#define BP_I2S_RCSR_STOPE    (30U)         /*!< Bit position for I2S_RCSR_STOPE. */
#define BM_I2S_RCSR_STOPE    (0x40000000U) /*!< Bit mask for I2S_RCSR_STOPE. */
#define BS_I2S_RCSR_STOPE    (1U)          /*!< Bit field size in bits for I2S_RCSR_STOPE. */

/*! @brief Read current value of the I2S_RCSR_STOPE field. */
#define BR_I2S_RCSR_STOPE(x) (BME_UBFX32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_STOPE, BS_I2S_RCSR_STOPE))

/*! @brief Format value for bitfield I2S_RCSR_STOPE. */
#define BF_I2S_RCSR_STOPE(v) ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_STOPE) & BM_I2S_RCSR_STOPE)

/*! @brief Set the STOPE field to a new value. */
#define BW_I2S_RCSR_STOPE(x, v) (BME_BFI32(HW_I2S_RCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_RCSR_STOPE), BP_I2S_RCSR_STOPE, 1))
/*@}*/

/*!
 * @name Register I2S_RCSR, field RE[31] (RW)
 *
 * Enables/disables the receiver. When software clears this field, the receiver
 * remains enabled, and this bit remains set, until the end of the current frame.
 *
 * Values:
 * - 0 - Receiver is disabled.
 * - 1 - Receiver is enabled, or receiver has been disabled and has not yet
 *     reached end of frame.
 */
/*@{*/
#define BP_I2S_RCSR_RE       (31U)         /*!< Bit position for I2S_RCSR_RE. */
#define BM_I2S_RCSR_RE       (0x80000000U) /*!< Bit mask for I2S_RCSR_RE. */
#define BS_I2S_RCSR_RE       (1U)          /*!< Bit field size in bits for I2S_RCSR_RE. */

/*! @brief Read current value of the I2S_RCSR_RE field. */
#define BR_I2S_RCSR_RE(x)    (BME_UBFX32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_RE, BS_I2S_RCSR_RE))

/*! @brief Format value for bitfield I2S_RCSR_RE. */
#define BF_I2S_RCSR_RE(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_RE) & BM_I2S_RCSR_RE)

/*! @brief Set the RE field to a new value. */
#define BW_I2S_RCSR_RE(x, v) (BME_BFI32(HW_I2S_RCSR_ADDR(x), ((uint32_t)(v) << BP_I2S_RCSR_RE), BP_I2S_RCSR_RE, 1))
/*@}*/

/*******************************************************************************
 * HW_I2S_RCR2 - SAI Receive Configuration 2 Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_RCR2 - SAI Receive Configuration 2 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when RCSR[RE] is set.
 */
typedef union _hw_i2s_rcr2
{
    uint32_t U;
    struct _hw_i2s_rcr2_bitfields
    {
        uint32_t DIV : 8;              /*!< [7:0] Bit Clock Divide */
        uint32_t RESERVED0 : 16;       /*!< [23:8]  */
        uint32_t BCD : 1;              /*!< [24] Bit Clock Direction */
        uint32_t BCP : 1;              /*!< [25] Bit Clock Polarity */
        uint32_t MSEL : 2;             /*!< [27:26] MCLK Select */
        uint32_t BCI : 1;              /*!< [28] Bit Clock Input */
        uint32_t BCS : 1;              /*!< [29] Bit Clock Swap */
        uint32_t SYNC : 2;             /*!< [31:30] Synchronous Mode */
    } B;
} hw_i2s_rcr2_t;

/*!
 * @name Constants and macros for entire I2S_RCR2 register
 */
/*@{*/
#define HW_I2S_RCR2_ADDR(x)      ((uint32_t)(x) + 0x88U)

#define HW_I2S_RCR2(x)           (*(__IO hw_i2s_rcr2_t *) HW_I2S_RCR2_ADDR(x))
#define HW_I2S_RCR2_RD(x)        (HW_I2S_RCR2(x).U)
#define HW_I2S_RCR2_WR(x, v)     (HW_I2S_RCR2(x).U = (v))
#define HW_I2S_RCR2_SET(x, v)    (BME_OR32(HW_I2S_RCR2_ADDR(x), (uint32_t)(v)))
#define HW_I2S_RCR2_CLR(x, v)    (BME_AND32(HW_I2S_RCR2_ADDR(x), (uint32_t)(~(v))))
#define HW_I2S_RCR2_TOG(x, v)    (BME_XOR32(HW_I2S_RCR2_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR2 bitfields
 */

/*!
 * @name Register I2S_RCR2, field DIV[7:0] (RW)
 *
 * Divides down the audio master clock to generate the bit clock when configured
 * for an internal bit clock. The division value is (DIV + 1) * 2.
 */
/*@{*/
#define BP_I2S_RCR2_DIV      (0U)          /*!< Bit position for I2S_RCR2_DIV. */
#define BM_I2S_RCR2_DIV      (0x000000FFU) /*!< Bit mask for I2S_RCR2_DIV. */
#define BS_I2S_RCR2_DIV      (8U)          /*!< Bit field size in bits for I2S_RCR2_DIV. */

/*! @brief Read current value of the I2S_RCR2_DIV field. */
#define BR_I2S_RCR2_DIV(x)   (BME_UBFX32(HW_I2S_RCR2_ADDR(x), BP_I2S_RCR2_DIV, BS_I2S_RCR2_DIV))

/*! @brief Format value for bitfield I2S_RCR2_DIV. */
#define BF_I2S_RCR2_DIV(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR2_DIV) & BM_I2S_RCR2_DIV)

/*! @brief Set the DIV field to a new value. */
#define BW_I2S_RCR2_DIV(x, v) (BME_BFI32(HW_I2S_RCR2_ADDR(x), ((uint32_t)(v) << BP_I2S_RCR2_DIV), BP_I2S_RCR2_DIV, 8))
/*@}*/

/*!
 * @name Register I2S_RCR2, field BCD[24] (RW)
 *
 * Configures the direction of the bit clock.
 *
 * Values:
 * - 0 - Bit clock is generated externally in Slave mode.
 * - 1 - Bit clock is generated internally in Master mode.
 */
/*@{*/
#define BP_I2S_RCR2_BCD      (24U)         /*!< Bit position for I2S_RCR2_BCD. */
#define BM_I2S_RCR2_BCD      (0x01000000U) /*!< Bit mask for I2S_RCR2_BCD. */
#define BS_I2S_RCR2_BCD      (1U)          /*!< Bit field size in bits for I2S_RCR2_BCD. */

/*! @brief Read current value of the I2S_RCR2_BCD field. */
#define BR_I2S_RCR2_BCD(x)   (BME_UBFX32(HW_I2S_RCR2_ADDR(x), BP_I2S_RCR2_BCD, BS_I2S_RCR2_BCD))

/*! @brief Format value for bitfield I2S_RCR2_BCD. */
#define BF_I2S_RCR2_BCD(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR2_BCD) & BM_I2S_RCR2_BCD)

/*! @brief Set the BCD field to a new value. */
#define BW_I2S_RCR2_BCD(x, v) (BME_BFI32(HW_I2S_RCR2_ADDR(x), ((uint32_t)(v) << BP_I2S_RCR2_BCD), BP_I2S_RCR2_BCD, 1))
/*@}*/

/*!
 * @name Register I2S_RCR2, field BCP[25] (RW)
 *
 * Configures the polarity of the bit clock.
 *
 * Values:
 * - 0 - Bit Clock is active high with drive outputs on rising edge and sample
 *     inputs on falling edge.
 * - 1 - Bit Clock is active low with drive outputs on falling edge and sample
 *     inputs on rising edge.
 */
/*@{*/
#define BP_I2S_RCR2_BCP      (25U)         /*!< Bit position for I2S_RCR2_BCP. */
#define BM_I2S_RCR2_BCP      (0x02000000U) /*!< Bit mask for I2S_RCR2_BCP. */
#define BS_I2S_RCR2_BCP      (1U)          /*!< Bit field size in bits for I2S_RCR2_BCP. */

/*! @brief Read current value of the I2S_RCR2_BCP field. */
#define BR_I2S_RCR2_BCP(x)   (BME_UBFX32(HW_I2S_RCR2_ADDR(x), BP_I2S_RCR2_BCP, BS_I2S_RCR2_BCP))

/*! @brief Format value for bitfield I2S_RCR2_BCP. */
#define BF_I2S_RCR2_BCP(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR2_BCP) & BM_I2S_RCR2_BCP)

/*! @brief Set the BCP field to a new value. */
#define BW_I2S_RCR2_BCP(x, v) (BME_BFI32(HW_I2S_RCR2_ADDR(x), ((uint32_t)(v) << BP_I2S_RCR2_BCP), BP_I2S_RCR2_BCP, 1))
/*@}*/

/*!
 * @name Register I2S_RCR2, field MSEL[27:26] (RW)
 *
 * Selects the audio Master Clock option used to generate an internally
 * generated bit clock. This field has no effect when configured for an externally
 * generated bit clock. Depending on the device, some Master Clock options might not be
 * available. See the chip configuration details for the availability and
 * chip-specific meaning of each option.
 *
 * Values:
 * - 00 - Bus Clock selected.
 * - 01 - Master Clock (MCLK) 1 option selected.
 * - 10 - Master Clock (MCLK) 2 option selected.
 * - 11 - Master Clock (MCLK) 3 option selected.
 */
/*@{*/
#define BP_I2S_RCR2_MSEL     (26U)         /*!< Bit position for I2S_RCR2_MSEL. */
#define BM_I2S_RCR2_MSEL     (0x0C000000U) /*!< Bit mask for I2S_RCR2_MSEL. */
#define BS_I2S_RCR2_MSEL     (2U)          /*!< Bit field size in bits for I2S_RCR2_MSEL. */

/*! @brief Read current value of the I2S_RCR2_MSEL field. */
#define BR_I2S_RCR2_MSEL(x)  (BME_UBFX32(HW_I2S_RCR2_ADDR(x), BP_I2S_RCR2_MSEL, BS_I2S_RCR2_MSEL))

/*! @brief Format value for bitfield I2S_RCR2_MSEL. */
#define BF_I2S_RCR2_MSEL(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCR2_MSEL) & BM_I2S_RCR2_MSEL)

/*! @brief Set the MSEL field to a new value. */
#define BW_I2S_RCR2_MSEL(x, v) (BME_BFI32(HW_I2S_RCR2_ADDR(x), ((uint32_t)(v) << BP_I2S_RCR2_MSEL), BP_I2S_RCR2_MSEL, 2))
/*@}*/

/*!
 * @name Register I2S_RCR2, field BCI[28] (RW)
 *
 * When this field is set and using an internally generated bit clock in either
 * synchronous or asynchronous mode, the bit clock actually used by the receiver
 * is delayed by the pad output delay (the receiver is clocked by the pad input
 * as if the clock was externally generated). This has the effect of decreasing
 * the data input setup time, but increasing the data output valid time. The slave
 * mode timing from the datasheet should be used for the receiver when this bit
 * is set. In synchronous mode, this bit allows the receiver to use the slave mode
 * timing from the datasheet, while the transmitter uses the master mode timing.
 * This field has no effect when configured for an externally generated bit
 * clock .
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Internal logic is clocked as if bit clock was externally generated.
 */
/*@{*/
#define BP_I2S_RCR2_BCI      (28U)         /*!< Bit position for I2S_RCR2_BCI. */
#define BM_I2S_RCR2_BCI      (0x10000000U) /*!< Bit mask for I2S_RCR2_BCI. */
#define BS_I2S_RCR2_BCI      (1U)          /*!< Bit field size in bits for I2S_RCR2_BCI. */

/*! @brief Read current value of the I2S_RCR2_BCI field. */
#define BR_I2S_RCR2_BCI(x)   (BME_UBFX32(HW_I2S_RCR2_ADDR(x), BP_I2S_RCR2_BCI, BS_I2S_RCR2_BCI))

/*! @brief Format value for bitfield I2S_RCR2_BCI. */
#define BF_I2S_RCR2_BCI(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR2_BCI) & BM_I2S_RCR2_BCI)

/*! @brief Set the BCI field to a new value. */
#define BW_I2S_RCR2_BCI(x, v) (BME_BFI32(HW_I2S_RCR2_ADDR(x), ((uint32_t)(v) << BP_I2S_RCR2_BCI), BP_I2S_RCR2_BCI, 1))
/*@}*/

/*!
 * @name Register I2S_RCR2, field BCS[29] (RW)
 *
 * This field swaps the bit clock used by the receiver. When the receiver is
 * configured in asynchronous mode and this bit is set, the receiver is clocked by
 * the transmitter bit clock (SAI_TX_BCLK). This allows the transmitter and
 * receiver to share the same bit clock, but the receiver continues to use the receiver
 * frame sync (SAI_RX_SYNC). When the receiver is configured in synchronous
 * mode, the transmitter BCS field and receiver BCS field must be set to the same
 * value. When both are set, the transmitter and receiver are both clocked by the
 * receiver bit clock (SAI_RX_BCLK) but use the transmitter frame sync
 * (SAI_TX_SYNC).
 *
 * Values:
 * - 0 - Use the normal bit clock source.
 * - 1 - Swap the bit clock source.
 */
/*@{*/
#define BP_I2S_RCR2_BCS      (29U)         /*!< Bit position for I2S_RCR2_BCS. */
#define BM_I2S_RCR2_BCS      (0x20000000U) /*!< Bit mask for I2S_RCR2_BCS. */
#define BS_I2S_RCR2_BCS      (1U)          /*!< Bit field size in bits for I2S_RCR2_BCS. */

/*! @brief Read current value of the I2S_RCR2_BCS field. */
#define BR_I2S_RCR2_BCS(x)   (BME_UBFX32(HW_I2S_RCR2_ADDR(x), BP_I2S_RCR2_BCS, BS_I2S_RCR2_BCS))

/*! @brief Format value for bitfield I2S_RCR2_BCS. */
#define BF_I2S_RCR2_BCS(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR2_BCS) & BM_I2S_RCR2_BCS)

/*! @brief Set the BCS field to a new value. */
#define BW_I2S_RCR2_BCS(x, v) (BME_BFI32(HW_I2S_RCR2_ADDR(x), ((uint32_t)(v) << BP_I2S_RCR2_BCS), BP_I2S_RCR2_BCS, 1))
/*@}*/

/*!
 * @name Register I2S_RCR2, field SYNC[31:30] (RW)
 *
 * Configures between asynchronous and synchronous modes of operation. When
 * configured for a synchronous mode of operation, the transmitter must be configured
 * for asynchronous operation.
 *
 * Values:
 * - 00 - Asynchronous mode.
 * - 01 - Synchronous with transmitter.
 * - 10 - Synchronous with another SAI receiver.
 * - 11 - Synchronous with another SAI transmitter.
 */
/*@{*/
#define BP_I2S_RCR2_SYNC     (30U)         /*!< Bit position for I2S_RCR2_SYNC. */
#define BM_I2S_RCR2_SYNC     (0xC0000000U) /*!< Bit mask for I2S_RCR2_SYNC. */
#define BS_I2S_RCR2_SYNC     (2U)          /*!< Bit field size in bits for I2S_RCR2_SYNC. */

/*! @brief Read current value of the I2S_RCR2_SYNC field. */
#define BR_I2S_RCR2_SYNC(x)  (BME_UBFX32(HW_I2S_RCR2_ADDR(x), BP_I2S_RCR2_SYNC, BS_I2S_RCR2_SYNC))

/*! @brief Format value for bitfield I2S_RCR2_SYNC. */
#define BF_I2S_RCR2_SYNC(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCR2_SYNC) & BM_I2S_RCR2_SYNC)

/*! @brief Set the SYNC field to a new value. */
#define BW_I2S_RCR2_SYNC(x, v) (BME_BFI32(HW_I2S_RCR2_ADDR(x), ((uint32_t)(v) << BP_I2S_RCR2_SYNC), BP_I2S_RCR2_SYNC, 2))
/*@}*/

/*******************************************************************************
 * HW_I2S_RCR3 - SAI Receive Configuration 3 Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_RCR3 - SAI Receive Configuration 3 Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_i2s_rcr3
{
    uint32_t U;
    struct _hw_i2s_rcr3_bitfields
    {
        uint32_t WDFL : 1;             /*!< [0] Word Flag Configuration */
        uint32_t RESERVED0 : 15;       /*!< [15:1]  */
        uint32_t RCE : 1;              /*!< [16] Receive Channel Enable */
        uint32_t RESERVED1 : 15;       /*!< [31:17]  */
    } B;
} hw_i2s_rcr3_t;

/*!
 * @name Constants and macros for entire I2S_RCR3 register
 */
/*@{*/
#define HW_I2S_RCR3_ADDR(x)      ((uint32_t)(x) + 0x8CU)

#define HW_I2S_RCR3(x)           (*(__IO hw_i2s_rcr3_t *) HW_I2S_RCR3_ADDR(x))
#define HW_I2S_RCR3_RD(x)        (HW_I2S_RCR3(x).U)
#define HW_I2S_RCR3_WR(x, v)     (HW_I2S_RCR3(x).U = (v))
#define HW_I2S_RCR3_SET(x, v)    (BME_OR32(HW_I2S_RCR3_ADDR(x), (uint32_t)(v)))
#define HW_I2S_RCR3_CLR(x, v)    (BME_AND32(HW_I2S_RCR3_ADDR(x), (uint32_t)(~(v))))
#define HW_I2S_RCR3_TOG(x, v)    (BME_XOR32(HW_I2S_RCR3_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR3 bitfields
 */

/*!
 * @name Register I2S_RCR3, field WDFL[0] (RW)
 *
 * Configures which word the start of word flag is set. The value written should
 * be one less than the word number (for example, write zero to configure for
 * the first word in the frame). When configured to a value greater than the Frame
 * Size field, then the start of word flag is never set.
 */
/*@{*/
#define BP_I2S_RCR3_WDFL     (0U)          /*!< Bit position for I2S_RCR3_WDFL. */
#define BM_I2S_RCR3_WDFL     (0x00000001U) /*!< Bit mask for I2S_RCR3_WDFL. */
#define BS_I2S_RCR3_WDFL     (1U)          /*!< Bit field size in bits for I2S_RCR3_WDFL. */

/*! @brief Read current value of the I2S_RCR3_WDFL field. */
#define BR_I2S_RCR3_WDFL(x)  (BME_UBFX32(HW_I2S_RCR3_ADDR(x), BP_I2S_RCR3_WDFL, BS_I2S_RCR3_WDFL))

/*! @brief Format value for bitfield I2S_RCR3_WDFL. */
#define BF_I2S_RCR3_WDFL(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCR3_WDFL) & BM_I2S_RCR3_WDFL)

/*! @brief Set the WDFL field to a new value. */
#define BW_I2S_RCR3_WDFL(x, v) (BME_BFI32(HW_I2S_RCR3_ADDR(x), ((uint32_t)(v) << BP_I2S_RCR3_WDFL), BP_I2S_RCR3_WDFL, 1))
/*@}*/

/*!
 * @name Register I2S_RCR3, field RCE[16] (RW)
 *
 * Enables the corresponding data channel for receive operation. A channel must
 * be enabled before its FIFO is accessed. Changing this field will take effect
 * immediately for generating the FIFO request and warning flags, but at the end
 * of each frame for receive operation.
 *
 * Values:
 * - 0 - Receive data channel N is disabled.
 * - 1 - Receive data channel N is enabled.
 */
/*@{*/
#define BP_I2S_RCR3_RCE      (16U)         /*!< Bit position for I2S_RCR3_RCE. */
#define BM_I2S_RCR3_RCE      (0x00010000U) /*!< Bit mask for I2S_RCR3_RCE. */
#define BS_I2S_RCR3_RCE      (1U)          /*!< Bit field size in bits for I2S_RCR3_RCE. */

/*! @brief Read current value of the I2S_RCR3_RCE field. */
#define BR_I2S_RCR3_RCE(x)   (BME_UBFX32(HW_I2S_RCR3_ADDR(x), BP_I2S_RCR3_RCE, BS_I2S_RCR3_RCE))

/*! @brief Format value for bitfield I2S_RCR3_RCE. */
#define BF_I2S_RCR3_RCE(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR3_RCE) & BM_I2S_RCR3_RCE)

/*! @brief Set the RCE field to a new value. */
#define BW_I2S_RCR3_RCE(x, v) (BME_BFI32(HW_I2S_RCR3_ADDR(x), ((uint32_t)(v) << BP_I2S_RCR3_RCE), BP_I2S_RCR3_RCE, 1))
/*@}*/

/*******************************************************************************
 * HW_I2S_RCR4 - SAI Receive Configuration 4 Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_RCR4 - SAI Receive Configuration 4 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when RCSR[RE] is set.
 */
typedef union _hw_i2s_rcr4
{
    uint32_t U;
    struct _hw_i2s_rcr4_bitfields
    {
        uint32_t FSD : 1;              /*!< [0] Frame Sync Direction */
        uint32_t FSP : 1;              /*!< [1] Frame Sync Polarity */
        uint32_t ONDEM : 1;            /*!< [2] On Demand Mode */
        uint32_t FSE : 1;              /*!< [3] Frame Sync Early */
        uint32_t MF : 1;               /*!< [4] MSB First */
        uint32_t RESERVED0 : 3;        /*!< [7:5]  */
        uint32_t SYWD : 5;             /*!< [12:8] Sync Width */
        uint32_t RESERVED1 : 3;        /*!< [15:13]  */
        uint32_t FRSZ : 1;             /*!< [16] Frame Size */
        uint32_t RESERVED2 : 7;        /*!< [23:17]  */
        uint32_t FPACK : 2;            /*!< [25:24] FIFO Packing Mode */
        uint32_t RESERVED3 : 2;        /*!< [27:26]  */
        uint32_t FCONT : 1;            /*!< [28] FIFO Continue on Error */
        uint32_t RESERVED4 : 3;        /*!< [31:29]  */
    } B;
} hw_i2s_rcr4_t;

/*!
 * @name Constants and macros for entire I2S_RCR4 register
 */
/*@{*/
#define HW_I2S_RCR4_ADDR(x)      ((uint32_t)(x) + 0x90U)

#define HW_I2S_RCR4(x)           (*(__IO hw_i2s_rcr4_t *) HW_I2S_RCR4_ADDR(x))
#define HW_I2S_RCR4_RD(x)        (HW_I2S_RCR4(x).U)
#define HW_I2S_RCR4_WR(x, v)     (HW_I2S_RCR4(x).U = (v))
#define HW_I2S_RCR4_SET(x, v)    (BME_OR32(HW_I2S_RCR4_ADDR(x), (uint32_t)(v)))
#define HW_I2S_RCR4_CLR(x, v)    (BME_AND32(HW_I2S_RCR4_ADDR(x), (uint32_t)(~(v))))
#define HW_I2S_RCR4_TOG(x, v)    (BME_XOR32(HW_I2S_RCR4_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR4 bitfields
 */

/*!
 * @name Register I2S_RCR4, field FSD[0] (RW)
 *
 * Configures the direction of the frame sync.
 *
 * Values:
 * - 0 - Frame Sync is generated externally in Slave mode.
 * - 1 - Frame Sync is generated internally in Master mode.
 */
/*@{*/
#define BP_I2S_RCR4_FSD      (0U)          /*!< Bit position for I2S_RCR4_FSD. */
#define BM_I2S_RCR4_FSD      (0x00000001U) /*!< Bit mask for I2S_RCR4_FSD. */
#define BS_I2S_RCR4_FSD      (1U)          /*!< Bit field size in bits for I2S_RCR4_FSD. */

/*! @brief Read current value of the I2S_RCR4_FSD field. */
#define BR_I2S_RCR4_FSD(x)   (BME_UBFX32(HW_I2S_RCR4_ADDR(x), BP_I2S_RCR4_FSD, BS_I2S_RCR4_FSD))

/*! @brief Format value for bitfield I2S_RCR4_FSD. */
#define BF_I2S_RCR4_FSD(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR4_FSD) & BM_I2S_RCR4_FSD)

/*! @brief Set the FSD field to a new value. */
#define BW_I2S_RCR4_FSD(x, v) (BME_BFI32(HW_I2S_RCR4_ADDR(x), ((uint32_t)(v) << BP_I2S_RCR4_FSD), BP_I2S_RCR4_FSD, 1))
/*@}*/

/*!
 * @name Register I2S_RCR4, field FSP[1] (RW)
 *
 * Configures the polarity of the frame sync.
 *
 * Values:
 * - 0 - Frame sync is active high.
 * - 1 - Frame sync is active low.
 */
/*@{*/
#define BP_I2S_RCR4_FSP      (1U)          /*!< Bit position for I2S_RCR4_FSP. */
#define BM_I2S_RCR4_FSP      (0x00000002U) /*!< Bit mask for I2S_RCR4_FSP. */
#define BS_I2S_RCR4_FSP      (1U)          /*!< Bit field size in bits for I2S_RCR4_FSP. */

/*! @brief Read current value of the I2S_RCR4_FSP field. */
#define BR_I2S_RCR4_FSP(x)   (BME_UBFX32(HW_I2S_RCR4_ADDR(x), BP_I2S_RCR4_FSP, BS_I2S_RCR4_FSP))

/*! @brief Format value for bitfield I2S_RCR4_FSP. */
#define BF_I2S_RCR4_FSP(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR4_FSP) & BM_I2S_RCR4_FSP)

/*! @brief Set the FSP field to a new value. */
#define BW_I2S_RCR4_FSP(x, v) (BME_BFI32(HW_I2S_RCR4_ADDR(x), ((uint32_t)(v) << BP_I2S_RCR4_FSP), BP_I2S_RCR4_FSP, 1))
/*@}*/

/*!
 * @name Register I2S_RCR4, field ONDEM[2] (RW)
 *
 * When set, and the frame sync is generated internally, a frame sync is only
 * generated when the FIFO warning flag is clear.
 *
 * Values:
 * - 0 - Internal frame sync is generated continuously.
 * - 1 - Internal frame sync is generated when the FIFO warning flag is clear.
 */
/*@{*/
#define BP_I2S_RCR4_ONDEM    (2U)          /*!< Bit position for I2S_RCR4_ONDEM. */
#define BM_I2S_RCR4_ONDEM    (0x00000004U) /*!< Bit mask for I2S_RCR4_ONDEM. */
#define BS_I2S_RCR4_ONDEM    (1U)          /*!< Bit field size in bits for I2S_RCR4_ONDEM. */

/*! @brief Read current value of the I2S_RCR4_ONDEM field. */
#define BR_I2S_RCR4_ONDEM(x) (BME_UBFX32(HW_I2S_RCR4_ADDR(x), BP_I2S_RCR4_ONDEM, BS_I2S_RCR4_ONDEM))

/*! @brief Format value for bitfield I2S_RCR4_ONDEM. */
#define BF_I2S_RCR4_ONDEM(v) ((uint32_t)((uint32_t)(v) << BP_I2S_RCR4_ONDEM) & BM_I2S_RCR4_ONDEM)

/*! @brief Set the ONDEM field to a new value. */
#define BW_I2S_RCR4_ONDEM(x, v) (BME_BFI32(HW_I2S_RCR4_ADDR(x), ((uint32_t)(v) << BP_I2S_RCR4_ONDEM), BP_I2S_RCR4_ONDEM, 1))
/*@}*/

/*!
 * @name Register I2S_RCR4, field FSE[3] (RW)
 *
 * Values:
 * - 0 - Frame sync asserts with the first bit of the frame.
 * - 1 - Frame sync asserts one bit before the first bit of the frame.
 */
/*@{*/
#define BP_I2S_RCR4_FSE      (3U)          /*!< Bit position for I2S_RCR4_FSE. */
#define BM_I2S_RCR4_FSE      (0x00000008U) /*!< Bit mask for I2S_RCR4_FSE. */
#define BS_I2S_RCR4_FSE      (1U)          /*!< Bit field size in bits for I2S_RCR4_FSE. */

/*! @brief Read current value of the I2S_RCR4_FSE field. */
#define BR_I2S_RCR4_FSE(x)   (BME_UBFX32(HW_I2S_RCR4_ADDR(x), BP_I2S_RCR4_FSE, BS_I2S_RCR4_FSE))

/*! @brief Format value for bitfield I2S_RCR4_FSE. */
#define BF_I2S_RCR4_FSE(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR4_FSE) & BM_I2S_RCR4_FSE)

/*! @brief Set the FSE field to a new value. */
#define BW_I2S_RCR4_FSE(x, v) (BME_BFI32(HW_I2S_RCR4_ADDR(x), ((uint32_t)(v) << BP_I2S_RCR4_FSE), BP_I2S_RCR4_FSE, 1))
/*@}*/

/*!
 * @name Register I2S_RCR4, field MF[4] (RW)
 *
 * Configures whether the LSB or the MSB is received first.
 *
 * Values:
 * - 0 - LSB is received first.
 * - 1 - MSB is received first.
 */
/*@{*/
#define BP_I2S_RCR4_MF       (4U)          /*!< Bit position for I2S_RCR4_MF. */
#define BM_I2S_RCR4_MF       (0x00000010U) /*!< Bit mask for I2S_RCR4_MF. */
#define BS_I2S_RCR4_MF       (1U)          /*!< Bit field size in bits for I2S_RCR4_MF. */

/*! @brief Read current value of the I2S_RCR4_MF field. */
#define BR_I2S_RCR4_MF(x)    (BME_UBFX32(HW_I2S_RCR4_ADDR(x), BP_I2S_RCR4_MF, BS_I2S_RCR4_MF))

/*! @brief Format value for bitfield I2S_RCR4_MF. */
#define BF_I2S_RCR4_MF(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_RCR4_MF) & BM_I2S_RCR4_MF)

/*! @brief Set the MF field to a new value. */
#define BW_I2S_RCR4_MF(x, v) (BME_BFI32(HW_I2S_RCR4_ADDR(x), ((uint32_t)(v) << BP_I2S_RCR4_MF), BP_I2S_RCR4_MF, 1))
/*@}*/

/*!
 * @name Register I2S_RCR4, field SYWD[12:8] (RW)
 *
 * Configures the length of the frame sync in number of bit clocks. The value
 * written must be one less than the number of bit clocks. For example, write 0 for
 * the frame sync to assert for one bit clock only. The sync width cannot be
 * configured longer than the first word of the frame.
 */
/*@{*/
#define BP_I2S_RCR4_SYWD     (8U)          /*!< Bit position for I2S_RCR4_SYWD. */
#define BM_I2S_RCR4_SYWD     (0x00001F00U) /*!< Bit mask for I2S_RCR4_SYWD. */
#define BS_I2S_RCR4_SYWD     (5U)          /*!< Bit field size in bits for I2S_RCR4_SYWD. */

/*! @brief Read current value of the I2S_RCR4_SYWD field. */
#define BR_I2S_RCR4_SYWD(x)  (BME_UBFX32(HW_I2S_RCR4_ADDR(x), BP_I2S_RCR4_SYWD, BS_I2S_RCR4_SYWD))

/*! @brief Format value for bitfield I2S_RCR4_SYWD. */
#define BF_I2S_RCR4_SYWD(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCR4_SYWD) & BM_I2S_RCR4_SYWD)

/*! @brief Set the SYWD field to a new value. */
#define BW_I2S_RCR4_SYWD(x, v) (BME_BFI32(HW_I2S_RCR4_ADDR(x), ((uint32_t)(v) << BP_I2S_RCR4_SYWD), BP_I2S_RCR4_SYWD, 5))
/*@}*/

/*!
 * @name Register I2S_RCR4, field FRSZ[16] (RW)
 *
 * Configures the number of words in each frame. The value written must be one
 * less than the number of words in the frame. For example, write 0 for one word
 * per frame. The maximum supported frame size is 2 words.
 */
/*@{*/
#define BP_I2S_RCR4_FRSZ     (16U)         /*!< Bit position for I2S_RCR4_FRSZ. */
#define BM_I2S_RCR4_FRSZ     (0x00010000U) /*!< Bit mask for I2S_RCR4_FRSZ. */
#define BS_I2S_RCR4_FRSZ     (1U)          /*!< Bit field size in bits for I2S_RCR4_FRSZ. */

/*! @brief Read current value of the I2S_RCR4_FRSZ field. */
#define BR_I2S_RCR4_FRSZ(x)  (BME_UBFX32(HW_I2S_RCR4_ADDR(x), BP_I2S_RCR4_FRSZ, BS_I2S_RCR4_FRSZ))

/*! @brief Format value for bitfield I2S_RCR4_FRSZ. */
#define BF_I2S_RCR4_FRSZ(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCR4_FRSZ) & BM_I2S_RCR4_FRSZ)

/*! @brief Set the FRSZ field to a new value. */
#define BW_I2S_RCR4_FRSZ(x, v) (BME_BFI32(HW_I2S_RCR4_ADDR(x), ((uint32_t)(v) << BP_I2S_RCR4_FRSZ), BP_I2S_RCR4_FRSZ, 1))
/*@}*/

/*!
 * @name Register I2S_RCR4, field FPACK[25:24] (RW)
 *
 * Enables packing of 8-bit data or 16-bit data into each 32-bit FIFO word. If
 * the word size is greater than 8-bit or 16-bit then only the first 8-bit or
 * 16-bits are stored to the FIFO. The first word in each frame always starts with a
 * new 32-bit FIFO word and the first bit shifted must be configured within the
 * first packed word. When FIFO packing is enabled, the FIFO read pointer will
 * only increment when the full 32-bit FIFO word has been read by software.
 *
 * Values:
 * - 00 - FIFO packing is disabled
 * - 01 - Reserved.
 * - 10 - 8-bit FIFO packing is enabled
 * - 11 - 16-bit FIFO packing is enabled
 */
/*@{*/
#define BP_I2S_RCR4_FPACK    (24U)         /*!< Bit position for I2S_RCR4_FPACK. */
#define BM_I2S_RCR4_FPACK    (0x03000000U) /*!< Bit mask for I2S_RCR4_FPACK. */
#define BS_I2S_RCR4_FPACK    (2U)          /*!< Bit field size in bits for I2S_RCR4_FPACK. */

/*! @brief Read current value of the I2S_RCR4_FPACK field. */
#define BR_I2S_RCR4_FPACK(x) (BME_UBFX32(HW_I2S_RCR4_ADDR(x), BP_I2S_RCR4_FPACK, BS_I2S_RCR4_FPACK))

/*! @brief Format value for bitfield I2S_RCR4_FPACK. */
#define BF_I2S_RCR4_FPACK(v) ((uint32_t)((uint32_t)(v) << BP_I2S_RCR4_FPACK) & BM_I2S_RCR4_FPACK)

/*! @brief Set the FPACK field to a new value. */
#define BW_I2S_RCR4_FPACK(x, v) (BME_BFI32(HW_I2S_RCR4_ADDR(x), ((uint32_t)(v) << BP_I2S_RCR4_FPACK), BP_I2S_RCR4_FPACK, 2))
/*@}*/

/*!
 * @name Register I2S_RCR4, field FCONT[28] (RW)
 *
 * Configures when the SAI will continue receiving after a FIFO error has been
 * detected.
 *
 * Values:
 * - 0 - On FIFO error, the SAI will continue from the start of the next frame
 *     after the FIFO error flag has been cleared.
 * - 1 - On FIFO error, the SAI will continue from the same word that caused the
 *     FIFO error to set after the FIFO warning flag has been cleared.
 */
/*@{*/
#define BP_I2S_RCR4_FCONT    (28U)         /*!< Bit position for I2S_RCR4_FCONT. */
#define BM_I2S_RCR4_FCONT    (0x10000000U) /*!< Bit mask for I2S_RCR4_FCONT. */
#define BS_I2S_RCR4_FCONT    (1U)          /*!< Bit field size in bits for I2S_RCR4_FCONT. */

/*! @brief Read current value of the I2S_RCR4_FCONT field. */
#define BR_I2S_RCR4_FCONT(x) (BME_UBFX32(HW_I2S_RCR4_ADDR(x), BP_I2S_RCR4_FCONT, BS_I2S_RCR4_FCONT))

/*! @brief Format value for bitfield I2S_RCR4_FCONT. */
#define BF_I2S_RCR4_FCONT(v) ((uint32_t)((uint32_t)(v) << BP_I2S_RCR4_FCONT) & BM_I2S_RCR4_FCONT)

/*! @brief Set the FCONT field to a new value. */
#define BW_I2S_RCR4_FCONT(x, v) (BME_BFI32(HW_I2S_RCR4_ADDR(x), ((uint32_t)(v) << BP_I2S_RCR4_FCONT), BP_I2S_RCR4_FCONT, 1))
/*@}*/

/*******************************************************************************
 * HW_I2S_RCR5 - SAI Receive Configuration 5 Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_RCR5 - SAI Receive Configuration 5 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when RCSR[RE] is set.
 */
typedef union _hw_i2s_rcr5
{
    uint32_t U;
    struct _hw_i2s_rcr5_bitfields
    {
        uint32_t RESERVED0 : 8;        /*!< [7:0]  */
        uint32_t FBT : 5;              /*!< [12:8] First Bit Shifted */
        uint32_t RESERVED1 : 3;        /*!< [15:13]  */
        uint32_t W0W : 5;              /*!< [20:16] Word 0 Width */
        uint32_t RESERVED2 : 3;        /*!< [23:21]  */
        uint32_t WNW : 5;              /*!< [28:24] Word N Width */
        uint32_t RESERVED3 : 3;        /*!< [31:29]  */
    } B;
} hw_i2s_rcr5_t;

/*!
 * @name Constants and macros for entire I2S_RCR5 register
 */
/*@{*/
#define HW_I2S_RCR5_ADDR(x)      ((uint32_t)(x) + 0x94U)

#define HW_I2S_RCR5(x)           (*(__IO hw_i2s_rcr5_t *) HW_I2S_RCR5_ADDR(x))
#define HW_I2S_RCR5_RD(x)        (HW_I2S_RCR5(x).U)
#define HW_I2S_RCR5_WR(x, v)     (HW_I2S_RCR5(x).U = (v))
#define HW_I2S_RCR5_SET(x, v)    (BME_OR32(HW_I2S_RCR5_ADDR(x), (uint32_t)(v)))
#define HW_I2S_RCR5_CLR(x, v)    (BME_AND32(HW_I2S_RCR5_ADDR(x), (uint32_t)(~(v))))
#define HW_I2S_RCR5_TOG(x, v)    (BME_XOR32(HW_I2S_RCR5_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR5 bitfields
 */

/*!
 * @name Register I2S_RCR5, field FBT[12:8] (RW)
 *
 * Configures the bit index for the first bit received for each word in the
 * frame. If configured for MSB First, the index of the next bit received is one less
 * than the current bit received. If configured for LSB First, the index of the
 * next bit received is one more than the current bit received. The value written
 * must be greater than or equal to the word width when configured for MSB
 * First. The value written must be less than or equal to 31-word width when
 * configured for LSB First.
 */
/*@{*/
#define BP_I2S_RCR5_FBT      (8U)          /*!< Bit position for I2S_RCR5_FBT. */
#define BM_I2S_RCR5_FBT      (0x00001F00U) /*!< Bit mask for I2S_RCR5_FBT. */
#define BS_I2S_RCR5_FBT      (5U)          /*!< Bit field size in bits for I2S_RCR5_FBT. */

/*! @brief Read current value of the I2S_RCR5_FBT field. */
#define BR_I2S_RCR5_FBT(x)   (BME_UBFX32(HW_I2S_RCR5_ADDR(x), BP_I2S_RCR5_FBT, BS_I2S_RCR5_FBT))

/*! @brief Format value for bitfield I2S_RCR5_FBT. */
#define BF_I2S_RCR5_FBT(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR5_FBT) & BM_I2S_RCR5_FBT)

/*! @brief Set the FBT field to a new value. */
#define BW_I2S_RCR5_FBT(x, v) (BME_BFI32(HW_I2S_RCR5_ADDR(x), ((uint32_t)(v) << BP_I2S_RCR5_FBT), BP_I2S_RCR5_FBT, 5))
/*@}*/

/*!
 * @name Register I2S_RCR5, field W0W[20:16] (RW)
 *
 * Configures the number of bits in the first word in each frame. The value
 * written must be one less than the number of bits in the first word. Word width of
 * less than 8 bits is not supported if there is only one word per frame.
 */
/*@{*/
#define BP_I2S_RCR5_W0W      (16U)         /*!< Bit position for I2S_RCR5_W0W. */
#define BM_I2S_RCR5_W0W      (0x001F0000U) /*!< Bit mask for I2S_RCR5_W0W. */
#define BS_I2S_RCR5_W0W      (5U)          /*!< Bit field size in bits for I2S_RCR5_W0W. */

/*! @brief Read current value of the I2S_RCR5_W0W field. */
#define BR_I2S_RCR5_W0W(x)   (BME_UBFX32(HW_I2S_RCR5_ADDR(x), BP_I2S_RCR5_W0W, BS_I2S_RCR5_W0W))

/*! @brief Format value for bitfield I2S_RCR5_W0W. */
#define BF_I2S_RCR5_W0W(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR5_W0W) & BM_I2S_RCR5_W0W)

/*! @brief Set the W0W field to a new value. */
#define BW_I2S_RCR5_W0W(x, v) (BME_BFI32(HW_I2S_RCR5_ADDR(x), ((uint32_t)(v) << BP_I2S_RCR5_W0W), BP_I2S_RCR5_W0W, 5))
/*@}*/

/*!
 * @name Register I2S_RCR5, field WNW[28:24] (RW)
 *
 * Configures the number of bits in each word, for each word except the first in
 * the frame. The value written must be one less than the number of bits per
 * word. Word width of less than 8 bits is not supported.
 */
/*@{*/
#define BP_I2S_RCR5_WNW      (24U)         /*!< Bit position for I2S_RCR5_WNW. */
#define BM_I2S_RCR5_WNW      (0x1F000000U) /*!< Bit mask for I2S_RCR5_WNW. */
#define BS_I2S_RCR5_WNW      (5U)          /*!< Bit field size in bits for I2S_RCR5_WNW. */

/*! @brief Read current value of the I2S_RCR5_WNW field. */
#define BR_I2S_RCR5_WNW(x)   (BME_UBFX32(HW_I2S_RCR5_ADDR(x), BP_I2S_RCR5_WNW, BS_I2S_RCR5_WNW))

/*! @brief Format value for bitfield I2S_RCR5_WNW. */
#define BF_I2S_RCR5_WNW(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR5_WNW) & BM_I2S_RCR5_WNW)

/*! @brief Set the WNW field to a new value. */
#define BW_I2S_RCR5_WNW(x, v) (BME_BFI32(HW_I2S_RCR5_ADDR(x), ((uint32_t)(v) << BP_I2S_RCR5_WNW), BP_I2S_RCR5_WNW, 5))
/*@}*/

/*******************************************************************************
 * HW_I2S_RDRn - SAI Receive Data Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_RDRn - SAI Receive Data Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Reading this register introduces one additional peripheral clock wait state
 * on each read.
 */
typedef union _hw_i2s_rdrn
{
    uint32_t U;
    struct _hw_i2s_rdrn_bitfields
    {
        uint32_t RDR : 32;             /*!< [31:0] Receive Data Register */
    } B;
} hw_i2s_rdrn_t;

/*!
 * @name Constants and macros for entire I2S_RDRn register
 */
/*@{*/
#define HW_I2S_RDRn_COUNT (1U)

#define HW_I2S_RDRn_ADDR(x, n)   ((uint32_t)(x) + 0xA0U + (0x4U * (n)))

#define HW_I2S_RDRn(x, n)        (*(__I hw_i2s_rdrn_t *) HW_I2S_RDRn_ADDR(x, n))
#define HW_I2S_RDRn_RD(x, n)     (HW_I2S_RDRn(x, n).U)
/*@}*/

/*
 * Constants & macros for individual I2S_RDRn bitfields
 */

/*!
 * @name Register I2S_RDRn, field RDR[31:0] (RO)
 *
 * The corresponding RCR3[RCE] bit must be set before accessing the channel's
 * receive data register. Reads from this register when the receive FIFO is not
 * empty will return the data from the top of the receive FIFO. Reads from this
 * register when the receive FIFO is empty are ignored.
 */
/*@{*/
#define BP_I2S_RDRn_RDR      (0U)          /*!< Bit position for I2S_RDRn_RDR. */
#define BM_I2S_RDRn_RDR      (0xFFFFFFFFU) /*!< Bit mask for I2S_RDRn_RDR. */
#define BS_I2S_RDRn_RDR      (32U)         /*!< Bit field size in bits for I2S_RDRn_RDR. */

/*! @brief Read current value of the I2S_RDRn_RDR field. */
#define BR_I2S_RDRn_RDR(x, n) (HW_I2S_RDRn(x, n).U)
/*@}*/

/*******************************************************************************
 * HW_I2S_RMR - SAI Receive Mask Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_RMR - SAI Receive Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is double-buffered and updates: When RCSR[RE] is first set At
 * the end of each frame This allows the masked words in each frame to change from
 * frame to frame.
 */
typedef union _hw_i2s_rmr
{
    uint32_t U;
    struct _hw_i2s_rmr_bitfields
    {
        uint32_t RWM : 2;              /*!< [1:0] Receive Word Mask */
        uint32_t RESERVED0 : 30;       /*!< [31:2]  */
    } B;
} hw_i2s_rmr_t;

/*!
 * @name Constants and macros for entire I2S_RMR register
 */
/*@{*/
#define HW_I2S_RMR_ADDR(x)       ((uint32_t)(x) + 0xE0U)

#define HW_I2S_RMR(x)            (*(__IO hw_i2s_rmr_t *) HW_I2S_RMR_ADDR(x))
#define HW_I2S_RMR_RD(x)         (HW_I2S_RMR(x).U)
#define HW_I2S_RMR_WR(x, v)      (HW_I2S_RMR(x).U = (v))
#define HW_I2S_RMR_SET(x, v)     (BME_OR32(HW_I2S_RMR_ADDR(x), (uint32_t)(v)))
#define HW_I2S_RMR_CLR(x, v)     (BME_AND32(HW_I2S_RMR_ADDR(x), (uint32_t)(~(v))))
#define HW_I2S_RMR_TOG(x, v)     (BME_XOR32(HW_I2S_RMR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2S_RMR bitfields
 */

/*!
 * @name Register I2S_RMR, field RWM[1:0] (RW)
 *
 * Configures whether the receive word is masked (received data ignored and not
 * written to receive FIFO) for the corresponding word in the frame.
 *
 * Values:
 * - 0 - Word N is enabled.
 * - 1 - Word N is masked.
 */
/*@{*/
#define BP_I2S_RMR_RWM       (0U)          /*!< Bit position for I2S_RMR_RWM. */
#define BM_I2S_RMR_RWM       (0x00000003U) /*!< Bit mask for I2S_RMR_RWM. */
#define BS_I2S_RMR_RWM       (2U)          /*!< Bit field size in bits for I2S_RMR_RWM. */

/*! @brief Read current value of the I2S_RMR_RWM field. */
#define BR_I2S_RMR_RWM(x)    (BME_UBFX32(HW_I2S_RMR_ADDR(x), BP_I2S_RMR_RWM, BS_I2S_RMR_RWM))

/*! @brief Format value for bitfield I2S_RMR_RWM. */
#define BF_I2S_RMR_RWM(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_RMR_RWM) & BM_I2S_RMR_RWM)

/*! @brief Set the RWM field to a new value. */
#define BW_I2S_RMR_RWM(x, v) (BME_BFI32(HW_I2S_RMR_ADDR(x), ((uint32_t)(v) << BP_I2S_RMR_RWM), BP_I2S_RMR_RWM, 2))
/*@}*/

/*******************************************************************************
 * HW_I2S_MCR - SAI MCLK Control Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_MCR - SAI MCLK Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCLK Control Register (MCR) controls the clock source and direction of
 * the audio master clock.
 */
typedef union _hw_i2s_mcr
{
    uint32_t U;
    struct _hw_i2s_mcr_bitfields
    {
        uint32_t RESERVED0 : 24;       /*!< [23:0]  */
        uint32_t MICS : 2;             /*!< [25:24] MCLK Input Clock Select */
        uint32_t RESERVED1 : 4;        /*!< [29:26]  */
        uint32_t MOE : 1;              /*!< [30] MCLK Output Enable */
        uint32_t DUF : 1;              /*!< [31] Divider Update Flag */
    } B;
} hw_i2s_mcr_t;

/*!
 * @name Constants and macros for entire I2S_MCR register
 */
/*@{*/
#define HW_I2S_MCR_ADDR(x)       ((uint32_t)(x) + 0x100U)

#define HW_I2S_MCR(x)            (*(__IO hw_i2s_mcr_t *) HW_I2S_MCR_ADDR(x))
#define HW_I2S_MCR_RD(x)         (HW_I2S_MCR(x).U)
#define HW_I2S_MCR_WR(x, v)      (HW_I2S_MCR(x).U = (v))
#define HW_I2S_MCR_SET(x, v)     (BME_OR32(HW_I2S_MCR_ADDR(x), (uint32_t)(v)))
#define HW_I2S_MCR_CLR(x, v)     (BME_AND32(HW_I2S_MCR_ADDR(x), (uint32_t)(~(v))))
#define HW_I2S_MCR_TOG(x, v)     (BME_XOR32(HW_I2S_MCR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2S_MCR bitfields
 */

/*!
 * @name Register I2S_MCR, field MICS[25:24] (RW)
 *
 * Selects the clock input to the MCLK divider. This field cannot be changed
 * while the MCLK divider is enabled. See the chip configuration details for
 * information about the connections to these inputs.
 *
 * Values:
 * - 00 - MCLK divider input clock 0 selected.
 * - 01 - MCLK divider input clock 1 selected.
 * - 10 - MCLK divider input clock 2 selected.
 * - 11 - MCLK divider input clock 3 selected.
 */
/*@{*/
#define BP_I2S_MCR_MICS      (24U)         /*!< Bit position for I2S_MCR_MICS. */
#define BM_I2S_MCR_MICS      (0x03000000U) /*!< Bit mask for I2S_MCR_MICS. */
#define BS_I2S_MCR_MICS      (2U)          /*!< Bit field size in bits for I2S_MCR_MICS. */

/*! @brief Read current value of the I2S_MCR_MICS field. */
#define BR_I2S_MCR_MICS(x)   (BME_UBFX32(HW_I2S_MCR_ADDR(x), BP_I2S_MCR_MICS, BS_I2S_MCR_MICS))

/*! @brief Format value for bitfield I2S_MCR_MICS. */
#define BF_I2S_MCR_MICS(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_MCR_MICS) & BM_I2S_MCR_MICS)

/*! @brief Set the MICS field to a new value. */
#define BW_I2S_MCR_MICS(x, v) (BME_BFI32(HW_I2S_MCR_ADDR(x), ((uint32_t)(v) << BP_I2S_MCR_MICS), BP_I2S_MCR_MICS, 2))
/*@}*/

/*!
 * @name Register I2S_MCR, field MOE[30] (RW)
 *
 * Enables the MCLK divider and configures the MCLK signal pin as an output.
 * When software clears this field, it remains set until the MCLK divider is fully
 * disabled.
 *
 * Values:
 * - 0 - MCLK signal pin is configured as an input that bypasses the MCLK
 *     divider.
 * - 1 - MCLK signal pin is configured as an output from the MCLK divider and
 *     the MCLK divider is enabled.
 */
/*@{*/
#define BP_I2S_MCR_MOE       (30U)         /*!< Bit position for I2S_MCR_MOE. */
#define BM_I2S_MCR_MOE       (0x40000000U) /*!< Bit mask for I2S_MCR_MOE. */
#define BS_I2S_MCR_MOE       (1U)          /*!< Bit field size in bits for I2S_MCR_MOE. */

/*! @brief Read current value of the I2S_MCR_MOE field. */
#define BR_I2S_MCR_MOE(x)    (BME_UBFX32(HW_I2S_MCR_ADDR(x), BP_I2S_MCR_MOE, BS_I2S_MCR_MOE))

/*! @brief Format value for bitfield I2S_MCR_MOE. */
#define BF_I2S_MCR_MOE(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_MCR_MOE) & BM_I2S_MCR_MOE)

/*! @brief Set the MOE field to a new value. */
#define BW_I2S_MCR_MOE(x, v) (BME_BFI32(HW_I2S_MCR_ADDR(x), ((uint32_t)(v) << BP_I2S_MCR_MOE), BP_I2S_MCR_MOE, 1))
/*@}*/

/*!
 * @name Register I2S_MCR, field DUF[31] (RO)
 *
 * Provides the status of on-the-fly updates to the MCLK divider ratio.
 *
 * Values:
 * - 0 - MCLK divider ratio is not being updated currently.
 * - 1 - MCLK divider ratio is updating on-the-fly. Further updates to the MCLK
 *     divider ratio are blocked while this flag remains set.
 */
/*@{*/
#define BP_I2S_MCR_DUF       (31U)         /*!< Bit position for I2S_MCR_DUF. */
#define BM_I2S_MCR_DUF       (0x80000000U) /*!< Bit mask for I2S_MCR_DUF. */
#define BS_I2S_MCR_DUF       (1U)          /*!< Bit field size in bits for I2S_MCR_DUF. */

/*! @brief Read current value of the I2S_MCR_DUF field. */
#define BR_I2S_MCR_DUF(x)    (BME_UBFX32(HW_I2S_MCR_ADDR(x), BP_I2S_MCR_DUF, BS_I2S_MCR_DUF))
/*@}*/

/*******************************************************************************
 * hw_i2s_t - module struct
 ******************************************************************************/
/*!
 * @brief All I2S module registers.
 */
#pragma pack(1)
typedef struct _hw_i2s
{
    __IO hw_i2s_tcsr_t TCSR;               /*!< [0x0] SAI Transmit Control Register */
    uint8_t _reserved0[4];
    __IO hw_i2s_tcr2_t TCR2;               /*!< [0x8] SAI Transmit Configuration 2 Register */
    __IO hw_i2s_tcr3_t TCR3;               /*!< [0xC] SAI Transmit Configuration 3 Register */
    __IO hw_i2s_tcr4_t TCR4;               /*!< [0x10] SAI Transmit Configuration 4 Register */
    __IO hw_i2s_tcr5_t TCR5;               /*!< [0x14] SAI Transmit Configuration 5 Register */
    uint8_t _reserved1[8];
    __O hw_i2s_tdrn_t TDRn[1];             /*!< [0x20] SAI Transmit Data Register */
    uint8_t _reserved2[60];
    __IO hw_i2s_tmr_t TMR;                 /*!< [0x60] SAI Transmit Mask Register */
    uint8_t _reserved3[28];
    __IO hw_i2s_rcsr_t RCSR;               /*!< [0x80] SAI Receive Control Register */
    uint8_t _reserved4[4];
    __IO hw_i2s_rcr2_t RCR2;               /*!< [0x88] SAI Receive Configuration 2 Register */
    __IO hw_i2s_rcr3_t RCR3;               /*!< [0x8C] SAI Receive Configuration 3 Register */
    __IO hw_i2s_rcr4_t RCR4;               /*!< [0x90] SAI Receive Configuration 4 Register */
    __IO hw_i2s_rcr5_t RCR5;               /*!< [0x94] SAI Receive Configuration 5 Register */
    uint8_t _reserved5[8];
    __I hw_i2s_rdrn_t RDRn[1];             /*!< [0xA0] SAI Receive Data Register */
    uint8_t _reserved6[60];
    __IO hw_i2s_rmr_t RMR;                 /*!< [0xE0] SAI Receive Mask Register */
    uint8_t _reserved7[28];
    __IO hw_i2s_mcr_t MCR;                 /*!< [0x100] SAI MCLK Control Register */
} hw_i2s_t;
#pragma pack()

/*! @brief Macro to access all I2S registers. */
/*! @param x I2S module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_I2S_REGS(I2S0_BASE)</code>. */
#define HW_I2S_REGS(x) (*(hw_i2s_t *)(x))

/*
 * MKL43Z4 LCD
 *
 * Segment Liquid Crystal Display
 *
 * Registers defined in this header file:
 * - HW_LCD_GCR - LCD General Control Register
 * - HW_LCD_AR - LCD Auxiliary Register
 * - HW_LCD_FDCR - LCD Fault Detect Control Register
 * - HW_LCD_FDSR - LCD Fault Detect Status Register
 * - HW_LCD_PENL - LCD Pin Enable register
 * - HW_LCD_PENH - LCD Pin Enable register
 * - HW_LCD_BPENL - LCD Back Plane Enable register
 * - HW_LCD_BPENH - LCD Back Plane Enable register
 * - HW_LCD_WF3TO0 - LCD Waveform register
 * - HW_LCD_WF7TO4 - LCD Waveform register
 * - HW_LCD_WF11TO8 - LCD Waveform register
 * - HW_LCD_WF15TO12 - LCD Waveform register
 * - HW_LCD_WF19TO16 - LCD Waveform register
 * - HW_LCD_WF23TO20 - LCD Waveform register
 * - HW_LCD_WF27TO24 - LCD Waveform register
 * - HW_LCD_WF31TO28 - LCD Waveform register
 * - HW_LCD_WF35TO32 - LCD Waveform register
 * - HW_LCD_WF39TO36 - LCD Waveform register
 * - HW_LCD_WF43TO40 - LCD Waveform register
 * - HW_LCD_WF47TO44 - LCD Waveform register
 * - HW_LCD_WF51TO48 - LCD Waveform register
 * - HW_LCD_WF55TO52 - LCD Waveform register
 * - HW_LCD_WF59TO56 - LCD Waveform register
 * - HW_LCD_WF63TO60 - LCD Waveform register
 * - HW_LCD_WF0 - LCD Waveform Register 0.
 * - HW_LCD_WF1 - LCD Waveform Register 1.
 * - HW_LCD_WF2 - LCD Waveform Register 2.
 * - HW_LCD_WF3 - LCD Waveform Register 3.
 * - HW_LCD_WF4 - LCD Waveform Register 4.
 * - HW_LCD_WF5 - LCD Waveform Register 5.
 * - HW_LCD_WF6 - LCD Waveform Register 6.
 * - HW_LCD_WF7 - LCD Waveform Register 7.
 * - HW_LCD_WF8 - LCD Waveform Register 8.
 * - HW_LCD_WF9 - LCD Waveform Register 9.
 * - HW_LCD_WF10 - LCD Waveform Register 10.
 * - HW_LCD_WF11 - LCD Waveform Register 11.
 * - HW_LCD_WF12 - LCD Waveform Register 12.
 * - HW_LCD_WF13 - LCD Waveform Register 13.
 * - HW_LCD_WF14 - LCD Waveform Register 14.
 * - HW_LCD_WF15 - LCD Waveform Register 15.
 * - HW_LCD_WF16 - LCD Waveform Register 16.
 * - HW_LCD_WF17 - LCD Waveform Register 17.
 * - HW_LCD_WF18 - LCD Waveform Register 18.
 * - HW_LCD_WF19 - LCD Waveform Register 19.
 * - HW_LCD_WF20 - LCD Waveform Register 20.
 * - HW_LCD_WF21 - LCD Waveform Register 21.
 * - HW_LCD_WF22 - LCD Waveform Register 22.
 * - HW_LCD_WF23 - LCD Waveform Register 23.
 * - HW_LCD_WF24 - LCD Waveform Register 24.
 * - HW_LCD_WF25 - LCD Waveform Register 25.
 * - HW_LCD_WF26 - LCD Waveform Register 26.
 * - HW_LCD_WF27 - LCD Waveform Register 27.
 * - HW_LCD_WF28 - LCD Waveform Register 28.
 * - HW_LCD_WF29 - LCD Waveform Register 29.
 * - HW_LCD_WF30 - LCD Waveform Register 30.
 * - HW_LCD_WF31 - LCD Waveform Register 31.
 * - HW_LCD_WF32 - LCD Waveform Register 32.
 * - HW_LCD_WF33 - LCD Waveform Register 33.
 * - HW_LCD_WF34 - LCD Waveform Register 34.
 * - HW_LCD_WF35 - LCD Waveform Register 35.
 * - HW_LCD_WF36 - LCD Waveform Register 36.
 * - HW_LCD_WF37 - LCD Waveform Register 37.
 * - HW_LCD_WF38 - LCD Waveform Register 38.
 * - HW_LCD_WF39 - LCD Waveform Register 39.
 * - HW_LCD_WF40 - LCD Waveform Register 40.
 * - HW_LCD_WF41 - LCD Waveform Register 41.
 * - HW_LCD_WF42 - LCD Waveform Register 42.
 * - HW_LCD_WF43 - LCD Waveform Register 43.
 * - HW_LCD_WF44 - LCD Waveform Register 44.
 * - HW_LCD_WF45 - LCD Waveform Register 45.
 * - HW_LCD_WF46 - LCD Waveform Register 46.
 * - HW_LCD_WF47 - LCD Waveform Register 47.
 * - HW_LCD_WF48 - LCD Waveform Register 48.
 * - HW_LCD_WF49 - LCD Waveform Register 49.
 * - HW_LCD_WF50 - LCD Waveform Register 50.
 * - HW_LCD_WF51 - LCD Waveform Register 51.
 * - HW_LCD_WF52 - LCD Waveform Register 52.
 * - HW_LCD_WF53 - LCD Waveform Register 53.
 * - HW_LCD_WF54 - LCD Waveform Register 54.
 * - HW_LCD_WF55 - LCD Waveform Register 55.
 * - HW_LCD_WF56 - LCD Waveform Register 56.
 * - HW_LCD_WF57 - LCD Waveform Register 57.
 * - HW_LCD_WF58 - LCD Waveform Register 58.
 * - HW_LCD_WF59 - LCD Waveform Register 59.
 * - HW_LCD_WF60 - LCD Waveform Register 60.
 * - HW_LCD_WF61 - LCD Waveform Register 61.
 * - HW_LCD_WF62 - LCD Waveform Register 62.
 * - HW_LCD_WF63 - LCD Waveform Register 63.
 *
 * - hw_lcd_t - Struct containing all module registers.
 */

#define HW_LCD_INSTANCE_COUNT (1U) /*!< Number of instances of the LCD module. */
#define HW_LCD (0U) /*!< Instance number for LCD. */

/*******************************************************************************
 * HW_LCD_GCR - LCD General Control Register
 ******************************************************************************/

/*!
 * @brief HW_LCD_GCR - LCD General Control Register (RW)
 *
 * Reset value: 0x08300003U
 *
 * Write: LCDEN anytime. Do not change SOURCE, LCLK, or DUTY while LCDEN = 1.
 * For proper operation, do not modify VSUPPLY while the LCDEN bit is asserted.
 * VSUPPLY must also be configured according to the external hardware power supply
 * configuration. The reset value of this register depends on the reset type: POR
 * -- 0x0831_0003
 */
typedef union _hw_lcd_gcr
{
    uint32_t U;
    struct _hw_lcd_gcr_bitfields
    {
        uint32_t DUTY : 3;             /*!< [2:0] LCD duty select */
        uint32_t LCLK : 3;             /*!< [5:3] LCD Clock Prescaler */
        uint32_t SOURCE : 1;           /*!< [6] LCD Clock Source Select */
        uint32_t LCDEN : 1;            /*!< [7] LCD Driver Enable */
        uint32_t LCDSTP : 1;           /*!< [8] LCD Stop */
        uint32_t LCDDOZE : 1;          /*!< [9] LCD Doze enable */
        uint32_t FFR : 1;              /*!< [10] Fast Frame Rate Select */
        uint32_t ALTSOURCE : 1;        /*!< [11] Selects the alternate clock source
                                        * */
        uint32_t ALTDIV : 2;           /*!< [13:12] LCD AlternateClock Divider */
        uint32_t FDCIEN : 1;           /*!< [14] LCD Fault Detection Complete Interrupt
                                        * Enable */
        uint32_t PADSAFE : 1;          /*!< [15] Pad Safe State Enable */
        uint32_t RESERVED0 : 1;        /*!< [16]  */
        uint32_t VSUPPLY : 1;          /*!< [17] Voltage Supply Control */
        uint32_t RESERVED1 : 2;        /*!< [19:18] Reserved */
        uint32_t LADJ : 2;             /*!< [21:20] Load Adjust */
        uint32_t RESERVED2 : 1;        /*!< [22] Reserved */
        uint32_t CPSEL : 1;            /*!< [23] Charge Pump or Resistor Bias Select */
        uint32_t RVTRIM : 4;           /*!< [27:24] Regulated Voltage Trim */
        uint32_t RESERVED3 : 3;        /*!< [30:28] Reserved */
        uint32_t RVEN : 1;             /*!< [31] Regulated Voltage Enable */
    } B;
} hw_lcd_gcr_t;

/*!
 * @name Constants and macros for entire LCD_GCR register
 */
/*@{*/
#define HW_LCD_GCR_ADDR(x)       ((uint32_t)(x) + 0x0U)

#define HW_LCD_GCR(x)            (*(__IO hw_lcd_gcr_t *) HW_LCD_GCR_ADDR(x))
#define HW_LCD_GCR_RD(x)         (HW_LCD_GCR(x).U)
#define HW_LCD_GCR_WR(x, v)      (HW_LCD_GCR(x).U = (v))
#define HW_LCD_GCR_SET(x, v)     (BME_OR32(HW_LCD_GCR_ADDR(x), (uint32_t)(v)))
#define HW_LCD_GCR_CLR(x, v)     (BME_AND32(HW_LCD_GCR_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_GCR_TOG(x, v)     (BME_XOR32(HW_LCD_GCR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_GCR bitfields
 */

/*!
 * @name Register LCD_GCR, field DUTY[2:0] (RW)
 *
 * Selects the duty cycle of the LCD controller driver.
 *
 * Values:
 * - 000 - Use 1 BP (1/1 duty cycle).
 * - 001 - Use 2 BP (1/2 duty cycle).
 * - 010 - Use 3 BP (1/3 duty cycle).
 * - 011 - Use 4 BP (1/4 duty cycle). (Default)
 * - 100 -
 * - 101 -
 * - 110 -
 * - 111 - Use 8 BP (1/8 duty cycle).
 */
/*@{*/
#define BP_LCD_GCR_DUTY      (0U)          /*!< Bit position for LCD_GCR_DUTY. */
#define BM_LCD_GCR_DUTY      (0x00000007U) /*!< Bit mask for LCD_GCR_DUTY. */
#define BS_LCD_GCR_DUTY      (3U)          /*!< Bit field size in bits for LCD_GCR_DUTY. */

/*! @brief Read current value of the LCD_GCR_DUTY field. */
#define BR_LCD_GCR_DUTY(x)   (BME_UBFX32(HW_LCD_GCR_ADDR(x), BP_LCD_GCR_DUTY, BS_LCD_GCR_DUTY))

/*! @brief Format value for bitfield LCD_GCR_DUTY. */
#define BF_LCD_GCR_DUTY(v)   ((uint32_t)((uint32_t)(v) << BP_LCD_GCR_DUTY) & BM_LCD_GCR_DUTY)

/*! @brief Set the DUTY field to a new value. */
#define BW_LCD_GCR_DUTY(x, v) (BME_BFI32(HW_LCD_GCR_ADDR(x), ((uint32_t)(v) << BP_LCD_GCR_DUTY), BP_LCD_GCR_DUTY, 3))
/*@}*/

/*!
 * @name Register LCD_GCR, field LCLK[5:3] (RW)
 *
 * Used as a clock divider to generate the SLCD frame frequency. LCD controller
 * duty cycle configuration is used to determine the LCD controller frame
 * frequency. LCD controller frame frequency calculations are provided in SLCD base
 * clock and frame frequency . LCD controller frame frequency = LCD clock/((DUTY + 1)
 * * 8 * (4 + LCLK[2:0]) * Y) where: 30 < LCD clock < 39.063 kHz Y = 2, 2, 3, 3,
 * 4, 5, 8, 16 chosen by module duty cycle configuration
 */
/*@{*/
#define BP_LCD_GCR_LCLK      (3U)          /*!< Bit position for LCD_GCR_LCLK. */
#define BM_LCD_GCR_LCLK      (0x00000038U) /*!< Bit mask for LCD_GCR_LCLK. */
#define BS_LCD_GCR_LCLK      (3U)          /*!< Bit field size in bits for LCD_GCR_LCLK. */

/*! @brief Read current value of the LCD_GCR_LCLK field. */
#define BR_LCD_GCR_LCLK(x)   (BME_UBFX32(HW_LCD_GCR_ADDR(x), BP_LCD_GCR_LCLK, BS_LCD_GCR_LCLK))

/*! @brief Format value for bitfield LCD_GCR_LCLK. */
#define BF_LCD_GCR_LCLK(v)   ((uint32_t)((uint32_t)(v) << BP_LCD_GCR_LCLK) & BM_LCD_GCR_LCLK)

/*! @brief Set the LCLK field to a new value. */
#define BW_LCD_GCR_LCLK(x, v) (BME_BFI32(HW_LCD_GCR_ADDR(x), ((uint32_t)(v) << BP_LCD_GCR_LCLK), BP_LCD_GCR_LCLK, 3))
/*@}*/

/*!
 * @name Register LCD_GCR, field SOURCE[6] (RW)
 *
 * This bit is used to select which clock source is the basis for LCD clock. The
 * clock sources are chip-specific. For the clock source assignments, see the
 * chapter that describes how modules are configured. Alternate clock can be only
 * MCGIRCLK, and therefore when SOURCE=1, SIM_SOPT1[OSC32KSEL] bit plays no role.
 * Default clock can be either MCGIRCLK, ERCLK32K, OSC32KCLK, according to the
 * selection in SIM_SOPT1[OSC32KSEL].
 *
 * Values:
 * - 0 - Selects the default clock as the LCD clock source.
 * - 1 - Selects output of the alternate clock source selection (see ALTSOURCE)
 *     as the LCD clock source.
 */
/*@{*/
#define BP_LCD_GCR_SOURCE    (6U)          /*!< Bit position for LCD_GCR_SOURCE. */
#define BM_LCD_GCR_SOURCE    (0x00000040U) /*!< Bit mask for LCD_GCR_SOURCE. */
#define BS_LCD_GCR_SOURCE    (1U)          /*!< Bit field size in bits for LCD_GCR_SOURCE. */

/*! @brief Read current value of the LCD_GCR_SOURCE field. */
#define BR_LCD_GCR_SOURCE(x) (BME_UBFX32(HW_LCD_GCR_ADDR(x), BP_LCD_GCR_SOURCE, BS_LCD_GCR_SOURCE))

/*! @brief Format value for bitfield LCD_GCR_SOURCE. */
#define BF_LCD_GCR_SOURCE(v) ((uint32_t)((uint32_t)(v) << BP_LCD_GCR_SOURCE) & BM_LCD_GCR_SOURCE)

/*! @brief Set the SOURCE field to a new value. */
#define BW_LCD_GCR_SOURCE(x, v) (BME_BFI32(HW_LCD_GCR_ADDR(x), ((uint32_t)(v) << BP_LCD_GCR_SOURCE), BP_LCD_GCR_SOURCE, 1))
/*@}*/

/*!
 * @name Register LCD_GCR, field LCDEN[7] (RW)
 *
 * Starts LCD controller waveform generator.
 *
 * Values:
 * - 0 - All front plane and back plane pins are disabled. The LCD controller
 *     system is also disabled, and all LCD waveform generation clocks are stopped.
 *     V LL3 is connected to V DD internally. All LCD pins, LCD_Pn, enabled
 *     using the LCD Pin Enable register, output a low value.
 * - 1 - LCD controller driver system is enabled, and front plane and back plane
 *     waveforms are generated. All LCD pins, LCD_Pn, enabled if PAD_SAFE is
 *     clearusing the LCD Pin Enable register, output an LCD driver waveform. The
 *     back plane pins output an LCD driver back plane waveform based on the
 *     settings of DUTY[2:0]. Charge pump or resistor bias is enabled.
 */
/*@{*/
#define BP_LCD_GCR_LCDEN     (7U)          /*!< Bit position for LCD_GCR_LCDEN. */
#define BM_LCD_GCR_LCDEN     (0x00000080U) /*!< Bit mask for LCD_GCR_LCDEN. */
#define BS_LCD_GCR_LCDEN     (1U)          /*!< Bit field size in bits for LCD_GCR_LCDEN. */

/*! @brief Read current value of the LCD_GCR_LCDEN field. */
#define BR_LCD_GCR_LCDEN(x)  (BME_UBFX32(HW_LCD_GCR_ADDR(x), BP_LCD_GCR_LCDEN, BS_LCD_GCR_LCDEN))

/*! @brief Format value for bitfield LCD_GCR_LCDEN. */
#define BF_LCD_GCR_LCDEN(v)  ((uint32_t)((uint32_t)(v) << BP_LCD_GCR_LCDEN) & BM_LCD_GCR_LCDEN)

/*! @brief Set the LCDEN field to a new value. */
#define BW_LCD_GCR_LCDEN(x, v) (BME_BFI32(HW_LCD_GCR_ADDR(x), ((uint32_t)(v) << BP_LCD_GCR_LCDEN), BP_LCD_GCR_LCDEN, 1))
/*@}*/

/*!
 * @name Register LCD_GCR, field LCDSTP[8] (RW)
 *
 * LCD driver, charge pump, resistor bias network, and voltage regulator stop
 * while in Stop mode.
 *
 * Values:
 * - 0 - Allows the LCD driver, charge pump, resistor bias network, and voltage
 *     regulator to continue running during Stop mode.
 * - 1 - Disables the LCD driver, charge pump, resistor bias network, and
 *     voltage regulator when MCU enters Stop mode.
 */
/*@{*/
#define BP_LCD_GCR_LCDSTP    (8U)          /*!< Bit position for LCD_GCR_LCDSTP. */
#define BM_LCD_GCR_LCDSTP    (0x00000100U) /*!< Bit mask for LCD_GCR_LCDSTP. */
#define BS_LCD_GCR_LCDSTP    (1U)          /*!< Bit field size in bits for LCD_GCR_LCDSTP. */

/*! @brief Read current value of the LCD_GCR_LCDSTP field. */
#define BR_LCD_GCR_LCDSTP(x) (BME_UBFX32(HW_LCD_GCR_ADDR(x), BP_LCD_GCR_LCDSTP, BS_LCD_GCR_LCDSTP))

/*! @brief Format value for bitfield LCD_GCR_LCDSTP. */
#define BF_LCD_GCR_LCDSTP(v) ((uint32_t)((uint32_t)(v) << BP_LCD_GCR_LCDSTP) & BM_LCD_GCR_LCDSTP)

/*! @brief Set the LCDSTP field to a new value. */
#define BW_LCD_GCR_LCDSTP(x, v) (BME_BFI32(HW_LCD_GCR_ADDR(x), ((uint32_t)(v) << BP_LCD_GCR_LCDSTP), BP_LCD_GCR_LCDSTP, 1))
/*@}*/

/*!
 * @name Register LCD_GCR, field LCDDOZE[9] (RW)
 *
 * LCD driver, charge pump, resistor bias network, and voltage regulator stop
 * while in Doze mode.
 *
 * Values:
 * - 0 - Allows the LCD driver, charge pump, resistor bias network, and voltage
 *     regulator to continue running during Doze mode.
 * - 1 - Disables the LCD driver, charge pump, resistor bias network, and
 *     voltage regulator when MCU enters Doze mode.
 */
/*@{*/
#define BP_LCD_GCR_LCDDOZE   (9U)          /*!< Bit position for LCD_GCR_LCDDOZE. */
#define BM_LCD_GCR_LCDDOZE   (0x00000200U) /*!< Bit mask for LCD_GCR_LCDDOZE. */
#define BS_LCD_GCR_LCDDOZE   (1U)          /*!< Bit field size in bits for LCD_GCR_LCDDOZE. */

/*! @brief Read current value of the LCD_GCR_LCDDOZE field. */
#define BR_LCD_GCR_LCDDOZE(x) (BME_UBFX32(HW_LCD_GCR_ADDR(x), BP_LCD_GCR_LCDDOZE, BS_LCD_GCR_LCDDOZE))

/*! @brief Format value for bitfield LCD_GCR_LCDDOZE. */
#define BF_LCD_GCR_LCDDOZE(v) ((uint32_t)((uint32_t)(v) << BP_LCD_GCR_LCDDOZE) & BM_LCD_GCR_LCDDOZE)

/*! @brief Set the LCDDOZE field to a new value. */
#define BW_LCD_GCR_LCDDOZE(x, v) (BME_BFI32(HW_LCD_GCR_ADDR(x), ((uint32_t)(v) << BP_LCD_GCR_LCDDOZE), BP_LCD_GCR_LCDDOZE, 1))
/*@}*/

/*!
 * @name Register LCD_GCR, field FFR[10] (RW)
 *
 * Increases the Frame Clock Frequency.
 *
 * Values:
 * - 0 - Standard Frame Rate LCD Frame Freq: 23.3 (min) 73.1 (max)
 * - 1 - Fast Frame Rate (Standard Frame Rate x2) LCD Frame Freq: 46.6 (min)
 *     146.2 (max)
 */
/*@{*/
#define BP_LCD_GCR_FFR       (10U)         /*!< Bit position for LCD_GCR_FFR. */
#define BM_LCD_GCR_FFR       (0x00000400U) /*!< Bit mask for LCD_GCR_FFR. */
#define BS_LCD_GCR_FFR       (1U)          /*!< Bit field size in bits for LCD_GCR_FFR. */

/*! @brief Read current value of the LCD_GCR_FFR field. */
#define BR_LCD_GCR_FFR(x)    (BME_UBFX32(HW_LCD_GCR_ADDR(x), BP_LCD_GCR_FFR, BS_LCD_GCR_FFR))

/*! @brief Format value for bitfield LCD_GCR_FFR. */
#define BF_LCD_GCR_FFR(v)    ((uint32_t)((uint32_t)(v) << BP_LCD_GCR_FFR) & BM_LCD_GCR_FFR)

/*! @brief Set the FFR field to a new value. */
#define BW_LCD_GCR_FFR(x, v) (BME_BFI32(HW_LCD_GCR_ADDR(x), ((uint32_t)(v) << BP_LCD_GCR_FFR), BP_LCD_GCR_FFR, 1))
/*@}*/

/*!
 * @name Register LCD_GCR, field ALTSOURCE[11] (RW)
 *
 * Values:
 * - 0 - Select Alternate Clock Source 1 (default)
 * - 1 - Select Alternate Clock Source 2
 */
/*@{*/
#define BP_LCD_GCR_ALTSOURCE (11U)         /*!< Bit position for LCD_GCR_ALTSOURCE. */
#define BM_LCD_GCR_ALTSOURCE (0x00000800U) /*!< Bit mask for LCD_GCR_ALTSOURCE. */
#define BS_LCD_GCR_ALTSOURCE (1U)          /*!< Bit field size in bits for LCD_GCR_ALTSOURCE. */

/*! @brief Read current value of the LCD_GCR_ALTSOURCE field. */
#define BR_LCD_GCR_ALTSOURCE(x) (BME_UBFX32(HW_LCD_GCR_ADDR(x), BP_LCD_GCR_ALTSOURCE, BS_LCD_GCR_ALTSOURCE))

/*! @brief Format value for bitfield LCD_GCR_ALTSOURCE. */
#define BF_LCD_GCR_ALTSOURCE(v) ((uint32_t)((uint32_t)(v) << BP_LCD_GCR_ALTSOURCE) & BM_LCD_GCR_ALTSOURCE)

/*! @brief Set the ALTSOURCE field to a new value. */
#define BW_LCD_GCR_ALTSOURCE(x, v) (BME_BFI32(HW_LCD_GCR_ADDR(x), ((uint32_t)(v) << BP_LCD_GCR_ALTSOURCE), BP_LCD_GCR_ALTSOURCE, 1))
/*@}*/

/*!
 * @name Register LCD_GCR, field ALTDIV[13:12] (RW)
 *
 * Functions as a clock divider to divide the alternate clock before it is
 * selected as LCD clock source.
 *
 * Values:
 * - 0 - Divide factor = 1 (No divide)
 * - 1 - Divide factor = 8
 */
/*@{*/
#define BP_LCD_GCR_ALTDIV    (12U)         /*!< Bit position for LCD_GCR_ALTDIV. */
#define BM_LCD_GCR_ALTDIV    (0x00003000U) /*!< Bit mask for LCD_GCR_ALTDIV. */
#define BS_LCD_GCR_ALTDIV    (2U)          /*!< Bit field size in bits for LCD_GCR_ALTDIV. */

/*! @brief Read current value of the LCD_GCR_ALTDIV field. */
#define BR_LCD_GCR_ALTDIV(x) (BME_UBFX32(HW_LCD_GCR_ADDR(x), BP_LCD_GCR_ALTDIV, BS_LCD_GCR_ALTDIV))

/*! @brief Format value for bitfield LCD_GCR_ALTDIV. */
#define BF_LCD_GCR_ALTDIV(v) ((uint32_t)((uint32_t)(v) << BP_LCD_GCR_ALTDIV) & BM_LCD_GCR_ALTDIV)

/*! @brief Set the ALTDIV field to a new value. */
#define BW_LCD_GCR_ALTDIV(x, v) (BME_BFI32(HW_LCD_GCR_ADDR(x), ((uint32_t)(v) << BP_LCD_GCR_ALTDIV), BP_LCD_GCR_ALTDIV, 2))
/*@}*/

/*!
 * @name Register LCD_GCR, field FDCIEN[14] (RW)
 *
 * Enables an LCD interrupt event when fault detection is completed.
 *
 * Values:
 * - 0 - No interrupt request is generated by this event.
 * - 1 - When a fault is detected and FDCF bit is set, this event causes an
 *     interrupt request.
 */
/*@{*/
#define BP_LCD_GCR_FDCIEN    (14U)         /*!< Bit position for LCD_GCR_FDCIEN. */
#define BM_LCD_GCR_FDCIEN    (0x00004000U) /*!< Bit mask for LCD_GCR_FDCIEN. */
#define BS_LCD_GCR_FDCIEN    (1U)          /*!< Bit field size in bits for LCD_GCR_FDCIEN. */

/*! @brief Read current value of the LCD_GCR_FDCIEN field. */
#define BR_LCD_GCR_FDCIEN(x) (BME_UBFX32(HW_LCD_GCR_ADDR(x), BP_LCD_GCR_FDCIEN, BS_LCD_GCR_FDCIEN))

/*! @brief Format value for bitfield LCD_GCR_FDCIEN. */
#define BF_LCD_GCR_FDCIEN(v) ((uint32_t)((uint32_t)(v) << BP_LCD_GCR_FDCIEN) & BM_LCD_GCR_FDCIEN)

/*! @brief Set the FDCIEN field to a new value. */
#define BW_LCD_GCR_FDCIEN(x, v) (BME_BFI32(HW_LCD_GCR_ADDR(x), ((uint32_t)(v) << BP_LCD_GCR_FDCIEN), BP_LCD_GCR_FDCIEN, 1))
/*@}*/

/*!
 * @name Register LCD_GCR, field PADSAFE[15] (RW)
 *
 * Force safe state on LCD pad controls (all LCD frontplane and backplane
 * functions disabled) regardless of other LCD control bits.
 *
 * Values:
 * - 0 - LCD frontplane and backplane functions enabled according to other LCD
 *     control bits
 * - 1 - LCD frontplane and backplane functions disabled
 */
/*@{*/
#define BP_LCD_GCR_PADSAFE   (15U)         /*!< Bit position for LCD_GCR_PADSAFE. */
#define BM_LCD_GCR_PADSAFE   (0x00008000U) /*!< Bit mask for LCD_GCR_PADSAFE. */
#define BS_LCD_GCR_PADSAFE   (1U)          /*!< Bit field size in bits for LCD_GCR_PADSAFE. */

/*! @brief Read current value of the LCD_GCR_PADSAFE field. */
#define BR_LCD_GCR_PADSAFE(x) (BME_UBFX32(HW_LCD_GCR_ADDR(x), BP_LCD_GCR_PADSAFE, BS_LCD_GCR_PADSAFE))

/*! @brief Format value for bitfield LCD_GCR_PADSAFE. */
#define BF_LCD_GCR_PADSAFE(v) ((uint32_t)((uint32_t)(v) << BP_LCD_GCR_PADSAFE) & BM_LCD_GCR_PADSAFE)

/*! @brief Set the PADSAFE field to a new value. */
#define BW_LCD_GCR_PADSAFE(x, v) (BME_BFI32(HW_LCD_GCR_ADDR(x), ((uint32_t)(v) << BP_LCD_GCR_PADSAFE), BP_LCD_GCR_PADSAFE, 1))
/*@}*/

/*!
 * @name Register LCD_GCR, field VSUPPLY[17] (RW)
 *
 * Configures whether the LCD controller power supply is external or internal.
 * Avoid modifying this field while the LCD controller is enabled, for example, if
 * LCDEN = 1.
 *
 * Values:
 * - 0 - Drive VLL3 internally from VDD
 * - 1 - Drive VLL3 externally from VDD or drive VLL internally from vIREG
 */
/*@{*/
#define BP_LCD_GCR_VSUPPLY   (17U)         /*!< Bit position for LCD_GCR_VSUPPLY. */
#define BM_LCD_GCR_VSUPPLY   (0x00020000U) /*!< Bit mask for LCD_GCR_VSUPPLY. */
#define BS_LCD_GCR_VSUPPLY   (1U)          /*!< Bit field size in bits for LCD_GCR_VSUPPLY. */

/*! @brief Read current value of the LCD_GCR_VSUPPLY field. */
#define BR_LCD_GCR_VSUPPLY(x) (BME_UBFX32(HW_LCD_GCR_ADDR(x), BP_LCD_GCR_VSUPPLY, BS_LCD_GCR_VSUPPLY))

/*! @brief Format value for bitfield LCD_GCR_VSUPPLY. */
#define BF_LCD_GCR_VSUPPLY(v) ((uint32_t)((uint32_t)(v) << BP_LCD_GCR_VSUPPLY) & BM_LCD_GCR_VSUPPLY)

/*! @brief Set the VSUPPLY field to a new value. */
#define BW_LCD_GCR_VSUPPLY(x, v) (BME_BFI32(HW_LCD_GCR_ADDR(x), ((uint32_t)(v) << BP_LCD_GCR_VSUPPLY), BP_LCD_GCR_VSUPPLY, 1))
/*@}*/

/*!
 * @name Register LCD_GCR, field LADJ[21:20] (RW)
 *
 * Configures SLCD to handle different LCD glass capacitance. For CPSEL = 0
 * Adjust the resistor bias network for different LCD glass capacitance. 00 - Low
 * Load (LCD glass capacitance 2000 pF or lower). LCD or GPIO functions can be used
 * on V LL1 , V LL2 , V CAP1 and V CAP2 pins. 01 - Low Load (LCD glass
 * capacitance 2000 pF or lower). LCD or GPIO functions can be used on V LL1 , V LL2 , V
 * CAP1 and V CAP2 pins. 10 - High Load (LCD glass capacitance 8000 pF or lower)
 * LCD or GPIO functions can be used on V CAP1 and V CAP2 pins. . 11 - High Load
 * (LCD glass capacitance 8000 pF or lower). LCD or GPIO functions can be used on V
 * CAP1 and V CAP2 pins. For CPSEL = 1 Adjust the clock source for the charge
 * pump. Higher loads require higher charge pump clock rates. 00 - Fastest clock
 * source for charge pump (LCD glass capacitance 8000 pF or 4000pF or lower if FFR
 * is set ). 01 - Intermediate clock source for charge pump (LCD glass
 * capacitance 4000 pF or 2000pF or lower if FFR is set ). 10 - Intermediate clock source
 * for charge pump (LCD glass capacitance 2000 pF or 1000pF or lower if FFR is set
 * ). 11 - Slowest clock source for charge pump (LCD glass capacitance 1000 pF
 * or 500pF or lower if FFR is set ).
 */
/*@{*/
#define BP_LCD_GCR_LADJ      (20U)         /*!< Bit position for LCD_GCR_LADJ. */
#define BM_LCD_GCR_LADJ      (0x00300000U) /*!< Bit mask for LCD_GCR_LADJ. */
#define BS_LCD_GCR_LADJ      (2U)          /*!< Bit field size in bits for LCD_GCR_LADJ. */

/*! @brief Read current value of the LCD_GCR_LADJ field. */
#define BR_LCD_GCR_LADJ(x)   (BME_UBFX32(HW_LCD_GCR_ADDR(x), BP_LCD_GCR_LADJ, BS_LCD_GCR_LADJ))

/*! @brief Format value for bitfield LCD_GCR_LADJ. */
#define BF_LCD_GCR_LADJ(v)   ((uint32_t)((uint32_t)(v) << BP_LCD_GCR_LADJ) & BM_LCD_GCR_LADJ)

/*! @brief Set the LADJ field to a new value. */
#define BW_LCD_GCR_LADJ(x, v) (BME_BFI32(HW_LCD_GCR_ADDR(x), ((uint32_t)(v) << BP_LCD_GCR_LADJ), BP_LCD_GCR_LADJ, 2))
/*@}*/

/*!
 * @name Register LCD_GCR, field CPSEL[23] (RW)
 *
 * Selects the LCD controller charge pump or a resistor network to supply the
 * LCD voltages V LL1 , V LL2 , and V LL3 .
 *
 * Values:
 * - 0 - LCD charge pump is disabled. Resistor network selected. (The internal
 *     1/3-bias is forced.)
 * - 1 - LCD charge pump is selected. Resistor network disabled. (The internal
 *     1/3-bias is forced.)
 */
/*@{*/
#define BP_LCD_GCR_CPSEL     (23U)         /*!< Bit position for LCD_GCR_CPSEL. */
#define BM_LCD_GCR_CPSEL     (0x00800000U) /*!< Bit mask for LCD_GCR_CPSEL. */
#define BS_LCD_GCR_CPSEL     (1U)          /*!< Bit field size in bits for LCD_GCR_CPSEL. */

/*! @brief Read current value of the LCD_GCR_CPSEL field. */
#define BR_LCD_GCR_CPSEL(x)  (BME_UBFX32(HW_LCD_GCR_ADDR(x), BP_LCD_GCR_CPSEL, BS_LCD_GCR_CPSEL))

/*! @brief Format value for bitfield LCD_GCR_CPSEL. */
#define BF_LCD_GCR_CPSEL(v)  ((uint32_t)((uint32_t)(v) << BP_LCD_GCR_CPSEL) & BM_LCD_GCR_CPSEL)

/*! @brief Set the CPSEL field to a new value. */
#define BW_LCD_GCR_CPSEL(x, v) (BME_BFI32(HW_LCD_GCR_ADDR(x), ((uint32_t)(v) << BP_LCD_GCR_CPSEL), BP_LCD_GCR_CPSEL, 1))
/*@}*/

/*!
 * @name Register LCD_GCR, field RVTRIM[27:24] (RW)
 *
 * This 4-bit trim register is used to adjust the regulated input. Each bit in
 * the register has equal weight. The regulated input is changed by 1.5% for each
 * count.
 */
/*@{*/
#define BP_LCD_GCR_RVTRIM    (24U)         /*!< Bit position for LCD_GCR_RVTRIM. */
#define BM_LCD_GCR_RVTRIM    (0x0F000000U) /*!< Bit mask for LCD_GCR_RVTRIM. */
#define BS_LCD_GCR_RVTRIM    (4U)          /*!< Bit field size in bits for LCD_GCR_RVTRIM. */

/*! @brief Read current value of the LCD_GCR_RVTRIM field. */
#define BR_LCD_GCR_RVTRIM(x) (BME_UBFX32(HW_LCD_GCR_ADDR(x), BP_LCD_GCR_RVTRIM, BS_LCD_GCR_RVTRIM))

/*! @brief Format value for bitfield LCD_GCR_RVTRIM. */
#define BF_LCD_GCR_RVTRIM(v) ((uint32_t)((uint32_t)(v) << BP_LCD_GCR_RVTRIM) & BM_LCD_GCR_RVTRIM)

/*! @brief Set the RVTRIM field to a new value. */
#define BW_LCD_GCR_RVTRIM(x, v) (BME_BFI32(HW_LCD_GCR_ADDR(x), ((uint32_t)(v) << BP_LCD_GCR_RVTRIM), BP_LCD_GCR_RVTRIM, 4))
/*@}*/

/*!
 * @name Register LCD_GCR, field RVEN[31] (RW)
 *
 * Enables internal voltage regulator. It must have the charge pump enabled.
 *
 * Values:
 * - 0 - Regulated voltage disabled.
 * - 1 - Regulated voltage enabled.
 */
/*@{*/
#define BP_LCD_GCR_RVEN      (31U)         /*!< Bit position for LCD_GCR_RVEN. */
#define BM_LCD_GCR_RVEN      (0x80000000U) /*!< Bit mask for LCD_GCR_RVEN. */
#define BS_LCD_GCR_RVEN      (1U)          /*!< Bit field size in bits for LCD_GCR_RVEN. */

/*! @brief Read current value of the LCD_GCR_RVEN field. */
#define BR_LCD_GCR_RVEN(x)   (BME_UBFX32(HW_LCD_GCR_ADDR(x), BP_LCD_GCR_RVEN, BS_LCD_GCR_RVEN))

/*! @brief Format value for bitfield LCD_GCR_RVEN. */
#define BF_LCD_GCR_RVEN(v)   ((uint32_t)((uint32_t)(v) << BP_LCD_GCR_RVEN) & BM_LCD_GCR_RVEN)

/*! @brief Set the RVEN field to a new value. */
#define BW_LCD_GCR_RVEN(x, v) (BME_BFI32(HW_LCD_GCR_ADDR(x), ((uint32_t)(v) << BP_LCD_GCR_RVEN), BP_LCD_GCR_RVEN, 1))
/*@}*/

/*******************************************************************************
 * HW_LCD_AR - LCD Auxiliary Register
 ******************************************************************************/

/*!
 * @brief HW_LCD_AR - LCD Auxiliary Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The reset value of this register depends on the reset type: POR - 0x0000_0000
 */
typedef union _hw_lcd_ar
{
    uint32_t U;
    struct _hw_lcd_ar_bitfields
    {
        uint32_t BRATE : 3;            /*!< [2:0] Blink-rate configuration */
        uint32_t BMODE : 1;            /*!< [3] Blink mode */
        uint32_t RESERVED0 : 1;        /*!< [4] Reserved */
        uint32_t BLANK : 1;            /*!< [5] Blank display mode */
        uint32_t ALT : 1;              /*!< [6] Alternate display mode */
        uint32_t BLINK : 1;            /*!< [7] Blink command */
        uint32_t RESERVED1 : 24;       /*!< [31:8] Reserved */
    } B;
} hw_lcd_ar_t;

/*!
 * @name Constants and macros for entire LCD_AR register
 */
/*@{*/
#define HW_LCD_AR_ADDR(x)        ((uint32_t)(x) + 0x4U)

#define HW_LCD_AR(x)             (*(__IO hw_lcd_ar_t *) HW_LCD_AR_ADDR(x))
#define HW_LCD_AR_RD(x)          (HW_LCD_AR(x).U)
#define HW_LCD_AR_WR(x, v)       (HW_LCD_AR(x).U = (v))
#define HW_LCD_AR_SET(x, v)      (BME_OR32(HW_LCD_AR_ADDR(x), (uint32_t)(v)))
#define HW_LCD_AR_CLR(x, v)      (BME_AND32(HW_LCD_AR_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_AR_TOG(x, v)      (BME_XOR32(HW_LCD_AR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_AR bitfields
 */

/*!
 * @name Register LCD_AR, field BRATE[2:0] (RW)
 *
 * Selects frequency at which the LCD blinks when the BLINK bit is asserted. The
 * following equation provides an expression for the LCD controller blink rate
 * and shows how BRATE field is used in the LCD blink-rate calculation. LCD
 * controller blink rate = LCD clock /2(12 + BRATE)
 */
/*@{*/
#define BP_LCD_AR_BRATE      (0U)          /*!< Bit position for LCD_AR_BRATE. */
#define BM_LCD_AR_BRATE      (0x00000007U) /*!< Bit mask for LCD_AR_BRATE. */
#define BS_LCD_AR_BRATE      (3U)          /*!< Bit field size in bits for LCD_AR_BRATE. */

/*! @brief Read current value of the LCD_AR_BRATE field. */
#define BR_LCD_AR_BRATE(x)   (BME_UBFX32(HW_LCD_AR_ADDR(x), BP_LCD_AR_BRATE, BS_LCD_AR_BRATE))

/*! @brief Format value for bitfield LCD_AR_BRATE. */
#define BF_LCD_AR_BRATE(v)   ((uint32_t)((uint32_t)(v) << BP_LCD_AR_BRATE) & BM_LCD_AR_BRATE)

/*! @brief Set the BRATE field to a new value. */
#define BW_LCD_AR_BRATE(x, v) (BME_BFI32(HW_LCD_AR_ADDR(x), ((uint32_t)(v) << BP_LCD_AR_BRATE), BP_LCD_AR_BRATE, 3))
/*@}*/

/*!
 * @name Register LCD_AR, field BMODE[3] (RW)
 *
 * Selects the blink mode displayed during the blink period.
 *
 * Values:
 * - 0 - Display blank during the blink period.
 * - 1 - Display alternate display during blink period (Ignored if duty is 5 or
 *     greater).
 */
/*@{*/
#define BP_LCD_AR_BMODE      (3U)          /*!< Bit position for LCD_AR_BMODE. */
#define BM_LCD_AR_BMODE      (0x00000008U) /*!< Bit mask for LCD_AR_BMODE. */
#define BS_LCD_AR_BMODE      (1U)          /*!< Bit field size in bits for LCD_AR_BMODE. */

/*! @brief Read current value of the LCD_AR_BMODE field. */
#define BR_LCD_AR_BMODE(x)   (BME_UBFX32(HW_LCD_AR_ADDR(x), BP_LCD_AR_BMODE, BS_LCD_AR_BMODE))

/*! @brief Format value for bitfield LCD_AR_BMODE. */
#define BF_LCD_AR_BMODE(v)   ((uint32_t)((uint32_t)(v) << BP_LCD_AR_BMODE) & BM_LCD_AR_BMODE)

/*! @brief Set the BMODE field to a new value. */
#define BW_LCD_AR_BMODE(x, v) (BME_BFI32(HW_LCD_AR_ADDR(x), ((uint32_t)(v) << BP_LCD_AR_BMODE), BP_LCD_AR_BMODE, 1))
/*@}*/

/*!
 * @name Register LCD_AR, field BLANK[5] (RW)
 *
 * Asserting this bit clears all segments in the LCD.
 *
 * Values:
 * - 0 - Normal or alternate display mode.
 * - 1 - Blank display mode.
 */
/*@{*/
#define BP_LCD_AR_BLANK      (5U)          /*!< Bit position for LCD_AR_BLANK. */
#define BM_LCD_AR_BLANK      (0x00000020U) /*!< Bit mask for LCD_AR_BLANK. */
#define BS_LCD_AR_BLANK      (1U)          /*!< Bit field size in bits for LCD_AR_BLANK. */

/*! @brief Read current value of the LCD_AR_BLANK field. */
#define BR_LCD_AR_BLANK(x)   (BME_UBFX32(HW_LCD_AR_ADDR(x), BP_LCD_AR_BLANK, BS_LCD_AR_BLANK))

/*! @brief Format value for bitfield LCD_AR_BLANK. */
#define BF_LCD_AR_BLANK(v)   ((uint32_t)((uint32_t)(v) << BP_LCD_AR_BLANK) & BM_LCD_AR_BLANK)

/*! @brief Set the BLANK field to a new value. */
#define BW_LCD_AR_BLANK(x, v) (BME_BFI32(HW_LCD_AR_ADDR(x), ((uint32_t)(v) << BP_LCD_AR_BLANK), BP_LCD_AR_BLANK, 1))
/*@}*/

/*!
 * @name Register LCD_AR, field ALT[6] (RW)
 *
 * For four back planes or less, the LCD back plane sequencer changes to output
 * an alternate display. ALT bit is ignored if DUTY[2:0] is 100 or greater.
 *
 * Values:
 * - 0 - Normal display mode.
 * - 1 - Alternate display mode.
 */
/*@{*/
#define BP_LCD_AR_ALT        (6U)          /*!< Bit position for LCD_AR_ALT. */
#define BM_LCD_AR_ALT        (0x00000040U) /*!< Bit mask for LCD_AR_ALT. */
#define BS_LCD_AR_ALT        (1U)          /*!< Bit field size in bits for LCD_AR_ALT. */

/*! @brief Read current value of the LCD_AR_ALT field. */
#define BR_LCD_AR_ALT(x)     (BME_UBFX32(HW_LCD_AR_ADDR(x), BP_LCD_AR_ALT, BS_LCD_AR_ALT))

/*! @brief Format value for bitfield LCD_AR_ALT. */
#define BF_LCD_AR_ALT(v)     ((uint32_t)((uint32_t)(v) << BP_LCD_AR_ALT) & BM_LCD_AR_ALT)

/*! @brief Set the ALT field to a new value. */
#define BW_LCD_AR_ALT(x, v)  (BME_BFI32(HW_LCD_AR_ADDR(x), ((uint32_t)(v) << BP_LCD_AR_ALT), BP_LCD_AR_ALT, 1))
/*@}*/

/*!
 * @name Register LCD_AR, field BLINK[7] (RW)
 *
 * Starts or stops SLCD blinking.
 *
 * Values:
 * - 0 - Disables blinking.
 * - 1 - Starts blinking at blinking frequency specified by LCD blink rate
 *     calculation.
 */
/*@{*/
#define BP_LCD_AR_BLINK      (7U)          /*!< Bit position for LCD_AR_BLINK. */
#define BM_LCD_AR_BLINK      (0x00000080U) /*!< Bit mask for LCD_AR_BLINK. */
#define BS_LCD_AR_BLINK      (1U)          /*!< Bit field size in bits for LCD_AR_BLINK. */

/*! @brief Read current value of the LCD_AR_BLINK field. */
#define BR_LCD_AR_BLINK(x)   (BME_UBFX32(HW_LCD_AR_ADDR(x), BP_LCD_AR_BLINK, BS_LCD_AR_BLINK))

/*! @brief Format value for bitfield LCD_AR_BLINK. */
#define BF_LCD_AR_BLINK(v)   ((uint32_t)((uint32_t)(v) << BP_LCD_AR_BLINK) & BM_LCD_AR_BLINK)

/*! @brief Set the BLINK field to a new value. */
#define BW_LCD_AR_BLINK(x, v) (BME_BFI32(HW_LCD_AR_ADDR(x), ((uint32_t)(v) << BP_LCD_AR_BLINK), BP_LCD_AR_BLINK, 1))
/*@}*/

/*******************************************************************************
 * HW_LCD_FDCR - LCD Fault Detect Control Register
 ******************************************************************************/

/*!
 * @brief HW_LCD_FDCR - LCD Fault Detect Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The reset value of this register depends on the reset type: POR - 0x0000_0000
 */
typedef union _hw_lcd_fdcr
{
    uint32_t U;
    struct _hw_lcd_fdcr_bitfields
    {
        uint32_t FDPINID : 6;          /*!< [5:0] Fault Detect Pin ID */
        uint32_t FDBPEN : 1;           /*!< [6] Fault Detect Back Plane Enable */
        uint32_t FDEN : 1;             /*!< [7] Fault Detect Enable */
        uint32_t RESERVED0 : 1;        /*!< [8] Reserved */
        uint32_t FDSWW : 3;            /*!< [11:9] Fault Detect Sample Window Width */
        uint32_t FDPRS : 3;            /*!< [14:12] Fault Detect Clock Prescaler */
        uint32_t RESERVED1 : 17;       /*!< [31:15] Reserved */
    } B;
} hw_lcd_fdcr_t;

/*!
 * @name Constants and macros for entire LCD_FDCR register
 */
/*@{*/
#define HW_LCD_FDCR_ADDR(x)      ((uint32_t)(x) + 0x8U)

#define HW_LCD_FDCR(x)           (*(__IO hw_lcd_fdcr_t *) HW_LCD_FDCR_ADDR(x))
#define HW_LCD_FDCR_RD(x)        (HW_LCD_FDCR(x).U)
#define HW_LCD_FDCR_WR(x, v)     (HW_LCD_FDCR(x).U = (v))
#define HW_LCD_FDCR_SET(x, v)    (BME_OR32(HW_LCD_FDCR_ADDR(x), (uint32_t)(v)))
#define HW_LCD_FDCR_CLR(x, v)    (BME_AND32(HW_LCD_FDCR_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_FDCR_TOG(x, v)    (BME_XOR32(HW_LCD_FDCR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_FDCR bitfields
 */

/*!
 * @name Register LCD_FDCR, field FDPINID[5:0] (RW)
 *
 * Specifies the LCD pin to be checked by pullup fault detection.
 *
 * Values:
 * - 0 - Fault detection for LCD_P0 pin.
 * - 1 - Fault detection for LCD_P1 pin.
 */
/*@{*/
#define BP_LCD_FDCR_FDPINID  (0U)          /*!< Bit position for LCD_FDCR_FDPINID. */
#define BM_LCD_FDCR_FDPINID  (0x0000003FU) /*!< Bit mask for LCD_FDCR_FDPINID. */
#define BS_LCD_FDCR_FDPINID  (6U)          /*!< Bit field size in bits for LCD_FDCR_FDPINID. */

/*! @brief Read current value of the LCD_FDCR_FDPINID field. */
#define BR_LCD_FDCR_FDPINID(x) (BME_UBFX32(HW_LCD_FDCR_ADDR(x), BP_LCD_FDCR_FDPINID, BS_LCD_FDCR_FDPINID))

/*! @brief Format value for bitfield LCD_FDCR_FDPINID. */
#define BF_LCD_FDCR_FDPINID(v) ((uint32_t)((uint32_t)(v) << BP_LCD_FDCR_FDPINID) & BM_LCD_FDCR_FDPINID)

/*! @brief Set the FDPINID field to a new value. */
#define BW_LCD_FDCR_FDPINID(x, v) (BME_BFI32(HW_LCD_FDCR_ADDR(x), ((uint32_t)(v) << BP_LCD_FDCR_FDPINID), BP_LCD_FDCR_FDPINID, 6))
/*@}*/

/*!
 * @name Register LCD_FDCR, field FDBPEN[6] (RW)
 *
 * Enables "back plane" timing for the fault detect circuit. FDBPEN = 0
 * generates front plane timing. This bit specifies the type of pin selected under fault
 * detect test.
 *
 * Values:
 * - 0 - Type of the selected pin under fault detect test is front plane.
 * - 1 - Type of the selected pin under fault detect test is back plane.
 */
/*@{*/
#define BP_LCD_FDCR_FDBPEN   (6U)          /*!< Bit position for LCD_FDCR_FDBPEN. */
#define BM_LCD_FDCR_FDBPEN   (0x00000040U) /*!< Bit mask for LCD_FDCR_FDBPEN. */
#define BS_LCD_FDCR_FDBPEN   (1U)          /*!< Bit field size in bits for LCD_FDCR_FDBPEN. */

/*! @brief Read current value of the LCD_FDCR_FDBPEN field. */
#define BR_LCD_FDCR_FDBPEN(x) (BME_UBFX32(HW_LCD_FDCR_ADDR(x), BP_LCD_FDCR_FDBPEN, BS_LCD_FDCR_FDBPEN))

/*! @brief Format value for bitfield LCD_FDCR_FDBPEN. */
#define BF_LCD_FDCR_FDBPEN(v) ((uint32_t)((uint32_t)(v) << BP_LCD_FDCR_FDBPEN) & BM_LCD_FDCR_FDBPEN)

/*! @brief Set the FDBPEN field to a new value. */
#define BW_LCD_FDCR_FDBPEN(x, v) (BME_BFI32(HW_LCD_FDCR_ADDR(x), ((uint32_t)(v) << BP_LCD_FDCR_FDBPEN), BP_LCD_FDCR_FDBPEN, 1))
/*@}*/

/*!
 * @name Register LCD_FDCR, field FDEN[7] (RW)
 *
 * If LCDEN is 1, asserting FDEN inserts a test frame after normal LCD refresh
 * frame is completed. After the test frame is done, Fault detection complete flag
 * (FDCF) is set. When the test frame is done, a normal LCD refresh frame
 * starts. FDEN is one-shot register, it clears after FDCF is set. To initiate another
 * fault detection, FDEN must be set again.
 *
 * Values:
 * - 0 - Disable fault detection.
 * - 1 - Enable fault detection.
 */
/*@{*/
#define BP_LCD_FDCR_FDEN     (7U)          /*!< Bit position for LCD_FDCR_FDEN. */
#define BM_LCD_FDCR_FDEN     (0x00000080U) /*!< Bit mask for LCD_FDCR_FDEN. */
#define BS_LCD_FDCR_FDEN     (1U)          /*!< Bit field size in bits for LCD_FDCR_FDEN. */

/*! @brief Read current value of the LCD_FDCR_FDEN field. */
#define BR_LCD_FDCR_FDEN(x)  (BME_UBFX32(HW_LCD_FDCR_ADDR(x), BP_LCD_FDCR_FDEN, BS_LCD_FDCR_FDEN))

/*! @brief Format value for bitfield LCD_FDCR_FDEN. */
#define BF_LCD_FDCR_FDEN(v)  ((uint32_t)((uint32_t)(v) << BP_LCD_FDCR_FDEN) & BM_LCD_FDCR_FDEN)

/*! @brief Set the FDEN field to a new value. */
#define BW_LCD_FDCR_FDEN(x, v) (BME_BFI32(HW_LCD_FDCR_ADDR(x), ((uint32_t)(v) << BP_LCD_FDCR_FDEN), BP_LCD_FDCR_FDEN, 1))
/*@}*/

/*!
 * @name Register LCD_FDCR, field FDSWW[11:9] (RW)
 *
 * Specifies the sample window width of fault detection, in number of cycles in
 * the range from 4-512 (Sample window = 4*2 N ).
 *
 * Values:
 * - 0 - Sample window width is 4 sample clock cycles.
 * - 1 - Sample window width is 8 sample clock cycles.
 */
/*@{*/
#define BP_LCD_FDCR_FDSWW    (9U)          /*!< Bit position for LCD_FDCR_FDSWW. */
#define BM_LCD_FDCR_FDSWW    (0x00000E00U) /*!< Bit mask for LCD_FDCR_FDSWW. */
#define BS_LCD_FDCR_FDSWW    (3U)          /*!< Bit field size in bits for LCD_FDCR_FDSWW. */

/*! @brief Read current value of the LCD_FDCR_FDSWW field. */
#define BR_LCD_FDCR_FDSWW(x) (BME_UBFX32(HW_LCD_FDCR_ADDR(x), BP_LCD_FDCR_FDSWW, BS_LCD_FDCR_FDSWW))

/*! @brief Format value for bitfield LCD_FDCR_FDSWW. */
#define BF_LCD_FDCR_FDSWW(v) ((uint32_t)((uint32_t)(v) << BP_LCD_FDCR_FDSWW) & BM_LCD_FDCR_FDSWW)

/*! @brief Set the FDSWW field to a new value. */
#define BW_LCD_FDCR_FDSWW(x, v) (BME_BFI32(HW_LCD_FDCR_ADDR(x), ((uint32_t)(v) << BP_LCD_FDCR_FDSWW), BP_LCD_FDCR_FDSWW, 3))
/*@}*/

/*!
 * @name Register LCD_FDCR, field FDPRS[14:12] (RW)
 *
 * Fault detect sample clock frequency is:
 *
 * Values:
 * - 0 - 1/1 bus clock.
 * - 1 - 1/2 bus clock.
 */
/*@{*/
#define BP_LCD_FDCR_FDPRS    (12U)         /*!< Bit position for LCD_FDCR_FDPRS. */
#define BM_LCD_FDCR_FDPRS    (0x00007000U) /*!< Bit mask for LCD_FDCR_FDPRS. */
#define BS_LCD_FDCR_FDPRS    (3U)          /*!< Bit field size in bits for LCD_FDCR_FDPRS. */

/*! @brief Read current value of the LCD_FDCR_FDPRS field. */
#define BR_LCD_FDCR_FDPRS(x) (BME_UBFX32(HW_LCD_FDCR_ADDR(x), BP_LCD_FDCR_FDPRS, BS_LCD_FDCR_FDPRS))

/*! @brief Format value for bitfield LCD_FDCR_FDPRS. */
#define BF_LCD_FDCR_FDPRS(v) ((uint32_t)((uint32_t)(v) << BP_LCD_FDCR_FDPRS) & BM_LCD_FDCR_FDPRS)

/*! @brief Set the FDPRS field to a new value. */
#define BW_LCD_FDCR_FDPRS(x, v) (BME_BFI32(HW_LCD_FDCR_ADDR(x), ((uint32_t)(v) << BP_LCD_FDCR_FDPRS), BP_LCD_FDCR_FDPRS, 3))
/*@}*/

/*******************************************************************************
 * HW_LCD_FDSR - LCD Fault Detect Status Register
 ******************************************************************************/

/*!
 * @brief HW_LCD_FDSR - LCD Fault Detect Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The reset value of this register depends on the reset type: POR - 0x0000_0000
 */
typedef union _hw_lcd_fdsr
{
    uint32_t U;
    struct _hw_lcd_fdsr_bitfields
    {
        uint32_t FDCNT : 8;            /*!< [7:0] Fault Detect Counter */
        uint32_t RESERVED0 : 7;        /*!< [14:8] Reserved */
        uint32_t FDCF : 1;             /*!< [15] Fault Detection Complete Flag */
        uint32_t RESERVED1 : 16;       /*!< [31:16] Reserved */
    } B;
} hw_lcd_fdsr_t;

/*!
 * @name Constants and macros for entire LCD_FDSR register
 */
/*@{*/
#define HW_LCD_FDSR_ADDR(x)      ((uint32_t)(x) + 0xCU)

#define HW_LCD_FDSR(x)           (*(__IO hw_lcd_fdsr_t *) HW_LCD_FDSR_ADDR(x))
#define HW_LCD_FDSR_RD(x)        (HW_LCD_FDSR(x).U)
#define HW_LCD_FDSR_WR(x, v)     (HW_LCD_FDSR(x).U = (v))
#define HW_LCD_FDSR_SET(x, v)    (BME_OR32(HW_LCD_FDSR_ADDR(x), (uint32_t)(v)))
#define HW_LCD_FDSR_CLR(x, v)    (BME_AND32(HW_LCD_FDSR_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_FDSR_TOG(x, v)    (BME_XOR32(HW_LCD_FDSR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_FDSR bitfields
 */

/*!
 * @name Register LCD_FDSR, field FDCNT[7:0] (RO)
 *
 * Contains how many "one/high" are sampled inside the fault detect sample
 * window.
 *
 * Values:
 * - 0 - No "one" samples.
 * - 1 - 1 "one" samples.
 */
/*@{*/
#define BP_LCD_FDSR_FDCNT    (0U)          /*!< Bit position for LCD_FDSR_FDCNT. */
#define BM_LCD_FDSR_FDCNT    (0x000000FFU) /*!< Bit mask for LCD_FDSR_FDCNT. */
#define BS_LCD_FDSR_FDCNT    (8U)          /*!< Bit field size in bits for LCD_FDSR_FDCNT. */

/*! @brief Read current value of the LCD_FDSR_FDCNT field. */
#define BR_LCD_FDSR_FDCNT(x) (BME_UBFX32(HW_LCD_FDSR_ADDR(x), BP_LCD_FDSR_FDCNT, BS_LCD_FDSR_FDCNT))
/*@}*/

/*!
 * @name Register LCD_FDSR, field FDCF[15] (W1C)
 *
 * FDCF indicates that the fault detection is completed. Writing 1 to this bit
 * clears it to zero. This bit also acts as an interrupt flag when FDCIEN is set.
 * Software can use either interrupt or polling to check whether one pin fault
 * detection is completed.
 *
 * Values:
 * - 0 - Fault detection is not completed.
 * - 1 - Fault detection is completed.
 */
/*@{*/
#define BP_LCD_FDSR_FDCF     (15U)         /*!< Bit position for LCD_FDSR_FDCF. */
#define BM_LCD_FDSR_FDCF     (0x00008000U) /*!< Bit mask for LCD_FDSR_FDCF. */
#define BS_LCD_FDSR_FDCF     (1U)          /*!< Bit field size in bits for LCD_FDSR_FDCF. */

/*! @brief Read current value of the LCD_FDSR_FDCF field. */
#define BR_LCD_FDSR_FDCF(x)  (BME_UBFX32(HW_LCD_FDSR_ADDR(x), BP_LCD_FDSR_FDCF, BS_LCD_FDSR_FDCF))

/*! @brief Format value for bitfield LCD_FDSR_FDCF. */
#define BF_LCD_FDSR_FDCF(v)  ((uint32_t)((uint32_t)(v) << BP_LCD_FDSR_FDCF) & BM_LCD_FDSR_FDCF)

/*! @brief Set the FDCF field to a new value. */
#define BW_LCD_FDSR_FDCF(x, v) (BME_BFI32(HW_LCD_FDSR_ADDR(x), ((uint32_t)(v) << BP_LCD_FDSR_FDCF), BP_LCD_FDSR_FDCF, 1))
/*@}*/

/*******************************************************************************
 * HW_LCD_PENL - LCD Pin Enable register
 ******************************************************************************/

/*!
 * @brief HW_LCD_PENL - LCD Pin Enable register (RW)
 *
 * Reset value: 0x00000000U
 *
 * When LCDEN = 1,and PAD_SAFE=0 each PEN bit enables the corresponding LCD pin
 * (LCD_Pn) for LCD waveform generation.When LCDEN=0, each PEN bit enabled to
 * corresponding LCD pin (LCD_Pn) to drive a low output. Initialize these registers
 * before enabling the LCD controller. The reset value of this register depends
 * on the reset type: POR - 0x0000_0000
 */
typedef union _hw_lcd_penl
{
    uint32_t U;
    struct _hw_lcd_penl_bitfields
    {
        uint32_t PEN : 32;             /*!< [31:0] LCD Pin Enable */
    } B;
} hw_lcd_penl_t;

/*!
 * @name Constants and macros for entire LCD_PENL register
 */
/*@{*/
#define HW_LCD_PENL_ADDR(x)      ((uint32_t)(x) + 0x10U)

#define HW_LCD_PENL(x)           (*(__IO hw_lcd_penl_t *) HW_LCD_PENL_ADDR(x))
#define HW_LCD_PENL_RD(x)        (HW_LCD_PENL(x).U)
#define HW_LCD_PENL_WR(x, v)     (HW_LCD_PENL(x).U = (v))
#define HW_LCD_PENL_SET(x, v)    (BME_OR32(HW_LCD_PENL_ADDR(x), (uint32_t)(v)))
#define HW_LCD_PENL_CLR(x, v)    (BME_AND32(HW_LCD_PENL_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_PENL_TOG(x, v)    (BME_XOR32(HW_LCD_PENL_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_PENL bitfields
 */

/*!
 * @name Register LCD_PENL, field PEN[31:0] (RW)
 *
 * The PEN[63:0] bits enable the LCD_P[63:0] pins for LCD operation. PENL
 * contains PEN[31:0], and PENH contains PEN[63:32]. Each LCD_P[63:0] pin can be
 * configured as a back plane or a front plane based on the corresponding BPEN[ n ] bit
 * in the Back Plane Enable register (BPEN). If LCDEN = 0, these bits enable the
 * pin to drive a low output. Set PEN[63:0] bits before LCDEN is set. When
 * PAD_SAFE=1, these bits have no effect in any condition on the LCD_P[63:0] pins.
 *
 * Values:
 * - 0 - LCD operation disabled on LCD_Pn.
 * - 1 - LCD operation enabled on LCD_Pn.
 */
/*@{*/
#define BP_LCD_PENL_PEN      (0U)          /*!< Bit position for LCD_PENL_PEN. */
#define BM_LCD_PENL_PEN      (0xFFFFFFFFU) /*!< Bit mask for LCD_PENL_PEN. */
#define BS_LCD_PENL_PEN      (32U)         /*!< Bit field size in bits for LCD_PENL_PEN. */

/*! @brief Read current value of the LCD_PENL_PEN field. */
#define BR_LCD_PENL_PEN(x)   (HW_LCD_PENL(x).U)

/*! @brief Format value for bitfield LCD_PENL_PEN. */
#define BF_LCD_PENL_PEN(v)   ((uint32_t)((uint32_t)(v) << BP_LCD_PENL_PEN) & BM_LCD_PENL_PEN)

/*! @brief Set the PEN field to a new value. */
#define BW_LCD_PENL_PEN(x, v) (HW_LCD_PENL_WR(x, v))
/*@}*/
/*******************************************************************************
 * HW_LCD_PENH - LCD Pin Enable register
 ******************************************************************************/

/*!
 * @brief HW_LCD_PENH - LCD Pin Enable register (RW)
 *
 * Reset value: 0x00000000U
 *
 * When LCDEN = 1,and PAD_SAFE=0 each PEN bit enables the corresponding LCD pin
 * (LCD_Pn) for LCD waveform generation.When LCDEN=0, each PEN bit enabled to
 * corresponding LCD pin (LCD_Pn) to drive a low output. Initialize these registers
 * before enabling the LCD controller. The reset value of this register depends
 * on the reset type: POR - 0x0000_0000
 */
typedef union _hw_lcd_penh
{
    uint32_t U;
    struct _hw_lcd_penh_bitfields
    {
        uint32_t PEN : 32;             /*!< [31:0] LCD Pin Enable */
    } B;
} hw_lcd_penh_t;

/*!
 * @name Constants and macros for entire LCD_PENH register
 */
/*@{*/
#define HW_LCD_PENH_ADDR(x)      ((uint32_t)(x) + 0x14U)

#define HW_LCD_PENH(x)           (*(__IO hw_lcd_penh_t *) HW_LCD_PENH_ADDR(x))
#define HW_LCD_PENH_RD(x)        (HW_LCD_PENH(x).U)
#define HW_LCD_PENH_WR(x, v)     (HW_LCD_PENH(x).U = (v))
#define HW_LCD_PENH_SET(x, v)    (BME_OR32(HW_LCD_PENH_ADDR(x), (uint32_t)(v)))
#define HW_LCD_PENH_CLR(x, v)    (BME_AND32(HW_LCD_PENH_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_PENH_TOG(x, v)    (BME_XOR32(HW_LCD_PENH_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_PENH bitfields
 */

/*!
 * @name Register LCD_PENH, field PEN[31:0] (RW)
 *
 * The PEN[63:0] bits enable the LCD_P[63:0] pins for LCD operation. PENL
 * contains PEN[31:0], and PENH contains PEN[63:32]. Each LCD_P[63:0] pin can be
 * configured as a back plane or a front plane based on the corresponding BPEN[ n ] bit
 * in the Back Plane Enable register (BPEN). If LCDEN = 0, these bits enable the
 * pin to drive a low output. Set PEN[63:0] bits before LCDEN is set. When
 * PAD_SAFE=1, these bits have no effect in any condition on the LCD_P[63:0] pins.
 *
 * Values:
 * - 0 - LCD operation disabled on LCD_Pn.
 * - 1 - LCD operation enabled on LCD_Pn.
 */
/*@{*/
#define BP_LCD_PENH_PEN      (0U)          /*!< Bit position for LCD_PENH_PEN. */
#define BM_LCD_PENH_PEN      (0xFFFFFFFFU) /*!< Bit mask for LCD_PENH_PEN. */
#define BS_LCD_PENH_PEN      (32U)         /*!< Bit field size in bits for LCD_PENH_PEN. */

/*! @brief Read current value of the LCD_PENH_PEN field. */
#define BR_LCD_PENH_PEN(x)   (HW_LCD_PENH(x).U)

/*! @brief Format value for bitfield LCD_PENH_PEN. */
#define BF_LCD_PENH_PEN(v)   ((uint32_t)((uint32_t)(v) << BP_LCD_PENH_PEN) & BM_LCD_PENH_PEN)

/*! @brief Set the PEN field to a new value. */
#define BW_LCD_PENH_PEN(x, v) (HW_LCD_PENH_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_LCD_BPENL - LCD Back Plane Enable register
 ******************************************************************************/

/*!
 * @brief HW_LCD_BPENL - LCD Back Plane Enable register (RW)
 *
 * Reset value: 0x00000000U
 *
 * When PEN[n] = 1, the BPEN[63:0] bits configure the corresponding LCD pin to
 * operate as an LCD back plane or an LCD front plane. Most applications set a
 * maximum of eight of these bits. Initialize these registers before enabling the
 * LCD controller. The reset value of this register depends on the reset type: POR
 * - 0x0000_0000
 */
typedef union _hw_lcd_bpenl
{
    uint32_t U;
    struct _hw_lcd_bpenl_bitfields
    {
        uint32_t BPEN : 32;            /*!< [31:0] Back Plane Enable */
    } B;
} hw_lcd_bpenl_t;

/*!
 * @name Constants and macros for entire LCD_BPENL register
 */
/*@{*/
#define HW_LCD_BPENL_ADDR(x)     ((uint32_t)(x) + 0x18U)

#define HW_LCD_BPENL(x)          (*(__IO hw_lcd_bpenl_t *) HW_LCD_BPENL_ADDR(x))
#define HW_LCD_BPENL_RD(x)       (HW_LCD_BPENL(x).U)
#define HW_LCD_BPENL_WR(x, v)    (HW_LCD_BPENL(x).U = (v))
#define HW_LCD_BPENL_SET(x, v)   (BME_OR32(HW_LCD_BPENL_ADDR(x), (uint32_t)(v)))
#define HW_LCD_BPENL_CLR(x, v)   (BME_AND32(HW_LCD_BPENL_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_BPENL_TOG(x, v)   (BME_XOR32(HW_LCD_BPENL_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_BPENL bitfields
 */

/*!
 * @name Register LCD_BPENL, field BPEN[31:0] (RW)
 *
 * The BPEN[63:0] bits configure the LCD_P[63:0] pins to operate as an LCD back
 * plane or LCD front plane. BPENL contains BPEN[31:0], and BPENH contains
 * BPEN[63:32]. If LCDEN = 0, these bits have no effect on the state of the I/O pins.
 * It is recommended to set BPEN[63:0] bits before LCDEN is set.
 *
 * Values:
 * - 0 - Front plane operation enabled on LCD_Pn.
 * - 1 - Back plane operation enabled on LCD_Pn.
 */
/*@{*/
#define BP_LCD_BPENL_BPEN    (0U)          /*!< Bit position for LCD_BPENL_BPEN. */
#define BM_LCD_BPENL_BPEN    (0xFFFFFFFFU) /*!< Bit mask for LCD_BPENL_BPEN. */
#define BS_LCD_BPENL_BPEN    (32U)         /*!< Bit field size in bits for LCD_BPENL_BPEN. */

/*! @brief Read current value of the LCD_BPENL_BPEN field. */
#define BR_LCD_BPENL_BPEN(x) (HW_LCD_BPENL(x).U)

/*! @brief Format value for bitfield LCD_BPENL_BPEN. */
#define BF_LCD_BPENL_BPEN(v) ((uint32_t)((uint32_t)(v) << BP_LCD_BPENL_BPEN) & BM_LCD_BPENL_BPEN)

/*! @brief Set the BPEN field to a new value. */
#define BW_LCD_BPENL_BPEN(x, v) (HW_LCD_BPENL_WR(x, v))
/*@}*/
/*******************************************************************************
 * HW_LCD_BPENH - LCD Back Plane Enable register
 ******************************************************************************/

/*!
 * @brief HW_LCD_BPENH - LCD Back Plane Enable register (RW)
 *
 * Reset value: 0x00000000U
 *
 * When PEN[n] = 1, the BPEN[63:0] bits configure the corresponding LCD pin to
 * operate as an LCD back plane or an LCD front plane. Most applications set a
 * maximum of eight of these bits. Initialize these registers before enabling the
 * LCD controller. The reset value of this register depends on the reset type: POR
 * - 0x0000_0000
 */
typedef union _hw_lcd_bpenh
{
    uint32_t U;
    struct _hw_lcd_bpenh_bitfields
    {
        uint32_t BPEN : 32;            /*!< [31:0] Back Plane Enable */
    } B;
} hw_lcd_bpenh_t;

/*!
 * @name Constants and macros for entire LCD_BPENH register
 */
/*@{*/
#define HW_LCD_BPENH_ADDR(x)     ((uint32_t)(x) + 0x1CU)

#define HW_LCD_BPENH(x)          (*(__IO hw_lcd_bpenh_t *) HW_LCD_BPENH_ADDR(x))
#define HW_LCD_BPENH_RD(x)       (HW_LCD_BPENH(x).U)
#define HW_LCD_BPENH_WR(x, v)    (HW_LCD_BPENH(x).U = (v))
#define HW_LCD_BPENH_SET(x, v)   (BME_OR32(HW_LCD_BPENH_ADDR(x), (uint32_t)(v)))
#define HW_LCD_BPENH_CLR(x, v)   (BME_AND32(HW_LCD_BPENH_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_BPENH_TOG(x, v)   (BME_XOR32(HW_LCD_BPENH_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_BPENH bitfields
 */

/*!
 * @name Register LCD_BPENH, field BPEN[31:0] (RW)
 *
 * The BPEN[63:0] bits configure the LCD_P[63:0] pins to operate as an LCD back
 * plane or LCD front plane. BPENL contains BPEN[31:0], and BPENH contains
 * BPEN[63:32]. If LCDEN = 0, these bits have no effect on the state of the I/O pins.
 * It is recommended to set BPEN[63:0] bits before LCDEN is set.
 *
 * Values:
 * - 0 - Front plane operation enabled on LCD_Pn.
 * - 1 - Back plane operation enabled on LCD_Pn.
 */
/*@{*/
#define BP_LCD_BPENH_BPEN    (0U)          /*!< Bit position for LCD_BPENH_BPEN. */
#define BM_LCD_BPENH_BPEN    (0xFFFFFFFFU) /*!< Bit mask for LCD_BPENH_BPEN. */
#define BS_LCD_BPENH_BPEN    (32U)         /*!< Bit field size in bits for LCD_BPENH_BPEN. */

/*! @brief Read current value of the LCD_BPENH_BPEN field. */
#define BR_LCD_BPENH_BPEN(x) (HW_LCD_BPENH(x).U)

/*! @brief Format value for bitfield LCD_BPENH_BPEN. */
#define BF_LCD_BPENH_BPEN(v) ((uint32_t)((uint32_t)(v) << BP_LCD_BPENH_BPEN) & BM_LCD_BPENH_BPEN)

/*! @brief Set the BPEN field to a new value. */
#define BW_LCD_BPENH_BPEN(x, v) (HW_LCD_BPENH_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_LCD_WF3TO0 - LCD Waveform register
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF3TO0 - LCD Waveform register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each of the WFyTOx registers contains four waveform control (WFn) fields,
 * where x is the n index value of the WFn field in the least significant byte (bits
 * 7-0) and y is the n index value of the WFn field in the most significant byte
 * (bits 31-24). The bits in each WFn field control the front plane segments or
 * back plane phases connected to the LCD_Pn signal. In an LCD controller, each
 * element consists of a front plane segment and a back plane phase. These
 * segments and phases are labeled A through H (x8 multiplexing, 1/8 duty cycle). Each
 * LCD_Pn signal can be connected to one or more segments (in front plane
 * operation) or one or more phases (in back plane operation). An LCD element is turned
 * on when the associated back plane phase is activated and the front plane
 * segment is on. If LCD_Pn is configured for front plane operation, the bits in WFn
 * turn on or off each of the front plane segments connected to LCD_Pn: bit 0
 * controls segment A, bit 1 controls segment B, and so on. If LCD_Pn is configured
 * for back plane operation, the bits in WFn activate or deactivate each of the
 * back plane phases connected to LCD_Pn: bit 0 controls phase A, bit 1 controls
 * phase B, and so on. Software can write to this register with 8-bit, 16-bit, or
 * 32-bit writes. After reset, the WFyTOx register is cleared to 0. The reset value
 * of this register depends on the reset type: POR - 0x0000_0000
 */
typedef union _hw_lcd_wf3to0
{
    uint32_t U;
    struct _hw_lcd_wf3to0_bitfields
    {
        uint32_t WF0 : 8;              /*!< [7:0]  */
        uint32_t WF1 : 8;              /*!< [15:8]  */
        uint32_t WF2 : 8;              /*!< [23:16]  */
        uint32_t WF3 : 8;              /*!< [31:24]  */
    } B;
} hw_lcd_wf3to0_t;

/*!
 * @name Constants and macros for entire LCD_WF3TO0 register
 */
/*@{*/
#define HW_LCD_WF3TO0_ADDR(x)    ((uint32_t)(x) + 0x20U)

#define HW_LCD_WF3TO0(x)         (*(__IO hw_lcd_wf3to0_t *) HW_LCD_WF3TO0_ADDR(x))
#define HW_LCD_WF3TO0_RD(x)      (HW_LCD_WF3TO0(x).U)
#define HW_LCD_WF3TO0_WR(x, v)   (HW_LCD_WF3TO0(x).U = (v))
#define HW_LCD_WF3TO0_SET(x, v)  (BME_OR32(HW_LCD_WF3TO0_ADDR(x), (uint32_t)(v)))
#define HW_LCD_WF3TO0_CLR(x, v)  (BME_AND32(HW_LCD_WF3TO0_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_WF3TO0_TOG(x, v)  (BME_XOR32(HW_LCD_WF3TO0_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF3TO0 bitfields
 */

/*!
 * @name Register LCD_WF3TO0, field WF0[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P0 as described above for WF3.
 */
/*@{*/
#define BP_LCD_WF3TO0_WF0    (0U)          /*!< Bit position for LCD_WF3TO0_WF0. */
#define BM_LCD_WF3TO0_WF0    (0x000000FFU) /*!< Bit mask for LCD_WF3TO0_WF0. */
#define BS_LCD_WF3TO0_WF0    (8U)          /*!< Bit field size in bits for LCD_WF3TO0_WF0. */

/*! @brief Read current value of the LCD_WF3TO0_WF0 field. */
#define BR_LCD_WF3TO0_WF0(x) (BME_UBFX32(HW_LCD_WF3TO0_ADDR(x), BP_LCD_WF3TO0_WF0, BS_LCD_WF3TO0_WF0))

/*! @brief Format value for bitfield LCD_WF3TO0_WF0. */
#define BF_LCD_WF3TO0_WF0(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF3TO0_WF0) & BM_LCD_WF3TO0_WF0)

/*! @brief Set the WF0 field to a new value. */
#define BW_LCD_WF3TO0_WF0(x, v) (BME_BFI32(HW_LCD_WF3TO0_ADDR(x), ((uint32_t)(v) << BP_LCD_WF3TO0_WF0), BP_LCD_WF3TO0_WF0, 8))
/*@}*/

/*!
 * @name Register LCD_WF3TO0, field WF1[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P1 as described above for WF3.
 */
/*@{*/
#define BP_LCD_WF3TO0_WF1    (8U)          /*!< Bit position for LCD_WF3TO0_WF1. */
#define BM_LCD_WF3TO0_WF1    (0x0000FF00U) /*!< Bit mask for LCD_WF3TO0_WF1. */
#define BS_LCD_WF3TO0_WF1    (8U)          /*!< Bit field size in bits for LCD_WF3TO0_WF1. */

/*! @brief Read current value of the LCD_WF3TO0_WF1 field. */
#define BR_LCD_WF3TO0_WF1(x) (BME_UBFX32(HW_LCD_WF3TO0_ADDR(x), BP_LCD_WF3TO0_WF1, BS_LCD_WF3TO0_WF1))

/*! @brief Format value for bitfield LCD_WF3TO0_WF1. */
#define BF_LCD_WF3TO0_WF1(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF3TO0_WF1) & BM_LCD_WF3TO0_WF1)

/*! @brief Set the WF1 field to a new value. */
#define BW_LCD_WF3TO0_WF1(x, v) (BME_BFI32(HW_LCD_WF3TO0_ADDR(x), ((uint32_t)(v) << BP_LCD_WF3TO0_WF1), BP_LCD_WF3TO0_WF1, 8))
/*@}*/

/*!
 * @name Register LCD_WF3TO0, field WF2[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P2 as described above for WF3.
 */
/*@{*/
#define BP_LCD_WF3TO0_WF2    (16U)         /*!< Bit position for LCD_WF3TO0_WF2. */
#define BM_LCD_WF3TO0_WF2    (0x00FF0000U) /*!< Bit mask for LCD_WF3TO0_WF2. */
#define BS_LCD_WF3TO0_WF2    (8U)          /*!< Bit field size in bits for LCD_WF3TO0_WF2. */

/*! @brief Read current value of the LCD_WF3TO0_WF2 field. */
#define BR_LCD_WF3TO0_WF2(x) (BME_UBFX32(HW_LCD_WF3TO0_ADDR(x), BP_LCD_WF3TO0_WF2, BS_LCD_WF3TO0_WF2))

/*! @brief Format value for bitfield LCD_WF3TO0_WF2. */
#define BF_LCD_WF3TO0_WF2(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF3TO0_WF2) & BM_LCD_WF3TO0_WF2)

/*! @brief Set the WF2 field to a new value. */
#define BW_LCD_WF3TO0_WF2(x, v) (BME_BFI32(HW_LCD_WF3TO0_ADDR(x), ((uint32_t)(v) << BP_LCD_WF3TO0_WF2), BP_LCD_WF3TO0_WF2, 8))
/*@}*/

/*!
 * @name Register LCD_WF3TO0, field WF3[31:24] (RW)
 *
 * Segment-on front plane operation - Each bit turns on or off the segments
 * associated with LCD_P3 in the following pattern: HGFEDCBA (most significant bit
 * controls segment H and least significant bit controls segment A). Segment-on
 * back plane operation - Each bit activates or deactivates the phases associated
 * with LCD_P3 in the following pattern: HGFEDCBA (most significant bit controls
 * phase H and least significant bit controls phase A). For each bit: 0 Segment off
 * or phase deactivated 1 Segment on or phase activated
 */
/*@{*/
#define BP_LCD_WF3TO0_WF3    (24U)         /*!< Bit position for LCD_WF3TO0_WF3. */
#define BM_LCD_WF3TO0_WF3    (0xFF000000U) /*!< Bit mask for LCD_WF3TO0_WF3. */
#define BS_LCD_WF3TO0_WF3    (8U)          /*!< Bit field size in bits for LCD_WF3TO0_WF3. */

/*! @brief Read current value of the LCD_WF3TO0_WF3 field. */
#define BR_LCD_WF3TO0_WF3(x) (BME_UBFX32(HW_LCD_WF3TO0_ADDR(x), BP_LCD_WF3TO0_WF3, BS_LCD_WF3TO0_WF3))

/*! @brief Format value for bitfield LCD_WF3TO0_WF3. */
#define BF_LCD_WF3TO0_WF3(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF3TO0_WF3) & BM_LCD_WF3TO0_WF3)

/*! @brief Set the WF3 field to a new value. */
#define BW_LCD_WF3TO0_WF3(x, v) (BME_BFI32(HW_LCD_WF3TO0_ADDR(x), ((uint32_t)(v) << BP_LCD_WF3TO0_WF3), BP_LCD_WF3TO0_WF3, 8))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF7TO4 - LCD Waveform register
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF7TO4 - LCD Waveform register (RW)
 *
 * Reset value: 0x00000000U
 *
 * See the LCD Waveform register (WFC3TO0) for register and field descriptions.
 * The reset value of this register depends on the reset type: POR - 0x0000_0000
 */
typedef union _hw_lcd_wf7to4
{
    uint32_t U;
    struct _hw_lcd_wf7to4_bitfields
    {
        uint32_t WF4 : 8;              /*!< [7:0]  */
        uint32_t WF5 : 8;              /*!< [15:8]  */
        uint32_t WF6 : 8;              /*!< [23:16]  */
        uint32_t WF7 : 8;              /*!< [31:24]  */
    } B;
} hw_lcd_wf7to4_t;

/*!
 * @name Constants and macros for entire LCD_WF7TO4 register
 */
/*@{*/
#define HW_LCD_WF7TO4_ADDR(x)    ((uint32_t)(x) + 0x24U)

#define HW_LCD_WF7TO4(x)         (*(__IO hw_lcd_wf7to4_t *) HW_LCD_WF7TO4_ADDR(x))
#define HW_LCD_WF7TO4_RD(x)      (HW_LCD_WF7TO4(x).U)
#define HW_LCD_WF7TO4_WR(x, v)   (HW_LCD_WF7TO4(x).U = (v))
#define HW_LCD_WF7TO4_SET(x, v)  (BME_OR32(HW_LCD_WF7TO4_ADDR(x), (uint32_t)(v)))
#define HW_LCD_WF7TO4_CLR(x, v)  (BME_AND32(HW_LCD_WF7TO4_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_WF7TO4_TOG(x, v)  (BME_XOR32(HW_LCD_WF7TO4_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF7TO4 bitfields
 */

/*!
 * @name Register LCD_WF7TO4, field WF4[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P4 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF7TO4_WF4    (0U)          /*!< Bit position for LCD_WF7TO4_WF4. */
#define BM_LCD_WF7TO4_WF4    (0x000000FFU) /*!< Bit mask for LCD_WF7TO4_WF4. */
#define BS_LCD_WF7TO4_WF4    (8U)          /*!< Bit field size in bits for LCD_WF7TO4_WF4. */

/*! @brief Read current value of the LCD_WF7TO4_WF4 field. */
#define BR_LCD_WF7TO4_WF4(x) (BME_UBFX32(HW_LCD_WF7TO4_ADDR(x), BP_LCD_WF7TO4_WF4, BS_LCD_WF7TO4_WF4))

/*! @brief Format value for bitfield LCD_WF7TO4_WF4. */
#define BF_LCD_WF7TO4_WF4(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF7TO4_WF4) & BM_LCD_WF7TO4_WF4)

/*! @brief Set the WF4 field to a new value. */
#define BW_LCD_WF7TO4_WF4(x, v) (BME_BFI32(HW_LCD_WF7TO4_ADDR(x), ((uint32_t)(v) << BP_LCD_WF7TO4_WF4), BP_LCD_WF7TO4_WF4, 8))
/*@}*/

/*!
 * @name Register LCD_WF7TO4, field WF5[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P5 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF7TO4_WF5    (8U)          /*!< Bit position for LCD_WF7TO4_WF5. */
#define BM_LCD_WF7TO4_WF5    (0x0000FF00U) /*!< Bit mask for LCD_WF7TO4_WF5. */
#define BS_LCD_WF7TO4_WF5    (8U)          /*!< Bit field size in bits for LCD_WF7TO4_WF5. */

/*! @brief Read current value of the LCD_WF7TO4_WF5 field. */
#define BR_LCD_WF7TO4_WF5(x) (BME_UBFX32(HW_LCD_WF7TO4_ADDR(x), BP_LCD_WF7TO4_WF5, BS_LCD_WF7TO4_WF5))

/*! @brief Format value for bitfield LCD_WF7TO4_WF5. */
#define BF_LCD_WF7TO4_WF5(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF7TO4_WF5) & BM_LCD_WF7TO4_WF5)

/*! @brief Set the WF5 field to a new value. */
#define BW_LCD_WF7TO4_WF5(x, v) (BME_BFI32(HW_LCD_WF7TO4_ADDR(x), ((uint32_t)(v) << BP_LCD_WF7TO4_WF5), BP_LCD_WF7TO4_WF5, 8))
/*@}*/

/*!
 * @name Register LCD_WF7TO4, field WF6[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P6 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF7TO4_WF6    (16U)         /*!< Bit position for LCD_WF7TO4_WF6. */
#define BM_LCD_WF7TO4_WF6    (0x00FF0000U) /*!< Bit mask for LCD_WF7TO4_WF6. */
#define BS_LCD_WF7TO4_WF6    (8U)          /*!< Bit field size in bits for LCD_WF7TO4_WF6. */

/*! @brief Read current value of the LCD_WF7TO4_WF6 field. */
#define BR_LCD_WF7TO4_WF6(x) (BME_UBFX32(HW_LCD_WF7TO4_ADDR(x), BP_LCD_WF7TO4_WF6, BS_LCD_WF7TO4_WF6))

/*! @brief Format value for bitfield LCD_WF7TO4_WF6. */
#define BF_LCD_WF7TO4_WF6(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF7TO4_WF6) & BM_LCD_WF7TO4_WF6)

/*! @brief Set the WF6 field to a new value. */
#define BW_LCD_WF7TO4_WF6(x, v) (BME_BFI32(HW_LCD_WF7TO4_ADDR(x), ((uint32_t)(v) << BP_LCD_WF7TO4_WF6), BP_LCD_WF7TO4_WF6, 8))
/*@}*/

/*!
 * @name Register LCD_WF7TO4, field WF7[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P7 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF7TO4_WF7    (24U)         /*!< Bit position for LCD_WF7TO4_WF7. */
#define BM_LCD_WF7TO4_WF7    (0xFF000000U) /*!< Bit mask for LCD_WF7TO4_WF7. */
#define BS_LCD_WF7TO4_WF7    (8U)          /*!< Bit field size in bits for LCD_WF7TO4_WF7. */

/*! @brief Read current value of the LCD_WF7TO4_WF7 field. */
#define BR_LCD_WF7TO4_WF7(x) (BME_UBFX32(HW_LCD_WF7TO4_ADDR(x), BP_LCD_WF7TO4_WF7, BS_LCD_WF7TO4_WF7))

/*! @brief Format value for bitfield LCD_WF7TO4_WF7. */
#define BF_LCD_WF7TO4_WF7(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF7TO4_WF7) & BM_LCD_WF7TO4_WF7)

/*! @brief Set the WF7 field to a new value. */
#define BW_LCD_WF7TO4_WF7(x, v) (BME_BFI32(HW_LCD_WF7TO4_ADDR(x), ((uint32_t)(v) << BP_LCD_WF7TO4_WF7), BP_LCD_WF7TO4_WF7, 8))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF11TO8 - LCD Waveform register
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF11TO8 - LCD Waveform register (RW)
 *
 * Reset value: 0x00000000U
 *
 * See the LCD Waveform register (WFC3TO0) for register and field descriptions.
 * The reset value of this register depends on the reset type: POR - 0x0000_0000
 */
typedef union _hw_lcd_wf11to8
{
    uint32_t U;
    struct _hw_lcd_wf11to8_bitfields
    {
        uint32_t WF8 : 8;              /*!< [7:0]  */
        uint32_t WF9 : 8;              /*!< [15:8]  */
        uint32_t WF10 : 8;             /*!< [23:16]  */
        uint32_t WF11 : 8;             /*!< [31:24]  */
    } B;
} hw_lcd_wf11to8_t;

/*!
 * @name Constants and macros for entire LCD_WF11TO8 register
 */
/*@{*/
#define HW_LCD_WF11TO8_ADDR(x)   ((uint32_t)(x) + 0x28U)

#define HW_LCD_WF11TO8(x)        (*(__IO hw_lcd_wf11to8_t *) HW_LCD_WF11TO8_ADDR(x))
#define HW_LCD_WF11TO8_RD(x)     (HW_LCD_WF11TO8(x).U)
#define HW_LCD_WF11TO8_WR(x, v)  (HW_LCD_WF11TO8(x).U = (v))
#define HW_LCD_WF11TO8_SET(x, v) (BME_OR32(HW_LCD_WF11TO8_ADDR(x), (uint32_t)(v)))
#define HW_LCD_WF11TO8_CLR(x, v) (BME_AND32(HW_LCD_WF11TO8_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_WF11TO8_TOG(x, v) (BME_XOR32(HW_LCD_WF11TO8_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF11TO8 bitfields
 */

/*!
 * @name Register LCD_WF11TO8, field WF8[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P8 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF11TO8_WF8   (0U)          /*!< Bit position for LCD_WF11TO8_WF8. */
#define BM_LCD_WF11TO8_WF8   (0x000000FFU) /*!< Bit mask for LCD_WF11TO8_WF8. */
#define BS_LCD_WF11TO8_WF8   (8U)          /*!< Bit field size in bits for LCD_WF11TO8_WF8. */

/*! @brief Read current value of the LCD_WF11TO8_WF8 field. */
#define BR_LCD_WF11TO8_WF8(x) (BME_UBFX32(HW_LCD_WF11TO8_ADDR(x), BP_LCD_WF11TO8_WF8, BS_LCD_WF11TO8_WF8))

/*! @brief Format value for bitfield LCD_WF11TO8_WF8. */
#define BF_LCD_WF11TO8_WF8(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF11TO8_WF8) & BM_LCD_WF11TO8_WF8)

/*! @brief Set the WF8 field to a new value. */
#define BW_LCD_WF11TO8_WF8(x, v) (BME_BFI32(HW_LCD_WF11TO8_ADDR(x), ((uint32_t)(v) << BP_LCD_WF11TO8_WF8), BP_LCD_WF11TO8_WF8, 8))
/*@}*/

/*!
 * @name Register LCD_WF11TO8, field WF9[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P9 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF11TO8_WF9   (8U)          /*!< Bit position for LCD_WF11TO8_WF9. */
#define BM_LCD_WF11TO8_WF9   (0x0000FF00U) /*!< Bit mask for LCD_WF11TO8_WF9. */
#define BS_LCD_WF11TO8_WF9   (8U)          /*!< Bit field size in bits for LCD_WF11TO8_WF9. */

/*! @brief Read current value of the LCD_WF11TO8_WF9 field. */
#define BR_LCD_WF11TO8_WF9(x) (BME_UBFX32(HW_LCD_WF11TO8_ADDR(x), BP_LCD_WF11TO8_WF9, BS_LCD_WF11TO8_WF9))

/*! @brief Format value for bitfield LCD_WF11TO8_WF9. */
#define BF_LCD_WF11TO8_WF9(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF11TO8_WF9) & BM_LCD_WF11TO8_WF9)

/*! @brief Set the WF9 field to a new value. */
#define BW_LCD_WF11TO8_WF9(x, v) (BME_BFI32(HW_LCD_WF11TO8_ADDR(x), ((uint32_t)(v) << BP_LCD_WF11TO8_WF9), BP_LCD_WF11TO8_WF9, 8))
/*@}*/

/*!
 * @name Register LCD_WF11TO8, field WF10[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P10 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF11TO8_WF10  (16U)         /*!< Bit position for LCD_WF11TO8_WF10. */
#define BM_LCD_WF11TO8_WF10  (0x00FF0000U) /*!< Bit mask for LCD_WF11TO8_WF10. */
#define BS_LCD_WF11TO8_WF10  (8U)          /*!< Bit field size in bits for LCD_WF11TO8_WF10. */

/*! @brief Read current value of the LCD_WF11TO8_WF10 field. */
#define BR_LCD_WF11TO8_WF10(x) (BME_UBFX32(HW_LCD_WF11TO8_ADDR(x), BP_LCD_WF11TO8_WF10, BS_LCD_WF11TO8_WF10))

/*! @brief Format value for bitfield LCD_WF11TO8_WF10. */
#define BF_LCD_WF11TO8_WF10(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF11TO8_WF10) & BM_LCD_WF11TO8_WF10)

/*! @brief Set the WF10 field to a new value. */
#define BW_LCD_WF11TO8_WF10(x, v) (BME_BFI32(HW_LCD_WF11TO8_ADDR(x), ((uint32_t)(v) << BP_LCD_WF11TO8_WF10), BP_LCD_WF11TO8_WF10, 8))
/*@}*/

/*!
 * @name Register LCD_WF11TO8, field WF11[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P11 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF11TO8_WF11  (24U)         /*!< Bit position for LCD_WF11TO8_WF11. */
#define BM_LCD_WF11TO8_WF11  (0xFF000000U) /*!< Bit mask for LCD_WF11TO8_WF11. */
#define BS_LCD_WF11TO8_WF11  (8U)          /*!< Bit field size in bits for LCD_WF11TO8_WF11. */

/*! @brief Read current value of the LCD_WF11TO8_WF11 field. */
#define BR_LCD_WF11TO8_WF11(x) (BME_UBFX32(HW_LCD_WF11TO8_ADDR(x), BP_LCD_WF11TO8_WF11, BS_LCD_WF11TO8_WF11))

/*! @brief Format value for bitfield LCD_WF11TO8_WF11. */
#define BF_LCD_WF11TO8_WF11(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF11TO8_WF11) & BM_LCD_WF11TO8_WF11)

/*! @brief Set the WF11 field to a new value. */
#define BW_LCD_WF11TO8_WF11(x, v) (BME_BFI32(HW_LCD_WF11TO8_ADDR(x), ((uint32_t)(v) << BP_LCD_WF11TO8_WF11), BP_LCD_WF11TO8_WF11, 8))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF15TO12 - LCD Waveform register
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF15TO12 - LCD Waveform register (RW)
 *
 * Reset value: 0x00000000U
 *
 * See the LCD Waveform register (WFC3TO0) for register and field descriptions.
 * The reset value of this register depends on the reset type: POR - 0x0000_0000
 */
typedef union _hw_lcd_wf15to12
{
    uint32_t U;
    struct _hw_lcd_wf15to12_bitfields
    {
        uint32_t WF12 : 8;             /*!< [7:0]  */
        uint32_t WF13 : 8;             /*!< [15:8]  */
        uint32_t WF14 : 8;             /*!< [23:16]  */
        uint32_t WF15 : 8;             /*!< [31:24]  */
    } B;
} hw_lcd_wf15to12_t;

/*!
 * @name Constants and macros for entire LCD_WF15TO12 register
 */
/*@{*/
#define HW_LCD_WF15TO12_ADDR(x)  ((uint32_t)(x) + 0x2CU)

#define HW_LCD_WF15TO12(x)       (*(__IO hw_lcd_wf15to12_t *) HW_LCD_WF15TO12_ADDR(x))
#define HW_LCD_WF15TO12_RD(x)    (HW_LCD_WF15TO12(x).U)
#define HW_LCD_WF15TO12_WR(x, v) (HW_LCD_WF15TO12(x).U = (v))
#define HW_LCD_WF15TO12_SET(x, v) (BME_OR32(HW_LCD_WF15TO12_ADDR(x), (uint32_t)(v)))
#define HW_LCD_WF15TO12_CLR(x, v) (BME_AND32(HW_LCD_WF15TO12_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_WF15TO12_TOG(x, v) (BME_XOR32(HW_LCD_WF15TO12_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF15TO12 bitfields
 */

/*!
 * @name Register LCD_WF15TO12, field WF12[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P12 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF15TO12_WF12 (0U)          /*!< Bit position for LCD_WF15TO12_WF12. */
#define BM_LCD_WF15TO12_WF12 (0x000000FFU) /*!< Bit mask for LCD_WF15TO12_WF12. */
#define BS_LCD_WF15TO12_WF12 (8U)          /*!< Bit field size in bits for LCD_WF15TO12_WF12. */

/*! @brief Read current value of the LCD_WF15TO12_WF12 field. */
#define BR_LCD_WF15TO12_WF12(x) (BME_UBFX32(HW_LCD_WF15TO12_ADDR(x), BP_LCD_WF15TO12_WF12, BS_LCD_WF15TO12_WF12))

/*! @brief Format value for bitfield LCD_WF15TO12_WF12. */
#define BF_LCD_WF15TO12_WF12(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF15TO12_WF12) & BM_LCD_WF15TO12_WF12)

/*! @brief Set the WF12 field to a new value. */
#define BW_LCD_WF15TO12_WF12(x, v) (BME_BFI32(HW_LCD_WF15TO12_ADDR(x), ((uint32_t)(v) << BP_LCD_WF15TO12_WF12), BP_LCD_WF15TO12_WF12, 8))
/*@}*/

/*!
 * @name Register LCD_WF15TO12, field WF13[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P13 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF15TO12_WF13 (8U)          /*!< Bit position for LCD_WF15TO12_WF13. */
#define BM_LCD_WF15TO12_WF13 (0x0000FF00U) /*!< Bit mask for LCD_WF15TO12_WF13. */
#define BS_LCD_WF15TO12_WF13 (8U)          /*!< Bit field size in bits for LCD_WF15TO12_WF13. */

/*! @brief Read current value of the LCD_WF15TO12_WF13 field. */
#define BR_LCD_WF15TO12_WF13(x) (BME_UBFX32(HW_LCD_WF15TO12_ADDR(x), BP_LCD_WF15TO12_WF13, BS_LCD_WF15TO12_WF13))

/*! @brief Format value for bitfield LCD_WF15TO12_WF13. */
#define BF_LCD_WF15TO12_WF13(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF15TO12_WF13) & BM_LCD_WF15TO12_WF13)

/*! @brief Set the WF13 field to a new value. */
#define BW_LCD_WF15TO12_WF13(x, v) (BME_BFI32(HW_LCD_WF15TO12_ADDR(x), ((uint32_t)(v) << BP_LCD_WF15TO12_WF13), BP_LCD_WF15TO12_WF13, 8))
/*@}*/

/*!
 * @name Register LCD_WF15TO12, field WF14[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P14 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF15TO12_WF14 (16U)         /*!< Bit position for LCD_WF15TO12_WF14. */
#define BM_LCD_WF15TO12_WF14 (0x00FF0000U) /*!< Bit mask for LCD_WF15TO12_WF14. */
#define BS_LCD_WF15TO12_WF14 (8U)          /*!< Bit field size in bits for LCD_WF15TO12_WF14. */

/*! @brief Read current value of the LCD_WF15TO12_WF14 field. */
#define BR_LCD_WF15TO12_WF14(x) (BME_UBFX32(HW_LCD_WF15TO12_ADDR(x), BP_LCD_WF15TO12_WF14, BS_LCD_WF15TO12_WF14))

/*! @brief Format value for bitfield LCD_WF15TO12_WF14. */
#define BF_LCD_WF15TO12_WF14(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF15TO12_WF14) & BM_LCD_WF15TO12_WF14)

/*! @brief Set the WF14 field to a new value. */
#define BW_LCD_WF15TO12_WF14(x, v) (BME_BFI32(HW_LCD_WF15TO12_ADDR(x), ((uint32_t)(v) << BP_LCD_WF15TO12_WF14), BP_LCD_WF15TO12_WF14, 8))
/*@}*/

/*!
 * @name Register LCD_WF15TO12, field WF15[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P15 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF15TO12_WF15 (24U)         /*!< Bit position for LCD_WF15TO12_WF15. */
#define BM_LCD_WF15TO12_WF15 (0xFF000000U) /*!< Bit mask for LCD_WF15TO12_WF15. */
#define BS_LCD_WF15TO12_WF15 (8U)          /*!< Bit field size in bits for LCD_WF15TO12_WF15. */

/*! @brief Read current value of the LCD_WF15TO12_WF15 field. */
#define BR_LCD_WF15TO12_WF15(x) (BME_UBFX32(HW_LCD_WF15TO12_ADDR(x), BP_LCD_WF15TO12_WF15, BS_LCD_WF15TO12_WF15))

/*! @brief Format value for bitfield LCD_WF15TO12_WF15. */
#define BF_LCD_WF15TO12_WF15(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF15TO12_WF15) & BM_LCD_WF15TO12_WF15)

/*! @brief Set the WF15 field to a new value. */
#define BW_LCD_WF15TO12_WF15(x, v) (BME_BFI32(HW_LCD_WF15TO12_ADDR(x), ((uint32_t)(v) << BP_LCD_WF15TO12_WF15), BP_LCD_WF15TO12_WF15, 8))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF19TO16 - LCD Waveform register
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF19TO16 - LCD Waveform register (RW)
 *
 * Reset value: 0x00000000U
 *
 * See the LCD Waveform register (WFC3TO0) for register and field descriptions.
 * The reset value of this register depends on the reset type: POR - 0x0000_0000
 */
typedef union _hw_lcd_wf19to16
{
    uint32_t U;
    struct _hw_lcd_wf19to16_bitfields
    {
        uint32_t WF16 : 8;             /*!< [7:0]  */
        uint32_t WF17 : 8;             /*!< [15:8]  */
        uint32_t WF18 : 8;             /*!< [23:16]  */
        uint32_t WF19 : 8;             /*!< [31:24]  */
    } B;
} hw_lcd_wf19to16_t;

/*!
 * @name Constants and macros for entire LCD_WF19TO16 register
 */
/*@{*/
#define HW_LCD_WF19TO16_ADDR(x)  ((uint32_t)(x) + 0x30U)

#define HW_LCD_WF19TO16(x)       (*(__IO hw_lcd_wf19to16_t *) HW_LCD_WF19TO16_ADDR(x))
#define HW_LCD_WF19TO16_RD(x)    (HW_LCD_WF19TO16(x).U)
#define HW_LCD_WF19TO16_WR(x, v) (HW_LCD_WF19TO16(x).U = (v))
#define HW_LCD_WF19TO16_SET(x, v) (BME_OR32(HW_LCD_WF19TO16_ADDR(x), (uint32_t)(v)))
#define HW_LCD_WF19TO16_CLR(x, v) (BME_AND32(HW_LCD_WF19TO16_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_WF19TO16_TOG(x, v) (BME_XOR32(HW_LCD_WF19TO16_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF19TO16 bitfields
 */

/*!
 * @name Register LCD_WF19TO16, field WF16[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P16 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF19TO16_WF16 (0U)          /*!< Bit position for LCD_WF19TO16_WF16. */
#define BM_LCD_WF19TO16_WF16 (0x000000FFU) /*!< Bit mask for LCD_WF19TO16_WF16. */
#define BS_LCD_WF19TO16_WF16 (8U)          /*!< Bit field size in bits for LCD_WF19TO16_WF16. */

/*! @brief Read current value of the LCD_WF19TO16_WF16 field. */
#define BR_LCD_WF19TO16_WF16(x) (BME_UBFX32(HW_LCD_WF19TO16_ADDR(x), BP_LCD_WF19TO16_WF16, BS_LCD_WF19TO16_WF16))

/*! @brief Format value for bitfield LCD_WF19TO16_WF16. */
#define BF_LCD_WF19TO16_WF16(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF19TO16_WF16) & BM_LCD_WF19TO16_WF16)

/*! @brief Set the WF16 field to a new value. */
#define BW_LCD_WF19TO16_WF16(x, v) (BME_BFI32(HW_LCD_WF19TO16_ADDR(x), ((uint32_t)(v) << BP_LCD_WF19TO16_WF16), BP_LCD_WF19TO16_WF16, 8))
/*@}*/

/*!
 * @name Register LCD_WF19TO16, field WF17[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P17 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF19TO16_WF17 (8U)          /*!< Bit position for LCD_WF19TO16_WF17. */
#define BM_LCD_WF19TO16_WF17 (0x0000FF00U) /*!< Bit mask for LCD_WF19TO16_WF17. */
#define BS_LCD_WF19TO16_WF17 (8U)          /*!< Bit field size in bits for LCD_WF19TO16_WF17. */

/*! @brief Read current value of the LCD_WF19TO16_WF17 field. */
#define BR_LCD_WF19TO16_WF17(x) (BME_UBFX32(HW_LCD_WF19TO16_ADDR(x), BP_LCD_WF19TO16_WF17, BS_LCD_WF19TO16_WF17))

/*! @brief Format value for bitfield LCD_WF19TO16_WF17. */
#define BF_LCD_WF19TO16_WF17(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF19TO16_WF17) & BM_LCD_WF19TO16_WF17)

/*! @brief Set the WF17 field to a new value. */
#define BW_LCD_WF19TO16_WF17(x, v) (BME_BFI32(HW_LCD_WF19TO16_ADDR(x), ((uint32_t)(v) << BP_LCD_WF19TO16_WF17), BP_LCD_WF19TO16_WF17, 8))
/*@}*/

/*!
 * @name Register LCD_WF19TO16, field WF18[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P18 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF19TO16_WF18 (16U)         /*!< Bit position for LCD_WF19TO16_WF18. */
#define BM_LCD_WF19TO16_WF18 (0x00FF0000U) /*!< Bit mask for LCD_WF19TO16_WF18. */
#define BS_LCD_WF19TO16_WF18 (8U)          /*!< Bit field size in bits for LCD_WF19TO16_WF18. */

/*! @brief Read current value of the LCD_WF19TO16_WF18 field. */
#define BR_LCD_WF19TO16_WF18(x) (BME_UBFX32(HW_LCD_WF19TO16_ADDR(x), BP_LCD_WF19TO16_WF18, BS_LCD_WF19TO16_WF18))

/*! @brief Format value for bitfield LCD_WF19TO16_WF18. */
#define BF_LCD_WF19TO16_WF18(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF19TO16_WF18) & BM_LCD_WF19TO16_WF18)

/*! @brief Set the WF18 field to a new value. */
#define BW_LCD_WF19TO16_WF18(x, v) (BME_BFI32(HW_LCD_WF19TO16_ADDR(x), ((uint32_t)(v) << BP_LCD_WF19TO16_WF18), BP_LCD_WF19TO16_WF18, 8))
/*@}*/

/*!
 * @name Register LCD_WF19TO16, field WF19[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P19 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF19TO16_WF19 (24U)         /*!< Bit position for LCD_WF19TO16_WF19. */
#define BM_LCD_WF19TO16_WF19 (0xFF000000U) /*!< Bit mask for LCD_WF19TO16_WF19. */
#define BS_LCD_WF19TO16_WF19 (8U)          /*!< Bit field size in bits for LCD_WF19TO16_WF19. */

/*! @brief Read current value of the LCD_WF19TO16_WF19 field. */
#define BR_LCD_WF19TO16_WF19(x) (BME_UBFX32(HW_LCD_WF19TO16_ADDR(x), BP_LCD_WF19TO16_WF19, BS_LCD_WF19TO16_WF19))

/*! @brief Format value for bitfield LCD_WF19TO16_WF19. */
#define BF_LCD_WF19TO16_WF19(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF19TO16_WF19) & BM_LCD_WF19TO16_WF19)

/*! @brief Set the WF19 field to a new value. */
#define BW_LCD_WF19TO16_WF19(x, v) (BME_BFI32(HW_LCD_WF19TO16_ADDR(x), ((uint32_t)(v) << BP_LCD_WF19TO16_WF19), BP_LCD_WF19TO16_WF19, 8))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF23TO20 - LCD Waveform register
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF23TO20 - LCD Waveform register (RW)
 *
 * Reset value: 0x00000000U
 *
 * See the LCD Waveform register (WFC3TO0) for register and field descriptions.
 * The reset value of this register depends on the reset type: POR - 0x0000_0000
 */
typedef union _hw_lcd_wf23to20
{
    uint32_t U;
    struct _hw_lcd_wf23to20_bitfields
    {
        uint32_t WF20 : 8;             /*!< [7:0]  */
        uint32_t WF21 : 8;             /*!< [15:8]  */
        uint32_t WF22 : 8;             /*!< [23:16]  */
        uint32_t WF23 : 8;             /*!< [31:24]  */
    } B;
} hw_lcd_wf23to20_t;

/*!
 * @name Constants and macros for entire LCD_WF23TO20 register
 */
/*@{*/
#define HW_LCD_WF23TO20_ADDR(x)  ((uint32_t)(x) + 0x34U)

#define HW_LCD_WF23TO20(x)       (*(__IO hw_lcd_wf23to20_t *) HW_LCD_WF23TO20_ADDR(x))
#define HW_LCD_WF23TO20_RD(x)    (HW_LCD_WF23TO20(x).U)
#define HW_LCD_WF23TO20_WR(x, v) (HW_LCD_WF23TO20(x).U = (v))
#define HW_LCD_WF23TO20_SET(x, v) (BME_OR32(HW_LCD_WF23TO20_ADDR(x), (uint32_t)(v)))
#define HW_LCD_WF23TO20_CLR(x, v) (BME_AND32(HW_LCD_WF23TO20_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_WF23TO20_TOG(x, v) (BME_XOR32(HW_LCD_WF23TO20_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF23TO20 bitfields
 */

/*!
 * @name Register LCD_WF23TO20, field WF20[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P20 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF23TO20_WF20 (0U)          /*!< Bit position for LCD_WF23TO20_WF20. */
#define BM_LCD_WF23TO20_WF20 (0x000000FFU) /*!< Bit mask for LCD_WF23TO20_WF20. */
#define BS_LCD_WF23TO20_WF20 (8U)          /*!< Bit field size in bits for LCD_WF23TO20_WF20. */

/*! @brief Read current value of the LCD_WF23TO20_WF20 field. */
#define BR_LCD_WF23TO20_WF20(x) (BME_UBFX32(HW_LCD_WF23TO20_ADDR(x), BP_LCD_WF23TO20_WF20, BS_LCD_WF23TO20_WF20))

/*! @brief Format value for bitfield LCD_WF23TO20_WF20. */
#define BF_LCD_WF23TO20_WF20(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF23TO20_WF20) & BM_LCD_WF23TO20_WF20)

/*! @brief Set the WF20 field to a new value. */
#define BW_LCD_WF23TO20_WF20(x, v) (BME_BFI32(HW_LCD_WF23TO20_ADDR(x), ((uint32_t)(v) << BP_LCD_WF23TO20_WF20), BP_LCD_WF23TO20_WF20, 8))
/*@}*/

/*!
 * @name Register LCD_WF23TO20, field WF21[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P21 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF23TO20_WF21 (8U)          /*!< Bit position for LCD_WF23TO20_WF21. */
#define BM_LCD_WF23TO20_WF21 (0x0000FF00U) /*!< Bit mask for LCD_WF23TO20_WF21. */
#define BS_LCD_WF23TO20_WF21 (8U)          /*!< Bit field size in bits for LCD_WF23TO20_WF21. */

/*! @brief Read current value of the LCD_WF23TO20_WF21 field. */
#define BR_LCD_WF23TO20_WF21(x) (BME_UBFX32(HW_LCD_WF23TO20_ADDR(x), BP_LCD_WF23TO20_WF21, BS_LCD_WF23TO20_WF21))

/*! @brief Format value for bitfield LCD_WF23TO20_WF21. */
#define BF_LCD_WF23TO20_WF21(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF23TO20_WF21) & BM_LCD_WF23TO20_WF21)

/*! @brief Set the WF21 field to a new value. */
#define BW_LCD_WF23TO20_WF21(x, v) (BME_BFI32(HW_LCD_WF23TO20_ADDR(x), ((uint32_t)(v) << BP_LCD_WF23TO20_WF21), BP_LCD_WF23TO20_WF21, 8))
/*@}*/

/*!
 * @name Register LCD_WF23TO20, field WF22[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P22 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF23TO20_WF22 (16U)         /*!< Bit position for LCD_WF23TO20_WF22. */
#define BM_LCD_WF23TO20_WF22 (0x00FF0000U) /*!< Bit mask for LCD_WF23TO20_WF22. */
#define BS_LCD_WF23TO20_WF22 (8U)          /*!< Bit field size in bits for LCD_WF23TO20_WF22. */

/*! @brief Read current value of the LCD_WF23TO20_WF22 field. */
#define BR_LCD_WF23TO20_WF22(x) (BME_UBFX32(HW_LCD_WF23TO20_ADDR(x), BP_LCD_WF23TO20_WF22, BS_LCD_WF23TO20_WF22))

/*! @brief Format value for bitfield LCD_WF23TO20_WF22. */
#define BF_LCD_WF23TO20_WF22(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF23TO20_WF22) & BM_LCD_WF23TO20_WF22)

/*! @brief Set the WF22 field to a new value. */
#define BW_LCD_WF23TO20_WF22(x, v) (BME_BFI32(HW_LCD_WF23TO20_ADDR(x), ((uint32_t)(v) << BP_LCD_WF23TO20_WF22), BP_LCD_WF23TO20_WF22, 8))
/*@}*/

/*!
 * @name Register LCD_WF23TO20, field WF23[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P23 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF23TO20_WF23 (24U)         /*!< Bit position for LCD_WF23TO20_WF23. */
#define BM_LCD_WF23TO20_WF23 (0xFF000000U) /*!< Bit mask for LCD_WF23TO20_WF23. */
#define BS_LCD_WF23TO20_WF23 (8U)          /*!< Bit field size in bits for LCD_WF23TO20_WF23. */

/*! @brief Read current value of the LCD_WF23TO20_WF23 field. */
#define BR_LCD_WF23TO20_WF23(x) (BME_UBFX32(HW_LCD_WF23TO20_ADDR(x), BP_LCD_WF23TO20_WF23, BS_LCD_WF23TO20_WF23))

/*! @brief Format value for bitfield LCD_WF23TO20_WF23. */
#define BF_LCD_WF23TO20_WF23(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF23TO20_WF23) & BM_LCD_WF23TO20_WF23)

/*! @brief Set the WF23 field to a new value. */
#define BW_LCD_WF23TO20_WF23(x, v) (BME_BFI32(HW_LCD_WF23TO20_ADDR(x), ((uint32_t)(v) << BP_LCD_WF23TO20_WF23), BP_LCD_WF23TO20_WF23, 8))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF27TO24 - LCD Waveform register
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF27TO24 - LCD Waveform register (RW)
 *
 * Reset value: 0x00000000U
 *
 * See the LCD Waveform register (WFC3TO0) for register and field descriptions.
 * The reset value of this register depends on the reset type: POR - 0x0000_0000
 */
typedef union _hw_lcd_wf27to24
{
    uint32_t U;
    struct _hw_lcd_wf27to24_bitfields
    {
        uint32_t WF24 : 8;             /*!< [7:0]  */
        uint32_t WF25 : 8;             /*!< [15:8]  */
        uint32_t WF26 : 8;             /*!< [23:16]  */
        uint32_t WF27 : 8;             /*!< [31:24]  */
    } B;
} hw_lcd_wf27to24_t;

/*!
 * @name Constants and macros for entire LCD_WF27TO24 register
 */
/*@{*/
#define HW_LCD_WF27TO24_ADDR(x)  ((uint32_t)(x) + 0x38U)

#define HW_LCD_WF27TO24(x)       (*(__IO hw_lcd_wf27to24_t *) HW_LCD_WF27TO24_ADDR(x))
#define HW_LCD_WF27TO24_RD(x)    (HW_LCD_WF27TO24(x).U)
#define HW_LCD_WF27TO24_WR(x, v) (HW_LCD_WF27TO24(x).U = (v))
#define HW_LCD_WF27TO24_SET(x, v) (BME_OR32(HW_LCD_WF27TO24_ADDR(x), (uint32_t)(v)))
#define HW_LCD_WF27TO24_CLR(x, v) (BME_AND32(HW_LCD_WF27TO24_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_WF27TO24_TOG(x, v) (BME_XOR32(HW_LCD_WF27TO24_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF27TO24 bitfields
 */

/*!
 * @name Register LCD_WF27TO24, field WF24[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P24 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF27TO24_WF24 (0U)          /*!< Bit position for LCD_WF27TO24_WF24. */
#define BM_LCD_WF27TO24_WF24 (0x000000FFU) /*!< Bit mask for LCD_WF27TO24_WF24. */
#define BS_LCD_WF27TO24_WF24 (8U)          /*!< Bit field size in bits for LCD_WF27TO24_WF24. */

/*! @brief Read current value of the LCD_WF27TO24_WF24 field. */
#define BR_LCD_WF27TO24_WF24(x) (BME_UBFX32(HW_LCD_WF27TO24_ADDR(x), BP_LCD_WF27TO24_WF24, BS_LCD_WF27TO24_WF24))

/*! @brief Format value for bitfield LCD_WF27TO24_WF24. */
#define BF_LCD_WF27TO24_WF24(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF27TO24_WF24) & BM_LCD_WF27TO24_WF24)

/*! @brief Set the WF24 field to a new value. */
#define BW_LCD_WF27TO24_WF24(x, v) (BME_BFI32(HW_LCD_WF27TO24_ADDR(x), ((uint32_t)(v) << BP_LCD_WF27TO24_WF24), BP_LCD_WF27TO24_WF24, 8))
/*@}*/

/*!
 * @name Register LCD_WF27TO24, field WF25[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P25 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF27TO24_WF25 (8U)          /*!< Bit position for LCD_WF27TO24_WF25. */
#define BM_LCD_WF27TO24_WF25 (0x0000FF00U) /*!< Bit mask for LCD_WF27TO24_WF25. */
#define BS_LCD_WF27TO24_WF25 (8U)          /*!< Bit field size in bits for LCD_WF27TO24_WF25. */

/*! @brief Read current value of the LCD_WF27TO24_WF25 field. */
#define BR_LCD_WF27TO24_WF25(x) (BME_UBFX32(HW_LCD_WF27TO24_ADDR(x), BP_LCD_WF27TO24_WF25, BS_LCD_WF27TO24_WF25))

/*! @brief Format value for bitfield LCD_WF27TO24_WF25. */
#define BF_LCD_WF27TO24_WF25(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF27TO24_WF25) & BM_LCD_WF27TO24_WF25)

/*! @brief Set the WF25 field to a new value. */
#define BW_LCD_WF27TO24_WF25(x, v) (BME_BFI32(HW_LCD_WF27TO24_ADDR(x), ((uint32_t)(v) << BP_LCD_WF27TO24_WF25), BP_LCD_WF27TO24_WF25, 8))
/*@}*/

/*!
 * @name Register LCD_WF27TO24, field WF26[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P26 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF27TO24_WF26 (16U)         /*!< Bit position for LCD_WF27TO24_WF26. */
#define BM_LCD_WF27TO24_WF26 (0x00FF0000U) /*!< Bit mask for LCD_WF27TO24_WF26. */
#define BS_LCD_WF27TO24_WF26 (8U)          /*!< Bit field size in bits for LCD_WF27TO24_WF26. */

/*! @brief Read current value of the LCD_WF27TO24_WF26 field. */
#define BR_LCD_WF27TO24_WF26(x) (BME_UBFX32(HW_LCD_WF27TO24_ADDR(x), BP_LCD_WF27TO24_WF26, BS_LCD_WF27TO24_WF26))

/*! @brief Format value for bitfield LCD_WF27TO24_WF26. */
#define BF_LCD_WF27TO24_WF26(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF27TO24_WF26) & BM_LCD_WF27TO24_WF26)

/*! @brief Set the WF26 field to a new value. */
#define BW_LCD_WF27TO24_WF26(x, v) (BME_BFI32(HW_LCD_WF27TO24_ADDR(x), ((uint32_t)(v) << BP_LCD_WF27TO24_WF26), BP_LCD_WF27TO24_WF26, 8))
/*@}*/

/*!
 * @name Register LCD_WF27TO24, field WF27[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P27 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF27TO24_WF27 (24U)         /*!< Bit position for LCD_WF27TO24_WF27. */
#define BM_LCD_WF27TO24_WF27 (0xFF000000U) /*!< Bit mask for LCD_WF27TO24_WF27. */
#define BS_LCD_WF27TO24_WF27 (8U)          /*!< Bit field size in bits for LCD_WF27TO24_WF27. */

/*! @brief Read current value of the LCD_WF27TO24_WF27 field. */
#define BR_LCD_WF27TO24_WF27(x) (BME_UBFX32(HW_LCD_WF27TO24_ADDR(x), BP_LCD_WF27TO24_WF27, BS_LCD_WF27TO24_WF27))

/*! @brief Format value for bitfield LCD_WF27TO24_WF27. */
#define BF_LCD_WF27TO24_WF27(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF27TO24_WF27) & BM_LCD_WF27TO24_WF27)

/*! @brief Set the WF27 field to a new value. */
#define BW_LCD_WF27TO24_WF27(x, v) (BME_BFI32(HW_LCD_WF27TO24_ADDR(x), ((uint32_t)(v) << BP_LCD_WF27TO24_WF27), BP_LCD_WF27TO24_WF27, 8))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF31TO28 - LCD Waveform register
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF31TO28 - LCD Waveform register (RW)
 *
 * Reset value: 0x00000000U
 *
 * See the LCD Waveform register (WFC3TO0) for register and field descriptions.
 * The reset value of this register depends on the reset type: POR - 0x0000_0000
 */
typedef union _hw_lcd_wf31to28
{
    uint32_t U;
    struct _hw_lcd_wf31to28_bitfields
    {
        uint32_t WF28 : 8;             /*!< [7:0]  */
        uint32_t WF29 : 8;             /*!< [15:8]  */
        uint32_t WF30 : 8;             /*!< [23:16]  */
        uint32_t WF31 : 8;             /*!< [31:24]  */
    } B;
} hw_lcd_wf31to28_t;

/*!
 * @name Constants and macros for entire LCD_WF31TO28 register
 */
/*@{*/
#define HW_LCD_WF31TO28_ADDR(x)  ((uint32_t)(x) + 0x3CU)

#define HW_LCD_WF31TO28(x)       (*(__IO hw_lcd_wf31to28_t *) HW_LCD_WF31TO28_ADDR(x))
#define HW_LCD_WF31TO28_RD(x)    (HW_LCD_WF31TO28(x).U)
#define HW_LCD_WF31TO28_WR(x, v) (HW_LCD_WF31TO28(x).U = (v))
#define HW_LCD_WF31TO28_SET(x, v) (BME_OR32(HW_LCD_WF31TO28_ADDR(x), (uint32_t)(v)))
#define HW_LCD_WF31TO28_CLR(x, v) (BME_AND32(HW_LCD_WF31TO28_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_WF31TO28_TOG(x, v) (BME_XOR32(HW_LCD_WF31TO28_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF31TO28 bitfields
 */

/*!
 * @name Register LCD_WF31TO28, field WF28[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P28 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF31TO28_WF28 (0U)          /*!< Bit position for LCD_WF31TO28_WF28. */
#define BM_LCD_WF31TO28_WF28 (0x000000FFU) /*!< Bit mask for LCD_WF31TO28_WF28. */
#define BS_LCD_WF31TO28_WF28 (8U)          /*!< Bit field size in bits for LCD_WF31TO28_WF28. */

/*! @brief Read current value of the LCD_WF31TO28_WF28 field. */
#define BR_LCD_WF31TO28_WF28(x) (BME_UBFX32(HW_LCD_WF31TO28_ADDR(x), BP_LCD_WF31TO28_WF28, BS_LCD_WF31TO28_WF28))

/*! @brief Format value for bitfield LCD_WF31TO28_WF28. */
#define BF_LCD_WF31TO28_WF28(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF31TO28_WF28) & BM_LCD_WF31TO28_WF28)

/*! @brief Set the WF28 field to a new value. */
#define BW_LCD_WF31TO28_WF28(x, v) (BME_BFI32(HW_LCD_WF31TO28_ADDR(x), ((uint32_t)(v) << BP_LCD_WF31TO28_WF28), BP_LCD_WF31TO28_WF28, 8))
/*@}*/

/*!
 * @name Register LCD_WF31TO28, field WF29[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P29 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF31TO28_WF29 (8U)          /*!< Bit position for LCD_WF31TO28_WF29. */
#define BM_LCD_WF31TO28_WF29 (0x0000FF00U) /*!< Bit mask for LCD_WF31TO28_WF29. */
#define BS_LCD_WF31TO28_WF29 (8U)          /*!< Bit field size in bits for LCD_WF31TO28_WF29. */

/*! @brief Read current value of the LCD_WF31TO28_WF29 field. */
#define BR_LCD_WF31TO28_WF29(x) (BME_UBFX32(HW_LCD_WF31TO28_ADDR(x), BP_LCD_WF31TO28_WF29, BS_LCD_WF31TO28_WF29))

/*! @brief Format value for bitfield LCD_WF31TO28_WF29. */
#define BF_LCD_WF31TO28_WF29(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF31TO28_WF29) & BM_LCD_WF31TO28_WF29)

/*! @brief Set the WF29 field to a new value. */
#define BW_LCD_WF31TO28_WF29(x, v) (BME_BFI32(HW_LCD_WF31TO28_ADDR(x), ((uint32_t)(v) << BP_LCD_WF31TO28_WF29), BP_LCD_WF31TO28_WF29, 8))
/*@}*/

/*!
 * @name Register LCD_WF31TO28, field WF30[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P30 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF31TO28_WF30 (16U)         /*!< Bit position for LCD_WF31TO28_WF30. */
#define BM_LCD_WF31TO28_WF30 (0x00FF0000U) /*!< Bit mask for LCD_WF31TO28_WF30. */
#define BS_LCD_WF31TO28_WF30 (8U)          /*!< Bit field size in bits for LCD_WF31TO28_WF30. */

/*! @brief Read current value of the LCD_WF31TO28_WF30 field. */
#define BR_LCD_WF31TO28_WF30(x) (BME_UBFX32(HW_LCD_WF31TO28_ADDR(x), BP_LCD_WF31TO28_WF30, BS_LCD_WF31TO28_WF30))

/*! @brief Format value for bitfield LCD_WF31TO28_WF30. */
#define BF_LCD_WF31TO28_WF30(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF31TO28_WF30) & BM_LCD_WF31TO28_WF30)

/*! @brief Set the WF30 field to a new value. */
#define BW_LCD_WF31TO28_WF30(x, v) (BME_BFI32(HW_LCD_WF31TO28_ADDR(x), ((uint32_t)(v) << BP_LCD_WF31TO28_WF30), BP_LCD_WF31TO28_WF30, 8))
/*@}*/

/*!
 * @name Register LCD_WF31TO28, field WF31[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P31 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF31TO28_WF31 (24U)         /*!< Bit position for LCD_WF31TO28_WF31. */
#define BM_LCD_WF31TO28_WF31 (0xFF000000U) /*!< Bit mask for LCD_WF31TO28_WF31. */
#define BS_LCD_WF31TO28_WF31 (8U)          /*!< Bit field size in bits for LCD_WF31TO28_WF31. */

/*! @brief Read current value of the LCD_WF31TO28_WF31 field. */
#define BR_LCD_WF31TO28_WF31(x) (BME_UBFX32(HW_LCD_WF31TO28_ADDR(x), BP_LCD_WF31TO28_WF31, BS_LCD_WF31TO28_WF31))

/*! @brief Format value for bitfield LCD_WF31TO28_WF31. */
#define BF_LCD_WF31TO28_WF31(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF31TO28_WF31) & BM_LCD_WF31TO28_WF31)

/*! @brief Set the WF31 field to a new value. */
#define BW_LCD_WF31TO28_WF31(x, v) (BME_BFI32(HW_LCD_WF31TO28_ADDR(x), ((uint32_t)(v) << BP_LCD_WF31TO28_WF31), BP_LCD_WF31TO28_WF31, 8))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF35TO32 - LCD Waveform register
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF35TO32 - LCD Waveform register (RW)
 *
 * Reset value: 0x00000000U
 *
 * See the LCD Waveform register (WFC3TO0) for register and field descriptions.
 * The reset value of this register depends on the reset type: POR - 0x0000_0000
 */
typedef union _hw_lcd_wf35to32
{
    uint32_t U;
    struct _hw_lcd_wf35to32_bitfields
    {
        uint32_t WF32 : 8;             /*!< [7:0]  */
        uint32_t WF33 : 8;             /*!< [15:8]  */
        uint32_t WF34 : 8;             /*!< [23:16]  */
        uint32_t WF35 : 8;             /*!< [31:24]  */
    } B;
} hw_lcd_wf35to32_t;

/*!
 * @name Constants and macros for entire LCD_WF35TO32 register
 */
/*@{*/
#define HW_LCD_WF35TO32_ADDR(x)  ((uint32_t)(x) + 0x40U)

#define HW_LCD_WF35TO32(x)       (*(__IO hw_lcd_wf35to32_t *) HW_LCD_WF35TO32_ADDR(x))
#define HW_LCD_WF35TO32_RD(x)    (HW_LCD_WF35TO32(x).U)
#define HW_LCD_WF35TO32_WR(x, v) (HW_LCD_WF35TO32(x).U = (v))
#define HW_LCD_WF35TO32_SET(x, v) (BME_OR32(HW_LCD_WF35TO32_ADDR(x), (uint32_t)(v)))
#define HW_LCD_WF35TO32_CLR(x, v) (BME_AND32(HW_LCD_WF35TO32_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_WF35TO32_TOG(x, v) (BME_XOR32(HW_LCD_WF35TO32_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF35TO32 bitfields
 */

/*!
 * @name Register LCD_WF35TO32, field WF32[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P32 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF35TO32_WF32 (0U)          /*!< Bit position for LCD_WF35TO32_WF32. */
#define BM_LCD_WF35TO32_WF32 (0x000000FFU) /*!< Bit mask for LCD_WF35TO32_WF32. */
#define BS_LCD_WF35TO32_WF32 (8U)          /*!< Bit field size in bits for LCD_WF35TO32_WF32. */

/*! @brief Read current value of the LCD_WF35TO32_WF32 field. */
#define BR_LCD_WF35TO32_WF32(x) (BME_UBFX32(HW_LCD_WF35TO32_ADDR(x), BP_LCD_WF35TO32_WF32, BS_LCD_WF35TO32_WF32))

/*! @brief Format value for bitfield LCD_WF35TO32_WF32. */
#define BF_LCD_WF35TO32_WF32(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF35TO32_WF32) & BM_LCD_WF35TO32_WF32)

/*! @brief Set the WF32 field to a new value. */
#define BW_LCD_WF35TO32_WF32(x, v) (BME_BFI32(HW_LCD_WF35TO32_ADDR(x), ((uint32_t)(v) << BP_LCD_WF35TO32_WF32), BP_LCD_WF35TO32_WF32, 8))
/*@}*/

/*!
 * @name Register LCD_WF35TO32, field WF33[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P33 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF35TO32_WF33 (8U)          /*!< Bit position for LCD_WF35TO32_WF33. */
#define BM_LCD_WF35TO32_WF33 (0x0000FF00U) /*!< Bit mask for LCD_WF35TO32_WF33. */
#define BS_LCD_WF35TO32_WF33 (8U)          /*!< Bit field size in bits for LCD_WF35TO32_WF33. */

/*! @brief Read current value of the LCD_WF35TO32_WF33 field. */
#define BR_LCD_WF35TO32_WF33(x) (BME_UBFX32(HW_LCD_WF35TO32_ADDR(x), BP_LCD_WF35TO32_WF33, BS_LCD_WF35TO32_WF33))

/*! @brief Format value for bitfield LCD_WF35TO32_WF33. */
#define BF_LCD_WF35TO32_WF33(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF35TO32_WF33) & BM_LCD_WF35TO32_WF33)

/*! @brief Set the WF33 field to a new value. */
#define BW_LCD_WF35TO32_WF33(x, v) (BME_BFI32(HW_LCD_WF35TO32_ADDR(x), ((uint32_t)(v) << BP_LCD_WF35TO32_WF33), BP_LCD_WF35TO32_WF33, 8))
/*@}*/

/*!
 * @name Register LCD_WF35TO32, field WF34[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P34 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF35TO32_WF34 (16U)         /*!< Bit position for LCD_WF35TO32_WF34. */
#define BM_LCD_WF35TO32_WF34 (0x00FF0000U) /*!< Bit mask for LCD_WF35TO32_WF34. */
#define BS_LCD_WF35TO32_WF34 (8U)          /*!< Bit field size in bits for LCD_WF35TO32_WF34. */

/*! @brief Read current value of the LCD_WF35TO32_WF34 field. */
#define BR_LCD_WF35TO32_WF34(x) (BME_UBFX32(HW_LCD_WF35TO32_ADDR(x), BP_LCD_WF35TO32_WF34, BS_LCD_WF35TO32_WF34))

/*! @brief Format value for bitfield LCD_WF35TO32_WF34. */
#define BF_LCD_WF35TO32_WF34(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF35TO32_WF34) & BM_LCD_WF35TO32_WF34)

/*! @brief Set the WF34 field to a new value. */
#define BW_LCD_WF35TO32_WF34(x, v) (BME_BFI32(HW_LCD_WF35TO32_ADDR(x), ((uint32_t)(v) << BP_LCD_WF35TO32_WF34), BP_LCD_WF35TO32_WF34, 8))
/*@}*/

/*!
 * @name Register LCD_WF35TO32, field WF35[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P35 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF35TO32_WF35 (24U)         /*!< Bit position for LCD_WF35TO32_WF35. */
#define BM_LCD_WF35TO32_WF35 (0xFF000000U) /*!< Bit mask for LCD_WF35TO32_WF35. */
#define BS_LCD_WF35TO32_WF35 (8U)          /*!< Bit field size in bits for LCD_WF35TO32_WF35. */

/*! @brief Read current value of the LCD_WF35TO32_WF35 field. */
#define BR_LCD_WF35TO32_WF35(x) (BME_UBFX32(HW_LCD_WF35TO32_ADDR(x), BP_LCD_WF35TO32_WF35, BS_LCD_WF35TO32_WF35))

/*! @brief Format value for bitfield LCD_WF35TO32_WF35. */
#define BF_LCD_WF35TO32_WF35(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF35TO32_WF35) & BM_LCD_WF35TO32_WF35)

/*! @brief Set the WF35 field to a new value. */
#define BW_LCD_WF35TO32_WF35(x, v) (BME_BFI32(HW_LCD_WF35TO32_ADDR(x), ((uint32_t)(v) << BP_LCD_WF35TO32_WF35), BP_LCD_WF35TO32_WF35, 8))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF39TO36 - LCD Waveform register
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF39TO36 - LCD Waveform register (RW)
 *
 * Reset value: 0x00000000U
 *
 * See the LCD Waveform register (WFC3TO0) for register and field descriptions.
 * The reset value of this register depends on the reset type: POR - 0x0000_0000
 */
typedef union _hw_lcd_wf39to36
{
    uint32_t U;
    struct _hw_lcd_wf39to36_bitfields
    {
        uint32_t WF36 : 8;             /*!< [7:0]  */
        uint32_t WF37 : 8;             /*!< [15:8]  */
        uint32_t WF38 : 8;             /*!< [23:16]  */
        uint32_t WF39 : 8;             /*!< [31:24]  */
    } B;
} hw_lcd_wf39to36_t;

/*!
 * @name Constants and macros for entire LCD_WF39TO36 register
 */
/*@{*/
#define HW_LCD_WF39TO36_ADDR(x)  ((uint32_t)(x) + 0x44U)

#define HW_LCD_WF39TO36(x)       (*(__IO hw_lcd_wf39to36_t *) HW_LCD_WF39TO36_ADDR(x))
#define HW_LCD_WF39TO36_RD(x)    (HW_LCD_WF39TO36(x).U)
#define HW_LCD_WF39TO36_WR(x, v) (HW_LCD_WF39TO36(x).U = (v))
#define HW_LCD_WF39TO36_SET(x, v) (BME_OR32(HW_LCD_WF39TO36_ADDR(x), (uint32_t)(v)))
#define HW_LCD_WF39TO36_CLR(x, v) (BME_AND32(HW_LCD_WF39TO36_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_WF39TO36_TOG(x, v) (BME_XOR32(HW_LCD_WF39TO36_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF39TO36 bitfields
 */

/*!
 * @name Register LCD_WF39TO36, field WF36[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P36 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF39TO36_WF36 (0U)          /*!< Bit position for LCD_WF39TO36_WF36. */
#define BM_LCD_WF39TO36_WF36 (0x000000FFU) /*!< Bit mask for LCD_WF39TO36_WF36. */
#define BS_LCD_WF39TO36_WF36 (8U)          /*!< Bit field size in bits for LCD_WF39TO36_WF36. */

/*! @brief Read current value of the LCD_WF39TO36_WF36 field. */
#define BR_LCD_WF39TO36_WF36(x) (BME_UBFX32(HW_LCD_WF39TO36_ADDR(x), BP_LCD_WF39TO36_WF36, BS_LCD_WF39TO36_WF36))

/*! @brief Format value for bitfield LCD_WF39TO36_WF36. */
#define BF_LCD_WF39TO36_WF36(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF39TO36_WF36) & BM_LCD_WF39TO36_WF36)

/*! @brief Set the WF36 field to a new value. */
#define BW_LCD_WF39TO36_WF36(x, v) (BME_BFI32(HW_LCD_WF39TO36_ADDR(x), ((uint32_t)(v) << BP_LCD_WF39TO36_WF36), BP_LCD_WF39TO36_WF36, 8))
/*@}*/

/*!
 * @name Register LCD_WF39TO36, field WF37[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P37 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF39TO36_WF37 (8U)          /*!< Bit position for LCD_WF39TO36_WF37. */
#define BM_LCD_WF39TO36_WF37 (0x0000FF00U) /*!< Bit mask for LCD_WF39TO36_WF37. */
#define BS_LCD_WF39TO36_WF37 (8U)          /*!< Bit field size in bits for LCD_WF39TO36_WF37. */

/*! @brief Read current value of the LCD_WF39TO36_WF37 field. */
#define BR_LCD_WF39TO36_WF37(x) (BME_UBFX32(HW_LCD_WF39TO36_ADDR(x), BP_LCD_WF39TO36_WF37, BS_LCD_WF39TO36_WF37))

/*! @brief Format value for bitfield LCD_WF39TO36_WF37. */
#define BF_LCD_WF39TO36_WF37(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF39TO36_WF37) & BM_LCD_WF39TO36_WF37)

/*! @brief Set the WF37 field to a new value. */
#define BW_LCD_WF39TO36_WF37(x, v) (BME_BFI32(HW_LCD_WF39TO36_ADDR(x), ((uint32_t)(v) << BP_LCD_WF39TO36_WF37), BP_LCD_WF39TO36_WF37, 8))
/*@}*/

/*!
 * @name Register LCD_WF39TO36, field WF38[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P38 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF39TO36_WF38 (16U)         /*!< Bit position for LCD_WF39TO36_WF38. */
#define BM_LCD_WF39TO36_WF38 (0x00FF0000U) /*!< Bit mask for LCD_WF39TO36_WF38. */
#define BS_LCD_WF39TO36_WF38 (8U)          /*!< Bit field size in bits for LCD_WF39TO36_WF38. */

/*! @brief Read current value of the LCD_WF39TO36_WF38 field. */
#define BR_LCD_WF39TO36_WF38(x) (BME_UBFX32(HW_LCD_WF39TO36_ADDR(x), BP_LCD_WF39TO36_WF38, BS_LCD_WF39TO36_WF38))

/*! @brief Format value for bitfield LCD_WF39TO36_WF38. */
#define BF_LCD_WF39TO36_WF38(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF39TO36_WF38) & BM_LCD_WF39TO36_WF38)

/*! @brief Set the WF38 field to a new value. */
#define BW_LCD_WF39TO36_WF38(x, v) (BME_BFI32(HW_LCD_WF39TO36_ADDR(x), ((uint32_t)(v) << BP_LCD_WF39TO36_WF38), BP_LCD_WF39TO36_WF38, 8))
/*@}*/

/*!
 * @name Register LCD_WF39TO36, field WF39[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P39 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF39TO36_WF39 (24U)         /*!< Bit position for LCD_WF39TO36_WF39. */
#define BM_LCD_WF39TO36_WF39 (0xFF000000U) /*!< Bit mask for LCD_WF39TO36_WF39. */
#define BS_LCD_WF39TO36_WF39 (8U)          /*!< Bit field size in bits for LCD_WF39TO36_WF39. */

/*! @brief Read current value of the LCD_WF39TO36_WF39 field. */
#define BR_LCD_WF39TO36_WF39(x) (BME_UBFX32(HW_LCD_WF39TO36_ADDR(x), BP_LCD_WF39TO36_WF39, BS_LCD_WF39TO36_WF39))

/*! @brief Format value for bitfield LCD_WF39TO36_WF39. */
#define BF_LCD_WF39TO36_WF39(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF39TO36_WF39) & BM_LCD_WF39TO36_WF39)

/*! @brief Set the WF39 field to a new value. */
#define BW_LCD_WF39TO36_WF39(x, v) (BME_BFI32(HW_LCD_WF39TO36_ADDR(x), ((uint32_t)(v) << BP_LCD_WF39TO36_WF39), BP_LCD_WF39TO36_WF39, 8))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF43TO40 - LCD Waveform register
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF43TO40 - LCD Waveform register (RW)
 *
 * Reset value: 0x00000000U
 *
 * See the LCD Waveform register (WFC3TO0) for register and field descriptions.
 * The reset value of this register depends on the reset type: POR - 0x0000_0000
 */
typedef union _hw_lcd_wf43to40
{
    uint32_t U;
    struct _hw_lcd_wf43to40_bitfields
    {
        uint32_t WF40 : 8;             /*!< [7:0]  */
        uint32_t WF41 : 8;             /*!< [15:8]  */
        uint32_t WF42 : 8;             /*!< [23:16]  */
        uint32_t WF43 : 8;             /*!< [31:24]  */
    } B;
} hw_lcd_wf43to40_t;

/*!
 * @name Constants and macros for entire LCD_WF43TO40 register
 */
/*@{*/
#define HW_LCD_WF43TO40_ADDR(x)  ((uint32_t)(x) + 0x48U)

#define HW_LCD_WF43TO40(x)       (*(__IO hw_lcd_wf43to40_t *) HW_LCD_WF43TO40_ADDR(x))
#define HW_LCD_WF43TO40_RD(x)    (HW_LCD_WF43TO40(x).U)
#define HW_LCD_WF43TO40_WR(x, v) (HW_LCD_WF43TO40(x).U = (v))
#define HW_LCD_WF43TO40_SET(x, v) (BME_OR32(HW_LCD_WF43TO40_ADDR(x), (uint32_t)(v)))
#define HW_LCD_WF43TO40_CLR(x, v) (BME_AND32(HW_LCD_WF43TO40_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_WF43TO40_TOG(x, v) (BME_XOR32(HW_LCD_WF43TO40_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF43TO40 bitfields
 */

/*!
 * @name Register LCD_WF43TO40, field WF40[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P40 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF43TO40_WF40 (0U)          /*!< Bit position for LCD_WF43TO40_WF40. */
#define BM_LCD_WF43TO40_WF40 (0x000000FFU) /*!< Bit mask for LCD_WF43TO40_WF40. */
#define BS_LCD_WF43TO40_WF40 (8U)          /*!< Bit field size in bits for LCD_WF43TO40_WF40. */

/*! @brief Read current value of the LCD_WF43TO40_WF40 field. */
#define BR_LCD_WF43TO40_WF40(x) (BME_UBFX32(HW_LCD_WF43TO40_ADDR(x), BP_LCD_WF43TO40_WF40, BS_LCD_WF43TO40_WF40))

/*! @brief Format value for bitfield LCD_WF43TO40_WF40. */
#define BF_LCD_WF43TO40_WF40(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF43TO40_WF40) & BM_LCD_WF43TO40_WF40)

/*! @brief Set the WF40 field to a new value. */
#define BW_LCD_WF43TO40_WF40(x, v) (BME_BFI32(HW_LCD_WF43TO40_ADDR(x), ((uint32_t)(v) << BP_LCD_WF43TO40_WF40), BP_LCD_WF43TO40_WF40, 8))
/*@}*/

/*!
 * @name Register LCD_WF43TO40, field WF41[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P41 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF43TO40_WF41 (8U)          /*!< Bit position for LCD_WF43TO40_WF41. */
#define BM_LCD_WF43TO40_WF41 (0x0000FF00U) /*!< Bit mask for LCD_WF43TO40_WF41. */
#define BS_LCD_WF43TO40_WF41 (8U)          /*!< Bit field size in bits for LCD_WF43TO40_WF41. */

/*! @brief Read current value of the LCD_WF43TO40_WF41 field. */
#define BR_LCD_WF43TO40_WF41(x) (BME_UBFX32(HW_LCD_WF43TO40_ADDR(x), BP_LCD_WF43TO40_WF41, BS_LCD_WF43TO40_WF41))

/*! @brief Format value for bitfield LCD_WF43TO40_WF41. */
#define BF_LCD_WF43TO40_WF41(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF43TO40_WF41) & BM_LCD_WF43TO40_WF41)

/*! @brief Set the WF41 field to a new value. */
#define BW_LCD_WF43TO40_WF41(x, v) (BME_BFI32(HW_LCD_WF43TO40_ADDR(x), ((uint32_t)(v) << BP_LCD_WF43TO40_WF41), BP_LCD_WF43TO40_WF41, 8))
/*@}*/

/*!
 * @name Register LCD_WF43TO40, field WF42[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P42 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF43TO40_WF42 (16U)         /*!< Bit position for LCD_WF43TO40_WF42. */
#define BM_LCD_WF43TO40_WF42 (0x00FF0000U) /*!< Bit mask for LCD_WF43TO40_WF42. */
#define BS_LCD_WF43TO40_WF42 (8U)          /*!< Bit field size in bits for LCD_WF43TO40_WF42. */

/*! @brief Read current value of the LCD_WF43TO40_WF42 field. */
#define BR_LCD_WF43TO40_WF42(x) (BME_UBFX32(HW_LCD_WF43TO40_ADDR(x), BP_LCD_WF43TO40_WF42, BS_LCD_WF43TO40_WF42))

/*! @brief Format value for bitfield LCD_WF43TO40_WF42. */
#define BF_LCD_WF43TO40_WF42(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF43TO40_WF42) & BM_LCD_WF43TO40_WF42)

/*! @brief Set the WF42 field to a new value. */
#define BW_LCD_WF43TO40_WF42(x, v) (BME_BFI32(HW_LCD_WF43TO40_ADDR(x), ((uint32_t)(v) << BP_LCD_WF43TO40_WF42), BP_LCD_WF43TO40_WF42, 8))
/*@}*/

/*!
 * @name Register LCD_WF43TO40, field WF43[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P43 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF43TO40_WF43 (24U)         /*!< Bit position for LCD_WF43TO40_WF43. */
#define BM_LCD_WF43TO40_WF43 (0xFF000000U) /*!< Bit mask for LCD_WF43TO40_WF43. */
#define BS_LCD_WF43TO40_WF43 (8U)          /*!< Bit field size in bits for LCD_WF43TO40_WF43. */

/*! @brief Read current value of the LCD_WF43TO40_WF43 field. */
#define BR_LCD_WF43TO40_WF43(x) (BME_UBFX32(HW_LCD_WF43TO40_ADDR(x), BP_LCD_WF43TO40_WF43, BS_LCD_WF43TO40_WF43))

/*! @brief Format value for bitfield LCD_WF43TO40_WF43. */
#define BF_LCD_WF43TO40_WF43(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF43TO40_WF43) & BM_LCD_WF43TO40_WF43)

/*! @brief Set the WF43 field to a new value. */
#define BW_LCD_WF43TO40_WF43(x, v) (BME_BFI32(HW_LCD_WF43TO40_ADDR(x), ((uint32_t)(v) << BP_LCD_WF43TO40_WF43), BP_LCD_WF43TO40_WF43, 8))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF47TO44 - LCD Waveform register
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF47TO44 - LCD Waveform register (RW)
 *
 * Reset value: 0x00000000U
 *
 * See the LCD Waveform register (WFC3TO0) for register and field descriptions.
 * The reset value of this register depends on the reset type: POR - 0x0000_0000
 */
typedef union _hw_lcd_wf47to44
{
    uint32_t U;
    struct _hw_lcd_wf47to44_bitfields
    {
        uint32_t WF44 : 8;             /*!< [7:0]  */
        uint32_t WF45 : 8;             /*!< [15:8]  */
        uint32_t WF46 : 8;             /*!< [23:16]  */
        uint32_t WF47 : 8;             /*!< [31:24]  */
    } B;
} hw_lcd_wf47to44_t;

/*!
 * @name Constants and macros for entire LCD_WF47TO44 register
 */
/*@{*/
#define HW_LCD_WF47TO44_ADDR(x)  ((uint32_t)(x) + 0x4CU)

#define HW_LCD_WF47TO44(x)       (*(__IO hw_lcd_wf47to44_t *) HW_LCD_WF47TO44_ADDR(x))
#define HW_LCD_WF47TO44_RD(x)    (HW_LCD_WF47TO44(x).U)
#define HW_LCD_WF47TO44_WR(x, v) (HW_LCD_WF47TO44(x).U = (v))
#define HW_LCD_WF47TO44_SET(x, v) (BME_OR32(HW_LCD_WF47TO44_ADDR(x), (uint32_t)(v)))
#define HW_LCD_WF47TO44_CLR(x, v) (BME_AND32(HW_LCD_WF47TO44_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_WF47TO44_TOG(x, v) (BME_XOR32(HW_LCD_WF47TO44_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF47TO44 bitfields
 */

/*!
 * @name Register LCD_WF47TO44, field WF44[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P44 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF47TO44_WF44 (0U)          /*!< Bit position for LCD_WF47TO44_WF44. */
#define BM_LCD_WF47TO44_WF44 (0x000000FFU) /*!< Bit mask for LCD_WF47TO44_WF44. */
#define BS_LCD_WF47TO44_WF44 (8U)          /*!< Bit field size in bits for LCD_WF47TO44_WF44. */

/*! @brief Read current value of the LCD_WF47TO44_WF44 field. */
#define BR_LCD_WF47TO44_WF44(x) (BME_UBFX32(HW_LCD_WF47TO44_ADDR(x), BP_LCD_WF47TO44_WF44, BS_LCD_WF47TO44_WF44))

/*! @brief Format value for bitfield LCD_WF47TO44_WF44. */
#define BF_LCD_WF47TO44_WF44(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF47TO44_WF44) & BM_LCD_WF47TO44_WF44)

/*! @brief Set the WF44 field to a new value. */
#define BW_LCD_WF47TO44_WF44(x, v) (BME_BFI32(HW_LCD_WF47TO44_ADDR(x), ((uint32_t)(v) << BP_LCD_WF47TO44_WF44), BP_LCD_WF47TO44_WF44, 8))
/*@}*/

/*!
 * @name Register LCD_WF47TO44, field WF45[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P45 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF47TO44_WF45 (8U)          /*!< Bit position for LCD_WF47TO44_WF45. */
#define BM_LCD_WF47TO44_WF45 (0x0000FF00U) /*!< Bit mask for LCD_WF47TO44_WF45. */
#define BS_LCD_WF47TO44_WF45 (8U)          /*!< Bit field size in bits for LCD_WF47TO44_WF45. */

/*! @brief Read current value of the LCD_WF47TO44_WF45 field. */
#define BR_LCD_WF47TO44_WF45(x) (BME_UBFX32(HW_LCD_WF47TO44_ADDR(x), BP_LCD_WF47TO44_WF45, BS_LCD_WF47TO44_WF45))

/*! @brief Format value for bitfield LCD_WF47TO44_WF45. */
#define BF_LCD_WF47TO44_WF45(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF47TO44_WF45) & BM_LCD_WF47TO44_WF45)

/*! @brief Set the WF45 field to a new value. */
#define BW_LCD_WF47TO44_WF45(x, v) (BME_BFI32(HW_LCD_WF47TO44_ADDR(x), ((uint32_t)(v) << BP_LCD_WF47TO44_WF45), BP_LCD_WF47TO44_WF45, 8))
/*@}*/

/*!
 * @name Register LCD_WF47TO44, field WF46[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P46 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF47TO44_WF46 (16U)         /*!< Bit position for LCD_WF47TO44_WF46. */
#define BM_LCD_WF47TO44_WF46 (0x00FF0000U) /*!< Bit mask for LCD_WF47TO44_WF46. */
#define BS_LCD_WF47TO44_WF46 (8U)          /*!< Bit field size in bits for LCD_WF47TO44_WF46. */

/*! @brief Read current value of the LCD_WF47TO44_WF46 field. */
#define BR_LCD_WF47TO44_WF46(x) (BME_UBFX32(HW_LCD_WF47TO44_ADDR(x), BP_LCD_WF47TO44_WF46, BS_LCD_WF47TO44_WF46))

/*! @brief Format value for bitfield LCD_WF47TO44_WF46. */
#define BF_LCD_WF47TO44_WF46(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF47TO44_WF46) & BM_LCD_WF47TO44_WF46)

/*! @brief Set the WF46 field to a new value. */
#define BW_LCD_WF47TO44_WF46(x, v) (BME_BFI32(HW_LCD_WF47TO44_ADDR(x), ((uint32_t)(v) << BP_LCD_WF47TO44_WF46), BP_LCD_WF47TO44_WF46, 8))
/*@}*/

/*!
 * @name Register LCD_WF47TO44, field WF47[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P47 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF47TO44_WF47 (24U)         /*!< Bit position for LCD_WF47TO44_WF47. */
#define BM_LCD_WF47TO44_WF47 (0xFF000000U) /*!< Bit mask for LCD_WF47TO44_WF47. */
#define BS_LCD_WF47TO44_WF47 (8U)          /*!< Bit field size in bits for LCD_WF47TO44_WF47. */

/*! @brief Read current value of the LCD_WF47TO44_WF47 field. */
#define BR_LCD_WF47TO44_WF47(x) (BME_UBFX32(HW_LCD_WF47TO44_ADDR(x), BP_LCD_WF47TO44_WF47, BS_LCD_WF47TO44_WF47))

/*! @brief Format value for bitfield LCD_WF47TO44_WF47. */
#define BF_LCD_WF47TO44_WF47(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF47TO44_WF47) & BM_LCD_WF47TO44_WF47)

/*! @brief Set the WF47 field to a new value. */
#define BW_LCD_WF47TO44_WF47(x, v) (BME_BFI32(HW_LCD_WF47TO44_ADDR(x), ((uint32_t)(v) << BP_LCD_WF47TO44_WF47), BP_LCD_WF47TO44_WF47, 8))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF51TO48 - LCD Waveform register
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF51TO48 - LCD Waveform register (RW)
 *
 * Reset value: 0x00000000U
 *
 * See the LCD Waveform register (WFC3TO0) for register and field descriptions.
 * The reset value of this register depends on the reset type: POR - 0x0000_0000
 */
typedef union _hw_lcd_wf51to48
{
    uint32_t U;
    struct _hw_lcd_wf51to48_bitfields
    {
        uint32_t WF48 : 8;             /*!< [7:0]  */
        uint32_t WF49 : 8;             /*!< [15:8]  */
        uint32_t WF50 : 8;             /*!< [23:16]  */
        uint32_t WF51 : 8;             /*!< [31:24]  */
    } B;
} hw_lcd_wf51to48_t;

/*!
 * @name Constants and macros for entire LCD_WF51TO48 register
 */
/*@{*/
#define HW_LCD_WF51TO48_ADDR(x)  ((uint32_t)(x) + 0x50U)

#define HW_LCD_WF51TO48(x)       (*(__IO hw_lcd_wf51to48_t *) HW_LCD_WF51TO48_ADDR(x))
#define HW_LCD_WF51TO48_RD(x)    (HW_LCD_WF51TO48(x).U)
#define HW_LCD_WF51TO48_WR(x, v) (HW_LCD_WF51TO48(x).U = (v))
#define HW_LCD_WF51TO48_SET(x, v) (BME_OR32(HW_LCD_WF51TO48_ADDR(x), (uint32_t)(v)))
#define HW_LCD_WF51TO48_CLR(x, v) (BME_AND32(HW_LCD_WF51TO48_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_WF51TO48_TOG(x, v) (BME_XOR32(HW_LCD_WF51TO48_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF51TO48 bitfields
 */

/*!
 * @name Register LCD_WF51TO48, field WF48[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P48 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF51TO48_WF48 (0U)          /*!< Bit position for LCD_WF51TO48_WF48. */
#define BM_LCD_WF51TO48_WF48 (0x000000FFU) /*!< Bit mask for LCD_WF51TO48_WF48. */
#define BS_LCD_WF51TO48_WF48 (8U)          /*!< Bit field size in bits for LCD_WF51TO48_WF48. */

/*! @brief Read current value of the LCD_WF51TO48_WF48 field. */
#define BR_LCD_WF51TO48_WF48(x) (BME_UBFX32(HW_LCD_WF51TO48_ADDR(x), BP_LCD_WF51TO48_WF48, BS_LCD_WF51TO48_WF48))

/*! @brief Format value for bitfield LCD_WF51TO48_WF48. */
#define BF_LCD_WF51TO48_WF48(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF51TO48_WF48) & BM_LCD_WF51TO48_WF48)

/*! @brief Set the WF48 field to a new value. */
#define BW_LCD_WF51TO48_WF48(x, v) (BME_BFI32(HW_LCD_WF51TO48_ADDR(x), ((uint32_t)(v) << BP_LCD_WF51TO48_WF48), BP_LCD_WF51TO48_WF48, 8))
/*@}*/

/*!
 * @name Register LCD_WF51TO48, field WF49[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P49 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF51TO48_WF49 (8U)          /*!< Bit position for LCD_WF51TO48_WF49. */
#define BM_LCD_WF51TO48_WF49 (0x0000FF00U) /*!< Bit mask for LCD_WF51TO48_WF49. */
#define BS_LCD_WF51TO48_WF49 (8U)          /*!< Bit field size in bits for LCD_WF51TO48_WF49. */

/*! @brief Read current value of the LCD_WF51TO48_WF49 field. */
#define BR_LCD_WF51TO48_WF49(x) (BME_UBFX32(HW_LCD_WF51TO48_ADDR(x), BP_LCD_WF51TO48_WF49, BS_LCD_WF51TO48_WF49))

/*! @brief Format value for bitfield LCD_WF51TO48_WF49. */
#define BF_LCD_WF51TO48_WF49(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF51TO48_WF49) & BM_LCD_WF51TO48_WF49)

/*! @brief Set the WF49 field to a new value. */
#define BW_LCD_WF51TO48_WF49(x, v) (BME_BFI32(HW_LCD_WF51TO48_ADDR(x), ((uint32_t)(v) << BP_LCD_WF51TO48_WF49), BP_LCD_WF51TO48_WF49, 8))
/*@}*/

/*!
 * @name Register LCD_WF51TO48, field WF50[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P50 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF51TO48_WF50 (16U)         /*!< Bit position for LCD_WF51TO48_WF50. */
#define BM_LCD_WF51TO48_WF50 (0x00FF0000U) /*!< Bit mask for LCD_WF51TO48_WF50. */
#define BS_LCD_WF51TO48_WF50 (8U)          /*!< Bit field size in bits for LCD_WF51TO48_WF50. */

/*! @brief Read current value of the LCD_WF51TO48_WF50 field. */
#define BR_LCD_WF51TO48_WF50(x) (BME_UBFX32(HW_LCD_WF51TO48_ADDR(x), BP_LCD_WF51TO48_WF50, BS_LCD_WF51TO48_WF50))

/*! @brief Format value for bitfield LCD_WF51TO48_WF50. */
#define BF_LCD_WF51TO48_WF50(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF51TO48_WF50) & BM_LCD_WF51TO48_WF50)

/*! @brief Set the WF50 field to a new value. */
#define BW_LCD_WF51TO48_WF50(x, v) (BME_BFI32(HW_LCD_WF51TO48_ADDR(x), ((uint32_t)(v) << BP_LCD_WF51TO48_WF50), BP_LCD_WF51TO48_WF50, 8))
/*@}*/

/*!
 * @name Register LCD_WF51TO48, field WF51[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P51 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF51TO48_WF51 (24U)         /*!< Bit position for LCD_WF51TO48_WF51. */
#define BM_LCD_WF51TO48_WF51 (0xFF000000U) /*!< Bit mask for LCD_WF51TO48_WF51. */
#define BS_LCD_WF51TO48_WF51 (8U)          /*!< Bit field size in bits for LCD_WF51TO48_WF51. */

/*! @brief Read current value of the LCD_WF51TO48_WF51 field. */
#define BR_LCD_WF51TO48_WF51(x) (BME_UBFX32(HW_LCD_WF51TO48_ADDR(x), BP_LCD_WF51TO48_WF51, BS_LCD_WF51TO48_WF51))

/*! @brief Format value for bitfield LCD_WF51TO48_WF51. */
#define BF_LCD_WF51TO48_WF51(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF51TO48_WF51) & BM_LCD_WF51TO48_WF51)

/*! @brief Set the WF51 field to a new value. */
#define BW_LCD_WF51TO48_WF51(x, v) (BME_BFI32(HW_LCD_WF51TO48_ADDR(x), ((uint32_t)(v) << BP_LCD_WF51TO48_WF51), BP_LCD_WF51TO48_WF51, 8))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF55TO52 - LCD Waveform register
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF55TO52 - LCD Waveform register (RW)
 *
 * Reset value: 0x00000000U
 *
 * See the LCD Waveform register (WFC3TO0) for register and field descriptions.
 * The reset value of this register depends on the reset type: POR - 0x0000_0000
 */
typedef union _hw_lcd_wf55to52
{
    uint32_t U;
    struct _hw_lcd_wf55to52_bitfields
    {
        uint32_t WF52 : 8;             /*!< [7:0]  */
        uint32_t WF53 : 8;             /*!< [15:8]  */
        uint32_t WF54 : 8;             /*!< [23:16]  */
        uint32_t WF55 : 8;             /*!< [31:24]  */
    } B;
} hw_lcd_wf55to52_t;

/*!
 * @name Constants and macros for entire LCD_WF55TO52 register
 */
/*@{*/
#define HW_LCD_WF55TO52_ADDR(x)  ((uint32_t)(x) + 0x54U)

#define HW_LCD_WF55TO52(x)       (*(__IO hw_lcd_wf55to52_t *) HW_LCD_WF55TO52_ADDR(x))
#define HW_LCD_WF55TO52_RD(x)    (HW_LCD_WF55TO52(x).U)
#define HW_LCD_WF55TO52_WR(x, v) (HW_LCD_WF55TO52(x).U = (v))
#define HW_LCD_WF55TO52_SET(x, v) (BME_OR32(HW_LCD_WF55TO52_ADDR(x), (uint32_t)(v)))
#define HW_LCD_WF55TO52_CLR(x, v) (BME_AND32(HW_LCD_WF55TO52_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_WF55TO52_TOG(x, v) (BME_XOR32(HW_LCD_WF55TO52_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF55TO52 bitfields
 */

/*!
 * @name Register LCD_WF55TO52, field WF52[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P52 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF55TO52_WF52 (0U)          /*!< Bit position for LCD_WF55TO52_WF52. */
#define BM_LCD_WF55TO52_WF52 (0x000000FFU) /*!< Bit mask for LCD_WF55TO52_WF52. */
#define BS_LCD_WF55TO52_WF52 (8U)          /*!< Bit field size in bits for LCD_WF55TO52_WF52. */

/*! @brief Read current value of the LCD_WF55TO52_WF52 field. */
#define BR_LCD_WF55TO52_WF52(x) (BME_UBFX32(HW_LCD_WF55TO52_ADDR(x), BP_LCD_WF55TO52_WF52, BS_LCD_WF55TO52_WF52))

/*! @brief Format value for bitfield LCD_WF55TO52_WF52. */
#define BF_LCD_WF55TO52_WF52(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF55TO52_WF52) & BM_LCD_WF55TO52_WF52)

/*! @brief Set the WF52 field to a new value. */
#define BW_LCD_WF55TO52_WF52(x, v) (BME_BFI32(HW_LCD_WF55TO52_ADDR(x), ((uint32_t)(v) << BP_LCD_WF55TO52_WF52), BP_LCD_WF55TO52_WF52, 8))
/*@}*/

/*!
 * @name Register LCD_WF55TO52, field WF53[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P53 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF55TO52_WF53 (8U)          /*!< Bit position for LCD_WF55TO52_WF53. */
#define BM_LCD_WF55TO52_WF53 (0x0000FF00U) /*!< Bit mask for LCD_WF55TO52_WF53. */
#define BS_LCD_WF55TO52_WF53 (8U)          /*!< Bit field size in bits for LCD_WF55TO52_WF53. */

/*! @brief Read current value of the LCD_WF55TO52_WF53 field. */
#define BR_LCD_WF55TO52_WF53(x) (BME_UBFX32(HW_LCD_WF55TO52_ADDR(x), BP_LCD_WF55TO52_WF53, BS_LCD_WF55TO52_WF53))

/*! @brief Format value for bitfield LCD_WF55TO52_WF53. */
#define BF_LCD_WF55TO52_WF53(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF55TO52_WF53) & BM_LCD_WF55TO52_WF53)

/*! @brief Set the WF53 field to a new value. */
#define BW_LCD_WF55TO52_WF53(x, v) (BME_BFI32(HW_LCD_WF55TO52_ADDR(x), ((uint32_t)(v) << BP_LCD_WF55TO52_WF53), BP_LCD_WF55TO52_WF53, 8))
/*@}*/

/*!
 * @name Register LCD_WF55TO52, field WF54[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P54 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF55TO52_WF54 (16U)         /*!< Bit position for LCD_WF55TO52_WF54. */
#define BM_LCD_WF55TO52_WF54 (0x00FF0000U) /*!< Bit mask for LCD_WF55TO52_WF54. */
#define BS_LCD_WF55TO52_WF54 (8U)          /*!< Bit field size in bits for LCD_WF55TO52_WF54. */

/*! @brief Read current value of the LCD_WF55TO52_WF54 field. */
#define BR_LCD_WF55TO52_WF54(x) (BME_UBFX32(HW_LCD_WF55TO52_ADDR(x), BP_LCD_WF55TO52_WF54, BS_LCD_WF55TO52_WF54))

/*! @brief Format value for bitfield LCD_WF55TO52_WF54. */
#define BF_LCD_WF55TO52_WF54(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF55TO52_WF54) & BM_LCD_WF55TO52_WF54)

/*! @brief Set the WF54 field to a new value. */
#define BW_LCD_WF55TO52_WF54(x, v) (BME_BFI32(HW_LCD_WF55TO52_ADDR(x), ((uint32_t)(v) << BP_LCD_WF55TO52_WF54), BP_LCD_WF55TO52_WF54, 8))
/*@}*/

/*!
 * @name Register LCD_WF55TO52, field WF55[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P55 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF55TO52_WF55 (24U)         /*!< Bit position for LCD_WF55TO52_WF55. */
#define BM_LCD_WF55TO52_WF55 (0xFF000000U) /*!< Bit mask for LCD_WF55TO52_WF55. */
#define BS_LCD_WF55TO52_WF55 (8U)          /*!< Bit field size in bits for LCD_WF55TO52_WF55. */

/*! @brief Read current value of the LCD_WF55TO52_WF55 field. */
#define BR_LCD_WF55TO52_WF55(x) (BME_UBFX32(HW_LCD_WF55TO52_ADDR(x), BP_LCD_WF55TO52_WF55, BS_LCD_WF55TO52_WF55))

/*! @brief Format value for bitfield LCD_WF55TO52_WF55. */
#define BF_LCD_WF55TO52_WF55(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF55TO52_WF55) & BM_LCD_WF55TO52_WF55)

/*! @brief Set the WF55 field to a new value. */
#define BW_LCD_WF55TO52_WF55(x, v) (BME_BFI32(HW_LCD_WF55TO52_ADDR(x), ((uint32_t)(v) << BP_LCD_WF55TO52_WF55), BP_LCD_WF55TO52_WF55, 8))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF59TO56 - LCD Waveform register
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF59TO56 - LCD Waveform register (RW)
 *
 * Reset value: 0x00000000U
 *
 * See the LCD Waveform register (WFC3TO0) for register and field descriptions.
 * The reset value of this register depends on the reset type: POR - 0x0000_0000
 */
typedef union _hw_lcd_wf59to56
{
    uint32_t U;
    struct _hw_lcd_wf59to56_bitfields
    {
        uint32_t WF56 : 8;             /*!< [7:0]  */
        uint32_t WF57 : 8;             /*!< [15:8]  */
        uint32_t WF58 : 8;             /*!< [23:16]  */
        uint32_t WF59 : 8;             /*!< [31:24]  */
    } B;
} hw_lcd_wf59to56_t;

/*!
 * @name Constants and macros for entire LCD_WF59TO56 register
 */
/*@{*/
#define HW_LCD_WF59TO56_ADDR(x)  ((uint32_t)(x) + 0x58U)

#define HW_LCD_WF59TO56(x)       (*(__IO hw_lcd_wf59to56_t *) HW_LCD_WF59TO56_ADDR(x))
#define HW_LCD_WF59TO56_RD(x)    (HW_LCD_WF59TO56(x).U)
#define HW_LCD_WF59TO56_WR(x, v) (HW_LCD_WF59TO56(x).U = (v))
#define HW_LCD_WF59TO56_SET(x, v) (BME_OR32(HW_LCD_WF59TO56_ADDR(x), (uint32_t)(v)))
#define HW_LCD_WF59TO56_CLR(x, v) (BME_AND32(HW_LCD_WF59TO56_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_WF59TO56_TOG(x, v) (BME_XOR32(HW_LCD_WF59TO56_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF59TO56 bitfields
 */

/*!
 * @name Register LCD_WF59TO56, field WF56[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P56 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF59TO56_WF56 (0U)          /*!< Bit position for LCD_WF59TO56_WF56. */
#define BM_LCD_WF59TO56_WF56 (0x000000FFU) /*!< Bit mask for LCD_WF59TO56_WF56. */
#define BS_LCD_WF59TO56_WF56 (8U)          /*!< Bit field size in bits for LCD_WF59TO56_WF56. */

/*! @brief Read current value of the LCD_WF59TO56_WF56 field. */
#define BR_LCD_WF59TO56_WF56(x) (BME_UBFX32(HW_LCD_WF59TO56_ADDR(x), BP_LCD_WF59TO56_WF56, BS_LCD_WF59TO56_WF56))

/*! @brief Format value for bitfield LCD_WF59TO56_WF56. */
#define BF_LCD_WF59TO56_WF56(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF59TO56_WF56) & BM_LCD_WF59TO56_WF56)

/*! @brief Set the WF56 field to a new value. */
#define BW_LCD_WF59TO56_WF56(x, v) (BME_BFI32(HW_LCD_WF59TO56_ADDR(x), ((uint32_t)(v) << BP_LCD_WF59TO56_WF56), BP_LCD_WF59TO56_WF56, 8))
/*@}*/

/*!
 * @name Register LCD_WF59TO56, field WF57[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P57 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF59TO56_WF57 (8U)          /*!< Bit position for LCD_WF59TO56_WF57. */
#define BM_LCD_WF59TO56_WF57 (0x0000FF00U) /*!< Bit mask for LCD_WF59TO56_WF57. */
#define BS_LCD_WF59TO56_WF57 (8U)          /*!< Bit field size in bits for LCD_WF59TO56_WF57. */

/*! @brief Read current value of the LCD_WF59TO56_WF57 field. */
#define BR_LCD_WF59TO56_WF57(x) (BME_UBFX32(HW_LCD_WF59TO56_ADDR(x), BP_LCD_WF59TO56_WF57, BS_LCD_WF59TO56_WF57))

/*! @brief Format value for bitfield LCD_WF59TO56_WF57. */
#define BF_LCD_WF59TO56_WF57(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF59TO56_WF57) & BM_LCD_WF59TO56_WF57)

/*! @brief Set the WF57 field to a new value. */
#define BW_LCD_WF59TO56_WF57(x, v) (BME_BFI32(HW_LCD_WF59TO56_ADDR(x), ((uint32_t)(v) << BP_LCD_WF59TO56_WF57), BP_LCD_WF59TO56_WF57, 8))
/*@}*/

/*!
 * @name Register LCD_WF59TO56, field WF58[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P58 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF59TO56_WF58 (16U)         /*!< Bit position for LCD_WF59TO56_WF58. */
#define BM_LCD_WF59TO56_WF58 (0x00FF0000U) /*!< Bit mask for LCD_WF59TO56_WF58. */
#define BS_LCD_WF59TO56_WF58 (8U)          /*!< Bit field size in bits for LCD_WF59TO56_WF58. */

/*! @brief Read current value of the LCD_WF59TO56_WF58 field. */
#define BR_LCD_WF59TO56_WF58(x) (BME_UBFX32(HW_LCD_WF59TO56_ADDR(x), BP_LCD_WF59TO56_WF58, BS_LCD_WF59TO56_WF58))

/*! @brief Format value for bitfield LCD_WF59TO56_WF58. */
#define BF_LCD_WF59TO56_WF58(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF59TO56_WF58) & BM_LCD_WF59TO56_WF58)

/*! @brief Set the WF58 field to a new value. */
#define BW_LCD_WF59TO56_WF58(x, v) (BME_BFI32(HW_LCD_WF59TO56_ADDR(x), ((uint32_t)(v) << BP_LCD_WF59TO56_WF58), BP_LCD_WF59TO56_WF58, 8))
/*@}*/

/*!
 * @name Register LCD_WF59TO56, field WF59[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P59 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF59TO56_WF59 (24U)         /*!< Bit position for LCD_WF59TO56_WF59. */
#define BM_LCD_WF59TO56_WF59 (0xFF000000U) /*!< Bit mask for LCD_WF59TO56_WF59. */
#define BS_LCD_WF59TO56_WF59 (8U)          /*!< Bit field size in bits for LCD_WF59TO56_WF59. */

/*! @brief Read current value of the LCD_WF59TO56_WF59 field. */
#define BR_LCD_WF59TO56_WF59(x) (BME_UBFX32(HW_LCD_WF59TO56_ADDR(x), BP_LCD_WF59TO56_WF59, BS_LCD_WF59TO56_WF59))

/*! @brief Format value for bitfield LCD_WF59TO56_WF59. */
#define BF_LCD_WF59TO56_WF59(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF59TO56_WF59) & BM_LCD_WF59TO56_WF59)

/*! @brief Set the WF59 field to a new value. */
#define BW_LCD_WF59TO56_WF59(x, v) (BME_BFI32(HW_LCD_WF59TO56_ADDR(x), ((uint32_t)(v) << BP_LCD_WF59TO56_WF59), BP_LCD_WF59TO56_WF59, 8))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF63TO60 - LCD Waveform register
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF63TO60 - LCD Waveform register (RW)
 *
 * Reset value: 0x00000000U
 *
 * See the LCD Waveform register (WFC3TO0) for register and field descriptions.
 * The reset value of this register depends on the reset type: POR - 0x0000_0000
 */
typedef union _hw_lcd_wf63to60
{
    uint32_t U;
    struct _hw_lcd_wf63to60_bitfields
    {
        uint32_t WF60 : 8;             /*!< [7:0]  */
        uint32_t WF61 : 8;             /*!< [15:8]  */
        uint32_t WF62 : 8;             /*!< [23:16]  */
        uint32_t WF63 : 8;             /*!< [31:24]  */
    } B;
} hw_lcd_wf63to60_t;

/*!
 * @name Constants and macros for entire LCD_WF63TO60 register
 */
/*@{*/
#define HW_LCD_WF63TO60_ADDR(x)  ((uint32_t)(x) + 0x5CU)

#define HW_LCD_WF63TO60(x)       (*(__IO hw_lcd_wf63to60_t *) HW_LCD_WF63TO60_ADDR(x))
#define HW_LCD_WF63TO60_RD(x)    (HW_LCD_WF63TO60(x).U)
#define HW_LCD_WF63TO60_WR(x, v) (HW_LCD_WF63TO60(x).U = (v))
#define HW_LCD_WF63TO60_SET(x, v) (BME_OR32(HW_LCD_WF63TO60_ADDR(x), (uint32_t)(v)))
#define HW_LCD_WF63TO60_CLR(x, v) (BME_AND32(HW_LCD_WF63TO60_ADDR(x), (uint32_t)(~(v))))
#define HW_LCD_WF63TO60_TOG(x, v) (BME_XOR32(HW_LCD_WF63TO60_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF63TO60 bitfields
 */

/*!
 * @name Register LCD_WF63TO60, field WF60[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P60 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF63TO60_WF60 (0U)          /*!< Bit position for LCD_WF63TO60_WF60. */
#define BM_LCD_WF63TO60_WF60 (0x000000FFU) /*!< Bit mask for LCD_WF63TO60_WF60. */
#define BS_LCD_WF63TO60_WF60 (8U)          /*!< Bit field size in bits for LCD_WF63TO60_WF60. */

/*! @brief Read current value of the LCD_WF63TO60_WF60 field. */
#define BR_LCD_WF63TO60_WF60(x) (BME_UBFX32(HW_LCD_WF63TO60_ADDR(x), BP_LCD_WF63TO60_WF60, BS_LCD_WF63TO60_WF60))

/*! @brief Format value for bitfield LCD_WF63TO60_WF60. */
#define BF_LCD_WF63TO60_WF60(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF63TO60_WF60) & BM_LCD_WF63TO60_WF60)

/*! @brief Set the WF60 field to a new value. */
#define BW_LCD_WF63TO60_WF60(x, v) (BME_BFI32(HW_LCD_WF63TO60_ADDR(x), ((uint32_t)(v) << BP_LCD_WF63TO60_WF60), BP_LCD_WF63TO60_WF60, 8))
/*@}*/

/*!
 * @name Register LCD_WF63TO60, field WF61[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P61 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF63TO60_WF61 (8U)          /*!< Bit position for LCD_WF63TO60_WF61. */
#define BM_LCD_WF63TO60_WF61 (0x0000FF00U) /*!< Bit mask for LCD_WF63TO60_WF61. */
#define BS_LCD_WF63TO60_WF61 (8U)          /*!< Bit field size in bits for LCD_WF63TO60_WF61. */

/*! @brief Read current value of the LCD_WF63TO60_WF61 field. */
#define BR_LCD_WF63TO60_WF61(x) (BME_UBFX32(HW_LCD_WF63TO60_ADDR(x), BP_LCD_WF63TO60_WF61, BS_LCD_WF63TO60_WF61))

/*! @brief Format value for bitfield LCD_WF63TO60_WF61. */
#define BF_LCD_WF63TO60_WF61(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF63TO60_WF61) & BM_LCD_WF63TO60_WF61)

/*! @brief Set the WF61 field to a new value. */
#define BW_LCD_WF63TO60_WF61(x, v) (BME_BFI32(HW_LCD_WF63TO60_ADDR(x), ((uint32_t)(v) << BP_LCD_WF63TO60_WF61), BP_LCD_WF63TO60_WF61, 8))
/*@}*/

/*!
 * @name Register LCD_WF63TO60, field WF62[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P62 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF63TO60_WF62 (16U)         /*!< Bit position for LCD_WF63TO60_WF62. */
#define BM_LCD_WF63TO60_WF62 (0x00FF0000U) /*!< Bit mask for LCD_WF63TO60_WF62. */
#define BS_LCD_WF63TO60_WF62 (8U)          /*!< Bit field size in bits for LCD_WF63TO60_WF62. */

/*! @brief Read current value of the LCD_WF63TO60_WF62 field. */
#define BR_LCD_WF63TO60_WF62(x) (BME_UBFX32(HW_LCD_WF63TO60_ADDR(x), BP_LCD_WF63TO60_WF62, BS_LCD_WF63TO60_WF62))

/*! @brief Format value for bitfield LCD_WF63TO60_WF62. */
#define BF_LCD_WF63TO60_WF62(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF63TO60_WF62) & BM_LCD_WF63TO60_WF62)

/*! @brief Set the WF62 field to a new value. */
#define BW_LCD_WF63TO60_WF62(x, v) (BME_BFI32(HW_LCD_WF63TO60_ADDR(x), ((uint32_t)(v) << BP_LCD_WF63TO60_WF62), BP_LCD_WF63TO60_WF62, 8))
/*@}*/

/*!
 * @name Register LCD_WF63TO60, field WF63[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P63 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
#define BP_LCD_WF63TO60_WF63 (24U)         /*!< Bit position for LCD_WF63TO60_WF63. */
#define BM_LCD_WF63TO60_WF63 (0xFF000000U) /*!< Bit mask for LCD_WF63TO60_WF63. */
#define BS_LCD_WF63TO60_WF63 (8U)          /*!< Bit field size in bits for LCD_WF63TO60_WF63. */

/*! @brief Read current value of the LCD_WF63TO60_WF63 field. */
#define BR_LCD_WF63TO60_WF63(x) (BME_UBFX32(HW_LCD_WF63TO60_ADDR(x), BP_LCD_WF63TO60_WF63, BS_LCD_WF63TO60_WF63))

/*! @brief Format value for bitfield LCD_WF63TO60_WF63. */
#define BF_LCD_WF63TO60_WF63(v) ((uint32_t)((uint32_t)(v) << BP_LCD_WF63TO60_WF63) & BM_LCD_WF63TO60_WF63)

/*! @brief Set the WF63 field to a new value. */
#define BW_LCD_WF63TO60_WF63(x, v) (BME_BFI32(HW_LCD_WF63TO60_ADDR(x), ((uint32_t)(v) << BP_LCD_WF63TO60_WF63), BP_LCD_WF63TO60_WF63, 8))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF0 - LCD Waveform Register 0.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF0 - LCD Waveform Register 0. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf0
{
    uint8_t U;
    struct _hw_lcd_wf0_bitfields
    {
        uint8_t BPALCD0 : 1;           /*!< [0]  */
        uint8_t BPBLCD0 : 1;           /*!< [1]  */
        uint8_t BPCLCD0 : 1;           /*!< [2]  */
        uint8_t BPDLCD0 : 1;           /*!< [3]  */
        uint8_t BPELCD0 : 1;           /*!< [4]  */
        uint8_t BPFLCD0 : 1;           /*!< [5]  */
        uint8_t BPGLCD0 : 1;           /*!< [6]  */
        uint8_t BPHLCD0 : 1;           /*!< [7]  */
    } B;
} hw_lcd_wf0_t;

/*!
 * @name Constants and macros for entire LCD_WF0 register
 */
/*@{*/
#define HW_LCD_WF0_ADDR(x)       ((uint32_t)(x) + 0x20U)

#define HW_LCD_WF0(x)            (*(__IO hw_lcd_wf0_t *) HW_LCD_WF0_ADDR(x))
#define HW_LCD_WF0_RD(x)         (HW_LCD_WF0(x).U)
#define HW_LCD_WF0_WR(x, v)      (HW_LCD_WF0(x).U = (v))
#define HW_LCD_WF0_SET(x, v)     (BME_OR8(HW_LCD_WF0_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF0_CLR(x, v)     (BME_AND8(HW_LCD_WF0_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF0_TOG(x, v)     (BME_XOR8(HW_LCD_WF0_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF0 bitfields
 */

/*!
 * @name Register LCD_WF0, field BPALCD0[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF0_BPALCD0   (0U)          /*!< Bit position for LCD_WF0_BPALCD0. */
#define BM_LCD_WF0_BPALCD0   (0x01U)       /*!< Bit mask for LCD_WF0_BPALCD0. */
#define BS_LCD_WF0_BPALCD0   (1U)          /*!< Bit field size in bits for LCD_WF0_BPALCD0. */

/*! @brief Read current value of the LCD_WF0_BPALCD0 field. */
#define BR_LCD_WF0_BPALCD0(x) (BME_UBFX8(HW_LCD_WF0_ADDR(x), BP_LCD_WF0_BPALCD0, BS_LCD_WF0_BPALCD0))

/*! @brief Format value for bitfield LCD_WF0_BPALCD0. */
#define BF_LCD_WF0_BPALCD0(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF0_BPALCD0) & BM_LCD_WF0_BPALCD0)

/*! @brief Set the BPALCD0 field to a new value. */
#define BW_LCD_WF0_BPALCD0(x, v) (BME_BFI8(HW_LCD_WF0_ADDR(x), ((uint8_t)(v) << BP_LCD_WF0_BPALCD0), BP_LCD_WF0_BPALCD0, 1))
/*@}*/

/*!
 * @name Register LCD_WF0, field BPBLCD0[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF0_BPBLCD0   (1U)          /*!< Bit position for LCD_WF0_BPBLCD0. */
#define BM_LCD_WF0_BPBLCD0   (0x02U)       /*!< Bit mask for LCD_WF0_BPBLCD0. */
#define BS_LCD_WF0_BPBLCD0   (1U)          /*!< Bit field size in bits for LCD_WF0_BPBLCD0. */

/*! @brief Read current value of the LCD_WF0_BPBLCD0 field. */
#define BR_LCD_WF0_BPBLCD0(x) (BME_UBFX8(HW_LCD_WF0_ADDR(x), BP_LCD_WF0_BPBLCD0, BS_LCD_WF0_BPBLCD0))

/*! @brief Format value for bitfield LCD_WF0_BPBLCD0. */
#define BF_LCD_WF0_BPBLCD0(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF0_BPBLCD0) & BM_LCD_WF0_BPBLCD0)

/*! @brief Set the BPBLCD0 field to a new value. */
#define BW_LCD_WF0_BPBLCD0(x, v) (BME_BFI8(HW_LCD_WF0_ADDR(x), ((uint8_t)(v) << BP_LCD_WF0_BPBLCD0), BP_LCD_WF0_BPBLCD0, 1))
/*@}*/

/*!
 * @name Register LCD_WF0, field BPCLCD0[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF0_BPCLCD0   (2U)          /*!< Bit position for LCD_WF0_BPCLCD0. */
#define BM_LCD_WF0_BPCLCD0   (0x04U)       /*!< Bit mask for LCD_WF0_BPCLCD0. */
#define BS_LCD_WF0_BPCLCD0   (1U)          /*!< Bit field size in bits for LCD_WF0_BPCLCD0. */

/*! @brief Read current value of the LCD_WF0_BPCLCD0 field. */
#define BR_LCD_WF0_BPCLCD0(x) (BME_UBFX8(HW_LCD_WF0_ADDR(x), BP_LCD_WF0_BPCLCD0, BS_LCD_WF0_BPCLCD0))

/*! @brief Format value for bitfield LCD_WF0_BPCLCD0. */
#define BF_LCD_WF0_BPCLCD0(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF0_BPCLCD0) & BM_LCD_WF0_BPCLCD0)

/*! @brief Set the BPCLCD0 field to a new value. */
#define BW_LCD_WF0_BPCLCD0(x, v) (BME_BFI8(HW_LCD_WF0_ADDR(x), ((uint8_t)(v) << BP_LCD_WF0_BPCLCD0), BP_LCD_WF0_BPCLCD0, 1))
/*@}*/

/*!
 * @name Register LCD_WF0, field BPDLCD0[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF0_BPDLCD0   (3U)          /*!< Bit position for LCD_WF0_BPDLCD0. */
#define BM_LCD_WF0_BPDLCD0   (0x08U)       /*!< Bit mask for LCD_WF0_BPDLCD0. */
#define BS_LCD_WF0_BPDLCD0   (1U)          /*!< Bit field size in bits for LCD_WF0_BPDLCD0. */

/*! @brief Read current value of the LCD_WF0_BPDLCD0 field. */
#define BR_LCD_WF0_BPDLCD0(x) (BME_UBFX8(HW_LCD_WF0_ADDR(x), BP_LCD_WF0_BPDLCD0, BS_LCD_WF0_BPDLCD0))

/*! @brief Format value for bitfield LCD_WF0_BPDLCD0. */
#define BF_LCD_WF0_BPDLCD0(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF0_BPDLCD0) & BM_LCD_WF0_BPDLCD0)

/*! @brief Set the BPDLCD0 field to a new value. */
#define BW_LCD_WF0_BPDLCD0(x, v) (BME_BFI8(HW_LCD_WF0_ADDR(x), ((uint8_t)(v) << BP_LCD_WF0_BPDLCD0), BP_LCD_WF0_BPDLCD0, 1))
/*@}*/

/*!
 * @name Register LCD_WF0, field BPELCD0[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF0_BPELCD0   (4U)          /*!< Bit position for LCD_WF0_BPELCD0. */
#define BM_LCD_WF0_BPELCD0   (0x10U)       /*!< Bit mask for LCD_WF0_BPELCD0. */
#define BS_LCD_WF0_BPELCD0   (1U)          /*!< Bit field size in bits for LCD_WF0_BPELCD0. */

/*! @brief Read current value of the LCD_WF0_BPELCD0 field. */
#define BR_LCD_WF0_BPELCD0(x) (BME_UBFX8(HW_LCD_WF0_ADDR(x), BP_LCD_WF0_BPELCD0, BS_LCD_WF0_BPELCD0))

/*! @brief Format value for bitfield LCD_WF0_BPELCD0. */
#define BF_LCD_WF0_BPELCD0(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF0_BPELCD0) & BM_LCD_WF0_BPELCD0)

/*! @brief Set the BPELCD0 field to a new value. */
#define BW_LCD_WF0_BPELCD0(x, v) (BME_BFI8(HW_LCD_WF0_ADDR(x), ((uint8_t)(v) << BP_LCD_WF0_BPELCD0), BP_LCD_WF0_BPELCD0, 1))
/*@}*/

/*!
 * @name Register LCD_WF0, field BPFLCD0[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF0_BPFLCD0   (5U)          /*!< Bit position for LCD_WF0_BPFLCD0. */
#define BM_LCD_WF0_BPFLCD0   (0x20U)       /*!< Bit mask for LCD_WF0_BPFLCD0. */
#define BS_LCD_WF0_BPFLCD0   (1U)          /*!< Bit field size in bits for LCD_WF0_BPFLCD0. */

/*! @brief Read current value of the LCD_WF0_BPFLCD0 field. */
#define BR_LCD_WF0_BPFLCD0(x) (BME_UBFX8(HW_LCD_WF0_ADDR(x), BP_LCD_WF0_BPFLCD0, BS_LCD_WF0_BPFLCD0))

/*! @brief Format value for bitfield LCD_WF0_BPFLCD0. */
#define BF_LCD_WF0_BPFLCD0(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF0_BPFLCD0) & BM_LCD_WF0_BPFLCD0)

/*! @brief Set the BPFLCD0 field to a new value. */
#define BW_LCD_WF0_BPFLCD0(x, v) (BME_BFI8(HW_LCD_WF0_ADDR(x), ((uint8_t)(v) << BP_LCD_WF0_BPFLCD0), BP_LCD_WF0_BPFLCD0, 1))
/*@}*/

/*!
 * @name Register LCD_WF0, field BPGLCD0[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF0_BPGLCD0   (6U)          /*!< Bit position for LCD_WF0_BPGLCD0. */
#define BM_LCD_WF0_BPGLCD0   (0x40U)       /*!< Bit mask for LCD_WF0_BPGLCD0. */
#define BS_LCD_WF0_BPGLCD0   (1U)          /*!< Bit field size in bits for LCD_WF0_BPGLCD0. */

/*! @brief Read current value of the LCD_WF0_BPGLCD0 field. */
#define BR_LCD_WF0_BPGLCD0(x) (BME_UBFX8(HW_LCD_WF0_ADDR(x), BP_LCD_WF0_BPGLCD0, BS_LCD_WF0_BPGLCD0))

/*! @brief Format value for bitfield LCD_WF0_BPGLCD0. */
#define BF_LCD_WF0_BPGLCD0(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF0_BPGLCD0) & BM_LCD_WF0_BPGLCD0)

/*! @brief Set the BPGLCD0 field to a new value. */
#define BW_LCD_WF0_BPGLCD0(x, v) (BME_BFI8(HW_LCD_WF0_ADDR(x), ((uint8_t)(v) << BP_LCD_WF0_BPGLCD0), BP_LCD_WF0_BPGLCD0, 1))
/*@}*/

/*!
 * @name Register LCD_WF0, field BPHLCD0[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF0_BPHLCD0   (7U)          /*!< Bit position for LCD_WF0_BPHLCD0. */
#define BM_LCD_WF0_BPHLCD0   (0x80U)       /*!< Bit mask for LCD_WF0_BPHLCD0. */
#define BS_LCD_WF0_BPHLCD0   (1U)          /*!< Bit field size in bits for LCD_WF0_BPHLCD0. */

/*! @brief Read current value of the LCD_WF0_BPHLCD0 field. */
#define BR_LCD_WF0_BPHLCD0(x) (BME_UBFX8(HW_LCD_WF0_ADDR(x), BP_LCD_WF0_BPHLCD0, BS_LCD_WF0_BPHLCD0))

/*! @brief Format value for bitfield LCD_WF0_BPHLCD0. */
#define BF_LCD_WF0_BPHLCD0(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF0_BPHLCD0) & BM_LCD_WF0_BPHLCD0)

/*! @brief Set the BPHLCD0 field to a new value. */
#define BW_LCD_WF0_BPHLCD0(x, v) (BME_BFI8(HW_LCD_WF0_ADDR(x), ((uint8_t)(v) << BP_LCD_WF0_BPHLCD0), BP_LCD_WF0_BPHLCD0, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF1 - LCD Waveform Register 1.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF1 - LCD Waveform Register 1. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf1
{
    uint8_t U;
    struct _hw_lcd_wf1_bitfields
    {
        uint8_t BPALCD1 : 1;           /*!< [0]  */
        uint8_t BPBLCD1 : 1;           /*!< [1]  */
        uint8_t BPCLCD1 : 1;           /*!< [2]  */
        uint8_t BPDLCD1 : 1;           /*!< [3]  */
        uint8_t BPELCD1 : 1;           /*!< [4]  */
        uint8_t BPFLCD1 : 1;           /*!< [5]  */
        uint8_t BPGLCD1 : 1;           /*!< [6]  */
        uint8_t BPHLCD1 : 1;           /*!< [7]  */
    } B;
} hw_lcd_wf1_t;

/*!
 * @name Constants and macros for entire LCD_WF1 register
 */
/*@{*/
#define HW_LCD_WF1_ADDR(x)       ((uint32_t)(x) + 0x21U)

#define HW_LCD_WF1(x)            (*(__IO hw_lcd_wf1_t *) HW_LCD_WF1_ADDR(x))
#define HW_LCD_WF1_RD(x)         (HW_LCD_WF1(x).U)
#define HW_LCD_WF1_WR(x, v)      (HW_LCD_WF1(x).U = (v))
#define HW_LCD_WF1_SET(x, v)     (BME_OR8(HW_LCD_WF1_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF1_CLR(x, v)     (BME_AND8(HW_LCD_WF1_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF1_TOG(x, v)     (BME_XOR8(HW_LCD_WF1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF1 bitfields
 */

/*!
 * @name Register LCD_WF1, field BPALCD1[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF1_BPALCD1   (0U)          /*!< Bit position for LCD_WF1_BPALCD1. */
#define BM_LCD_WF1_BPALCD1   (0x01U)       /*!< Bit mask for LCD_WF1_BPALCD1. */
#define BS_LCD_WF1_BPALCD1   (1U)          /*!< Bit field size in bits for LCD_WF1_BPALCD1. */

/*! @brief Read current value of the LCD_WF1_BPALCD1 field. */
#define BR_LCD_WF1_BPALCD1(x) (BME_UBFX8(HW_LCD_WF1_ADDR(x), BP_LCD_WF1_BPALCD1, BS_LCD_WF1_BPALCD1))

/*! @brief Format value for bitfield LCD_WF1_BPALCD1. */
#define BF_LCD_WF1_BPALCD1(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF1_BPALCD1) & BM_LCD_WF1_BPALCD1)

/*! @brief Set the BPALCD1 field to a new value. */
#define BW_LCD_WF1_BPALCD1(x, v) (BME_BFI8(HW_LCD_WF1_ADDR(x), ((uint8_t)(v) << BP_LCD_WF1_BPALCD1), BP_LCD_WF1_BPALCD1, 1))
/*@}*/

/*!
 * @name Register LCD_WF1, field BPBLCD1[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF1_BPBLCD1   (1U)          /*!< Bit position for LCD_WF1_BPBLCD1. */
#define BM_LCD_WF1_BPBLCD1   (0x02U)       /*!< Bit mask for LCD_WF1_BPBLCD1. */
#define BS_LCD_WF1_BPBLCD1   (1U)          /*!< Bit field size in bits for LCD_WF1_BPBLCD1. */

/*! @brief Read current value of the LCD_WF1_BPBLCD1 field. */
#define BR_LCD_WF1_BPBLCD1(x) (BME_UBFX8(HW_LCD_WF1_ADDR(x), BP_LCD_WF1_BPBLCD1, BS_LCD_WF1_BPBLCD1))

/*! @brief Format value for bitfield LCD_WF1_BPBLCD1. */
#define BF_LCD_WF1_BPBLCD1(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF1_BPBLCD1) & BM_LCD_WF1_BPBLCD1)

/*! @brief Set the BPBLCD1 field to a new value. */
#define BW_LCD_WF1_BPBLCD1(x, v) (BME_BFI8(HW_LCD_WF1_ADDR(x), ((uint8_t)(v) << BP_LCD_WF1_BPBLCD1), BP_LCD_WF1_BPBLCD1, 1))
/*@}*/

/*!
 * @name Register LCD_WF1, field BPCLCD1[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF1_BPCLCD1   (2U)          /*!< Bit position for LCD_WF1_BPCLCD1. */
#define BM_LCD_WF1_BPCLCD1   (0x04U)       /*!< Bit mask for LCD_WF1_BPCLCD1. */
#define BS_LCD_WF1_BPCLCD1   (1U)          /*!< Bit field size in bits for LCD_WF1_BPCLCD1. */

/*! @brief Read current value of the LCD_WF1_BPCLCD1 field. */
#define BR_LCD_WF1_BPCLCD1(x) (BME_UBFX8(HW_LCD_WF1_ADDR(x), BP_LCD_WF1_BPCLCD1, BS_LCD_WF1_BPCLCD1))

/*! @brief Format value for bitfield LCD_WF1_BPCLCD1. */
#define BF_LCD_WF1_BPCLCD1(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF1_BPCLCD1) & BM_LCD_WF1_BPCLCD1)

/*! @brief Set the BPCLCD1 field to a new value. */
#define BW_LCD_WF1_BPCLCD1(x, v) (BME_BFI8(HW_LCD_WF1_ADDR(x), ((uint8_t)(v) << BP_LCD_WF1_BPCLCD1), BP_LCD_WF1_BPCLCD1, 1))
/*@}*/

/*!
 * @name Register LCD_WF1, field BPDLCD1[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF1_BPDLCD1   (3U)          /*!< Bit position for LCD_WF1_BPDLCD1. */
#define BM_LCD_WF1_BPDLCD1   (0x08U)       /*!< Bit mask for LCD_WF1_BPDLCD1. */
#define BS_LCD_WF1_BPDLCD1   (1U)          /*!< Bit field size in bits for LCD_WF1_BPDLCD1. */

/*! @brief Read current value of the LCD_WF1_BPDLCD1 field. */
#define BR_LCD_WF1_BPDLCD1(x) (BME_UBFX8(HW_LCD_WF1_ADDR(x), BP_LCD_WF1_BPDLCD1, BS_LCD_WF1_BPDLCD1))

/*! @brief Format value for bitfield LCD_WF1_BPDLCD1. */
#define BF_LCD_WF1_BPDLCD1(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF1_BPDLCD1) & BM_LCD_WF1_BPDLCD1)

/*! @brief Set the BPDLCD1 field to a new value. */
#define BW_LCD_WF1_BPDLCD1(x, v) (BME_BFI8(HW_LCD_WF1_ADDR(x), ((uint8_t)(v) << BP_LCD_WF1_BPDLCD1), BP_LCD_WF1_BPDLCD1, 1))
/*@}*/

/*!
 * @name Register LCD_WF1, field BPELCD1[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF1_BPELCD1   (4U)          /*!< Bit position for LCD_WF1_BPELCD1. */
#define BM_LCD_WF1_BPELCD1   (0x10U)       /*!< Bit mask for LCD_WF1_BPELCD1. */
#define BS_LCD_WF1_BPELCD1   (1U)          /*!< Bit field size in bits for LCD_WF1_BPELCD1. */

/*! @brief Read current value of the LCD_WF1_BPELCD1 field. */
#define BR_LCD_WF1_BPELCD1(x) (BME_UBFX8(HW_LCD_WF1_ADDR(x), BP_LCD_WF1_BPELCD1, BS_LCD_WF1_BPELCD1))

/*! @brief Format value for bitfield LCD_WF1_BPELCD1. */
#define BF_LCD_WF1_BPELCD1(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF1_BPELCD1) & BM_LCD_WF1_BPELCD1)

/*! @brief Set the BPELCD1 field to a new value. */
#define BW_LCD_WF1_BPELCD1(x, v) (BME_BFI8(HW_LCD_WF1_ADDR(x), ((uint8_t)(v) << BP_LCD_WF1_BPELCD1), BP_LCD_WF1_BPELCD1, 1))
/*@}*/

/*!
 * @name Register LCD_WF1, field BPFLCD1[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF1_BPFLCD1   (5U)          /*!< Bit position for LCD_WF1_BPFLCD1. */
#define BM_LCD_WF1_BPFLCD1   (0x20U)       /*!< Bit mask for LCD_WF1_BPFLCD1. */
#define BS_LCD_WF1_BPFLCD1   (1U)          /*!< Bit field size in bits for LCD_WF1_BPFLCD1. */

/*! @brief Read current value of the LCD_WF1_BPFLCD1 field. */
#define BR_LCD_WF1_BPFLCD1(x) (BME_UBFX8(HW_LCD_WF1_ADDR(x), BP_LCD_WF1_BPFLCD1, BS_LCD_WF1_BPFLCD1))

/*! @brief Format value for bitfield LCD_WF1_BPFLCD1. */
#define BF_LCD_WF1_BPFLCD1(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF1_BPFLCD1) & BM_LCD_WF1_BPFLCD1)

/*! @brief Set the BPFLCD1 field to a new value. */
#define BW_LCD_WF1_BPFLCD1(x, v) (BME_BFI8(HW_LCD_WF1_ADDR(x), ((uint8_t)(v) << BP_LCD_WF1_BPFLCD1), BP_LCD_WF1_BPFLCD1, 1))
/*@}*/

/*!
 * @name Register LCD_WF1, field BPGLCD1[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF1_BPGLCD1   (6U)          /*!< Bit position for LCD_WF1_BPGLCD1. */
#define BM_LCD_WF1_BPGLCD1   (0x40U)       /*!< Bit mask for LCD_WF1_BPGLCD1. */
#define BS_LCD_WF1_BPGLCD1   (1U)          /*!< Bit field size in bits for LCD_WF1_BPGLCD1. */

/*! @brief Read current value of the LCD_WF1_BPGLCD1 field. */
#define BR_LCD_WF1_BPGLCD1(x) (BME_UBFX8(HW_LCD_WF1_ADDR(x), BP_LCD_WF1_BPGLCD1, BS_LCD_WF1_BPGLCD1))

/*! @brief Format value for bitfield LCD_WF1_BPGLCD1. */
#define BF_LCD_WF1_BPGLCD1(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF1_BPGLCD1) & BM_LCD_WF1_BPGLCD1)

/*! @brief Set the BPGLCD1 field to a new value. */
#define BW_LCD_WF1_BPGLCD1(x, v) (BME_BFI8(HW_LCD_WF1_ADDR(x), ((uint8_t)(v) << BP_LCD_WF1_BPGLCD1), BP_LCD_WF1_BPGLCD1, 1))
/*@}*/

/*!
 * @name Register LCD_WF1, field BPHLCD1[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF1_BPHLCD1   (7U)          /*!< Bit position for LCD_WF1_BPHLCD1. */
#define BM_LCD_WF1_BPHLCD1   (0x80U)       /*!< Bit mask for LCD_WF1_BPHLCD1. */
#define BS_LCD_WF1_BPHLCD1   (1U)          /*!< Bit field size in bits for LCD_WF1_BPHLCD1. */

/*! @brief Read current value of the LCD_WF1_BPHLCD1 field. */
#define BR_LCD_WF1_BPHLCD1(x) (BME_UBFX8(HW_LCD_WF1_ADDR(x), BP_LCD_WF1_BPHLCD1, BS_LCD_WF1_BPHLCD1))

/*! @brief Format value for bitfield LCD_WF1_BPHLCD1. */
#define BF_LCD_WF1_BPHLCD1(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF1_BPHLCD1) & BM_LCD_WF1_BPHLCD1)

/*! @brief Set the BPHLCD1 field to a new value. */
#define BW_LCD_WF1_BPHLCD1(x, v) (BME_BFI8(HW_LCD_WF1_ADDR(x), ((uint8_t)(v) << BP_LCD_WF1_BPHLCD1), BP_LCD_WF1_BPHLCD1, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF2 - LCD Waveform Register 2.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF2 - LCD Waveform Register 2. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf2
{
    uint8_t U;
    struct _hw_lcd_wf2_bitfields
    {
        uint8_t BPALCD2 : 1;           /*!< [0]  */
        uint8_t BPBLCD2 : 1;           /*!< [1]  */
        uint8_t BPCLCD2 : 1;           /*!< [2]  */
        uint8_t BPDLCD2 : 1;           /*!< [3]  */
        uint8_t BPELCD2 : 1;           /*!< [4]  */
        uint8_t BPFLCD2 : 1;           /*!< [5]  */
        uint8_t BPGLCD2 : 1;           /*!< [6]  */
        uint8_t BPHLCD2 : 1;           /*!< [7]  */
    } B;
} hw_lcd_wf2_t;

/*!
 * @name Constants and macros for entire LCD_WF2 register
 */
/*@{*/
#define HW_LCD_WF2_ADDR(x)       ((uint32_t)(x) + 0x22U)

#define HW_LCD_WF2(x)            (*(__IO hw_lcd_wf2_t *) HW_LCD_WF2_ADDR(x))
#define HW_LCD_WF2_RD(x)         (HW_LCD_WF2(x).U)
#define HW_LCD_WF2_WR(x, v)      (HW_LCD_WF2(x).U = (v))
#define HW_LCD_WF2_SET(x, v)     (BME_OR8(HW_LCD_WF2_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF2_CLR(x, v)     (BME_AND8(HW_LCD_WF2_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF2_TOG(x, v)     (BME_XOR8(HW_LCD_WF2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF2 bitfields
 */

/*!
 * @name Register LCD_WF2, field BPALCD2[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF2_BPALCD2   (0U)          /*!< Bit position for LCD_WF2_BPALCD2. */
#define BM_LCD_WF2_BPALCD2   (0x01U)       /*!< Bit mask for LCD_WF2_BPALCD2. */
#define BS_LCD_WF2_BPALCD2   (1U)          /*!< Bit field size in bits for LCD_WF2_BPALCD2. */

/*! @brief Read current value of the LCD_WF2_BPALCD2 field. */
#define BR_LCD_WF2_BPALCD2(x) (BME_UBFX8(HW_LCD_WF2_ADDR(x), BP_LCD_WF2_BPALCD2, BS_LCD_WF2_BPALCD2))

/*! @brief Format value for bitfield LCD_WF2_BPALCD2. */
#define BF_LCD_WF2_BPALCD2(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF2_BPALCD2) & BM_LCD_WF2_BPALCD2)

/*! @brief Set the BPALCD2 field to a new value. */
#define BW_LCD_WF2_BPALCD2(x, v) (BME_BFI8(HW_LCD_WF2_ADDR(x), ((uint8_t)(v) << BP_LCD_WF2_BPALCD2), BP_LCD_WF2_BPALCD2, 1))
/*@}*/

/*!
 * @name Register LCD_WF2, field BPBLCD2[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF2_BPBLCD2   (1U)          /*!< Bit position for LCD_WF2_BPBLCD2. */
#define BM_LCD_WF2_BPBLCD2   (0x02U)       /*!< Bit mask for LCD_WF2_BPBLCD2. */
#define BS_LCD_WF2_BPBLCD2   (1U)          /*!< Bit field size in bits for LCD_WF2_BPBLCD2. */

/*! @brief Read current value of the LCD_WF2_BPBLCD2 field. */
#define BR_LCD_WF2_BPBLCD2(x) (BME_UBFX8(HW_LCD_WF2_ADDR(x), BP_LCD_WF2_BPBLCD2, BS_LCD_WF2_BPBLCD2))

/*! @brief Format value for bitfield LCD_WF2_BPBLCD2. */
#define BF_LCD_WF2_BPBLCD2(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF2_BPBLCD2) & BM_LCD_WF2_BPBLCD2)

/*! @brief Set the BPBLCD2 field to a new value. */
#define BW_LCD_WF2_BPBLCD2(x, v) (BME_BFI8(HW_LCD_WF2_ADDR(x), ((uint8_t)(v) << BP_LCD_WF2_BPBLCD2), BP_LCD_WF2_BPBLCD2, 1))
/*@}*/

/*!
 * @name Register LCD_WF2, field BPCLCD2[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF2_BPCLCD2   (2U)          /*!< Bit position for LCD_WF2_BPCLCD2. */
#define BM_LCD_WF2_BPCLCD2   (0x04U)       /*!< Bit mask for LCD_WF2_BPCLCD2. */
#define BS_LCD_WF2_BPCLCD2   (1U)          /*!< Bit field size in bits for LCD_WF2_BPCLCD2. */

/*! @brief Read current value of the LCD_WF2_BPCLCD2 field. */
#define BR_LCD_WF2_BPCLCD2(x) (BME_UBFX8(HW_LCD_WF2_ADDR(x), BP_LCD_WF2_BPCLCD2, BS_LCD_WF2_BPCLCD2))

/*! @brief Format value for bitfield LCD_WF2_BPCLCD2. */
#define BF_LCD_WF2_BPCLCD2(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF2_BPCLCD2) & BM_LCD_WF2_BPCLCD2)

/*! @brief Set the BPCLCD2 field to a new value. */
#define BW_LCD_WF2_BPCLCD2(x, v) (BME_BFI8(HW_LCD_WF2_ADDR(x), ((uint8_t)(v) << BP_LCD_WF2_BPCLCD2), BP_LCD_WF2_BPCLCD2, 1))
/*@}*/

/*!
 * @name Register LCD_WF2, field BPDLCD2[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF2_BPDLCD2   (3U)          /*!< Bit position for LCD_WF2_BPDLCD2. */
#define BM_LCD_WF2_BPDLCD2   (0x08U)       /*!< Bit mask for LCD_WF2_BPDLCD2. */
#define BS_LCD_WF2_BPDLCD2   (1U)          /*!< Bit field size in bits for LCD_WF2_BPDLCD2. */

/*! @brief Read current value of the LCD_WF2_BPDLCD2 field. */
#define BR_LCD_WF2_BPDLCD2(x) (BME_UBFX8(HW_LCD_WF2_ADDR(x), BP_LCD_WF2_BPDLCD2, BS_LCD_WF2_BPDLCD2))

/*! @brief Format value for bitfield LCD_WF2_BPDLCD2. */
#define BF_LCD_WF2_BPDLCD2(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF2_BPDLCD2) & BM_LCD_WF2_BPDLCD2)

/*! @brief Set the BPDLCD2 field to a new value. */
#define BW_LCD_WF2_BPDLCD2(x, v) (BME_BFI8(HW_LCD_WF2_ADDR(x), ((uint8_t)(v) << BP_LCD_WF2_BPDLCD2), BP_LCD_WF2_BPDLCD2, 1))
/*@}*/

/*!
 * @name Register LCD_WF2, field BPELCD2[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF2_BPELCD2   (4U)          /*!< Bit position for LCD_WF2_BPELCD2. */
#define BM_LCD_WF2_BPELCD2   (0x10U)       /*!< Bit mask for LCD_WF2_BPELCD2. */
#define BS_LCD_WF2_BPELCD2   (1U)          /*!< Bit field size in bits for LCD_WF2_BPELCD2. */

/*! @brief Read current value of the LCD_WF2_BPELCD2 field. */
#define BR_LCD_WF2_BPELCD2(x) (BME_UBFX8(HW_LCD_WF2_ADDR(x), BP_LCD_WF2_BPELCD2, BS_LCD_WF2_BPELCD2))

/*! @brief Format value for bitfield LCD_WF2_BPELCD2. */
#define BF_LCD_WF2_BPELCD2(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF2_BPELCD2) & BM_LCD_WF2_BPELCD2)

/*! @brief Set the BPELCD2 field to a new value. */
#define BW_LCD_WF2_BPELCD2(x, v) (BME_BFI8(HW_LCD_WF2_ADDR(x), ((uint8_t)(v) << BP_LCD_WF2_BPELCD2), BP_LCD_WF2_BPELCD2, 1))
/*@}*/

/*!
 * @name Register LCD_WF2, field BPFLCD2[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF2_BPFLCD2   (5U)          /*!< Bit position for LCD_WF2_BPFLCD2. */
#define BM_LCD_WF2_BPFLCD2   (0x20U)       /*!< Bit mask for LCD_WF2_BPFLCD2. */
#define BS_LCD_WF2_BPFLCD2   (1U)          /*!< Bit field size in bits for LCD_WF2_BPFLCD2. */

/*! @brief Read current value of the LCD_WF2_BPFLCD2 field. */
#define BR_LCD_WF2_BPFLCD2(x) (BME_UBFX8(HW_LCD_WF2_ADDR(x), BP_LCD_WF2_BPFLCD2, BS_LCD_WF2_BPFLCD2))

/*! @brief Format value for bitfield LCD_WF2_BPFLCD2. */
#define BF_LCD_WF2_BPFLCD2(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF2_BPFLCD2) & BM_LCD_WF2_BPFLCD2)

/*! @brief Set the BPFLCD2 field to a new value. */
#define BW_LCD_WF2_BPFLCD2(x, v) (BME_BFI8(HW_LCD_WF2_ADDR(x), ((uint8_t)(v) << BP_LCD_WF2_BPFLCD2), BP_LCD_WF2_BPFLCD2, 1))
/*@}*/

/*!
 * @name Register LCD_WF2, field BPGLCD2[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF2_BPGLCD2   (6U)          /*!< Bit position for LCD_WF2_BPGLCD2. */
#define BM_LCD_WF2_BPGLCD2   (0x40U)       /*!< Bit mask for LCD_WF2_BPGLCD2. */
#define BS_LCD_WF2_BPGLCD2   (1U)          /*!< Bit field size in bits for LCD_WF2_BPGLCD2. */

/*! @brief Read current value of the LCD_WF2_BPGLCD2 field. */
#define BR_LCD_WF2_BPGLCD2(x) (BME_UBFX8(HW_LCD_WF2_ADDR(x), BP_LCD_WF2_BPGLCD2, BS_LCD_WF2_BPGLCD2))

/*! @brief Format value for bitfield LCD_WF2_BPGLCD2. */
#define BF_LCD_WF2_BPGLCD2(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF2_BPGLCD2) & BM_LCD_WF2_BPGLCD2)

/*! @brief Set the BPGLCD2 field to a new value. */
#define BW_LCD_WF2_BPGLCD2(x, v) (BME_BFI8(HW_LCD_WF2_ADDR(x), ((uint8_t)(v) << BP_LCD_WF2_BPGLCD2), BP_LCD_WF2_BPGLCD2, 1))
/*@}*/

/*!
 * @name Register LCD_WF2, field BPHLCD2[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF2_BPHLCD2   (7U)          /*!< Bit position for LCD_WF2_BPHLCD2. */
#define BM_LCD_WF2_BPHLCD2   (0x80U)       /*!< Bit mask for LCD_WF2_BPHLCD2. */
#define BS_LCD_WF2_BPHLCD2   (1U)          /*!< Bit field size in bits for LCD_WF2_BPHLCD2. */

/*! @brief Read current value of the LCD_WF2_BPHLCD2 field. */
#define BR_LCD_WF2_BPHLCD2(x) (BME_UBFX8(HW_LCD_WF2_ADDR(x), BP_LCD_WF2_BPHLCD2, BS_LCD_WF2_BPHLCD2))

/*! @brief Format value for bitfield LCD_WF2_BPHLCD2. */
#define BF_LCD_WF2_BPHLCD2(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF2_BPHLCD2) & BM_LCD_WF2_BPHLCD2)

/*! @brief Set the BPHLCD2 field to a new value. */
#define BW_LCD_WF2_BPHLCD2(x, v) (BME_BFI8(HW_LCD_WF2_ADDR(x), ((uint8_t)(v) << BP_LCD_WF2_BPHLCD2), BP_LCD_WF2_BPHLCD2, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF3 - LCD Waveform Register 3.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF3 - LCD Waveform Register 3. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf3
{
    uint8_t U;
    struct _hw_lcd_wf3_bitfields
    {
        uint8_t BPALCD3 : 1;           /*!< [0]  */
        uint8_t BPBLCD3 : 1;           /*!< [1]  */
        uint8_t BPCLCD3 : 1;           /*!< [2]  */
        uint8_t BPDLCD3 : 1;           /*!< [3]  */
        uint8_t BPELCD3 : 1;           /*!< [4]  */
        uint8_t BPFLCD3 : 1;           /*!< [5]  */
        uint8_t BPGLCD3 : 1;           /*!< [6]  */
        uint8_t BPHLCD3 : 1;           /*!< [7]  */
    } B;
} hw_lcd_wf3_t;

/*!
 * @name Constants and macros for entire LCD_WF3 register
 */
/*@{*/
#define HW_LCD_WF3_ADDR(x)       ((uint32_t)(x) + 0x23U)

#define HW_LCD_WF3(x)            (*(__IO hw_lcd_wf3_t *) HW_LCD_WF3_ADDR(x))
#define HW_LCD_WF3_RD(x)         (HW_LCD_WF3(x).U)
#define HW_LCD_WF3_WR(x, v)      (HW_LCD_WF3(x).U = (v))
#define HW_LCD_WF3_SET(x, v)     (BME_OR8(HW_LCD_WF3_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF3_CLR(x, v)     (BME_AND8(HW_LCD_WF3_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF3_TOG(x, v)     (BME_XOR8(HW_LCD_WF3_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF3 bitfields
 */

/*!
 * @name Register LCD_WF3, field BPALCD3[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF3_BPALCD3   (0U)          /*!< Bit position for LCD_WF3_BPALCD3. */
#define BM_LCD_WF3_BPALCD3   (0x01U)       /*!< Bit mask for LCD_WF3_BPALCD3. */
#define BS_LCD_WF3_BPALCD3   (1U)          /*!< Bit field size in bits for LCD_WF3_BPALCD3. */

/*! @brief Read current value of the LCD_WF3_BPALCD3 field. */
#define BR_LCD_WF3_BPALCD3(x) (BME_UBFX8(HW_LCD_WF3_ADDR(x), BP_LCD_WF3_BPALCD3, BS_LCD_WF3_BPALCD3))

/*! @brief Format value for bitfield LCD_WF3_BPALCD3. */
#define BF_LCD_WF3_BPALCD3(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF3_BPALCD3) & BM_LCD_WF3_BPALCD3)

/*! @brief Set the BPALCD3 field to a new value. */
#define BW_LCD_WF3_BPALCD3(x, v) (BME_BFI8(HW_LCD_WF3_ADDR(x), ((uint8_t)(v) << BP_LCD_WF3_BPALCD3), BP_LCD_WF3_BPALCD3, 1))
/*@}*/

/*!
 * @name Register LCD_WF3, field BPBLCD3[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF3_BPBLCD3   (1U)          /*!< Bit position for LCD_WF3_BPBLCD3. */
#define BM_LCD_WF3_BPBLCD3   (0x02U)       /*!< Bit mask for LCD_WF3_BPBLCD3. */
#define BS_LCD_WF3_BPBLCD3   (1U)          /*!< Bit field size in bits for LCD_WF3_BPBLCD3. */

/*! @brief Read current value of the LCD_WF3_BPBLCD3 field. */
#define BR_LCD_WF3_BPBLCD3(x) (BME_UBFX8(HW_LCD_WF3_ADDR(x), BP_LCD_WF3_BPBLCD3, BS_LCD_WF3_BPBLCD3))

/*! @brief Format value for bitfield LCD_WF3_BPBLCD3. */
#define BF_LCD_WF3_BPBLCD3(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF3_BPBLCD3) & BM_LCD_WF3_BPBLCD3)

/*! @brief Set the BPBLCD3 field to a new value. */
#define BW_LCD_WF3_BPBLCD3(x, v) (BME_BFI8(HW_LCD_WF3_ADDR(x), ((uint8_t)(v) << BP_LCD_WF3_BPBLCD3), BP_LCD_WF3_BPBLCD3, 1))
/*@}*/

/*!
 * @name Register LCD_WF3, field BPCLCD3[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF3_BPCLCD3   (2U)          /*!< Bit position for LCD_WF3_BPCLCD3. */
#define BM_LCD_WF3_BPCLCD3   (0x04U)       /*!< Bit mask for LCD_WF3_BPCLCD3. */
#define BS_LCD_WF3_BPCLCD3   (1U)          /*!< Bit field size in bits for LCD_WF3_BPCLCD3. */

/*! @brief Read current value of the LCD_WF3_BPCLCD3 field. */
#define BR_LCD_WF3_BPCLCD3(x) (BME_UBFX8(HW_LCD_WF3_ADDR(x), BP_LCD_WF3_BPCLCD3, BS_LCD_WF3_BPCLCD3))

/*! @brief Format value for bitfield LCD_WF3_BPCLCD3. */
#define BF_LCD_WF3_BPCLCD3(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF3_BPCLCD3) & BM_LCD_WF3_BPCLCD3)

/*! @brief Set the BPCLCD3 field to a new value. */
#define BW_LCD_WF3_BPCLCD3(x, v) (BME_BFI8(HW_LCD_WF3_ADDR(x), ((uint8_t)(v) << BP_LCD_WF3_BPCLCD3), BP_LCD_WF3_BPCLCD3, 1))
/*@}*/

/*!
 * @name Register LCD_WF3, field BPDLCD3[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF3_BPDLCD3   (3U)          /*!< Bit position for LCD_WF3_BPDLCD3. */
#define BM_LCD_WF3_BPDLCD3   (0x08U)       /*!< Bit mask for LCD_WF3_BPDLCD3. */
#define BS_LCD_WF3_BPDLCD3   (1U)          /*!< Bit field size in bits for LCD_WF3_BPDLCD3. */

/*! @brief Read current value of the LCD_WF3_BPDLCD3 field. */
#define BR_LCD_WF3_BPDLCD3(x) (BME_UBFX8(HW_LCD_WF3_ADDR(x), BP_LCD_WF3_BPDLCD3, BS_LCD_WF3_BPDLCD3))

/*! @brief Format value for bitfield LCD_WF3_BPDLCD3. */
#define BF_LCD_WF3_BPDLCD3(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF3_BPDLCD3) & BM_LCD_WF3_BPDLCD3)

/*! @brief Set the BPDLCD3 field to a new value. */
#define BW_LCD_WF3_BPDLCD3(x, v) (BME_BFI8(HW_LCD_WF3_ADDR(x), ((uint8_t)(v) << BP_LCD_WF3_BPDLCD3), BP_LCD_WF3_BPDLCD3, 1))
/*@}*/

/*!
 * @name Register LCD_WF3, field BPELCD3[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF3_BPELCD3   (4U)          /*!< Bit position for LCD_WF3_BPELCD3. */
#define BM_LCD_WF3_BPELCD3   (0x10U)       /*!< Bit mask for LCD_WF3_BPELCD3. */
#define BS_LCD_WF3_BPELCD3   (1U)          /*!< Bit field size in bits for LCD_WF3_BPELCD3. */

/*! @brief Read current value of the LCD_WF3_BPELCD3 field. */
#define BR_LCD_WF3_BPELCD3(x) (BME_UBFX8(HW_LCD_WF3_ADDR(x), BP_LCD_WF3_BPELCD3, BS_LCD_WF3_BPELCD3))

/*! @brief Format value for bitfield LCD_WF3_BPELCD3. */
#define BF_LCD_WF3_BPELCD3(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF3_BPELCD3) & BM_LCD_WF3_BPELCD3)

/*! @brief Set the BPELCD3 field to a new value. */
#define BW_LCD_WF3_BPELCD3(x, v) (BME_BFI8(HW_LCD_WF3_ADDR(x), ((uint8_t)(v) << BP_LCD_WF3_BPELCD3), BP_LCD_WF3_BPELCD3, 1))
/*@}*/

/*!
 * @name Register LCD_WF3, field BPFLCD3[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF3_BPFLCD3   (5U)          /*!< Bit position for LCD_WF3_BPFLCD3. */
#define BM_LCD_WF3_BPFLCD3   (0x20U)       /*!< Bit mask for LCD_WF3_BPFLCD3. */
#define BS_LCD_WF3_BPFLCD3   (1U)          /*!< Bit field size in bits for LCD_WF3_BPFLCD3. */

/*! @brief Read current value of the LCD_WF3_BPFLCD3 field. */
#define BR_LCD_WF3_BPFLCD3(x) (BME_UBFX8(HW_LCD_WF3_ADDR(x), BP_LCD_WF3_BPFLCD3, BS_LCD_WF3_BPFLCD3))

/*! @brief Format value for bitfield LCD_WF3_BPFLCD3. */
#define BF_LCD_WF3_BPFLCD3(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF3_BPFLCD3) & BM_LCD_WF3_BPFLCD3)

/*! @brief Set the BPFLCD3 field to a new value. */
#define BW_LCD_WF3_BPFLCD3(x, v) (BME_BFI8(HW_LCD_WF3_ADDR(x), ((uint8_t)(v) << BP_LCD_WF3_BPFLCD3), BP_LCD_WF3_BPFLCD3, 1))
/*@}*/

/*!
 * @name Register LCD_WF3, field BPGLCD3[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF3_BPGLCD3   (6U)          /*!< Bit position for LCD_WF3_BPGLCD3. */
#define BM_LCD_WF3_BPGLCD3   (0x40U)       /*!< Bit mask for LCD_WF3_BPGLCD3. */
#define BS_LCD_WF3_BPGLCD3   (1U)          /*!< Bit field size in bits for LCD_WF3_BPGLCD3. */

/*! @brief Read current value of the LCD_WF3_BPGLCD3 field. */
#define BR_LCD_WF3_BPGLCD3(x) (BME_UBFX8(HW_LCD_WF3_ADDR(x), BP_LCD_WF3_BPGLCD3, BS_LCD_WF3_BPGLCD3))

/*! @brief Format value for bitfield LCD_WF3_BPGLCD3. */
#define BF_LCD_WF3_BPGLCD3(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF3_BPGLCD3) & BM_LCD_WF3_BPGLCD3)

/*! @brief Set the BPGLCD3 field to a new value. */
#define BW_LCD_WF3_BPGLCD3(x, v) (BME_BFI8(HW_LCD_WF3_ADDR(x), ((uint8_t)(v) << BP_LCD_WF3_BPGLCD3), BP_LCD_WF3_BPGLCD3, 1))
/*@}*/

/*!
 * @name Register LCD_WF3, field BPHLCD3[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF3_BPHLCD3   (7U)          /*!< Bit position for LCD_WF3_BPHLCD3. */
#define BM_LCD_WF3_BPHLCD3   (0x80U)       /*!< Bit mask for LCD_WF3_BPHLCD3. */
#define BS_LCD_WF3_BPHLCD3   (1U)          /*!< Bit field size in bits for LCD_WF3_BPHLCD3. */

/*! @brief Read current value of the LCD_WF3_BPHLCD3 field. */
#define BR_LCD_WF3_BPHLCD3(x) (BME_UBFX8(HW_LCD_WF3_ADDR(x), BP_LCD_WF3_BPHLCD3, BS_LCD_WF3_BPHLCD3))

/*! @brief Format value for bitfield LCD_WF3_BPHLCD3. */
#define BF_LCD_WF3_BPHLCD3(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF3_BPHLCD3) & BM_LCD_WF3_BPHLCD3)

/*! @brief Set the BPHLCD3 field to a new value. */
#define BW_LCD_WF3_BPHLCD3(x, v) (BME_BFI8(HW_LCD_WF3_ADDR(x), ((uint8_t)(v) << BP_LCD_WF3_BPHLCD3), BP_LCD_WF3_BPHLCD3, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF4 - LCD Waveform Register 4.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF4 - LCD Waveform Register 4. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf4
{
    uint8_t U;
    struct _hw_lcd_wf4_bitfields
    {
        uint8_t BPALCD4 : 1;           /*!< [0]  */
        uint8_t BPBLCD4 : 1;           /*!< [1]  */
        uint8_t BPCLCD4 : 1;           /*!< [2]  */
        uint8_t BPDLCD4 : 1;           /*!< [3]  */
        uint8_t BPELCD4 : 1;           /*!< [4]  */
        uint8_t BPFLCD4 : 1;           /*!< [5]  */
        uint8_t BPGLCD4 : 1;           /*!< [6]  */
        uint8_t BPHLCD4 : 1;           /*!< [7]  */
    } B;
} hw_lcd_wf4_t;

/*!
 * @name Constants and macros for entire LCD_WF4 register
 */
/*@{*/
#define HW_LCD_WF4_ADDR(x)       ((uint32_t)(x) + 0x24U)

#define HW_LCD_WF4(x)            (*(__IO hw_lcd_wf4_t *) HW_LCD_WF4_ADDR(x))
#define HW_LCD_WF4_RD(x)         (HW_LCD_WF4(x).U)
#define HW_LCD_WF4_WR(x, v)      (HW_LCD_WF4(x).U = (v))
#define HW_LCD_WF4_SET(x, v)     (BME_OR8(HW_LCD_WF4_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF4_CLR(x, v)     (BME_AND8(HW_LCD_WF4_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF4_TOG(x, v)     (BME_XOR8(HW_LCD_WF4_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF4 bitfields
 */

/*!
 * @name Register LCD_WF4, field BPALCD4[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF4_BPALCD4   (0U)          /*!< Bit position for LCD_WF4_BPALCD4. */
#define BM_LCD_WF4_BPALCD4   (0x01U)       /*!< Bit mask for LCD_WF4_BPALCD4. */
#define BS_LCD_WF4_BPALCD4   (1U)          /*!< Bit field size in bits for LCD_WF4_BPALCD4. */

/*! @brief Read current value of the LCD_WF4_BPALCD4 field. */
#define BR_LCD_WF4_BPALCD4(x) (BME_UBFX8(HW_LCD_WF4_ADDR(x), BP_LCD_WF4_BPALCD4, BS_LCD_WF4_BPALCD4))

/*! @brief Format value for bitfield LCD_WF4_BPALCD4. */
#define BF_LCD_WF4_BPALCD4(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF4_BPALCD4) & BM_LCD_WF4_BPALCD4)

/*! @brief Set the BPALCD4 field to a new value. */
#define BW_LCD_WF4_BPALCD4(x, v) (BME_BFI8(HW_LCD_WF4_ADDR(x), ((uint8_t)(v) << BP_LCD_WF4_BPALCD4), BP_LCD_WF4_BPALCD4, 1))
/*@}*/

/*!
 * @name Register LCD_WF4, field BPBLCD4[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF4_BPBLCD4   (1U)          /*!< Bit position for LCD_WF4_BPBLCD4. */
#define BM_LCD_WF4_BPBLCD4   (0x02U)       /*!< Bit mask for LCD_WF4_BPBLCD4. */
#define BS_LCD_WF4_BPBLCD4   (1U)          /*!< Bit field size in bits for LCD_WF4_BPBLCD4. */

/*! @brief Read current value of the LCD_WF4_BPBLCD4 field. */
#define BR_LCD_WF4_BPBLCD4(x) (BME_UBFX8(HW_LCD_WF4_ADDR(x), BP_LCD_WF4_BPBLCD4, BS_LCD_WF4_BPBLCD4))

/*! @brief Format value for bitfield LCD_WF4_BPBLCD4. */
#define BF_LCD_WF4_BPBLCD4(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF4_BPBLCD4) & BM_LCD_WF4_BPBLCD4)

/*! @brief Set the BPBLCD4 field to a new value. */
#define BW_LCD_WF4_BPBLCD4(x, v) (BME_BFI8(HW_LCD_WF4_ADDR(x), ((uint8_t)(v) << BP_LCD_WF4_BPBLCD4), BP_LCD_WF4_BPBLCD4, 1))
/*@}*/

/*!
 * @name Register LCD_WF4, field BPCLCD4[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF4_BPCLCD4   (2U)          /*!< Bit position for LCD_WF4_BPCLCD4. */
#define BM_LCD_WF4_BPCLCD4   (0x04U)       /*!< Bit mask for LCD_WF4_BPCLCD4. */
#define BS_LCD_WF4_BPCLCD4   (1U)          /*!< Bit field size in bits for LCD_WF4_BPCLCD4. */

/*! @brief Read current value of the LCD_WF4_BPCLCD4 field. */
#define BR_LCD_WF4_BPCLCD4(x) (BME_UBFX8(HW_LCD_WF4_ADDR(x), BP_LCD_WF4_BPCLCD4, BS_LCD_WF4_BPCLCD4))

/*! @brief Format value for bitfield LCD_WF4_BPCLCD4. */
#define BF_LCD_WF4_BPCLCD4(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF4_BPCLCD4) & BM_LCD_WF4_BPCLCD4)

/*! @brief Set the BPCLCD4 field to a new value. */
#define BW_LCD_WF4_BPCLCD4(x, v) (BME_BFI8(HW_LCD_WF4_ADDR(x), ((uint8_t)(v) << BP_LCD_WF4_BPCLCD4), BP_LCD_WF4_BPCLCD4, 1))
/*@}*/

/*!
 * @name Register LCD_WF4, field BPDLCD4[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF4_BPDLCD4   (3U)          /*!< Bit position for LCD_WF4_BPDLCD4. */
#define BM_LCD_WF4_BPDLCD4   (0x08U)       /*!< Bit mask for LCD_WF4_BPDLCD4. */
#define BS_LCD_WF4_BPDLCD4   (1U)          /*!< Bit field size in bits for LCD_WF4_BPDLCD4. */

/*! @brief Read current value of the LCD_WF4_BPDLCD4 field. */
#define BR_LCD_WF4_BPDLCD4(x) (BME_UBFX8(HW_LCD_WF4_ADDR(x), BP_LCD_WF4_BPDLCD4, BS_LCD_WF4_BPDLCD4))

/*! @brief Format value for bitfield LCD_WF4_BPDLCD4. */
#define BF_LCD_WF4_BPDLCD4(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF4_BPDLCD4) & BM_LCD_WF4_BPDLCD4)

/*! @brief Set the BPDLCD4 field to a new value. */
#define BW_LCD_WF4_BPDLCD4(x, v) (BME_BFI8(HW_LCD_WF4_ADDR(x), ((uint8_t)(v) << BP_LCD_WF4_BPDLCD4), BP_LCD_WF4_BPDLCD4, 1))
/*@}*/

/*!
 * @name Register LCD_WF4, field BPELCD4[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF4_BPELCD4   (4U)          /*!< Bit position for LCD_WF4_BPELCD4. */
#define BM_LCD_WF4_BPELCD4   (0x10U)       /*!< Bit mask for LCD_WF4_BPELCD4. */
#define BS_LCD_WF4_BPELCD4   (1U)          /*!< Bit field size in bits for LCD_WF4_BPELCD4. */

/*! @brief Read current value of the LCD_WF4_BPELCD4 field. */
#define BR_LCD_WF4_BPELCD4(x) (BME_UBFX8(HW_LCD_WF4_ADDR(x), BP_LCD_WF4_BPELCD4, BS_LCD_WF4_BPELCD4))

/*! @brief Format value for bitfield LCD_WF4_BPELCD4. */
#define BF_LCD_WF4_BPELCD4(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF4_BPELCD4) & BM_LCD_WF4_BPELCD4)

/*! @brief Set the BPELCD4 field to a new value. */
#define BW_LCD_WF4_BPELCD4(x, v) (BME_BFI8(HW_LCD_WF4_ADDR(x), ((uint8_t)(v) << BP_LCD_WF4_BPELCD4), BP_LCD_WF4_BPELCD4, 1))
/*@}*/

/*!
 * @name Register LCD_WF4, field BPFLCD4[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF4_BPFLCD4   (5U)          /*!< Bit position for LCD_WF4_BPFLCD4. */
#define BM_LCD_WF4_BPFLCD4   (0x20U)       /*!< Bit mask for LCD_WF4_BPFLCD4. */
#define BS_LCD_WF4_BPFLCD4   (1U)          /*!< Bit field size in bits for LCD_WF4_BPFLCD4. */

/*! @brief Read current value of the LCD_WF4_BPFLCD4 field. */
#define BR_LCD_WF4_BPFLCD4(x) (BME_UBFX8(HW_LCD_WF4_ADDR(x), BP_LCD_WF4_BPFLCD4, BS_LCD_WF4_BPFLCD4))

/*! @brief Format value for bitfield LCD_WF4_BPFLCD4. */
#define BF_LCD_WF4_BPFLCD4(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF4_BPFLCD4) & BM_LCD_WF4_BPFLCD4)

/*! @brief Set the BPFLCD4 field to a new value. */
#define BW_LCD_WF4_BPFLCD4(x, v) (BME_BFI8(HW_LCD_WF4_ADDR(x), ((uint8_t)(v) << BP_LCD_WF4_BPFLCD4), BP_LCD_WF4_BPFLCD4, 1))
/*@}*/

/*!
 * @name Register LCD_WF4, field BPGLCD4[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF4_BPGLCD4   (6U)          /*!< Bit position for LCD_WF4_BPGLCD4. */
#define BM_LCD_WF4_BPGLCD4   (0x40U)       /*!< Bit mask for LCD_WF4_BPGLCD4. */
#define BS_LCD_WF4_BPGLCD4   (1U)          /*!< Bit field size in bits for LCD_WF4_BPGLCD4. */

/*! @brief Read current value of the LCD_WF4_BPGLCD4 field. */
#define BR_LCD_WF4_BPGLCD4(x) (BME_UBFX8(HW_LCD_WF4_ADDR(x), BP_LCD_WF4_BPGLCD4, BS_LCD_WF4_BPGLCD4))

/*! @brief Format value for bitfield LCD_WF4_BPGLCD4. */
#define BF_LCD_WF4_BPGLCD4(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF4_BPGLCD4) & BM_LCD_WF4_BPGLCD4)

/*! @brief Set the BPGLCD4 field to a new value. */
#define BW_LCD_WF4_BPGLCD4(x, v) (BME_BFI8(HW_LCD_WF4_ADDR(x), ((uint8_t)(v) << BP_LCD_WF4_BPGLCD4), BP_LCD_WF4_BPGLCD4, 1))
/*@}*/

/*!
 * @name Register LCD_WF4, field BPHLCD4[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF4_BPHLCD4   (7U)          /*!< Bit position for LCD_WF4_BPHLCD4. */
#define BM_LCD_WF4_BPHLCD4   (0x80U)       /*!< Bit mask for LCD_WF4_BPHLCD4. */
#define BS_LCD_WF4_BPHLCD4   (1U)          /*!< Bit field size in bits for LCD_WF4_BPHLCD4. */

/*! @brief Read current value of the LCD_WF4_BPHLCD4 field. */
#define BR_LCD_WF4_BPHLCD4(x) (BME_UBFX8(HW_LCD_WF4_ADDR(x), BP_LCD_WF4_BPHLCD4, BS_LCD_WF4_BPHLCD4))

/*! @brief Format value for bitfield LCD_WF4_BPHLCD4. */
#define BF_LCD_WF4_BPHLCD4(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF4_BPHLCD4) & BM_LCD_WF4_BPHLCD4)

/*! @brief Set the BPHLCD4 field to a new value. */
#define BW_LCD_WF4_BPHLCD4(x, v) (BME_BFI8(HW_LCD_WF4_ADDR(x), ((uint8_t)(v) << BP_LCD_WF4_BPHLCD4), BP_LCD_WF4_BPHLCD4, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF5 - LCD Waveform Register 5.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF5 - LCD Waveform Register 5. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf5
{
    uint8_t U;
    struct _hw_lcd_wf5_bitfields
    {
        uint8_t BPALCD5 : 1;           /*!< [0]  */
        uint8_t BPBLCD5 : 1;           /*!< [1]  */
        uint8_t BPCLCD5 : 1;           /*!< [2]  */
        uint8_t BPDLCD5 : 1;           /*!< [3]  */
        uint8_t BPELCD5 : 1;           /*!< [4]  */
        uint8_t BPFLCD5 : 1;           /*!< [5]  */
        uint8_t BPGLCD5 : 1;           /*!< [6]  */
        uint8_t BPHLCD5 : 1;           /*!< [7]  */
    } B;
} hw_lcd_wf5_t;

/*!
 * @name Constants and macros for entire LCD_WF5 register
 */
/*@{*/
#define HW_LCD_WF5_ADDR(x)       ((uint32_t)(x) + 0x25U)

#define HW_LCD_WF5(x)            (*(__IO hw_lcd_wf5_t *) HW_LCD_WF5_ADDR(x))
#define HW_LCD_WF5_RD(x)         (HW_LCD_WF5(x).U)
#define HW_LCD_WF5_WR(x, v)      (HW_LCD_WF5(x).U = (v))
#define HW_LCD_WF5_SET(x, v)     (BME_OR8(HW_LCD_WF5_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF5_CLR(x, v)     (BME_AND8(HW_LCD_WF5_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF5_TOG(x, v)     (BME_XOR8(HW_LCD_WF5_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF5 bitfields
 */

/*!
 * @name Register LCD_WF5, field BPALCD5[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF5_BPALCD5   (0U)          /*!< Bit position for LCD_WF5_BPALCD5. */
#define BM_LCD_WF5_BPALCD5   (0x01U)       /*!< Bit mask for LCD_WF5_BPALCD5. */
#define BS_LCD_WF5_BPALCD5   (1U)          /*!< Bit field size in bits for LCD_WF5_BPALCD5. */

/*! @brief Read current value of the LCD_WF5_BPALCD5 field. */
#define BR_LCD_WF5_BPALCD5(x) (BME_UBFX8(HW_LCD_WF5_ADDR(x), BP_LCD_WF5_BPALCD5, BS_LCD_WF5_BPALCD5))

/*! @brief Format value for bitfield LCD_WF5_BPALCD5. */
#define BF_LCD_WF5_BPALCD5(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF5_BPALCD5) & BM_LCD_WF5_BPALCD5)

/*! @brief Set the BPALCD5 field to a new value. */
#define BW_LCD_WF5_BPALCD5(x, v) (BME_BFI8(HW_LCD_WF5_ADDR(x), ((uint8_t)(v) << BP_LCD_WF5_BPALCD5), BP_LCD_WF5_BPALCD5, 1))
/*@}*/

/*!
 * @name Register LCD_WF5, field BPBLCD5[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF5_BPBLCD5   (1U)          /*!< Bit position for LCD_WF5_BPBLCD5. */
#define BM_LCD_WF5_BPBLCD5   (0x02U)       /*!< Bit mask for LCD_WF5_BPBLCD5. */
#define BS_LCD_WF5_BPBLCD5   (1U)          /*!< Bit field size in bits for LCD_WF5_BPBLCD5. */

/*! @brief Read current value of the LCD_WF5_BPBLCD5 field. */
#define BR_LCD_WF5_BPBLCD5(x) (BME_UBFX8(HW_LCD_WF5_ADDR(x), BP_LCD_WF5_BPBLCD5, BS_LCD_WF5_BPBLCD5))

/*! @brief Format value for bitfield LCD_WF5_BPBLCD5. */
#define BF_LCD_WF5_BPBLCD5(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF5_BPBLCD5) & BM_LCD_WF5_BPBLCD5)

/*! @brief Set the BPBLCD5 field to a new value. */
#define BW_LCD_WF5_BPBLCD5(x, v) (BME_BFI8(HW_LCD_WF5_ADDR(x), ((uint8_t)(v) << BP_LCD_WF5_BPBLCD5), BP_LCD_WF5_BPBLCD5, 1))
/*@}*/

/*!
 * @name Register LCD_WF5, field BPCLCD5[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF5_BPCLCD5   (2U)          /*!< Bit position for LCD_WF5_BPCLCD5. */
#define BM_LCD_WF5_BPCLCD5   (0x04U)       /*!< Bit mask for LCD_WF5_BPCLCD5. */
#define BS_LCD_WF5_BPCLCD5   (1U)          /*!< Bit field size in bits for LCD_WF5_BPCLCD5. */

/*! @brief Read current value of the LCD_WF5_BPCLCD5 field. */
#define BR_LCD_WF5_BPCLCD5(x) (BME_UBFX8(HW_LCD_WF5_ADDR(x), BP_LCD_WF5_BPCLCD5, BS_LCD_WF5_BPCLCD5))

/*! @brief Format value for bitfield LCD_WF5_BPCLCD5. */
#define BF_LCD_WF5_BPCLCD5(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF5_BPCLCD5) & BM_LCD_WF5_BPCLCD5)

/*! @brief Set the BPCLCD5 field to a new value. */
#define BW_LCD_WF5_BPCLCD5(x, v) (BME_BFI8(HW_LCD_WF5_ADDR(x), ((uint8_t)(v) << BP_LCD_WF5_BPCLCD5), BP_LCD_WF5_BPCLCD5, 1))
/*@}*/

/*!
 * @name Register LCD_WF5, field BPDLCD5[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF5_BPDLCD5   (3U)          /*!< Bit position for LCD_WF5_BPDLCD5. */
#define BM_LCD_WF5_BPDLCD5   (0x08U)       /*!< Bit mask for LCD_WF5_BPDLCD5. */
#define BS_LCD_WF5_BPDLCD5   (1U)          /*!< Bit field size in bits for LCD_WF5_BPDLCD5. */

/*! @brief Read current value of the LCD_WF5_BPDLCD5 field. */
#define BR_LCD_WF5_BPDLCD5(x) (BME_UBFX8(HW_LCD_WF5_ADDR(x), BP_LCD_WF5_BPDLCD5, BS_LCD_WF5_BPDLCD5))

/*! @brief Format value for bitfield LCD_WF5_BPDLCD5. */
#define BF_LCD_WF5_BPDLCD5(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF5_BPDLCD5) & BM_LCD_WF5_BPDLCD5)

/*! @brief Set the BPDLCD5 field to a new value. */
#define BW_LCD_WF5_BPDLCD5(x, v) (BME_BFI8(HW_LCD_WF5_ADDR(x), ((uint8_t)(v) << BP_LCD_WF5_BPDLCD5), BP_LCD_WF5_BPDLCD5, 1))
/*@}*/

/*!
 * @name Register LCD_WF5, field BPELCD5[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF5_BPELCD5   (4U)          /*!< Bit position for LCD_WF5_BPELCD5. */
#define BM_LCD_WF5_BPELCD5   (0x10U)       /*!< Bit mask for LCD_WF5_BPELCD5. */
#define BS_LCD_WF5_BPELCD5   (1U)          /*!< Bit field size in bits for LCD_WF5_BPELCD5. */

/*! @brief Read current value of the LCD_WF5_BPELCD5 field. */
#define BR_LCD_WF5_BPELCD5(x) (BME_UBFX8(HW_LCD_WF5_ADDR(x), BP_LCD_WF5_BPELCD5, BS_LCD_WF5_BPELCD5))

/*! @brief Format value for bitfield LCD_WF5_BPELCD5. */
#define BF_LCD_WF5_BPELCD5(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF5_BPELCD5) & BM_LCD_WF5_BPELCD5)

/*! @brief Set the BPELCD5 field to a new value. */
#define BW_LCD_WF5_BPELCD5(x, v) (BME_BFI8(HW_LCD_WF5_ADDR(x), ((uint8_t)(v) << BP_LCD_WF5_BPELCD5), BP_LCD_WF5_BPELCD5, 1))
/*@}*/

/*!
 * @name Register LCD_WF5, field BPFLCD5[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF5_BPFLCD5   (5U)          /*!< Bit position for LCD_WF5_BPFLCD5. */
#define BM_LCD_WF5_BPFLCD5   (0x20U)       /*!< Bit mask for LCD_WF5_BPFLCD5. */
#define BS_LCD_WF5_BPFLCD5   (1U)          /*!< Bit field size in bits for LCD_WF5_BPFLCD5. */

/*! @brief Read current value of the LCD_WF5_BPFLCD5 field. */
#define BR_LCD_WF5_BPFLCD5(x) (BME_UBFX8(HW_LCD_WF5_ADDR(x), BP_LCD_WF5_BPFLCD5, BS_LCD_WF5_BPFLCD5))

/*! @brief Format value for bitfield LCD_WF5_BPFLCD5. */
#define BF_LCD_WF5_BPFLCD5(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF5_BPFLCD5) & BM_LCD_WF5_BPFLCD5)

/*! @brief Set the BPFLCD5 field to a new value. */
#define BW_LCD_WF5_BPFLCD5(x, v) (BME_BFI8(HW_LCD_WF5_ADDR(x), ((uint8_t)(v) << BP_LCD_WF5_BPFLCD5), BP_LCD_WF5_BPFLCD5, 1))
/*@}*/

/*!
 * @name Register LCD_WF5, field BPGLCD5[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF5_BPGLCD5   (6U)          /*!< Bit position for LCD_WF5_BPGLCD5. */
#define BM_LCD_WF5_BPGLCD5   (0x40U)       /*!< Bit mask for LCD_WF5_BPGLCD5. */
#define BS_LCD_WF5_BPGLCD5   (1U)          /*!< Bit field size in bits for LCD_WF5_BPGLCD5. */

/*! @brief Read current value of the LCD_WF5_BPGLCD5 field. */
#define BR_LCD_WF5_BPGLCD5(x) (BME_UBFX8(HW_LCD_WF5_ADDR(x), BP_LCD_WF5_BPGLCD5, BS_LCD_WF5_BPGLCD5))

/*! @brief Format value for bitfield LCD_WF5_BPGLCD5. */
#define BF_LCD_WF5_BPGLCD5(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF5_BPGLCD5) & BM_LCD_WF5_BPGLCD5)

/*! @brief Set the BPGLCD5 field to a new value. */
#define BW_LCD_WF5_BPGLCD5(x, v) (BME_BFI8(HW_LCD_WF5_ADDR(x), ((uint8_t)(v) << BP_LCD_WF5_BPGLCD5), BP_LCD_WF5_BPGLCD5, 1))
/*@}*/

/*!
 * @name Register LCD_WF5, field BPHLCD5[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF5_BPHLCD5   (7U)          /*!< Bit position for LCD_WF5_BPHLCD5. */
#define BM_LCD_WF5_BPHLCD5   (0x80U)       /*!< Bit mask for LCD_WF5_BPHLCD5. */
#define BS_LCD_WF5_BPHLCD5   (1U)          /*!< Bit field size in bits for LCD_WF5_BPHLCD5. */

/*! @brief Read current value of the LCD_WF5_BPHLCD5 field. */
#define BR_LCD_WF5_BPHLCD5(x) (BME_UBFX8(HW_LCD_WF5_ADDR(x), BP_LCD_WF5_BPHLCD5, BS_LCD_WF5_BPHLCD5))

/*! @brief Format value for bitfield LCD_WF5_BPHLCD5. */
#define BF_LCD_WF5_BPHLCD5(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF5_BPHLCD5) & BM_LCD_WF5_BPHLCD5)

/*! @brief Set the BPHLCD5 field to a new value. */
#define BW_LCD_WF5_BPHLCD5(x, v) (BME_BFI8(HW_LCD_WF5_ADDR(x), ((uint8_t)(v) << BP_LCD_WF5_BPHLCD5), BP_LCD_WF5_BPHLCD5, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF6 - LCD Waveform Register 6.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF6 - LCD Waveform Register 6. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf6
{
    uint8_t U;
    struct _hw_lcd_wf6_bitfields
    {
        uint8_t BPALCD6 : 1;           /*!< [0]  */
        uint8_t BPBLCD6 : 1;           /*!< [1]  */
        uint8_t BPCLCD6 : 1;           /*!< [2]  */
        uint8_t BPDLCD6 : 1;           /*!< [3]  */
        uint8_t BPELCD6 : 1;           /*!< [4]  */
        uint8_t BPFLCD6 : 1;           /*!< [5]  */
        uint8_t BPGLCD6 : 1;           /*!< [6]  */
        uint8_t BPHLCD6 : 1;           /*!< [7]  */
    } B;
} hw_lcd_wf6_t;

/*!
 * @name Constants and macros for entire LCD_WF6 register
 */
/*@{*/
#define HW_LCD_WF6_ADDR(x)       ((uint32_t)(x) + 0x26U)

#define HW_LCD_WF6(x)            (*(__IO hw_lcd_wf6_t *) HW_LCD_WF6_ADDR(x))
#define HW_LCD_WF6_RD(x)         (HW_LCD_WF6(x).U)
#define HW_LCD_WF6_WR(x, v)      (HW_LCD_WF6(x).U = (v))
#define HW_LCD_WF6_SET(x, v)     (BME_OR8(HW_LCD_WF6_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF6_CLR(x, v)     (BME_AND8(HW_LCD_WF6_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF6_TOG(x, v)     (BME_XOR8(HW_LCD_WF6_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF6 bitfields
 */

/*!
 * @name Register LCD_WF6, field BPALCD6[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF6_BPALCD6   (0U)          /*!< Bit position for LCD_WF6_BPALCD6. */
#define BM_LCD_WF6_BPALCD6   (0x01U)       /*!< Bit mask for LCD_WF6_BPALCD6. */
#define BS_LCD_WF6_BPALCD6   (1U)          /*!< Bit field size in bits for LCD_WF6_BPALCD6. */

/*! @brief Read current value of the LCD_WF6_BPALCD6 field. */
#define BR_LCD_WF6_BPALCD6(x) (BME_UBFX8(HW_LCD_WF6_ADDR(x), BP_LCD_WF6_BPALCD6, BS_LCD_WF6_BPALCD6))

/*! @brief Format value for bitfield LCD_WF6_BPALCD6. */
#define BF_LCD_WF6_BPALCD6(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF6_BPALCD6) & BM_LCD_WF6_BPALCD6)

/*! @brief Set the BPALCD6 field to a new value. */
#define BW_LCD_WF6_BPALCD6(x, v) (BME_BFI8(HW_LCD_WF6_ADDR(x), ((uint8_t)(v) << BP_LCD_WF6_BPALCD6), BP_LCD_WF6_BPALCD6, 1))
/*@}*/

/*!
 * @name Register LCD_WF6, field BPBLCD6[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF6_BPBLCD6   (1U)          /*!< Bit position for LCD_WF6_BPBLCD6. */
#define BM_LCD_WF6_BPBLCD6   (0x02U)       /*!< Bit mask for LCD_WF6_BPBLCD6. */
#define BS_LCD_WF6_BPBLCD6   (1U)          /*!< Bit field size in bits for LCD_WF6_BPBLCD6. */

/*! @brief Read current value of the LCD_WF6_BPBLCD6 field. */
#define BR_LCD_WF6_BPBLCD6(x) (BME_UBFX8(HW_LCD_WF6_ADDR(x), BP_LCD_WF6_BPBLCD6, BS_LCD_WF6_BPBLCD6))

/*! @brief Format value for bitfield LCD_WF6_BPBLCD6. */
#define BF_LCD_WF6_BPBLCD6(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF6_BPBLCD6) & BM_LCD_WF6_BPBLCD6)

/*! @brief Set the BPBLCD6 field to a new value. */
#define BW_LCD_WF6_BPBLCD6(x, v) (BME_BFI8(HW_LCD_WF6_ADDR(x), ((uint8_t)(v) << BP_LCD_WF6_BPBLCD6), BP_LCD_WF6_BPBLCD6, 1))
/*@}*/

/*!
 * @name Register LCD_WF6, field BPCLCD6[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF6_BPCLCD6   (2U)          /*!< Bit position for LCD_WF6_BPCLCD6. */
#define BM_LCD_WF6_BPCLCD6   (0x04U)       /*!< Bit mask for LCD_WF6_BPCLCD6. */
#define BS_LCD_WF6_BPCLCD6   (1U)          /*!< Bit field size in bits for LCD_WF6_BPCLCD6. */

/*! @brief Read current value of the LCD_WF6_BPCLCD6 field. */
#define BR_LCD_WF6_BPCLCD6(x) (BME_UBFX8(HW_LCD_WF6_ADDR(x), BP_LCD_WF6_BPCLCD6, BS_LCD_WF6_BPCLCD6))

/*! @brief Format value for bitfield LCD_WF6_BPCLCD6. */
#define BF_LCD_WF6_BPCLCD6(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF6_BPCLCD6) & BM_LCD_WF6_BPCLCD6)

/*! @brief Set the BPCLCD6 field to a new value. */
#define BW_LCD_WF6_BPCLCD6(x, v) (BME_BFI8(HW_LCD_WF6_ADDR(x), ((uint8_t)(v) << BP_LCD_WF6_BPCLCD6), BP_LCD_WF6_BPCLCD6, 1))
/*@}*/

/*!
 * @name Register LCD_WF6, field BPDLCD6[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF6_BPDLCD6   (3U)          /*!< Bit position for LCD_WF6_BPDLCD6. */
#define BM_LCD_WF6_BPDLCD6   (0x08U)       /*!< Bit mask for LCD_WF6_BPDLCD6. */
#define BS_LCD_WF6_BPDLCD6   (1U)          /*!< Bit field size in bits for LCD_WF6_BPDLCD6. */

/*! @brief Read current value of the LCD_WF6_BPDLCD6 field. */
#define BR_LCD_WF6_BPDLCD6(x) (BME_UBFX8(HW_LCD_WF6_ADDR(x), BP_LCD_WF6_BPDLCD6, BS_LCD_WF6_BPDLCD6))

/*! @brief Format value for bitfield LCD_WF6_BPDLCD6. */
#define BF_LCD_WF6_BPDLCD6(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF6_BPDLCD6) & BM_LCD_WF6_BPDLCD6)

/*! @brief Set the BPDLCD6 field to a new value. */
#define BW_LCD_WF6_BPDLCD6(x, v) (BME_BFI8(HW_LCD_WF6_ADDR(x), ((uint8_t)(v) << BP_LCD_WF6_BPDLCD6), BP_LCD_WF6_BPDLCD6, 1))
/*@}*/

/*!
 * @name Register LCD_WF6, field BPELCD6[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF6_BPELCD6   (4U)          /*!< Bit position for LCD_WF6_BPELCD6. */
#define BM_LCD_WF6_BPELCD6   (0x10U)       /*!< Bit mask for LCD_WF6_BPELCD6. */
#define BS_LCD_WF6_BPELCD6   (1U)          /*!< Bit field size in bits for LCD_WF6_BPELCD6. */

/*! @brief Read current value of the LCD_WF6_BPELCD6 field. */
#define BR_LCD_WF6_BPELCD6(x) (BME_UBFX8(HW_LCD_WF6_ADDR(x), BP_LCD_WF6_BPELCD6, BS_LCD_WF6_BPELCD6))

/*! @brief Format value for bitfield LCD_WF6_BPELCD6. */
#define BF_LCD_WF6_BPELCD6(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF6_BPELCD6) & BM_LCD_WF6_BPELCD6)

/*! @brief Set the BPELCD6 field to a new value. */
#define BW_LCD_WF6_BPELCD6(x, v) (BME_BFI8(HW_LCD_WF6_ADDR(x), ((uint8_t)(v) << BP_LCD_WF6_BPELCD6), BP_LCD_WF6_BPELCD6, 1))
/*@}*/

/*!
 * @name Register LCD_WF6, field BPFLCD6[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF6_BPFLCD6   (5U)          /*!< Bit position for LCD_WF6_BPFLCD6. */
#define BM_LCD_WF6_BPFLCD6   (0x20U)       /*!< Bit mask for LCD_WF6_BPFLCD6. */
#define BS_LCD_WF6_BPFLCD6   (1U)          /*!< Bit field size in bits for LCD_WF6_BPFLCD6. */

/*! @brief Read current value of the LCD_WF6_BPFLCD6 field. */
#define BR_LCD_WF6_BPFLCD6(x) (BME_UBFX8(HW_LCD_WF6_ADDR(x), BP_LCD_WF6_BPFLCD6, BS_LCD_WF6_BPFLCD6))

/*! @brief Format value for bitfield LCD_WF6_BPFLCD6. */
#define BF_LCD_WF6_BPFLCD6(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF6_BPFLCD6) & BM_LCD_WF6_BPFLCD6)

/*! @brief Set the BPFLCD6 field to a new value. */
#define BW_LCD_WF6_BPFLCD6(x, v) (BME_BFI8(HW_LCD_WF6_ADDR(x), ((uint8_t)(v) << BP_LCD_WF6_BPFLCD6), BP_LCD_WF6_BPFLCD6, 1))
/*@}*/

/*!
 * @name Register LCD_WF6, field BPGLCD6[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF6_BPGLCD6   (6U)          /*!< Bit position for LCD_WF6_BPGLCD6. */
#define BM_LCD_WF6_BPGLCD6   (0x40U)       /*!< Bit mask for LCD_WF6_BPGLCD6. */
#define BS_LCD_WF6_BPGLCD6   (1U)          /*!< Bit field size in bits for LCD_WF6_BPGLCD6. */

/*! @brief Read current value of the LCD_WF6_BPGLCD6 field. */
#define BR_LCD_WF6_BPGLCD6(x) (BME_UBFX8(HW_LCD_WF6_ADDR(x), BP_LCD_WF6_BPGLCD6, BS_LCD_WF6_BPGLCD6))

/*! @brief Format value for bitfield LCD_WF6_BPGLCD6. */
#define BF_LCD_WF6_BPGLCD6(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF6_BPGLCD6) & BM_LCD_WF6_BPGLCD6)

/*! @brief Set the BPGLCD6 field to a new value. */
#define BW_LCD_WF6_BPGLCD6(x, v) (BME_BFI8(HW_LCD_WF6_ADDR(x), ((uint8_t)(v) << BP_LCD_WF6_BPGLCD6), BP_LCD_WF6_BPGLCD6, 1))
/*@}*/

/*!
 * @name Register LCD_WF6, field BPHLCD6[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF6_BPHLCD6   (7U)          /*!< Bit position for LCD_WF6_BPHLCD6. */
#define BM_LCD_WF6_BPHLCD6   (0x80U)       /*!< Bit mask for LCD_WF6_BPHLCD6. */
#define BS_LCD_WF6_BPHLCD6   (1U)          /*!< Bit field size in bits for LCD_WF6_BPHLCD6. */

/*! @brief Read current value of the LCD_WF6_BPHLCD6 field. */
#define BR_LCD_WF6_BPHLCD6(x) (BME_UBFX8(HW_LCD_WF6_ADDR(x), BP_LCD_WF6_BPHLCD6, BS_LCD_WF6_BPHLCD6))

/*! @brief Format value for bitfield LCD_WF6_BPHLCD6. */
#define BF_LCD_WF6_BPHLCD6(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF6_BPHLCD6) & BM_LCD_WF6_BPHLCD6)

/*! @brief Set the BPHLCD6 field to a new value. */
#define BW_LCD_WF6_BPHLCD6(x, v) (BME_BFI8(HW_LCD_WF6_ADDR(x), ((uint8_t)(v) << BP_LCD_WF6_BPHLCD6), BP_LCD_WF6_BPHLCD6, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF7 - LCD Waveform Register 7.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF7 - LCD Waveform Register 7. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf7
{
    uint8_t U;
    struct _hw_lcd_wf7_bitfields
    {
        uint8_t BPALCD7 : 1;           /*!< [0]  */
        uint8_t BPBLCD7 : 1;           /*!< [1]  */
        uint8_t BPCLCD7 : 1;           /*!< [2]  */
        uint8_t BPDLCD7 : 1;           /*!< [3]  */
        uint8_t BPELCD7 : 1;           /*!< [4]  */
        uint8_t BPFLCD7 : 1;           /*!< [5]  */
        uint8_t BPGLCD7 : 1;           /*!< [6]  */
        uint8_t BPHLCD7 : 1;           /*!< [7]  */
    } B;
} hw_lcd_wf7_t;

/*!
 * @name Constants and macros for entire LCD_WF7 register
 */
/*@{*/
#define HW_LCD_WF7_ADDR(x)       ((uint32_t)(x) + 0x27U)

#define HW_LCD_WF7(x)            (*(__IO hw_lcd_wf7_t *) HW_LCD_WF7_ADDR(x))
#define HW_LCD_WF7_RD(x)         (HW_LCD_WF7(x).U)
#define HW_LCD_WF7_WR(x, v)      (HW_LCD_WF7(x).U = (v))
#define HW_LCD_WF7_SET(x, v)     (BME_OR8(HW_LCD_WF7_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF7_CLR(x, v)     (BME_AND8(HW_LCD_WF7_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF7_TOG(x, v)     (BME_XOR8(HW_LCD_WF7_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF7 bitfields
 */

/*!
 * @name Register LCD_WF7, field BPALCD7[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF7_BPALCD7   (0U)          /*!< Bit position for LCD_WF7_BPALCD7. */
#define BM_LCD_WF7_BPALCD7   (0x01U)       /*!< Bit mask for LCD_WF7_BPALCD7. */
#define BS_LCD_WF7_BPALCD7   (1U)          /*!< Bit field size in bits for LCD_WF7_BPALCD7. */

/*! @brief Read current value of the LCD_WF7_BPALCD7 field. */
#define BR_LCD_WF7_BPALCD7(x) (BME_UBFX8(HW_LCD_WF7_ADDR(x), BP_LCD_WF7_BPALCD7, BS_LCD_WF7_BPALCD7))

/*! @brief Format value for bitfield LCD_WF7_BPALCD7. */
#define BF_LCD_WF7_BPALCD7(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF7_BPALCD7) & BM_LCD_WF7_BPALCD7)

/*! @brief Set the BPALCD7 field to a new value. */
#define BW_LCD_WF7_BPALCD7(x, v) (BME_BFI8(HW_LCD_WF7_ADDR(x), ((uint8_t)(v) << BP_LCD_WF7_BPALCD7), BP_LCD_WF7_BPALCD7, 1))
/*@}*/

/*!
 * @name Register LCD_WF7, field BPBLCD7[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF7_BPBLCD7   (1U)          /*!< Bit position for LCD_WF7_BPBLCD7. */
#define BM_LCD_WF7_BPBLCD7   (0x02U)       /*!< Bit mask for LCD_WF7_BPBLCD7. */
#define BS_LCD_WF7_BPBLCD7   (1U)          /*!< Bit field size in bits for LCD_WF7_BPBLCD7. */

/*! @brief Read current value of the LCD_WF7_BPBLCD7 field. */
#define BR_LCD_WF7_BPBLCD7(x) (BME_UBFX8(HW_LCD_WF7_ADDR(x), BP_LCD_WF7_BPBLCD7, BS_LCD_WF7_BPBLCD7))

/*! @brief Format value for bitfield LCD_WF7_BPBLCD7. */
#define BF_LCD_WF7_BPBLCD7(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF7_BPBLCD7) & BM_LCD_WF7_BPBLCD7)

/*! @brief Set the BPBLCD7 field to a new value. */
#define BW_LCD_WF7_BPBLCD7(x, v) (BME_BFI8(HW_LCD_WF7_ADDR(x), ((uint8_t)(v) << BP_LCD_WF7_BPBLCD7), BP_LCD_WF7_BPBLCD7, 1))
/*@}*/

/*!
 * @name Register LCD_WF7, field BPCLCD7[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF7_BPCLCD7   (2U)          /*!< Bit position for LCD_WF7_BPCLCD7. */
#define BM_LCD_WF7_BPCLCD7   (0x04U)       /*!< Bit mask for LCD_WF7_BPCLCD7. */
#define BS_LCD_WF7_BPCLCD7   (1U)          /*!< Bit field size in bits for LCD_WF7_BPCLCD7. */

/*! @brief Read current value of the LCD_WF7_BPCLCD7 field. */
#define BR_LCD_WF7_BPCLCD7(x) (BME_UBFX8(HW_LCD_WF7_ADDR(x), BP_LCD_WF7_BPCLCD7, BS_LCD_WF7_BPCLCD7))

/*! @brief Format value for bitfield LCD_WF7_BPCLCD7. */
#define BF_LCD_WF7_BPCLCD7(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF7_BPCLCD7) & BM_LCD_WF7_BPCLCD7)

/*! @brief Set the BPCLCD7 field to a new value. */
#define BW_LCD_WF7_BPCLCD7(x, v) (BME_BFI8(HW_LCD_WF7_ADDR(x), ((uint8_t)(v) << BP_LCD_WF7_BPCLCD7), BP_LCD_WF7_BPCLCD7, 1))
/*@}*/

/*!
 * @name Register LCD_WF7, field BPDLCD7[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF7_BPDLCD7   (3U)          /*!< Bit position for LCD_WF7_BPDLCD7. */
#define BM_LCD_WF7_BPDLCD7   (0x08U)       /*!< Bit mask for LCD_WF7_BPDLCD7. */
#define BS_LCD_WF7_BPDLCD7   (1U)          /*!< Bit field size in bits for LCD_WF7_BPDLCD7. */

/*! @brief Read current value of the LCD_WF7_BPDLCD7 field. */
#define BR_LCD_WF7_BPDLCD7(x) (BME_UBFX8(HW_LCD_WF7_ADDR(x), BP_LCD_WF7_BPDLCD7, BS_LCD_WF7_BPDLCD7))

/*! @brief Format value for bitfield LCD_WF7_BPDLCD7. */
#define BF_LCD_WF7_BPDLCD7(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF7_BPDLCD7) & BM_LCD_WF7_BPDLCD7)

/*! @brief Set the BPDLCD7 field to a new value. */
#define BW_LCD_WF7_BPDLCD7(x, v) (BME_BFI8(HW_LCD_WF7_ADDR(x), ((uint8_t)(v) << BP_LCD_WF7_BPDLCD7), BP_LCD_WF7_BPDLCD7, 1))
/*@}*/

/*!
 * @name Register LCD_WF7, field BPELCD7[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF7_BPELCD7   (4U)          /*!< Bit position for LCD_WF7_BPELCD7. */
#define BM_LCD_WF7_BPELCD7   (0x10U)       /*!< Bit mask for LCD_WF7_BPELCD7. */
#define BS_LCD_WF7_BPELCD7   (1U)          /*!< Bit field size in bits for LCD_WF7_BPELCD7. */

/*! @brief Read current value of the LCD_WF7_BPELCD7 field. */
#define BR_LCD_WF7_BPELCD7(x) (BME_UBFX8(HW_LCD_WF7_ADDR(x), BP_LCD_WF7_BPELCD7, BS_LCD_WF7_BPELCD7))

/*! @brief Format value for bitfield LCD_WF7_BPELCD7. */
#define BF_LCD_WF7_BPELCD7(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF7_BPELCD7) & BM_LCD_WF7_BPELCD7)

/*! @brief Set the BPELCD7 field to a new value. */
#define BW_LCD_WF7_BPELCD7(x, v) (BME_BFI8(HW_LCD_WF7_ADDR(x), ((uint8_t)(v) << BP_LCD_WF7_BPELCD7), BP_LCD_WF7_BPELCD7, 1))
/*@}*/

/*!
 * @name Register LCD_WF7, field BPFLCD7[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF7_BPFLCD7   (5U)          /*!< Bit position for LCD_WF7_BPFLCD7. */
#define BM_LCD_WF7_BPFLCD7   (0x20U)       /*!< Bit mask for LCD_WF7_BPFLCD7. */
#define BS_LCD_WF7_BPFLCD7   (1U)          /*!< Bit field size in bits for LCD_WF7_BPFLCD7. */

/*! @brief Read current value of the LCD_WF7_BPFLCD7 field. */
#define BR_LCD_WF7_BPFLCD7(x) (BME_UBFX8(HW_LCD_WF7_ADDR(x), BP_LCD_WF7_BPFLCD7, BS_LCD_WF7_BPFLCD7))

/*! @brief Format value for bitfield LCD_WF7_BPFLCD7. */
#define BF_LCD_WF7_BPFLCD7(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF7_BPFLCD7) & BM_LCD_WF7_BPFLCD7)

/*! @brief Set the BPFLCD7 field to a new value. */
#define BW_LCD_WF7_BPFLCD7(x, v) (BME_BFI8(HW_LCD_WF7_ADDR(x), ((uint8_t)(v) << BP_LCD_WF7_BPFLCD7), BP_LCD_WF7_BPFLCD7, 1))
/*@}*/

/*!
 * @name Register LCD_WF7, field BPGLCD7[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF7_BPGLCD7   (6U)          /*!< Bit position for LCD_WF7_BPGLCD7. */
#define BM_LCD_WF7_BPGLCD7   (0x40U)       /*!< Bit mask for LCD_WF7_BPGLCD7. */
#define BS_LCD_WF7_BPGLCD7   (1U)          /*!< Bit field size in bits for LCD_WF7_BPGLCD7. */

/*! @brief Read current value of the LCD_WF7_BPGLCD7 field. */
#define BR_LCD_WF7_BPGLCD7(x) (BME_UBFX8(HW_LCD_WF7_ADDR(x), BP_LCD_WF7_BPGLCD7, BS_LCD_WF7_BPGLCD7))

/*! @brief Format value for bitfield LCD_WF7_BPGLCD7. */
#define BF_LCD_WF7_BPGLCD7(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF7_BPGLCD7) & BM_LCD_WF7_BPGLCD7)

/*! @brief Set the BPGLCD7 field to a new value. */
#define BW_LCD_WF7_BPGLCD7(x, v) (BME_BFI8(HW_LCD_WF7_ADDR(x), ((uint8_t)(v) << BP_LCD_WF7_BPGLCD7), BP_LCD_WF7_BPGLCD7, 1))
/*@}*/

/*!
 * @name Register LCD_WF7, field BPHLCD7[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF7_BPHLCD7   (7U)          /*!< Bit position for LCD_WF7_BPHLCD7. */
#define BM_LCD_WF7_BPHLCD7   (0x80U)       /*!< Bit mask for LCD_WF7_BPHLCD7. */
#define BS_LCD_WF7_BPHLCD7   (1U)          /*!< Bit field size in bits for LCD_WF7_BPHLCD7. */

/*! @brief Read current value of the LCD_WF7_BPHLCD7 field. */
#define BR_LCD_WF7_BPHLCD7(x) (BME_UBFX8(HW_LCD_WF7_ADDR(x), BP_LCD_WF7_BPHLCD7, BS_LCD_WF7_BPHLCD7))

/*! @brief Format value for bitfield LCD_WF7_BPHLCD7. */
#define BF_LCD_WF7_BPHLCD7(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF7_BPHLCD7) & BM_LCD_WF7_BPHLCD7)

/*! @brief Set the BPHLCD7 field to a new value. */
#define BW_LCD_WF7_BPHLCD7(x, v) (BME_BFI8(HW_LCD_WF7_ADDR(x), ((uint8_t)(v) << BP_LCD_WF7_BPHLCD7), BP_LCD_WF7_BPHLCD7, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF8 - LCD Waveform Register 8.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF8 - LCD Waveform Register 8. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf8
{
    uint8_t U;
    struct _hw_lcd_wf8_bitfields
    {
        uint8_t BPALCD8 : 1;           /*!< [0]  */
        uint8_t BPBLCD8 : 1;           /*!< [1]  */
        uint8_t BPCLCD8 : 1;           /*!< [2]  */
        uint8_t BPDLCD8 : 1;           /*!< [3]  */
        uint8_t BPELCD8 : 1;           /*!< [4]  */
        uint8_t BPFLCD8 : 1;           /*!< [5]  */
        uint8_t BPGLCD8 : 1;           /*!< [6]  */
        uint8_t BPHLCD8 : 1;           /*!< [7]  */
    } B;
} hw_lcd_wf8_t;

/*!
 * @name Constants and macros for entire LCD_WF8 register
 */
/*@{*/
#define HW_LCD_WF8_ADDR(x)       ((uint32_t)(x) + 0x28U)

#define HW_LCD_WF8(x)            (*(__IO hw_lcd_wf8_t *) HW_LCD_WF8_ADDR(x))
#define HW_LCD_WF8_RD(x)         (HW_LCD_WF8(x).U)
#define HW_LCD_WF8_WR(x, v)      (HW_LCD_WF8(x).U = (v))
#define HW_LCD_WF8_SET(x, v)     (BME_OR8(HW_LCD_WF8_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF8_CLR(x, v)     (BME_AND8(HW_LCD_WF8_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF8_TOG(x, v)     (BME_XOR8(HW_LCD_WF8_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF8 bitfields
 */

/*!
 * @name Register LCD_WF8, field BPALCD8[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF8_BPALCD8   (0U)          /*!< Bit position for LCD_WF8_BPALCD8. */
#define BM_LCD_WF8_BPALCD8   (0x01U)       /*!< Bit mask for LCD_WF8_BPALCD8. */
#define BS_LCD_WF8_BPALCD8   (1U)          /*!< Bit field size in bits for LCD_WF8_BPALCD8. */

/*! @brief Read current value of the LCD_WF8_BPALCD8 field. */
#define BR_LCD_WF8_BPALCD8(x) (BME_UBFX8(HW_LCD_WF8_ADDR(x), BP_LCD_WF8_BPALCD8, BS_LCD_WF8_BPALCD8))

/*! @brief Format value for bitfield LCD_WF8_BPALCD8. */
#define BF_LCD_WF8_BPALCD8(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF8_BPALCD8) & BM_LCD_WF8_BPALCD8)

/*! @brief Set the BPALCD8 field to a new value. */
#define BW_LCD_WF8_BPALCD8(x, v) (BME_BFI8(HW_LCD_WF8_ADDR(x), ((uint8_t)(v) << BP_LCD_WF8_BPALCD8), BP_LCD_WF8_BPALCD8, 1))
/*@}*/

/*!
 * @name Register LCD_WF8, field BPBLCD8[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF8_BPBLCD8   (1U)          /*!< Bit position for LCD_WF8_BPBLCD8. */
#define BM_LCD_WF8_BPBLCD8   (0x02U)       /*!< Bit mask for LCD_WF8_BPBLCD8. */
#define BS_LCD_WF8_BPBLCD8   (1U)          /*!< Bit field size in bits for LCD_WF8_BPBLCD8. */

/*! @brief Read current value of the LCD_WF8_BPBLCD8 field. */
#define BR_LCD_WF8_BPBLCD8(x) (BME_UBFX8(HW_LCD_WF8_ADDR(x), BP_LCD_WF8_BPBLCD8, BS_LCD_WF8_BPBLCD8))

/*! @brief Format value for bitfield LCD_WF8_BPBLCD8. */
#define BF_LCD_WF8_BPBLCD8(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF8_BPBLCD8) & BM_LCD_WF8_BPBLCD8)

/*! @brief Set the BPBLCD8 field to a new value. */
#define BW_LCD_WF8_BPBLCD8(x, v) (BME_BFI8(HW_LCD_WF8_ADDR(x), ((uint8_t)(v) << BP_LCD_WF8_BPBLCD8), BP_LCD_WF8_BPBLCD8, 1))
/*@}*/

/*!
 * @name Register LCD_WF8, field BPCLCD8[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF8_BPCLCD8   (2U)          /*!< Bit position for LCD_WF8_BPCLCD8. */
#define BM_LCD_WF8_BPCLCD8   (0x04U)       /*!< Bit mask for LCD_WF8_BPCLCD8. */
#define BS_LCD_WF8_BPCLCD8   (1U)          /*!< Bit field size in bits for LCD_WF8_BPCLCD8. */

/*! @brief Read current value of the LCD_WF8_BPCLCD8 field. */
#define BR_LCD_WF8_BPCLCD8(x) (BME_UBFX8(HW_LCD_WF8_ADDR(x), BP_LCD_WF8_BPCLCD8, BS_LCD_WF8_BPCLCD8))

/*! @brief Format value for bitfield LCD_WF8_BPCLCD8. */
#define BF_LCD_WF8_BPCLCD8(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF8_BPCLCD8) & BM_LCD_WF8_BPCLCD8)

/*! @brief Set the BPCLCD8 field to a new value. */
#define BW_LCD_WF8_BPCLCD8(x, v) (BME_BFI8(HW_LCD_WF8_ADDR(x), ((uint8_t)(v) << BP_LCD_WF8_BPCLCD8), BP_LCD_WF8_BPCLCD8, 1))
/*@}*/

/*!
 * @name Register LCD_WF8, field BPDLCD8[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF8_BPDLCD8   (3U)          /*!< Bit position for LCD_WF8_BPDLCD8. */
#define BM_LCD_WF8_BPDLCD8   (0x08U)       /*!< Bit mask for LCD_WF8_BPDLCD8. */
#define BS_LCD_WF8_BPDLCD8   (1U)          /*!< Bit field size in bits for LCD_WF8_BPDLCD8. */

/*! @brief Read current value of the LCD_WF8_BPDLCD8 field. */
#define BR_LCD_WF8_BPDLCD8(x) (BME_UBFX8(HW_LCD_WF8_ADDR(x), BP_LCD_WF8_BPDLCD8, BS_LCD_WF8_BPDLCD8))

/*! @brief Format value for bitfield LCD_WF8_BPDLCD8. */
#define BF_LCD_WF8_BPDLCD8(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF8_BPDLCD8) & BM_LCD_WF8_BPDLCD8)

/*! @brief Set the BPDLCD8 field to a new value. */
#define BW_LCD_WF8_BPDLCD8(x, v) (BME_BFI8(HW_LCD_WF8_ADDR(x), ((uint8_t)(v) << BP_LCD_WF8_BPDLCD8), BP_LCD_WF8_BPDLCD8, 1))
/*@}*/

/*!
 * @name Register LCD_WF8, field BPELCD8[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF8_BPELCD8   (4U)          /*!< Bit position for LCD_WF8_BPELCD8. */
#define BM_LCD_WF8_BPELCD8   (0x10U)       /*!< Bit mask for LCD_WF8_BPELCD8. */
#define BS_LCD_WF8_BPELCD8   (1U)          /*!< Bit field size in bits for LCD_WF8_BPELCD8. */

/*! @brief Read current value of the LCD_WF8_BPELCD8 field. */
#define BR_LCD_WF8_BPELCD8(x) (BME_UBFX8(HW_LCD_WF8_ADDR(x), BP_LCD_WF8_BPELCD8, BS_LCD_WF8_BPELCD8))

/*! @brief Format value for bitfield LCD_WF8_BPELCD8. */
#define BF_LCD_WF8_BPELCD8(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF8_BPELCD8) & BM_LCD_WF8_BPELCD8)

/*! @brief Set the BPELCD8 field to a new value. */
#define BW_LCD_WF8_BPELCD8(x, v) (BME_BFI8(HW_LCD_WF8_ADDR(x), ((uint8_t)(v) << BP_LCD_WF8_BPELCD8), BP_LCD_WF8_BPELCD8, 1))
/*@}*/

/*!
 * @name Register LCD_WF8, field BPFLCD8[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF8_BPFLCD8   (5U)          /*!< Bit position for LCD_WF8_BPFLCD8. */
#define BM_LCD_WF8_BPFLCD8   (0x20U)       /*!< Bit mask for LCD_WF8_BPFLCD8. */
#define BS_LCD_WF8_BPFLCD8   (1U)          /*!< Bit field size in bits for LCD_WF8_BPFLCD8. */

/*! @brief Read current value of the LCD_WF8_BPFLCD8 field. */
#define BR_LCD_WF8_BPFLCD8(x) (BME_UBFX8(HW_LCD_WF8_ADDR(x), BP_LCD_WF8_BPFLCD8, BS_LCD_WF8_BPFLCD8))

/*! @brief Format value for bitfield LCD_WF8_BPFLCD8. */
#define BF_LCD_WF8_BPFLCD8(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF8_BPFLCD8) & BM_LCD_WF8_BPFLCD8)

/*! @brief Set the BPFLCD8 field to a new value. */
#define BW_LCD_WF8_BPFLCD8(x, v) (BME_BFI8(HW_LCD_WF8_ADDR(x), ((uint8_t)(v) << BP_LCD_WF8_BPFLCD8), BP_LCD_WF8_BPFLCD8, 1))
/*@}*/

/*!
 * @name Register LCD_WF8, field BPGLCD8[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF8_BPGLCD8   (6U)          /*!< Bit position for LCD_WF8_BPGLCD8. */
#define BM_LCD_WF8_BPGLCD8   (0x40U)       /*!< Bit mask for LCD_WF8_BPGLCD8. */
#define BS_LCD_WF8_BPGLCD8   (1U)          /*!< Bit field size in bits for LCD_WF8_BPGLCD8. */

/*! @brief Read current value of the LCD_WF8_BPGLCD8 field. */
#define BR_LCD_WF8_BPGLCD8(x) (BME_UBFX8(HW_LCD_WF8_ADDR(x), BP_LCD_WF8_BPGLCD8, BS_LCD_WF8_BPGLCD8))

/*! @brief Format value for bitfield LCD_WF8_BPGLCD8. */
#define BF_LCD_WF8_BPGLCD8(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF8_BPGLCD8) & BM_LCD_WF8_BPGLCD8)

/*! @brief Set the BPGLCD8 field to a new value. */
#define BW_LCD_WF8_BPGLCD8(x, v) (BME_BFI8(HW_LCD_WF8_ADDR(x), ((uint8_t)(v) << BP_LCD_WF8_BPGLCD8), BP_LCD_WF8_BPGLCD8, 1))
/*@}*/

/*!
 * @name Register LCD_WF8, field BPHLCD8[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF8_BPHLCD8   (7U)          /*!< Bit position for LCD_WF8_BPHLCD8. */
#define BM_LCD_WF8_BPHLCD8   (0x80U)       /*!< Bit mask for LCD_WF8_BPHLCD8. */
#define BS_LCD_WF8_BPHLCD8   (1U)          /*!< Bit field size in bits for LCD_WF8_BPHLCD8. */

/*! @brief Read current value of the LCD_WF8_BPHLCD8 field. */
#define BR_LCD_WF8_BPHLCD8(x) (BME_UBFX8(HW_LCD_WF8_ADDR(x), BP_LCD_WF8_BPHLCD8, BS_LCD_WF8_BPHLCD8))

/*! @brief Format value for bitfield LCD_WF8_BPHLCD8. */
#define BF_LCD_WF8_BPHLCD8(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF8_BPHLCD8) & BM_LCD_WF8_BPHLCD8)

/*! @brief Set the BPHLCD8 field to a new value. */
#define BW_LCD_WF8_BPHLCD8(x, v) (BME_BFI8(HW_LCD_WF8_ADDR(x), ((uint8_t)(v) << BP_LCD_WF8_BPHLCD8), BP_LCD_WF8_BPHLCD8, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF9 - LCD Waveform Register 9.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF9 - LCD Waveform Register 9. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf9
{
    uint8_t U;
    struct _hw_lcd_wf9_bitfields
    {
        uint8_t BPALCD9 : 1;           /*!< [0]  */
        uint8_t BPBLCD9 : 1;           /*!< [1]  */
        uint8_t BPCLCD9 : 1;           /*!< [2]  */
        uint8_t BPDLCD9 : 1;           /*!< [3]  */
        uint8_t BPELCD9 : 1;           /*!< [4]  */
        uint8_t BPFLCD9 : 1;           /*!< [5]  */
        uint8_t BPGLCD9 : 1;           /*!< [6]  */
        uint8_t BPHLCD9 : 1;           /*!< [7]  */
    } B;
} hw_lcd_wf9_t;

/*!
 * @name Constants and macros for entire LCD_WF9 register
 */
/*@{*/
#define HW_LCD_WF9_ADDR(x)       ((uint32_t)(x) + 0x29U)

#define HW_LCD_WF9(x)            (*(__IO hw_lcd_wf9_t *) HW_LCD_WF9_ADDR(x))
#define HW_LCD_WF9_RD(x)         (HW_LCD_WF9(x).U)
#define HW_LCD_WF9_WR(x, v)      (HW_LCD_WF9(x).U = (v))
#define HW_LCD_WF9_SET(x, v)     (BME_OR8(HW_LCD_WF9_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF9_CLR(x, v)     (BME_AND8(HW_LCD_WF9_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF9_TOG(x, v)     (BME_XOR8(HW_LCD_WF9_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF9 bitfields
 */

/*!
 * @name Register LCD_WF9, field BPALCD9[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF9_BPALCD9   (0U)          /*!< Bit position for LCD_WF9_BPALCD9. */
#define BM_LCD_WF9_BPALCD9   (0x01U)       /*!< Bit mask for LCD_WF9_BPALCD9. */
#define BS_LCD_WF9_BPALCD9   (1U)          /*!< Bit field size in bits for LCD_WF9_BPALCD9. */

/*! @brief Read current value of the LCD_WF9_BPALCD9 field. */
#define BR_LCD_WF9_BPALCD9(x) (BME_UBFX8(HW_LCD_WF9_ADDR(x), BP_LCD_WF9_BPALCD9, BS_LCD_WF9_BPALCD9))

/*! @brief Format value for bitfield LCD_WF9_BPALCD9. */
#define BF_LCD_WF9_BPALCD9(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF9_BPALCD9) & BM_LCD_WF9_BPALCD9)

/*! @brief Set the BPALCD9 field to a new value. */
#define BW_LCD_WF9_BPALCD9(x, v) (BME_BFI8(HW_LCD_WF9_ADDR(x), ((uint8_t)(v) << BP_LCD_WF9_BPALCD9), BP_LCD_WF9_BPALCD9, 1))
/*@}*/

/*!
 * @name Register LCD_WF9, field BPBLCD9[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF9_BPBLCD9   (1U)          /*!< Bit position for LCD_WF9_BPBLCD9. */
#define BM_LCD_WF9_BPBLCD9   (0x02U)       /*!< Bit mask for LCD_WF9_BPBLCD9. */
#define BS_LCD_WF9_BPBLCD9   (1U)          /*!< Bit field size in bits for LCD_WF9_BPBLCD9. */

/*! @brief Read current value of the LCD_WF9_BPBLCD9 field. */
#define BR_LCD_WF9_BPBLCD9(x) (BME_UBFX8(HW_LCD_WF9_ADDR(x), BP_LCD_WF9_BPBLCD9, BS_LCD_WF9_BPBLCD9))

/*! @brief Format value for bitfield LCD_WF9_BPBLCD9. */
#define BF_LCD_WF9_BPBLCD9(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF9_BPBLCD9) & BM_LCD_WF9_BPBLCD9)

/*! @brief Set the BPBLCD9 field to a new value. */
#define BW_LCD_WF9_BPBLCD9(x, v) (BME_BFI8(HW_LCD_WF9_ADDR(x), ((uint8_t)(v) << BP_LCD_WF9_BPBLCD9), BP_LCD_WF9_BPBLCD9, 1))
/*@}*/

/*!
 * @name Register LCD_WF9, field BPCLCD9[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF9_BPCLCD9   (2U)          /*!< Bit position for LCD_WF9_BPCLCD9. */
#define BM_LCD_WF9_BPCLCD9   (0x04U)       /*!< Bit mask for LCD_WF9_BPCLCD9. */
#define BS_LCD_WF9_BPCLCD9   (1U)          /*!< Bit field size in bits for LCD_WF9_BPCLCD9. */

/*! @brief Read current value of the LCD_WF9_BPCLCD9 field. */
#define BR_LCD_WF9_BPCLCD9(x) (BME_UBFX8(HW_LCD_WF9_ADDR(x), BP_LCD_WF9_BPCLCD9, BS_LCD_WF9_BPCLCD9))

/*! @brief Format value for bitfield LCD_WF9_BPCLCD9. */
#define BF_LCD_WF9_BPCLCD9(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF9_BPCLCD9) & BM_LCD_WF9_BPCLCD9)

/*! @brief Set the BPCLCD9 field to a new value. */
#define BW_LCD_WF9_BPCLCD9(x, v) (BME_BFI8(HW_LCD_WF9_ADDR(x), ((uint8_t)(v) << BP_LCD_WF9_BPCLCD9), BP_LCD_WF9_BPCLCD9, 1))
/*@}*/

/*!
 * @name Register LCD_WF9, field BPDLCD9[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF9_BPDLCD9   (3U)          /*!< Bit position for LCD_WF9_BPDLCD9. */
#define BM_LCD_WF9_BPDLCD9   (0x08U)       /*!< Bit mask for LCD_WF9_BPDLCD9. */
#define BS_LCD_WF9_BPDLCD9   (1U)          /*!< Bit field size in bits for LCD_WF9_BPDLCD9. */

/*! @brief Read current value of the LCD_WF9_BPDLCD9 field. */
#define BR_LCD_WF9_BPDLCD9(x) (BME_UBFX8(HW_LCD_WF9_ADDR(x), BP_LCD_WF9_BPDLCD9, BS_LCD_WF9_BPDLCD9))

/*! @brief Format value for bitfield LCD_WF9_BPDLCD9. */
#define BF_LCD_WF9_BPDLCD9(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF9_BPDLCD9) & BM_LCD_WF9_BPDLCD9)

/*! @brief Set the BPDLCD9 field to a new value. */
#define BW_LCD_WF9_BPDLCD9(x, v) (BME_BFI8(HW_LCD_WF9_ADDR(x), ((uint8_t)(v) << BP_LCD_WF9_BPDLCD9), BP_LCD_WF9_BPDLCD9, 1))
/*@}*/

/*!
 * @name Register LCD_WF9, field BPELCD9[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF9_BPELCD9   (4U)          /*!< Bit position for LCD_WF9_BPELCD9. */
#define BM_LCD_WF9_BPELCD9   (0x10U)       /*!< Bit mask for LCD_WF9_BPELCD9. */
#define BS_LCD_WF9_BPELCD9   (1U)          /*!< Bit field size in bits for LCD_WF9_BPELCD9. */

/*! @brief Read current value of the LCD_WF9_BPELCD9 field. */
#define BR_LCD_WF9_BPELCD9(x) (BME_UBFX8(HW_LCD_WF9_ADDR(x), BP_LCD_WF9_BPELCD9, BS_LCD_WF9_BPELCD9))

/*! @brief Format value for bitfield LCD_WF9_BPELCD9. */
#define BF_LCD_WF9_BPELCD9(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF9_BPELCD9) & BM_LCD_WF9_BPELCD9)

/*! @brief Set the BPELCD9 field to a new value. */
#define BW_LCD_WF9_BPELCD9(x, v) (BME_BFI8(HW_LCD_WF9_ADDR(x), ((uint8_t)(v) << BP_LCD_WF9_BPELCD9), BP_LCD_WF9_BPELCD9, 1))
/*@}*/

/*!
 * @name Register LCD_WF9, field BPFLCD9[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF9_BPFLCD9   (5U)          /*!< Bit position for LCD_WF9_BPFLCD9. */
#define BM_LCD_WF9_BPFLCD9   (0x20U)       /*!< Bit mask for LCD_WF9_BPFLCD9. */
#define BS_LCD_WF9_BPFLCD9   (1U)          /*!< Bit field size in bits for LCD_WF9_BPFLCD9. */

/*! @brief Read current value of the LCD_WF9_BPFLCD9 field. */
#define BR_LCD_WF9_BPFLCD9(x) (BME_UBFX8(HW_LCD_WF9_ADDR(x), BP_LCD_WF9_BPFLCD9, BS_LCD_WF9_BPFLCD9))

/*! @brief Format value for bitfield LCD_WF9_BPFLCD9. */
#define BF_LCD_WF9_BPFLCD9(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF9_BPFLCD9) & BM_LCD_WF9_BPFLCD9)

/*! @brief Set the BPFLCD9 field to a new value. */
#define BW_LCD_WF9_BPFLCD9(x, v) (BME_BFI8(HW_LCD_WF9_ADDR(x), ((uint8_t)(v) << BP_LCD_WF9_BPFLCD9), BP_LCD_WF9_BPFLCD9, 1))
/*@}*/

/*!
 * @name Register LCD_WF9, field BPGLCD9[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF9_BPGLCD9   (6U)          /*!< Bit position for LCD_WF9_BPGLCD9. */
#define BM_LCD_WF9_BPGLCD9   (0x40U)       /*!< Bit mask for LCD_WF9_BPGLCD9. */
#define BS_LCD_WF9_BPGLCD9   (1U)          /*!< Bit field size in bits for LCD_WF9_BPGLCD9. */

/*! @brief Read current value of the LCD_WF9_BPGLCD9 field. */
#define BR_LCD_WF9_BPGLCD9(x) (BME_UBFX8(HW_LCD_WF9_ADDR(x), BP_LCD_WF9_BPGLCD9, BS_LCD_WF9_BPGLCD9))

/*! @brief Format value for bitfield LCD_WF9_BPGLCD9. */
#define BF_LCD_WF9_BPGLCD9(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF9_BPGLCD9) & BM_LCD_WF9_BPGLCD9)

/*! @brief Set the BPGLCD9 field to a new value. */
#define BW_LCD_WF9_BPGLCD9(x, v) (BME_BFI8(HW_LCD_WF9_ADDR(x), ((uint8_t)(v) << BP_LCD_WF9_BPGLCD9), BP_LCD_WF9_BPGLCD9, 1))
/*@}*/

/*!
 * @name Register LCD_WF9, field BPHLCD9[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF9_BPHLCD9   (7U)          /*!< Bit position for LCD_WF9_BPHLCD9. */
#define BM_LCD_WF9_BPHLCD9   (0x80U)       /*!< Bit mask for LCD_WF9_BPHLCD9. */
#define BS_LCD_WF9_BPHLCD9   (1U)          /*!< Bit field size in bits for LCD_WF9_BPHLCD9. */

/*! @brief Read current value of the LCD_WF9_BPHLCD9 field. */
#define BR_LCD_WF9_BPHLCD9(x) (BME_UBFX8(HW_LCD_WF9_ADDR(x), BP_LCD_WF9_BPHLCD9, BS_LCD_WF9_BPHLCD9))

/*! @brief Format value for bitfield LCD_WF9_BPHLCD9. */
#define BF_LCD_WF9_BPHLCD9(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF9_BPHLCD9) & BM_LCD_WF9_BPHLCD9)

/*! @brief Set the BPHLCD9 field to a new value. */
#define BW_LCD_WF9_BPHLCD9(x, v) (BME_BFI8(HW_LCD_WF9_ADDR(x), ((uint8_t)(v) << BP_LCD_WF9_BPHLCD9), BP_LCD_WF9_BPHLCD9, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF10 - LCD Waveform Register 10.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF10 - LCD Waveform Register 10. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf10
{
    uint8_t U;
    struct _hw_lcd_wf10_bitfields
    {
        uint8_t BPALCD10 : 1;          /*!< [0]  */
        uint8_t BPBLCD10 : 1;          /*!< [1]  */
        uint8_t BPCLCD10 : 1;          /*!< [2]  */
        uint8_t BPDLCD10 : 1;          /*!< [3]  */
        uint8_t BPELCD10 : 1;          /*!< [4]  */
        uint8_t BPFLCD10 : 1;          /*!< [5]  */
        uint8_t BPGLCD10 : 1;          /*!< [6]  */
        uint8_t BPHLCD10 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf10_t;

/*!
 * @name Constants and macros for entire LCD_WF10 register
 */
/*@{*/
#define HW_LCD_WF10_ADDR(x)      ((uint32_t)(x) + 0x2AU)

#define HW_LCD_WF10(x)           (*(__IO hw_lcd_wf10_t *) HW_LCD_WF10_ADDR(x))
#define HW_LCD_WF10_RD(x)        (HW_LCD_WF10(x).U)
#define HW_LCD_WF10_WR(x, v)     (HW_LCD_WF10(x).U = (v))
#define HW_LCD_WF10_SET(x, v)    (BME_OR8(HW_LCD_WF10_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF10_CLR(x, v)    (BME_AND8(HW_LCD_WF10_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF10_TOG(x, v)    (BME_XOR8(HW_LCD_WF10_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF10 bitfields
 */

/*!
 * @name Register LCD_WF10, field BPALCD10[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF10_BPALCD10 (0U)          /*!< Bit position for LCD_WF10_BPALCD10. */
#define BM_LCD_WF10_BPALCD10 (0x01U)       /*!< Bit mask for LCD_WF10_BPALCD10. */
#define BS_LCD_WF10_BPALCD10 (1U)          /*!< Bit field size in bits for LCD_WF10_BPALCD10. */

/*! @brief Read current value of the LCD_WF10_BPALCD10 field. */
#define BR_LCD_WF10_BPALCD10(x) (BME_UBFX8(HW_LCD_WF10_ADDR(x), BP_LCD_WF10_BPALCD10, BS_LCD_WF10_BPALCD10))

/*! @brief Format value for bitfield LCD_WF10_BPALCD10. */
#define BF_LCD_WF10_BPALCD10(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF10_BPALCD10) & BM_LCD_WF10_BPALCD10)

/*! @brief Set the BPALCD10 field to a new value. */
#define BW_LCD_WF10_BPALCD10(x, v) (BME_BFI8(HW_LCD_WF10_ADDR(x), ((uint8_t)(v) << BP_LCD_WF10_BPALCD10), BP_LCD_WF10_BPALCD10, 1))
/*@}*/

/*!
 * @name Register LCD_WF10, field BPBLCD10[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF10_BPBLCD10 (1U)          /*!< Bit position for LCD_WF10_BPBLCD10. */
#define BM_LCD_WF10_BPBLCD10 (0x02U)       /*!< Bit mask for LCD_WF10_BPBLCD10. */
#define BS_LCD_WF10_BPBLCD10 (1U)          /*!< Bit field size in bits for LCD_WF10_BPBLCD10. */

/*! @brief Read current value of the LCD_WF10_BPBLCD10 field. */
#define BR_LCD_WF10_BPBLCD10(x) (BME_UBFX8(HW_LCD_WF10_ADDR(x), BP_LCD_WF10_BPBLCD10, BS_LCD_WF10_BPBLCD10))

/*! @brief Format value for bitfield LCD_WF10_BPBLCD10. */
#define BF_LCD_WF10_BPBLCD10(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF10_BPBLCD10) & BM_LCD_WF10_BPBLCD10)

/*! @brief Set the BPBLCD10 field to a new value. */
#define BW_LCD_WF10_BPBLCD10(x, v) (BME_BFI8(HW_LCD_WF10_ADDR(x), ((uint8_t)(v) << BP_LCD_WF10_BPBLCD10), BP_LCD_WF10_BPBLCD10, 1))
/*@}*/

/*!
 * @name Register LCD_WF10, field BPCLCD10[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF10_BPCLCD10 (2U)          /*!< Bit position for LCD_WF10_BPCLCD10. */
#define BM_LCD_WF10_BPCLCD10 (0x04U)       /*!< Bit mask for LCD_WF10_BPCLCD10. */
#define BS_LCD_WF10_BPCLCD10 (1U)          /*!< Bit field size in bits for LCD_WF10_BPCLCD10. */

/*! @brief Read current value of the LCD_WF10_BPCLCD10 field. */
#define BR_LCD_WF10_BPCLCD10(x) (BME_UBFX8(HW_LCD_WF10_ADDR(x), BP_LCD_WF10_BPCLCD10, BS_LCD_WF10_BPCLCD10))

/*! @brief Format value for bitfield LCD_WF10_BPCLCD10. */
#define BF_LCD_WF10_BPCLCD10(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF10_BPCLCD10) & BM_LCD_WF10_BPCLCD10)

/*! @brief Set the BPCLCD10 field to a new value. */
#define BW_LCD_WF10_BPCLCD10(x, v) (BME_BFI8(HW_LCD_WF10_ADDR(x), ((uint8_t)(v) << BP_LCD_WF10_BPCLCD10), BP_LCD_WF10_BPCLCD10, 1))
/*@}*/

/*!
 * @name Register LCD_WF10, field BPDLCD10[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF10_BPDLCD10 (3U)          /*!< Bit position for LCD_WF10_BPDLCD10. */
#define BM_LCD_WF10_BPDLCD10 (0x08U)       /*!< Bit mask for LCD_WF10_BPDLCD10. */
#define BS_LCD_WF10_BPDLCD10 (1U)          /*!< Bit field size in bits for LCD_WF10_BPDLCD10. */

/*! @brief Read current value of the LCD_WF10_BPDLCD10 field. */
#define BR_LCD_WF10_BPDLCD10(x) (BME_UBFX8(HW_LCD_WF10_ADDR(x), BP_LCD_WF10_BPDLCD10, BS_LCD_WF10_BPDLCD10))

/*! @brief Format value for bitfield LCD_WF10_BPDLCD10. */
#define BF_LCD_WF10_BPDLCD10(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF10_BPDLCD10) & BM_LCD_WF10_BPDLCD10)

/*! @brief Set the BPDLCD10 field to a new value. */
#define BW_LCD_WF10_BPDLCD10(x, v) (BME_BFI8(HW_LCD_WF10_ADDR(x), ((uint8_t)(v) << BP_LCD_WF10_BPDLCD10), BP_LCD_WF10_BPDLCD10, 1))
/*@}*/

/*!
 * @name Register LCD_WF10, field BPELCD10[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF10_BPELCD10 (4U)          /*!< Bit position for LCD_WF10_BPELCD10. */
#define BM_LCD_WF10_BPELCD10 (0x10U)       /*!< Bit mask for LCD_WF10_BPELCD10. */
#define BS_LCD_WF10_BPELCD10 (1U)          /*!< Bit field size in bits for LCD_WF10_BPELCD10. */

/*! @brief Read current value of the LCD_WF10_BPELCD10 field. */
#define BR_LCD_WF10_BPELCD10(x) (BME_UBFX8(HW_LCD_WF10_ADDR(x), BP_LCD_WF10_BPELCD10, BS_LCD_WF10_BPELCD10))

/*! @brief Format value for bitfield LCD_WF10_BPELCD10. */
#define BF_LCD_WF10_BPELCD10(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF10_BPELCD10) & BM_LCD_WF10_BPELCD10)

/*! @brief Set the BPELCD10 field to a new value. */
#define BW_LCD_WF10_BPELCD10(x, v) (BME_BFI8(HW_LCD_WF10_ADDR(x), ((uint8_t)(v) << BP_LCD_WF10_BPELCD10), BP_LCD_WF10_BPELCD10, 1))
/*@}*/

/*!
 * @name Register LCD_WF10, field BPFLCD10[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF10_BPFLCD10 (5U)          /*!< Bit position for LCD_WF10_BPFLCD10. */
#define BM_LCD_WF10_BPFLCD10 (0x20U)       /*!< Bit mask for LCD_WF10_BPFLCD10. */
#define BS_LCD_WF10_BPFLCD10 (1U)          /*!< Bit field size in bits for LCD_WF10_BPFLCD10. */

/*! @brief Read current value of the LCD_WF10_BPFLCD10 field. */
#define BR_LCD_WF10_BPFLCD10(x) (BME_UBFX8(HW_LCD_WF10_ADDR(x), BP_LCD_WF10_BPFLCD10, BS_LCD_WF10_BPFLCD10))

/*! @brief Format value for bitfield LCD_WF10_BPFLCD10. */
#define BF_LCD_WF10_BPFLCD10(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF10_BPFLCD10) & BM_LCD_WF10_BPFLCD10)

/*! @brief Set the BPFLCD10 field to a new value. */
#define BW_LCD_WF10_BPFLCD10(x, v) (BME_BFI8(HW_LCD_WF10_ADDR(x), ((uint8_t)(v) << BP_LCD_WF10_BPFLCD10), BP_LCD_WF10_BPFLCD10, 1))
/*@}*/

/*!
 * @name Register LCD_WF10, field BPGLCD10[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF10_BPGLCD10 (6U)          /*!< Bit position for LCD_WF10_BPGLCD10. */
#define BM_LCD_WF10_BPGLCD10 (0x40U)       /*!< Bit mask for LCD_WF10_BPGLCD10. */
#define BS_LCD_WF10_BPGLCD10 (1U)          /*!< Bit field size in bits for LCD_WF10_BPGLCD10. */

/*! @brief Read current value of the LCD_WF10_BPGLCD10 field. */
#define BR_LCD_WF10_BPGLCD10(x) (BME_UBFX8(HW_LCD_WF10_ADDR(x), BP_LCD_WF10_BPGLCD10, BS_LCD_WF10_BPGLCD10))

/*! @brief Format value for bitfield LCD_WF10_BPGLCD10. */
#define BF_LCD_WF10_BPGLCD10(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF10_BPGLCD10) & BM_LCD_WF10_BPGLCD10)

/*! @brief Set the BPGLCD10 field to a new value. */
#define BW_LCD_WF10_BPGLCD10(x, v) (BME_BFI8(HW_LCD_WF10_ADDR(x), ((uint8_t)(v) << BP_LCD_WF10_BPGLCD10), BP_LCD_WF10_BPGLCD10, 1))
/*@}*/

/*!
 * @name Register LCD_WF10, field BPHLCD10[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF10_BPHLCD10 (7U)          /*!< Bit position for LCD_WF10_BPHLCD10. */
#define BM_LCD_WF10_BPHLCD10 (0x80U)       /*!< Bit mask for LCD_WF10_BPHLCD10. */
#define BS_LCD_WF10_BPHLCD10 (1U)          /*!< Bit field size in bits for LCD_WF10_BPHLCD10. */

/*! @brief Read current value of the LCD_WF10_BPHLCD10 field. */
#define BR_LCD_WF10_BPHLCD10(x) (BME_UBFX8(HW_LCD_WF10_ADDR(x), BP_LCD_WF10_BPHLCD10, BS_LCD_WF10_BPHLCD10))

/*! @brief Format value for bitfield LCD_WF10_BPHLCD10. */
#define BF_LCD_WF10_BPHLCD10(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF10_BPHLCD10) & BM_LCD_WF10_BPHLCD10)

/*! @brief Set the BPHLCD10 field to a new value. */
#define BW_LCD_WF10_BPHLCD10(x, v) (BME_BFI8(HW_LCD_WF10_ADDR(x), ((uint8_t)(v) << BP_LCD_WF10_BPHLCD10), BP_LCD_WF10_BPHLCD10, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF11 - LCD Waveform Register 11.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF11 - LCD Waveform Register 11. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf11
{
    uint8_t U;
    struct _hw_lcd_wf11_bitfields
    {
        uint8_t BPALCD11 : 1;          /*!< [0]  */
        uint8_t BPBLCD11 : 1;          /*!< [1]  */
        uint8_t BPCLCD11 : 1;          /*!< [2]  */
        uint8_t BPDLCD11 : 1;          /*!< [3]  */
        uint8_t BPELCD11 : 1;          /*!< [4]  */
        uint8_t BPFLCD11 : 1;          /*!< [5]  */
        uint8_t BPGLCD11 : 1;          /*!< [6]  */
        uint8_t BPHLCD11 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf11_t;

/*!
 * @name Constants and macros for entire LCD_WF11 register
 */
/*@{*/
#define HW_LCD_WF11_ADDR(x)      ((uint32_t)(x) + 0x2BU)

#define HW_LCD_WF11(x)           (*(__IO hw_lcd_wf11_t *) HW_LCD_WF11_ADDR(x))
#define HW_LCD_WF11_RD(x)        (HW_LCD_WF11(x).U)
#define HW_LCD_WF11_WR(x, v)     (HW_LCD_WF11(x).U = (v))
#define HW_LCD_WF11_SET(x, v)    (BME_OR8(HW_LCD_WF11_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF11_CLR(x, v)    (BME_AND8(HW_LCD_WF11_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF11_TOG(x, v)    (BME_XOR8(HW_LCD_WF11_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF11 bitfields
 */

/*!
 * @name Register LCD_WF11, field BPALCD11[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF11_BPALCD11 (0U)          /*!< Bit position for LCD_WF11_BPALCD11. */
#define BM_LCD_WF11_BPALCD11 (0x01U)       /*!< Bit mask for LCD_WF11_BPALCD11. */
#define BS_LCD_WF11_BPALCD11 (1U)          /*!< Bit field size in bits for LCD_WF11_BPALCD11. */

/*! @brief Read current value of the LCD_WF11_BPALCD11 field. */
#define BR_LCD_WF11_BPALCD11(x) (BME_UBFX8(HW_LCD_WF11_ADDR(x), BP_LCD_WF11_BPALCD11, BS_LCD_WF11_BPALCD11))

/*! @brief Format value for bitfield LCD_WF11_BPALCD11. */
#define BF_LCD_WF11_BPALCD11(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF11_BPALCD11) & BM_LCD_WF11_BPALCD11)

/*! @brief Set the BPALCD11 field to a new value. */
#define BW_LCD_WF11_BPALCD11(x, v) (BME_BFI8(HW_LCD_WF11_ADDR(x), ((uint8_t)(v) << BP_LCD_WF11_BPALCD11), BP_LCD_WF11_BPALCD11, 1))
/*@}*/

/*!
 * @name Register LCD_WF11, field BPBLCD11[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF11_BPBLCD11 (1U)          /*!< Bit position for LCD_WF11_BPBLCD11. */
#define BM_LCD_WF11_BPBLCD11 (0x02U)       /*!< Bit mask for LCD_WF11_BPBLCD11. */
#define BS_LCD_WF11_BPBLCD11 (1U)          /*!< Bit field size in bits for LCD_WF11_BPBLCD11. */

/*! @brief Read current value of the LCD_WF11_BPBLCD11 field. */
#define BR_LCD_WF11_BPBLCD11(x) (BME_UBFX8(HW_LCD_WF11_ADDR(x), BP_LCD_WF11_BPBLCD11, BS_LCD_WF11_BPBLCD11))

/*! @brief Format value for bitfield LCD_WF11_BPBLCD11. */
#define BF_LCD_WF11_BPBLCD11(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF11_BPBLCD11) & BM_LCD_WF11_BPBLCD11)

/*! @brief Set the BPBLCD11 field to a new value. */
#define BW_LCD_WF11_BPBLCD11(x, v) (BME_BFI8(HW_LCD_WF11_ADDR(x), ((uint8_t)(v) << BP_LCD_WF11_BPBLCD11), BP_LCD_WF11_BPBLCD11, 1))
/*@}*/

/*!
 * @name Register LCD_WF11, field BPCLCD11[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF11_BPCLCD11 (2U)          /*!< Bit position for LCD_WF11_BPCLCD11. */
#define BM_LCD_WF11_BPCLCD11 (0x04U)       /*!< Bit mask for LCD_WF11_BPCLCD11. */
#define BS_LCD_WF11_BPCLCD11 (1U)          /*!< Bit field size in bits for LCD_WF11_BPCLCD11. */

/*! @brief Read current value of the LCD_WF11_BPCLCD11 field. */
#define BR_LCD_WF11_BPCLCD11(x) (BME_UBFX8(HW_LCD_WF11_ADDR(x), BP_LCD_WF11_BPCLCD11, BS_LCD_WF11_BPCLCD11))

/*! @brief Format value for bitfield LCD_WF11_BPCLCD11. */
#define BF_LCD_WF11_BPCLCD11(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF11_BPCLCD11) & BM_LCD_WF11_BPCLCD11)

/*! @brief Set the BPCLCD11 field to a new value. */
#define BW_LCD_WF11_BPCLCD11(x, v) (BME_BFI8(HW_LCD_WF11_ADDR(x), ((uint8_t)(v) << BP_LCD_WF11_BPCLCD11), BP_LCD_WF11_BPCLCD11, 1))
/*@}*/

/*!
 * @name Register LCD_WF11, field BPDLCD11[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF11_BPDLCD11 (3U)          /*!< Bit position for LCD_WF11_BPDLCD11. */
#define BM_LCD_WF11_BPDLCD11 (0x08U)       /*!< Bit mask for LCD_WF11_BPDLCD11. */
#define BS_LCD_WF11_BPDLCD11 (1U)          /*!< Bit field size in bits for LCD_WF11_BPDLCD11. */

/*! @brief Read current value of the LCD_WF11_BPDLCD11 field. */
#define BR_LCD_WF11_BPDLCD11(x) (BME_UBFX8(HW_LCD_WF11_ADDR(x), BP_LCD_WF11_BPDLCD11, BS_LCD_WF11_BPDLCD11))

/*! @brief Format value for bitfield LCD_WF11_BPDLCD11. */
#define BF_LCD_WF11_BPDLCD11(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF11_BPDLCD11) & BM_LCD_WF11_BPDLCD11)

/*! @brief Set the BPDLCD11 field to a new value. */
#define BW_LCD_WF11_BPDLCD11(x, v) (BME_BFI8(HW_LCD_WF11_ADDR(x), ((uint8_t)(v) << BP_LCD_WF11_BPDLCD11), BP_LCD_WF11_BPDLCD11, 1))
/*@}*/

/*!
 * @name Register LCD_WF11, field BPELCD11[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF11_BPELCD11 (4U)          /*!< Bit position for LCD_WF11_BPELCD11. */
#define BM_LCD_WF11_BPELCD11 (0x10U)       /*!< Bit mask for LCD_WF11_BPELCD11. */
#define BS_LCD_WF11_BPELCD11 (1U)          /*!< Bit field size in bits for LCD_WF11_BPELCD11. */

/*! @brief Read current value of the LCD_WF11_BPELCD11 field. */
#define BR_LCD_WF11_BPELCD11(x) (BME_UBFX8(HW_LCD_WF11_ADDR(x), BP_LCD_WF11_BPELCD11, BS_LCD_WF11_BPELCD11))

/*! @brief Format value for bitfield LCD_WF11_BPELCD11. */
#define BF_LCD_WF11_BPELCD11(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF11_BPELCD11) & BM_LCD_WF11_BPELCD11)

/*! @brief Set the BPELCD11 field to a new value. */
#define BW_LCD_WF11_BPELCD11(x, v) (BME_BFI8(HW_LCD_WF11_ADDR(x), ((uint8_t)(v) << BP_LCD_WF11_BPELCD11), BP_LCD_WF11_BPELCD11, 1))
/*@}*/

/*!
 * @name Register LCD_WF11, field BPFLCD11[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF11_BPFLCD11 (5U)          /*!< Bit position for LCD_WF11_BPFLCD11. */
#define BM_LCD_WF11_BPFLCD11 (0x20U)       /*!< Bit mask for LCD_WF11_BPFLCD11. */
#define BS_LCD_WF11_BPFLCD11 (1U)          /*!< Bit field size in bits for LCD_WF11_BPFLCD11. */

/*! @brief Read current value of the LCD_WF11_BPFLCD11 field. */
#define BR_LCD_WF11_BPFLCD11(x) (BME_UBFX8(HW_LCD_WF11_ADDR(x), BP_LCD_WF11_BPFLCD11, BS_LCD_WF11_BPFLCD11))

/*! @brief Format value for bitfield LCD_WF11_BPFLCD11. */
#define BF_LCD_WF11_BPFLCD11(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF11_BPFLCD11) & BM_LCD_WF11_BPFLCD11)

/*! @brief Set the BPFLCD11 field to a new value. */
#define BW_LCD_WF11_BPFLCD11(x, v) (BME_BFI8(HW_LCD_WF11_ADDR(x), ((uint8_t)(v) << BP_LCD_WF11_BPFLCD11), BP_LCD_WF11_BPFLCD11, 1))
/*@}*/

/*!
 * @name Register LCD_WF11, field BPGLCD11[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF11_BPGLCD11 (6U)          /*!< Bit position for LCD_WF11_BPGLCD11. */
#define BM_LCD_WF11_BPGLCD11 (0x40U)       /*!< Bit mask for LCD_WF11_BPGLCD11. */
#define BS_LCD_WF11_BPGLCD11 (1U)          /*!< Bit field size in bits for LCD_WF11_BPGLCD11. */

/*! @brief Read current value of the LCD_WF11_BPGLCD11 field. */
#define BR_LCD_WF11_BPGLCD11(x) (BME_UBFX8(HW_LCD_WF11_ADDR(x), BP_LCD_WF11_BPGLCD11, BS_LCD_WF11_BPGLCD11))

/*! @brief Format value for bitfield LCD_WF11_BPGLCD11. */
#define BF_LCD_WF11_BPGLCD11(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF11_BPGLCD11) & BM_LCD_WF11_BPGLCD11)

/*! @brief Set the BPGLCD11 field to a new value. */
#define BW_LCD_WF11_BPGLCD11(x, v) (BME_BFI8(HW_LCD_WF11_ADDR(x), ((uint8_t)(v) << BP_LCD_WF11_BPGLCD11), BP_LCD_WF11_BPGLCD11, 1))
/*@}*/

/*!
 * @name Register LCD_WF11, field BPHLCD11[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF11_BPHLCD11 (7U)          /*!< Bit position for LCD_WF11_BPHLCD11. */
#define BM_LCD_WF11_BPHLCD11 (0x80U)       /*!< Bit mask for LCD_WF11_BPHLCD11. */
#define BS_LCD_WF11_BPHLCD11 (1U)          /*!< Bit field size in bits for LCD_WF11_BPHLCD11. */

/*! @brief Read current value of the LCD_WF11_BPHLCD11 field. */
#define BR_LCD_WF11_BPHLCD11(x) (BME_UBFX8(HW_LCD_WF11_ADDR(x), BP_LCD_WF11_BPHLCD11, BS_LCD_WF11_BPHLCD11))

/*! @brief Format value for bitfield LCD_WF11_BPHLCD11. */
#define BF_LCD_WF11_BPHLCD11(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF11_BPHLCD11) & BM_LCD_WF11_BPHLCD11)

/*! @brief Set the BPHLCD11 field to a new value. */
#define BW_LCD_WF11_BPHLCD11(x, v) (BME_BFI8(HW_LCD_WF11_ADDR(x), ((uint8_t)(v) << BP_LCD_WF11_BPHLCD11), BP_LCD_WF11_BPHLCD11, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF12 - LCD Waveform Register 12.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF12 - LCD Waveform Register 12. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf12
{
    uint8_t U;
    struct _hw_lcd_wf12_bitfields
    {
        uint8_t BPALCD12 : 1;          /*!< [0]  */
        uint8_t BPBLCD12 : 1;          /*!< [1]  */
        uint8_t BPCLCD12 : 1;          /*!< [2]  */
        uint8_t BPDLCD12 : 1;          /*!< [3]  */
        uint8_t BPELCD12 : 1;          /*!< [4]  */
        uint8_t BPFLCD12 : 1;          /*!< [5]  */
        uint8_t BPGLCD12 : 1;          /*!< [6]  */
        uint8_t BPHLCD12 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf12_t;

/*!
 * @name Constants and macros for entire LCD_WF12 register
 */
/*@{*/
#define HW_LCD_WF12_ADDR(x)      ((uint32_t)(x) + 0x2CU)

#define HW_LCD_WF12(x)           (*(__IO hw_lcd_wf12_t *) HW_LCD_WF12_ADDR(x))
#define HW_LCD_WF12_RD(x)        (HW_LCD_WF12(x).U)
#define HW_LCD_WF12_WR(x, v)     (HW_LCD_WF12(x).U = (v))
#define HW_LCD_WF12_SET(x, v)    (BME_OR8(HW_LCD_WF12_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF12_CLR(x, v)    (BME_AND8(HW_LCD_WF12_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF12_TOG(x, v)    (BME_XOR8(HW_LCD_WF12_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF12 bitfields
 */

/*!
 * @name Register LCD_WF12, field BPALCD12[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF12_BPALCD12 (0U)          /*!< Bit position for LCD_WF12_BPALCD12. */
#define BM_LCD_WF12_BPALCD12 (0x01U)       /*!< Bit mask for LCD_WF12_BPALCD12. */
#define BS_LCD_WF12_BPALCD12 (1U)          /*!< Bit field size in bits for LCD_WF12_BPALCD12. */

/*! @brief Read current value of the LCD_WF12_BPALCD12 field. */
#define BR_LCD_WF12_BPALCD12(x) (BME_UBFX8(HW_LCD_WF12_ADDR(x), BP_LCD_WF12_BPALCD12, BS_LCD_WF12_BPALCD12))

/*! @brief Format value for bitfield LCD_WF12_BPALCD12. */
#define BF_LCD_WF12_BPALCD12(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF12_BPALCD12) & BM_LCD_WF12_BPALCD12)

/*! @brief Set the BPALCD12 field to a new value. */
#define BW_LCD_WF12_BPALCD12(x, v) (BME_BFI8(HW_LCD_WF12_ADDR(x), ((uint8_t)(v) << BP_LCD_WF12_BPALCD12), BP_LCD_WF12_BPALCD12, 1))
/*@}*/

/*!
 * @name Register LCD_WF12, field BPBLCD12[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF12_BPBLCD12 (1U)          /*!< Bit position for LCD_WF12_BPBLCD12. */
#define BM_LCD_WF12_BPBLCD12 (0x02U)       /*!< Bit mask for LCD_WF12_BPBLCD12. */
#define BS_LCD_WF12_BPBLCD12 (1U)          /*!< Bit field size in bits for LCD_WF12_BPBLCD12. */

/*! @brief Read current value of the LCD_WF12_BPBLCD12 field. */
#define BR_LCD_WF12_BPBLCD12(x) (BME_UBFX8(HW_LCD_WF12_ADDR(x), BP_LCD_WF12_BPBLCD12, BS_LCD_WF12_BPBLCD12))

/*! @brief Format value for bitfield LCD_WF12_BPBLCD12. */
#define BF_LCD_WF12_BPBLCD12(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF12_BPBLCD12) & BM_LCD_WF12_BPBLCD12)

/*! @brief Set the BPBLCD12 field to a new value. */
#define BW_LCD_WF12_BPBLCD12(x, v) (BME_BFI8(HW_LCD_WF12_ADDR(x), ((uint8_t)(v) << BP_LCD_WF12_BPBLCD12), BP_LCD_WF12_BPBLCD12, 1))
/*@}*/

/*!
 * @name Register LCD_WF12, field BPCLCD12[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF12_BPCLCD12 (2U)          /*!< Bit position for LCD_WF12_BPCLCD12. */
#define BM_LCD_WF12_BPCLCD12 (0x04U)       /*!< Bit mask for LCD_WF12_BPCLCD12. */
#define BS_LCD_WF12_BPCLCD12 (1U)          /*!< Bit field size in bits for LCD_WF12_BPCLCD12. */

/*! @brief Read current value of the LCD_WF12_BPCLCD12 field. */
#define BR_LCD_WF12_BPCLCD12(x) (BME_UBFX8(HW_LCD_WF12_ADDR(x), BP_LCD_WF12_BPCLCD12, BS_LCD_WF12_BPCLCD12))

/*! @brief Format value for bitfield LCD_WF12_BPCLCD12. */
#define BF_LCD_WF12_BPCLCD12(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF12_BPCLCD12) & BM_LCD_WF12_BPCLCD12)

/*! @brief Set the BPCLCD12 field to a new value. */
#define BW_LCD_WF12_BPCLCD12(x, v) (BME_BFI8(HW_LCD_WF12_ADDR(x), ((uint8_t)(v) << BP_LCD_WF12_BPCLCD12), BP_LCD_WF12_BPCLCD12, 1))
/*@}*/

/*!
 * @name Register LCD_WF12, field BPDLCD12[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF12_BPDLCD12 (3U)          /*!< Bit position for LCD_WF12_BPDLCD12. */
#define BM_LCD_WF12_BPDLCD12 (0x08U)       /*!< Bit mask for LCD_WF12_BPDLCD12. */
#define BS_LCD_WF12_BPDLCD12 (1U)          /*!< Bit field size in bits for LCD_WF12_BPDLCD12. */

/*! @brief Read current value of the LCD_WF12_BPDLCD12 field. */
#define BR_LCD_WF12_BPDLCD12(x) (BME_UBFX8(HW_LCD_WF12_ADDR(x), BP_LCD_WF12_BPDLCD12, BS_LCD_WF12_BPDLCD12))

/*! @brief Format value for bitfield LCD_WF12_BPDLCD12. */
#define BF_LCD_WF12_BPDLCD12(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF12_BPDLCD12) & BM_LCD_WF12_BPDLCD12)

/*! @brief Set the BPDLCD12 field to a new value. */
#define BW_LCD_WF12_BPDLCD12(x, v) (BME_BFI8(HW_LCD_WF12_ADDR(x), ((uint8_t)(v) << BP_LCD_WF12_BPDLCD12), BP_LCD_WF12_BPDLCD12, 1))
/*@}*/

/*!
 * @name Register LCD_WF12, field BPELCD12[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF12_BPELCD12 (4U)          /*!< Bit position for LCD_WF12_BPELCD12. */
#define BM_LCD_WF12_BPELCD12 (0x10U)       /*!< Bit mask for LCD_WF12_BPELCD12. */
#define BS_LCD_WF12_BPELCD12 (1U)          /*!< Bit field size in bits for LCD_WF12_BPELCD12. */

/*! @brief Read current value of the LCD_WF12_BPELCD12 field. */
#define BR_LCD_WF12_BPELCD12(x) (BME_UBFX8(HW_LCD_WF12_ADDR(x), BP_LCD_WF12_BPELCD12, BS_LCD_WF12_BPELCD12))

/*! @brief Format value for bitfield LCD_WF12_BPELCD12. */
#define BF_LCD_WF12_BPELCD12(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF12_BPELCD12) & BM_LCD_WF12_BPELCD12)

/*! @brief Set the BPELCD12 field to a new value. */
#define BW_LCD_WF12_BPELCD12(x, v) (BME_BFI8(HW_LCD_WF12_ADDR(x), ((uint8_t)(v) << BP_LCD_WF12_BPELCD12), BP_LCD_WF12_BPELCD12, 1))
/*@}*/

/*!
 * @name Register LCD_WF12, field BPFLCD12[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF12_BPFLCD12 (5U)          /*!< Bit position for LCD_WF12_BPFLCD12. */
#define BM_LCD_WF12_BPFLCD12 (0x20U)       /*!< Bit mask for LCD_WF12_BPFLCD12. */
#define BS_LCD_WF12_BPFLCD12 (1U)          /*!< Bit field size in bits for LCD_WF12_BPFLCD12. */

/*! @brief Read current value of the LCD_WF12_BPFLCD12 field. */
#define BR_LCD_WF12_BPFLCD12(x) (BME_UBFX8(HW_LCD_WF12_ADDR(x), BP_LCD_WF12_BPFLCD12, BS_LCD_WF12_BPFLCD12))

/*! @brief Format value for bitfield LCD_WF12_BPFLCD12. */
#define BF_LCD_WF12_BPFLCD12(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF12_BPFLCD12) & BM_LCD_WF12_BPFLCD12)

/*! @brief Set the BPFLCD12 field to a new value. */
#define BW_LCD_WF12_BPFLCD12(x, v) (BME_BFI8(HW_LCD_WF12_ADDR(x), ((uint8_t)(v) << BP_LCD_WF12_BPFLCD12), BP_LCD_WF12_BPFLCD12, 1))
/*@}*/

/*!
 * @name Register LCD_WF12, field BPGLCD12[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF12_BPGLCD12 (6U)          /*!< Bit position for LCD_WF12_BPGLCD12. */
#define BM_LCD_WF12_BPGLCD12 (0x40U)       /*!< Bit mask for LCD_WF12_BPGLCD12. */
#define BS_LCD_WF12_BPGLCD12 (1U)          /*!< Bit field size in bits for LCD_WF12_BPGLCD12. */

/*! @brief Read current value of the LCD_WF12_BPGLCD12 field. */
#define BR_LCD_WF12_BPGLCD12(x) (BME_UBFX8(HW_LCD_WF12_ADDR(x), BP_LCD_WF12_BPGLCD12, BS_LCD_WF12_BPGLCD12))

/*! @brief Format value for bitfield LCD_WF12_BPGLCD12. */
#define BF_LCD_WF12_BPGLCD12(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF12_BPGLCD12) & BM_LCD_WF12_BPGLCD12)

/*! @brief Set the BPGLCD12 field to a new value. */
#define BW_LCD_WF12_BPGLCD12(x, v) (BME_BFI8(HW_LCD_WF12_ADDR(x), ((uint8_t)(v) << BP_LCD_WF12_BPGLCD12), BP_LCD_WF12_BPGLCD12, 1))
/*@}*/

/*!
 * @name Register LCD_WF12, field BPHLCD12[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF12_BPHLCD12 (7U)          /*!< Bit position for LCD_WF12_BPHLCD12. */
#define BM_LCD_WF12_BPHLCD12 (0x80U)       /*!< Bit mask for LCD_WF12_BPHLCD12. */
#define BS_LCD_WF12_BPHLCD12 (1U)          /*!< Bit field size in bits for LCD_WF12_BPHLCD12. */

/*! @brief Read current value of the LCD_WF12_BPHLCD12 field. */
#define BR_LCD_WF12_BPHLCD12(x) (BME_UBFX8(HW_LCD_WF12_ADDR(x), BP_LCD_WF12_BPHLCD12, BS_LCD_WF12_BPHLCD12))

/*! @brief Format value for bitfield LCD_WF12_BPHLCD12. */
#define BF_LCD_WF12_BPHLCD12(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF12_BPHLCD12) & BM_LCD_WF12_BPHLCD12)

/*! @brief Set the BPHLCD12 field to a new value. */
#define BW_LCD_WF12_BPHLCD12(x, v) (BME_BFI8(HW_LCD_WF12_ADDR(x), ((uint8_t)(v) << BP_LCD_WF12_BPHLCD12), BP_LCD_WF12_BPHLCD12, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF13 - LCD Waveform Register 13.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF13 - LCD Waveform Register 13. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf13
{
    uint8_t U;
    struct _hw_lcd_wf13_bitfields
    {
        uint8_t BPALCD13 : 1;          /*!< [0]  */
        uint8_t BPBLCD13 : 1;          /*!< [1]  */
        uint8_t BPCLCD13 : 1;          /*!< [2]  */
        uint8_t BPDLCD13 : 1;          /*!< [3]  */
        uint8_t BPELCD13 : 1;          /*!< [4]  */
        uint8_t BPFLCD13 : 1;          /*!< [5]  */
        uint8_t BPGLCD13 : 1;          /*!< [6]  */
        uint8_t BPHLCD13 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf13_t;

/*!
 * @name Constants and macros for entire LCD_WF13 register
 */
/*@{*/
#define HW_LCD_WF13_ADDR(x)      ((uint32_t)(x) + 0x2DU)

#define HW_LCD_WF13(x)           (*(__IO hw_lcd_wf13_t *) HW_LCD_WF13_ADDR(x))
#define HW_LCD_WF13_RD(x)        (HW_LCD_WF13(x).U)
#define HW_LCD_WF13_WR(x, v)     (HW_LCD_WF13(x).U = (v))
#define HW_LCD_WF13_SET(x, v)    (BME_OR8(HW_LCD_WF13_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF13_CLR(x, v)    (BME_AND8(HW_LCD_WF13_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF13_TOG(x, v)    (BME_XOR8(HW_LCD_WF13_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF13 bitfields
 */

/*!
 * @name Register LCD_WF13, field BPALCD13[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF13_BPALCD13 (0U)          /*!< Bit position for LCD_WF13_BPALCD13. */
#define BM_LCD_WF13_BPALCD13 (0x01U)       /*!< Bit mask for LCD_WF13_BPALCD13. */
#define BS_LCD_WF13_BPALCD13 (1U)          /*!< Bit field size in bits for LCD_WF13_BPALCD13. */

/*! @brief Read current value of the LCD_WF13_BPALCD13 field. */
#define BR_LCD_WF13_BPALCD13(x) (BME_UBFX8(HW_LCD_WF13_ADDR(x), BP_LCD_WF13_BPALCD13, BS_LCD_WF13_BPALCD13))

/*! @brief Format value for bitfield LCD_WF13_BPALCD13. */
#define BF_LCD_WF13_BPALCD13(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF13_BPALCD13) & BM_LCD_WF13_BPALCD13)

/*! @brief Set the BPALCD13 field to a new value. */
#define BW_LCD_WF13_BPALCD13(x, v) (BME_BFI8(HW_LCD_WF13_ADDR(x), ((uint8_t)(v) << BP_LCD_WF13_BPALCD13), BP_LCD_WF13_BPALCD13, 1))
/*@}*/

/*!
 * @name Register LCD_WF13, field BPBLCD13[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF13_BPBLCD13 (1U)          /*!< Bit position for LCD_WF13_BPBLCD13. */
#define BM_LCD_WF13_BPBLCD13 (0x02U)       /*!< Bit mask for LCD_WF13_BPBLCD13. */
#define BS_LCD_WF13_BPBLCD13 (1U)          /*!< Bit field size in bits for LCD_WF13_BPBLCD13. */

/*! @brief Read current value of the LCD_WF13_BPBLCD13 field. */
#define BR_LCD_WF13_BPBLCD13(x) (BME_UBFX8(HW_LCD_WF13_ADDR(x), BP_LCD_WF13_BPBLCD13, BS_LCD_WF13_BPBLCD13))

/*! @brief Format value for bitfield LCD_WF13_BPBLCD13. */
#define BF_LCD_WF13_BPBLCD13(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF13_BPBLCD13) & BM_LCD_WF13_BPBLCD13)

/*! @brief Set the BPBLCD13 field to a new value. */
#define BW_LCD_WF13_BPBLCD13(x, v) (BME_BFI8(HW_LCD_WF13_ADDR(x), ((uint8_t)(v) << BP_LCD_WF13_BPBLCD13), BP_LCD_WF13_BPBLCD13, 1))
/*@}*/

/*!
 * @name Register LCD_WF13, field BPCLCD13[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF13_BPCLCD13 (2U)          /*!< Bit position for LCD_WF13_BPCLCD13. */
#define BM_LCD_WF13_BPCLCD13 (0x04U)       /*!< Bit mask for LCD_WF13_BPCLCD13. */
#define BS_LCD_WF13_BPCLCD13 (1U)          /*!< Bit field size in bits for LCD_WF13_BPCLCD13. */

/*! @brief Read current value of the LCD_WF13_BPCLCD13 field. */
#define BR_LCD_WF13_BPCLCD13(x) (BME_UBFX8(HW_LCD_WF13_ADDR(x), BP_LCD_WF13_BPCLCD13, BS_LCD_WF13_BPCLCD13))

/*! @brief Format value for bitfield LCD_WF13_BPCLCD13. */
#define BF_LCD_WF13_BPCLCD13(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF13_BPCLCD13) & BM_LCD_WF13_BPCLCD13)

/*! @brief Set the BPCLCD13 field to a new value. */
#define BW_LCD_WF13_BPCLCD13(x, v) (BME_BFI8(HW_LCD_WF13_ADDR(x), ((uint8_t)(v) << BP_LCD_WF13_BPCLCD13), BP_LCD_WF13_BPCLCD13, 1))
/*@}*/

/*!
 * @name Register LCD_WF13, field BPDLCD13[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF13_BPDLCD13 (3U)          /*!< Bit position for LCD_WF13_BPDLCD13. */
#define BM_LCD_WF13_BPDLCD13 (0x08U)       /*!< Bit mask for LCD_WF13_BPDLCD13. */
#define BS_LCD_WF13_BPDLCD13 (1U)          /*!< Bit field size in bits for LCD_WF13_BPDLCD13. */

/*! @brief Read current value of the LCD_WF13_BPDLCD13 field. */
#define BR_LCD_WF13_BPDLCD13(x) (BME_UBFX8(HW_LCD_WF13_ADDR(x), BP_LCD_WF13_BPDLCD13, BS_LCD_WF13_BPDLCD13))

/*! @brief Format value for bitfield LCD_WF13_BPDLCD13. */
#define BF_LCD_WF13_BPDLCD13(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF13_BPDLCD13) & BM_LCD_WF13_BPDLCD13)

/*! @brief Set the BPDLCD13 field to a new value. */
#define BW_LCD_WF13_BPDLCD13(x, v) (BME_BFI8(HW_LCD_WF13_ADDR(x), ((uint8_t)(v) << BP_LCD_WF13_BPDLCD13), BP_LCD_WF13_BPDLCD13, 1))
/*@}*/

/*!
 * @name Register LCD_WF13, field BPELCD13[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF13_BPELCD13 (4U)          /*!< Bit position for LCD_WF13_BPELCD13. */
#define BM_LCD_WF13_BPELCD13 (0x10U)       /*!< Bit mask for LCD_WF13_BPELCD13. */
#define BS_LCD_WF13_BPELCD13 (1U)          /*!< Bit field size in bits for LCD_WF13_BPELCD13. */

/*! @brief Read current value of the LCD_WF13_BPELCD13 field. */
#define BR_LCD_WF13_BPELCD13(x) (BME_UBFX8(HW_LCD_WF13_ADDR(x), BP_LCD_WF13_BPELCD13, BS_LCD_WF13_BPELCD13))

/*! @brief Format value for bitfield LCD_WF13_BPELCD13. */
#define BF_LCD_WF13_BPELCD13(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF13_BPELCD13) & BM_LCD_WF13_BPELCD13)

/*! @brief Set the BPELCD13 field to a new value. */
#define BW_LCD_WF13_BPELCD13(x, v) (BME_BFI8(HW_LCD_WF13_ADDR(x), ((uint8_t)(v) << BP_LCD_WF13_BPELCD13), BP_LCD_WF13_BPELCD13, 1))
/*@}*/

/*!
 * @name Register LCD_WF13, field BPFLCD13[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF13_BPFLCD13 (5U)          /*!< Bit position for LCD_WF13_BPFLCD13. */
#define BM_LCD_WF13_BPFLCD13 (0x20U)       /*!< Bit mask for LCD_WF13_BPFLCD13. */
#define BS_LCD_WF13_BPFLCD13 (1U)          /*!< Bit field size in bits for LCD_WF13_BPFLCD13. */

/*! @brief Read current value of the LCD_WF13_BPFLCD13 field. */
#define BR_LCD_WF13_BPFLCD13(x) (BME_UBFX8(HW_LCD_WF13_ADDR(x), BP_LCD_WF13_BPFLCD13, BS_LCD_WF13_BPFLCD13))

/*! @brief Format value for bitfield LCD_WF13_BPFLCD13. */
#define BF_LCD_WF13_BPFLCD13(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF13_BPFLCD13) & BM_LCD_WF13_BPFLCD13)

/*! @brief Set the BPFLCD13 field to a new value. */
#define BW_LCD_WF13_BPFLCD13(x, v) (BME_BFI8(HW_LCD_WF13_ADDR(x), ((uint8_t)(v) << BP_LCD_WF13_BPFLCD13), BP_LCD_WF13_BPFLCD13, 1))
/*@}*/

/*!
 * @name Register LCD_WF13, field BPGLCD13[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF13_BPGLCD13 (6U)          /*!< Bit position for LCD_WF13_BPGLCD13. */
#define BM_LCD_WF13_BPGLCD13 (0x40U)       /*!< Bit mask for LCD_WF13_BPGLCD13. */
#define BS_LCD_WF13_BPGLCD13 (1U)          /*!< Bit field size in bits for LCD_WF13_BPGLCD13. */

/*! @brief Read current value of the LCD_WF13_BPGLCD13 field. */
#define BR_LCD_WF13_BPGLCD13(x) (BME_UBFX8(HW_LCD_WF13_ADDR(x), BP_LCD_WF13_BPGLCD13, BS_LCD_WF13_BPGLCD13))

/*! @brief Format value for bitfield LCD_WF13_BPGLCD13. */
#define BF_LCD_WF13_BPGLCD13(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF13_BPGLCD13) & BM_LCD_WF13_BPGLCD13)

/*! @brief Set the BPGLCD13 field to a new value. */
#define BW_LCD_WF13_BPGLCD13(x, v) (BME_BFI8(HW_LCD_WF13_ADDR(x), ((uint8_t)(v) << BP_LCD_WF13_BPGLCD13), BP_LCD_WF13_BPGLCD13, 1))
/*@}*/

/*!
 * @name Register LCD_WF13, field BPHLCD13[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF13_BPHLCD13 (7U)          /*!< Bit position for LCD_WF13_BPHLCD13. */
#define BM_LCD_WF13_BPHLCD13 (0x80U)       /*!< Bit mask for LCD_WF13_BPHLCD13. */
#define BS_LCD_WF13_BPHLCD13 (1U)          /*!< Bit field size in bits for LCD_WF13_BPHLCD13. */

/*! @brief Read current value of the LCD_WF13_BPHLCD13 field. */
#define BR_LCD_WF13_BPHLCD13(x) (BME_UBFX8(HW_LCD_WF13_ADDR(x), BP_LCD_WF13_BPHLCD13, BS_LCD_WF13_BPHLCD13))

/*! @brief Format value for bitfield LCD_WF13_BPHLCD13. */
#define BF_LCD_WF13_BPHLCD13(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF13_BPHLCD13) & BM_LCD_WF13_BPHLCD13)

/*! @brief Set the BPHLCD13 field to a new value. */
#define BW_LCD_WF13_BPHLCD13(x, v) (BME_BFI8(HW_LCD_WF13_ADDR(x), ((uint8_t)(v) << BP_LCD_WF13_BPHLCD13), BP_LCD_WF13_BPHLCD13, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF14 - LCD Waveform Register 14.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF14 - LCD Waveform Register 14. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf14
{
    uint8_t U;
    struct _hw_lcd_wf14_bitfields
    {
        uint8_t BPALCD14 : 1;          /*!< [0]  */
        uint8_t BPBLCD14 : 1;          /*!< [1]  */
        uint8_t BPCLCD14 : 1;          /*!< [2]  */
        uint8_t BPDLCD14 : 1;          /*!< [3]  */
        uint8_t BPELCD14 : 1;          /*!< [4]  */
        uint8_t BPFLCD14 : 1;          /*!< [5]  */
        uint8_t BPGLCD14 : 1;          /*!< [6]  */
        uint8_t BPHLCD14 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf14_t;

/*!
 * @name Constants and macros for entire LCD_WF14 register
 */
/*@{*/
#define HW_LCD_WF14_ADDR(x)      ((uint32_t)(x) + 0x2EU)

#define HW_LCD_WF14(x)           (*(__IO hw_lcd_wf14_t *) HW_LCD_WF14_ADDR(x))
#define HW_LCD_WF14_RD(x)        (HW_LCD_WF14(x).U)
#define HW_LCD_WF14_WR(x, v)     (HW_LCD_WF14(x).U = (v))
#define HW_LCD_WF14_SET(x, v)    (BME_OR8(HW_LCD_WF14_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF14_CLR(x, v)    (BME_AND8(HW_LCD_WF14_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF14_TOG(x, v)    (BME_XOR8(HW_LCD_WF14_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF14 bitfields
 */

/*!
 * @name Register LCD_WF14, field BPALCD14[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF14_BPALCD14 (0U)          /*!< Bit position for LCD_WF14_BPALCD14. */
#define BM_LCD_WF14_BPALCD14 (0x01U)       /*!< Bit mask for LCD_WF14_BPALCD14. */
#define BS_LCD_WF14_BPALCD14 (1U)          /*!< Bit field size in bits for LCD_WF14_BPALCD14. */

/*! @brief Read current value of the LCD_WF14_BPALCD14 field. */
#define BR_LCD_WF14_BPALCD14(x) (BME_UBFX8(HW_LCD_WF14_ADDR(x), BP_LCD_WF14_BPALCD14, BS_LCD_WF14_BPALCD14))

/*! @brief Format value for bitfield LCD_WF14_BPALCD14. */
#define BF_LCD_WF14_BPALCD14(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF14_BPALCD14) & BM_LCD_WF14_BPALCD14)

/*! @brief Set the BPALCD14 field to a new value. */
#define BW_LCD_WF14_BPALCD14(x, v) (BME_BFI8(HW_LCD_WF14_ADDR(x), ((uint8_t)(v) << BP_LCD_WF14_BPALCD14), BP_LCD_WF14_BPALCD14, 1))
/*@}*/

/*!
 * @name Register LCD_WF14, field BPBLCD14[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF14_BPBLCD14 (1U)          /*!< Bit position for LCD_WF14_BPBLCD14. */
#define BM_LCD_WF14_BPBLCD14 (0x02U)       /*!< Bit mask for LCD_WF14_BPBLCD14. */
#define BS_LCD_WF14_BPBLCD14 (1U)          /*!< Bit field size in bits for LCD_WF14_BPBLCD14. */

/*! @brief Read current value of the LCD_WF14_BPBLCD14 field. */
#define BR_LCD_WF14_BPBLCD14(x) (BME_UBFX8(HW_LCD_WF14_ADDR(x), BP_LCD_WF14_BPBLCD14, BS_LCD_WF14_BPBLCD14))

/*! @brief Format value for bitfield LCD_WF14_BPBLCD14. */
#define BF_LCD_WF14_BPBLCD14(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF14_BPBLCD14) & BM_LCD_WF14_BPBLCD14)

/*! @brief Set the BPBLCD14 field to a new value. */
#define BW_LCD_WF14_BPBLCD14(x, v) (BME_BFI8(HW_LCD_WF14_ADDR(x), ((uint8_t)(v) << BP_LCD_WF14_BPBLCD14), BP_LCD_WF14_BPBLCD14, 1))
/*@}*/

/*!
 * @name Register LCD_WF14, field BPCLCD14[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF14_BPCLCD14 (2U)          /*!< Bit position for LCD_WF14_BPCLCD14. */
#define BM_LCD_WF14_BPCLCD14 (0x04U)       /*!< Bit mask for LCD_WF14_BPCLCD14. */
#define BS_LCD_WF14_BPCLCD14 (1U)          /*!< Bit field size in bits for LCD_WF14_BPCLCD14. */

/*! @brief Read current value of the LCD_WF14_BPCLCD14 field. */
#define BR_LCD_WF14_BPCLCD14(x) (BME_UBFX8(HW_LCD_WF14_ADDR(x), BP_LCD_WF14_BPCLCD14, BS_LCD_WF14_BPCLCD14))

/*! @brief Format value for bitfield LCD_WF14_BPCLCD14. */
#define BF_LCD_WF14_BPCLCD14(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF14_BPCLCD14) & BM_LCD_WF14_BPCLCD14)

/*! @brief Set the BPCLCD14 field to a new value. */
#define BW_LCD_WF14_BPCLCD14(x, v) (BME_BFI8(HW_LCD_WF14_ADDR(x), ((uint8_t)(v) << BP_LCD_WF14_BPCLCD14), BP_LCD_WF14_BPCLCD14, 1))
/*@}*/

/*!
 * @name Register LCD_WF14, field BPDLCD14[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF14_BPDLCD14 (3U)          /*!< Bit position for LCD_WF14_BPDLCD14. */
#define BM_LCD_WF14_BPDLCD14 (0x08U)       /*!< Bit mask for LCD_WF14_BPDLCD14. */
#define BS_LCD_WF14_BPDLCD14 (1U)          /*!< Bit field size in bits for LCD_WF14_BPDLCD14. */

/*! @brief Read current value of the LCD_WF14_BPDLCD14 field. */
#define BR_LCD_WF14_BPDLCD14(x) (BME_UBFX8(HW_LCD_WF14_ADDR(x), BP_LCD_WF14_BPDLCD14, BS_LCD_WF14_BPDLCD14))

/*! @brief Format value for bitfield LCD_WF14_BPDLCD14. */
#define BF_LCD_WF14_BPDLCD14(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF14_BPDLCD14) & BM_LCD_WF14_BPDLCD14)

/*! @brief Set the BPDLCD14 field to a new value. */
#define BW_LCD_WF14_BPDLCD14(x, v) (BME_BFI8(HW_LCD_WF14_ADDR(x), ((uint8_t)(v) << BP_LCD_WF14_BPDLCD14), BP_LCD_WF14_BPDLCD14, 1))
/*@}*/

/*!
 * @name Register LCD_WF14, field BPELCD14[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF14_BPELCD14 (4U)          /*!< Bit position for LCD_WF14_BPELCD14. */
#define BM_LCD_WF14_BPELCD14 (0x10U)       /*!< Bit mask for LCD_WF14_BPELCD14. */
#define BS_LCD_WF14_BPELCD14 (1U)          /*!< Bit field size in bits for LCD_WF14_BPELCD14. */

/*! @brief Read current value of the LCD_WF14_BPELCD14 field. */
#define BR_LCD_WF14_BPELCD14(x) (BME_UBFX8(HW_LCD_WF14_ADDR(x), BP_LCD_WF14_BPELCD14, BS_LCD_WF14_BPELCD14))

/*! @brief Format value for bitfield LCD_WF14_BPELCD14. */
#define BF_LCD_WF14_BPELCD14(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF14_BPELCD14) & BM_LCD_WF14_BPELCD14)

/*! @brief Set the BPELCD14 field to a new value. */
#define BW_LCD_WF14_BPELCD14(x, v) (BME_BFI8(HW_LCD_WF14_ADDR(x), ((uint8_t)(v) << BP_LCD_WF14_BPELCD14), BP_LCD_WF14_BPELCD14, 1))
/*@}*/

/*!
 * @name Register LCD_WF14, field BPFLCD14[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF14_BPFLCD14 (5U)          /*!< Bit position for LCD_WF14_BPFLCD14. */
#define BM_LCD_WF14_BPFLCD14 (0x20U)       /*!< Bit mask for LCD_WF14_BPFLCD14. */
#define BS_LCD_WF14_BPFLCD14 (1U)          /*!< Bit field size in bits for LCD_WF14_BPFLCD14. */

/*! @brief Read current value of the LCD_WF14_BPFLCD14 field. */
#define BR_LCD_WF14_BPFLCD14(x) (BME_UBFX8(HW_LCD_WF14_ADDR(x), BP_LCD_WF14_BPFLCD14, BS_LCD_WF14_BPFLCD14))

/*! @brief Format value for bitfield LCD_WF14_BPFLCD14. */
#define BF_LCD_WF14_BPFLCD14(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF14_BPFLCD14) & BM_LCD_WF14_BPFLCD14)

/*! @brief Set the BPFLCD14 field to a new value. */
#define BW_LCD_WF14_BPFLCD14(x, v) (BME_BFI8(HW_LCD_WF14_ADDR(x), ((uint8_t)(v) << BP_LCD_WF14_BPFLCD14), BP_LCD_WF14_BPFLCD14, 1))
/*@}*/

/*!
 * @name Register LCD_WF14, field BPGLCD14[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF14_BPGLCD14 (6U)          /*!< Bit position for LCD_WF14_BPGLCD14. */
#define BM_LCD_WF14_BPGLCD14 (0x40U)       /*!< Bit mask for LCD_WF14_BPGLCD14. */
#define BS_LCD_WF14_BPGLCD14 (1U)          /*!< Bit field size in bits for LCD_WF14_BPGLCD14. */

/*! @brief Read current value of the LCD_WF14_BPGLCD14 field. */
#define BR_LCD_WF14_BPGLCD14(x) (BME_UBFX8(HW_LCD_WF14_ADDR(x), BP_LCD_WF14_BPGLCD14, BS_LCD_WF14_BPGLCD14))

/*! @brief Format value for bitfield LCD_WF14_BPGLCD14. */
#define BF_LCD_WF14_BPGLCD14(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF14_BPGLCD14) & BM_LCD_WF14_BPGLCD14)

/*! @brief Set the BPGLCD14 field to a new value. */
#define BW_LCD_WF14_BPGLCD14(x, v) (BME_BFI8(HW_LCD_WF14_ADDR(x), ((uint8_t)(v) << BP_LCD_WF14_BPGLCD14), BP_LCD_WF14_BPGLCD14, 1))
/*@}*/

/*!
 * @name Register LCD_WF14, field BPHLCD14[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF14_BPHLCD14 (7U)          /*!< Bit position for LCD_WF14_BPHLCD14. */
#define BM_LCD_WF14_BPHLCD14 (0x80U)       /*!< Bit mask for LCD_WF14_BPHLCD14. */
#define BS_LCD_WF14_BPHLCD14 (1U)          /*!< Bit field size in bits for LCD_WF14_BPHLCD14. */

/*! @brief Read current value of the LCD_WF14_BPHLCD14 field. */
#define BR_LCD_WF14_BPHLCD14(x) (BME_UBFX8(HW_LCD_WF14_ADDR(x), BP_LCD_WF14_BPHLCD14, BS_LCD_WF14_BPHLCD14))

/*! @brief Format value for bitfield LCD_WF14_BPHLCD14. */
#define BF_LCD_WF14_BPHLCD14(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF14_BPHLCD14) & BM_LCD_WF14_BPHLCD14)

/*! @brief Set the BPHLCD14 field to a new value. */
#define BW_LCD_WF14_BPHLCD14(x, v) (BME_BFI8(HW_LCD_WF14_ADDR(x), ((uint8_t)(v) << BP_LCD_WF14_BPHLCD14), BP_LCD_WF14_BPHLCD14, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF15 - LCD Waveform Register 15.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF15 - LCD Waveform Register 15. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf15
{
    uint8_t U;
    struct _hw_lcd_wf15_bitfields
    {
        uint8_t BPALCD15 : 1;          /*!< [0]  */
        uint8_t BPBLCD15 : 1;          /*!< [1]  */
        uint8_t BPCLCD15 : 1;          /*!< [2]  */
        uint8_t BPDLCD15 : 1;          /*!< [3]  */
        uint8_t BPELCD15 : 1;          /*!< [4]  */
        uint8_t BPFLCD15 : 1;          /*!< [5]  */
        uint8_t BPGLCD15 : 1;          /*!< [6]  */
        uint8_t BPHLCD15 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf15_t;

/*!
 * @name Constants and macros for entire LCD_WF15 register
 */
/*@{*/
#define HW_LCD_WF15_ADDR(x)      ((uint32_t)(x) + 0x2FU)

#define HW_LCD_WF15(x)           (*(__IO hw_lcd_wf15_t *) HW_LCD_WF15_ADDR(x))
#define HW_LCD_WF15_RD(x)        (HW_LCD_WF15(x).U)
#define HW_LCD_WF15_WR(x, v)     (HW_LCD_WF15(x).U = (v))
#define HW_LCD_WF15_SET(x, v)    (BME_OR8(HW_LCD_WF15_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF15_CLR(x, v)    (BME_AND8(HW_LCD_WF15_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF15_TOG(x, v)    (BME_XOR8(HW_LCD_WF15_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF15 bitfields
 */

/*!
 * @name Register LCD_WF15, field BPALCD15[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF15_BPALCD15 (0U)          /*!< Bit position for LCD_WF15_BPALCD15. */
#define BM_LCD_WF15_BPALCD15 (0x01U)       /*!< Bit mask for LCD_WF15_BPALCD15. */
#define BS_LCD_WF15_BPALCD15 (1U)          /*!< Bit field size in bits for LCD_WF15_BPALCD15. */

/*! @brief Read current value of the LCD_WF15_BPALCD15 field. */
#define BR_LCD_WF15_BPALCD15(x) (BME_UBFX8(HW_LCD_WF15_ADDR(x), BP_LCD_WF15_BPALCD15, BS_LCD_WF15_BPALCD15))

/*! @brief Format value for bitfield LCD_WF15_BPALCD15. */
#define BF_LCD_WF15_BPALCD15(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF15_BPALCD15) & BM_LCD_WF15_BPALCD15)

/*! @brief Set the BPALCD15 field to a new value. */
#define BW_LCD_WF15_BPALCD15(x, v) (BME_BFI8(HW_LCD_WF15_ADDR(x), ((uint8_t)(v) << BP_LCD_WF15_BPALCD15), BP_LCD_WF15_BPALCD15, 1))
/*@}*/

/*!
 * @name Register LCD_WF15, field BPBLCD15[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF15_BPBLCD15 (1U)          /*!< Bit position for LCD_WF15_BPBLCD15. */
#define BM_LCD_WF15_BPBLCD15 (0x02U)       /*!< Bit mask for LCD_WF15_BPBLCD15. */
#define BS_LCD_WF15_BPBLCD15 (1U)          /*!< Bit field size in bits for LCD_WF15_BPBLCD15. */

/*! @brief Read current value of the LCD_WF15_BPBLCD15 field. */
#define BR_LCD_WF15_BPBLCD15(x) (BME_UBFX8(HW_LCD_WF15_ADDR(x), BP_LCD_WF15_BPBLCD15, BS_LCD_WF15_BPBLCD15))

/*! @brief Format value for bitfield LCD_WF15_BPBLCD15. */
#define BF_LCD_WF15_BPBLCD15(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF15_BPBLCD15) & BM_LCD_WF15_BPBLCD15)

/*! @brief Set the BPBLCD15 field to a new value. */
#define BW_LCD_WF15_BPBLCD15(x, v) (BME_BFI8(HW_LCD_WF15_ADDR(x), ((uint8_t)(v) << BP_LCD_WF15_BPBLCD15), BP_LCD_WF15_BPBLCD15, 1))
/*@}*/

/*!
 * @name Register LCD_WF15, field BPCLCD15[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF15_BPCLCD15 (2U)          /*!< Bit position for LCD_WF15_BPCLCD15. */
#define BM_LCD_WF15_BPCLCD15 (0x04U)       /*!< Bit mask for LCD_WF15_BPCLCD15. */
#define BS_LCD_WF15_BPCLCD15 (1U)          /*!< Bit field size in bits for LCD_WF15_BPCLCD15. */

/*! @brief Read current value of the LCD_WF15_BPCLCD15 field. */
#define BR_LCD_WF15_BPCLCD15(x) (BME_UBFX8(HW_LCD_WF15_ADDR(x), BP_LCD_WF15_BPCLCD15, BS_LCD_WF15_BPCLCD15))

/*! @brief Format value for bitfield LCD_WF15_BPCLCD15. */
#define BF_LCD_WF15_BPCLCD15(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF15_BPCLCD15) & BM_LCD_WF15_BPCLCD15)

/*! @brief Set the BPCLCD15 field to a new value. */
#define BW_LCD_WF15_BPCLCD15(x, v) (BME_BFI8(HW_LCD_WF15_ADDR(x), ((uint8_t)(v) << BP_LCD_WF15_BPCLCD15), BP_LCD_WF15_BPCLCD15, 1))
/*@}*/

/*!
 * @name Register LCD_WF15, field BPDLCD15[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF15_BPDLCD15 (3U)          /*!< Bit position for LCD_WF15_BPDLCD15. */
#define BM_LCD_WF15_BPDLCD15 (0x08U)       /*!< Bit mask for LCD_WF15_BPDLCD15. */
#define BS_LCD_WF15_BPDLCD15 (1U)          /*!< Bit field size in bits for LCD_WF15_BPDLCD15. */

/*! @brief Read current value of the LCD_WF15_BPDLCD15 field. */
#define BR_LCD_WF15_BPDLCD15(x) (BME_UBFX8(HW_LCD_WF15_ADDR(x), BP_LCD_WF15_BPDLCD15, BS_LCD_WF15_BPDLCD15))

/*! @brief Format value for bitfield LCD_WF15_BPDLCD15. */
#define BF_LCD_WF15_BPDLCD15(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF15_BPDLCD15) & BM_LCD_WF15_BPDLCD15)

/*! @brief Set the BPDLCD15 field to a new value. */
#define BW_LCD_WF15_BPDLCD15(x, v) (BME_BFI8(HW_LCD_WF15_ADDR(x), ((uint8_t)(v) << BP_LCD_WF15_BPDLCD15), BP_LCD_WF15_BPDLCD15, 1))
/*@}*/

/*!
 * @name Register LCD_WF15, field BPELCD15[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF15_BPELCD15 (4U)          /*!< Bit position for LCD_WF15_BPELCD15. */
#define BM_LCD_WF15_BPELCD15 (0x10U)       /*!< Bit mask for LCD_WF15_BPELCD15. */
#define BS_LCD_WF15_BPELCD15 (1U)          /*!< Bit field size in bits for LCD_WF15_BPELCD15. */

/*! @brief Read current value of the LCD_WF15_BPELCD15 field. */
#define BR_LCD_WF15_BPELCD15(x) (BME_UBFX8(HW_LCD_WF15_ADDR(x), BP_LCD_WF15_BPELCD15, BS_LCD_WF15_BPELCD15))

/*! @brief Format value for bitfield LCD_WF15_BPELCD15. */
#define BF_LCD_WF15_BPELCD15(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF15_BPELCD15) & BM_LCD_WF15_BPELCD15)

/*! @brief Set the BPELCD15 field to a new value. */
#define BW_LCD_WF15_BPELCD15(x, v) (BME_BFI8(HW_LCD_WF15_ADDR(x), ((uint8_t)(v) << BP_LCD_WF15_BPELCD15), BP_LCD_WF15_BPELCD15, 1))
/*@}*/

/*!
 * @name Register LCD_WF15, field BPFLCD15[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF15_BPFLCD15 (5U)          /*!< Bit position for LCD_WF15_BPFLCD15. */
#define BM_LCD_WF15_BPFLCD15 (0x20U)       /*!< Bit mask for LCD_WF15_BPFLCD15. */
#define BS_LCD_WF15_BPFLCD15 (1U)          /*!< Bit field size in bits for LCD_WF15_BPFLCD15. */

/*! @brief Read current value of the LCD_WF15_BPFLCD15 field. */
#define BR_LCD_WF15_BPFLCD15(x) (BME_UBFX8(HW_LCD_WF15_ADDR(x), BP_LCD_WF15_BPFLCD15, BS_LCD_WF15_BPFLCD15))

/*! @brief Format value for bitfield LCD_WF15_BPFLCD15. */
#define BF_LCD_WF15_BPFLCD15(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF15_BPFLCD15) & BM_LCD_WF15_BPFLCD15)

/*! @brief Set the BPFLCD15 field to a new value. */
#define BW_LCD_WF15_BPFLCD15(x, v) (BME_BFI8(HW_LCD_WF15_ADDR(x), ((uint8_t)(v) << BP_LCD_WF15_BPFLCD15), BP_LCD_WF15_BPFLCD15, 1))
/*@}*/

/*!
 * @name Register LCD_WF15, field BPGLCD15[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF15_BPGLCD15 (6U)          /*!< Bit position for LCD_WF15_BPGLCD15. */
#define BM_LCD_WF15_BPGLCD15 (0x40U)       /*!< Bit mask for LCD_WF15_BPGLCD15. */
#define BS_LCD_WF15_BPGLCD15 (1U)          /*!< Bit field size in bits for LCD_WF15_BPGLCD15. */

/*! @brief Read current value of the LCD_WF15_BPGLCD15 field. */
#define BR_LCD_WF15_BPGLCD15(x) (BME_UBFX8(HW_LCD_WF15_ADDR(x), BP_LCD_WF15_BPGLCD15, BS_LCD_WF15_BPGLCD15))

/*! @brief Format value for bitfield LCD_WF15_BPGLCD15. */
#define BF_LCD_WF15_BPGLCD15(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF15_BPGLCD15) & BM_LCD_WF15_BPGLCD15)

/*! @brief Set the BPGLCD15 field to a new value. */
#define BW_LCD_WF15_BPGLCD15(x, v) (BME_BFI8(HW_LCD_WF15_ADDR(x), ((uint8_t)(v) << BP_LCD_WF15_BPGLCD15), BP_LCD_WF15_BPGLCD15, 1))
/*@}*/

/*!
 * @name Register LCD_WF15, field BPHLCD15[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF15_BPHLCD15 (7U)          /*!< Bit position for LCD_WF15_BPHLCD15. */
#define BM_LCD_WF15_BPHLCD15 (0x80U)       /*!< Bit mask for LCD_WF15_BPHLCD15. */
#define BS_LCD_WF15_BPHLCD15 (1U)          /*!< Bit field size in bits for LCD_WF15_BPHLCD15. */

/*! @brief Read current value of the LCD_WF15_BPHLCD15 field. */
#define BR_LCD_WF15_BPHLCD15(x) (BME_UBFX8(HW_LCD_WF15_ADDR(x), BP_LCD_WF15_BPHLCD15, BS_LCD_WF15_BPHLCD15))

/*! @brief Format value for bitfield LCD_WF15_BPHLCD15. */
#define BF_LCD_WF15_BPHLCD15(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF15_BPHLCD15) & BM_LCD_WF15_BPHLCD15)

/*! @brief Set the BPHLCD15 field to a new value. */
#define BW_LCD_WF15_BPHLCD15(x, v) (BME_BFI8(HW_LCD_WF15_ADDR(x), ((uint8_t)(v) << BP_LCD_WF15_BPHLCD15), BP_LCD_WF15_BPHLCD15, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF16 - LCD Waveform Register 16.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF16 - LCD Waveform Register 16. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf16
{
    uint8_t U;
    struct _hw_lcd_wf16_bitfields
    {
        uint8_t BPALCD16 : 1;          /*!< [0]  */
        uint8_t BPBLCD16 : 1;          /*!< [1]  */
        uint8_t BPCLCD16 : 1;          /*!< [2]  */
        uint8_t BPDLCD16 : 1;          /*!< [3]  */
        uint8_t BPELCD16 : 1;          /*!< [4]  */
        uint8_t BPFLCD16 : 1;          /*!< [5]  */
        uint8_t BPGLCD16 : 1;          /*!< [6]  */
        uint8_t BPHLCD16 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf16_t;

/*!
 * @name Constants and macros for entire LCD_WF16 register
 */
/*@{*/
#define HW_LCD_WF16_ADDR(x)      ((uint32_t)(x) + 0x30U)

#define HW_LCD_WF16(x)           (*(__IO hw_lcd_wf16_t *) HW_LCD_WF16_ADDR(x))
#define HW_LCD_WF16_RD(x)        (HW_LCD_WF16(x).U)
#define HW_LCD_WF16_WR(x, v)     (HW_LCD_WF16(x).U = (v))
#define HW_LCD_WF16_SET(x, v)    (BME_OR8(HW_LCD_WF16_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF16_CLR(x, v)    (BME_AND8(HW_LCD_WF16_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF16_TOG(x, v)    (BME_XOR8(HW_LCD_WF16_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF16 bitfields
 */

/*!
 * @name Register LCD_WF16, field BPALCD16[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF16_BPALCD16 (0U)          /*!< Bit position for LCD_WF16_BPALCD16. */
#define BM_LCD_WF16_BPALCD16 (0x01U)       /*!< Bit mask for LCD_WF16_BPALCD16. */
#define BS_LCD_WF16_BPALCD16 (1U)          /*!< Bit field size in bits for LCD_WF16_BPALCD16. */

/*! @brief Read current value of the LCD_WF16_BPALCD16 field. */
#define BR_LCD_WF16_BPALCD16(x) (BME_UBFX8(HW_LCD_WF16_ADDR(x), BP_LCD_WF16_BPALCD16, BS_LCD_WF16_BPALCD16))

/*! @brief Format value for bitfield LCD_WF16_BPALCD16. */
#define BF_LCD_WF16_BPALCD16(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF16_BPALCD16) & BM_LCD_WF16_BPALCD16)

/*! @brief Set the BPALCD16 field to a new value. */
#define BW_LCD_WF16_BPALCD16(x, v) (BME_BFI8(HW_LCD_WF16_ADDR(x), ((uint8_t)(v) << BP_LCD_WF16_BPALCD16), BP_LCD_WF16_BPALCD16, 1))
/*@}*/

/*!
 * @name Register LCD_WF16, field BPBLCD16[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF16_BPBLCD16 (1U)          /*!< Bit position for LCD_WF16_BPBLCD16. */
#define BM_LCD_WF16_BPBLCD16 (0x02U)       /*!< Bit mask for LCD_WF16_BPBLCD16. */
#define BS_LCD_WF16_BPBLCD16 (1U)          /*!< Bit field size in bits for LCD_WF16_BPBLCD16. */

/*! @brief Read current value of the LCD_WF16_BPBLCD16 field. */
#define BR_LCD_WF16_BPBLCD16(x) (BME_UBFX8(HW_LCD_WF16_ADDR(x), BP_LCD_WF16_BPBLCD16, BS_LCD_WF16_BPBLCD16))

/*! @brief Format value for bitfield LCD_WF16_BPBLCD16. */
#define BF_LCD_WF16_BPBLCD16(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF16_BPBLCD16) & BM_LCD_WF16_BPBLCD16)

/*! @brief Set the BPBLCD16 field to a new value. */
#define BW_LCD_WF16_BPBLCD16(x, v) (BME_BFI8(HW_LCD_WF16_ADDR(x), ((uint8_t)(v) << BP_LCD_WF16_BPBLCD16), BP_LCD_WF16_BPBLCD16, 1))
/*@}*/

/*!
 * @name Register LCD_WF16, field BPCLCD16[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF16_BPCLCD16 (2U)          /*!< Bit position for LCD_WF16_BPCLCD16. */
#define BM_LCD_WF16_BPCLCD16 (0x04U)       /*!< Bit mask for LCD_WF16_BPCLCD16. */
#define BS_LCD_WF16_BPCLCD16 (1U)          /*!< Bit field size in bits for LCD_WF16_BPCLCD16. */

/*! @brief Read current value of the LCD_WF16_BPCLCD16 field. */
#define BR_LCD_WF16_BPCLCD16(x) (BME_UBFX8(HW_LCD_WF16_ADDR(x), BP_LCD_WF16_BPCLCD16, BS_LCD_WF16_BPCLCD16))

/*! @brief Format value for bitfield LCD_WF16_BPCLCD16. */
#define BF_LCD_WF16_BPCLCD16(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF16_BPCLCD16) & BM_LCD_WF16_BPCLCD16)

/*! @brief Set the BPCLCD16 field to a new value. */
#define BW_LCD_WF16_BPCLCD16(x, v) (BME_BFI8(HW_LCD_WF16_ADDR(x), ((uint8_t)(v) << BP_LCD_WF16_BPCLCD16), BP_LCD_WF16_BPCLCD16, 1))
/*@}*/

/*!
 * @name Register LCD_WF16, field BPDLCD16[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF16_BPDLCD16 (3U)          /*!< Bit position for LCD_WF16_BPDLCD16. */
#define BM_LCD_WF16_BPDLCD16 (0x08U)       /*!< Bit mask for LCD_WF16_BPDLCD16. */
#define BS_LCD_WF16_BPDLCD16 (1U)          /*!< Bit field size in bits for LCD_WF16_BPDLCD16. */

/*! @brief Read current value of the LCD_WF16_BPDLCD16 field. */
#define BR_LCD_WF16_BPDLCD16(x) (BME_UBFX8(HW_LCD_WF16_ADDR(x), BP_LCD_WF16_BPDLCD16, BS_LCD_WF16_BPDLCD16))

/*! @brief Format value for bitfield LCD_WF16_BPDLCD16. */
#define BF_LCD_WF16_BPDLCD16(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF16_BPDLCD16) & BM_LCD_WF16_BPDLCD16)

/*! @brief Set the BPDLCD16 field to a new value. */
#define BW_LCD_WF16_BPDLCD16(x, v) (BME_BFI8(HW_LCD_WF16_ADDR(x), ((uint8_t)(v) << BP_LCD_WF16_BPDLCD16), BP_LCD_WF16_BPDLCD16, 1))
/*@}*/

/*!
 * @name Register LCD_WF16, field BPELCD16[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF16_BPELCD16 (4U)          /*!< Bit position for LCD_WF16_BPELCD16. */
#define BM_LCD_WF16_BPELCD16 (0x10U)       /*!< Bit mask for LCD_WF16_BPELCD16. */
#define BS_LCD_WF16_BPELCD16 (1U)          /*!< Bit field size in bits for LCD_WF16_BPELCD16. */

/*! @brief Read current value of the LCD_WF16_BPELCD16 field. */
#define BR_LCD_WF16_BPELCD16(x) (BME_UBFX8(HW_LCD_WF16_ADDR(x), BP_LCD_WF16_BPELCD16, BS_LCD_WF16_BPELCD16))

/*! @brief Format value for bitfield LCD_WF16_BPELCD16. */
#define BF_LCD_WF16_BPELCD16(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF16_BPELCD16) & BM_LCD_WF16_BPELCD16)

/*! @brief Set the BPELCD16 field to a new value. */
#define BW_LCD_WF16_BPELCD16(x, v) (BME_BFI8(HW_LCD_WF16_ADDR(x), ((uint8_t)(v) << BP_LCD_WF16_BPELCD16), BP_LCD_WF16_BPELCD16, 1))
/*@}*/

/*!
 * @name Register LCD_WF16, field BPFLCD16[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF16_BPFLCD16 (5U)          /*!< Bit position for LCD_WF16_BPFLCD16. */
#define BM_LCD_WF16_BPFLCD16 (0x20U)       /*!< Bit mask for LCD_WF16_BPFLCD16. */
#define BS_LCD_WF16_BPFLCD16 (1U)          /*!< Bit field size in bits for LCD_WF16_BPFLCD16. */

/*! @brief Read current value of the LCD_WF16_BPFLCD16 field. */
#define BR_LCD_WF16_BPFLCD16(x) (BME_UBFX8(HW_LCD_WF16_ADDR(x), BP_LCD_WF16_BPFLCD16, BS_LCD_WF16_BPFLCD16))

/*! @brief Format value for bitfield LCD_WF16_BPFLCD16. */
#define BF_LCD_WF16_BPFLCD16(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF16_BPFLCD16) & BM_LCD_WF16_BPFLCD16)

/*! @brief Set the BPFLCD16 field to a new value. */
#define BW_LCD_WF16_BPFLCD16(x, v) (BME_BFI8(HW_LCD_WF16_ADDR(x), ((uint8_t)(v) << BP_LCD_WF16_BPFLCD16), BP_LCD_WF16_BPFLCD16, 1))
/*@}*/

/*!
 * @name Register LCD_WF16, field BPGLCD16[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF16_BPGLCD16 (6U)          /*!< Bit position for LCD_WF16_BPGLCD16. */
#define BM_LCD_WF16_BPGLCD16 (0x40U)       /*!< Bit mask for LCD_WF16_BPGLCD16. */
#define BS_LCD_WF16_BPGLCD16 (1U)          /*!< Bit field size in bits for LCD_WF16_BPGLCD16. */

/*! @brief Read current value of the LCD_WF16_BPGLCD16 field. */
#define BR_LCD_WF16_BPGLCD16(x) (BME_UBFX8(HW_LCD_WF16_ADDR(x), BP_LCD_WF16_BPGLCD16, BS_LCD_WF16_BPGLCD16))

/*! @brief Format value for bitfield LCD_WF16_BPGLCD16. */
#define BF_LCD_WF16_BPGLCD16(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF16_BPGLCD16) & BM_LCD_WF16_BPGLCD16)

/*! @brief Set the BPGLCD16 field to a new value. */
#define BW_LCD_WF16_BPGLCD16(x, v) (BME_BFI8(HW_LCD_WF16_ADDR(x), ((uint8_t)(v) << BP_LCD_WF16_BPGLCD16), BP_LCD_WF16_BPGLCD16, 1))
/*@}*/

/*!
 * @name Register LCD_WF16, field BPHLCD16[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF16_BPHLCD16 (7U)          /*!< Bit position for LCD_WF16_BPHLCD16. */
#define BM_LCD_WF16_BPHLCD16 (0x80U)       /*!< Bit mask for LCD_WF16_BPHLCD16. */
#define BS_LCD_WF16_BPHLCD16 (1U)          /*!< Bit field size in bits for LCD_WF16_BPHLCD16. */

/*! @brief Read current value of the LCD_WF16_BPHLCD16 field. */
#define BR_LCD_WF16_BPHLCD16(x) (BME_UBFX8(HW_LCD_WF16_ADDR(x), BP_LCD_WF16_BPHLCD16, BS_LCD_WF16_BPHLCD16))

/*! @brief Format value for bitfield LCD_WF16_BPHLCD16. */
#define BF_LCD_WF16_BPHLCD16(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF16_BPHLCD16) & BM_LCD_WF16_BPHLCD16)

/*! @brief Set the BPHLCD16 field to a new value. */
#define BW_LCD_WF16_BPHLCD16(x, v) (BME_BFI8(HW_LCD_WF16_ADDR(x), ((uint8_t)(v) << BP_LCD_WF16_BPHLCD16), BP_LCD_WF16_BPHLCD16, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF17 - LCD Waveform Register 17.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF17 - LCD Waveform Register 17. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf17
{
    uint8_t U;
    struct _hw_lcd_wf17_bitfields
    {
        uint8_t BPALCD17 : 1;          /*!< [0]  */
        uint8_t BPBLCD17 : 1;          /*!< [1]  */
        uint8_t BPCLCD17 : 1;          /*!< [2]  */
        uint8_t BPDLCD17 : 1;          /*!< [3]  */
        uint8_t BPELCD17 : 1;          /*!< [4]  */
        uint8_t BPFLCD17 : 1;          /*!< [5]  */
        uint8_t BPGLCD17 : 1;          /*!< [6]  */
        uint8_t BPHLCD17 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf17_t;

/*!
 * @name Constants and macros for entire LCD_WF17 register
 */
/*@{*/
#define HW_LCD_WF17_ADDR(x)      ((uint32_t)(x) + 0x31U)

#define HW_LCD_WF17(x)           (*(__IO hw_lcd_wf17_t *) HW_LCD_WF17_ADDR(x))
#define HW_LCD_WF17_RD(x)        (HW_LCD_WF17(x).U)
#define HW_LCD_WF17_WR(x, v)     (HW_LCD_WF17(x).U = (v))
#define HW_LCD_WF17_SET(x, v)    (BME_OR8(HW_LCD_WF17_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF17_CLR(x, v)    (BME_AND8(HW_LCD_WF17_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF17_TOG(x, v)    (BME_XOR8(HW_LCD_WF17_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF17 bitfields
 */

/*!
 * @name Register LCD_WF17, field BPALCD17[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF17_BPALCD17 (0U)          /*!< Bit position for LCD_WF17_BPALCD17. */
#define BM_LCD_WF17_BPALCD17 (0x01U)       /*!< Bit mask for LCD_WF17_BPALCD17. */
#define BS_LCD_WF17_BPALCD17 (1U)          /*!< Bit field size in bits for LCD_WF17_BPALCD17. */

/*! @brief Read current value of the LCD_WF17_BPALCD17 field. */
#define BR_LCD_WF17_BPALCD17(x) (BME_UBFX8(HW_LCD_WF17_ADDR(x), BP_LCD_WF17_BPALCD17, BS_LCD_WF17_BPALCD17))

/*! @brief Format value for bitfield LCD_WF17_BPALCD17. */
#define BF_LCD_WF17_BPALCD17(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF17_BPALCD17) & BM_LCD_WF17_BPALCD17)

/*! @brief Set the BPALCD17 field to a new value. */
#define BW_LCD_WF17_BPALCD17(x, v) (BME_BFI8(HW_LCD_WF17_ADDR(x), ((uint8_t)(v) << BP_LCD_WF17_BPALCD17), BP_LCD_WF17_BPALCD17, 1))
/*@}*/

/*!
 * @name Register LCD_WF17, field BPBLCD17[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF17_BPBLCD17 (1U)          /*!< Bit position for LCD_WF17_BPBLCD17. */
#define BM_LCD_WF17_BPBLCD17 (0x02U)       /*!< Bit mask for LCD_WF17_BPBLCD17. */
#define BS_LCD_WF17_BPBLCD17 (1U)          /*!< Bit field size in bits for LCD_WF17_BPBLCD17. */

/*! @brief Read current value of the LCD_WF17_BPBLCD17 field. */
#define BR_LCD_WF17_BPBLCD17(x) (BME_UBFX8(HW_LCD_WF17_ADDR(x), BP_LCD_WF17_BPBLCD17, BS_LCD_WF17_BPBLCD17))

/*! @brief Format value for bitfield LCD_WF17_BPBLCD17. */
#define BF_LCD_WF17_BPBLCD17(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF17_BPBLCD17) & BM_LCD_WF17_BPBLCD17)

/*! @brief Set the BPBLCD17 field to a new value. */
#define BW_LCD_WF17_BPBLCD17(x, v) (BME_BFI8(HW_LCD_WF17_ADDR(x), ((uint8_t)(v) << BP_LCD_WF17_BPBLCD17), BP_LCD_WF17_BPBLCD17, 1))
/*@}*/

/*!
 * @name Register LCD_WF17, field BPCLCD17[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF17_BPCLCD17 (2U)          /*!< Bit position for LCD_WF17_BPCLCD17. */
#define BM_LCD_WF17_BPCLCD17 (0x04U)       /*!< Bit mask for LCD_WF17_BPCLCD17. */
#define BS_LCD_WF17_BPCLCD17 (1U)          /*!< Bit field size in bits for LCD_WF17_BPCLCD17. */

/*! @brief Read current value of the LCD_WF17_BPCLCD17 field. */
#define BR_LCD_WF17_BPCLCD17(x) (BME_UBFX8(HW_LCD_WF17_ADDR(x), BP_LCD_WF17_BPCLCD17, BS_LCD_WF17_BPCLCD17))

/*! @brief Format value for bitfield LCD_WF17_BPCLCD17. */
#define BF_LCD_WF17_BPCLCD17(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF17_BPCLCD17) & BM_LCD_WF17_BPCLCD17)

/*! @brief Set the BPCLCD17 field to a new value. */
#define BW_LCD_WF17_BPCLCD17(x, v) (BME_BFI8(HW_LCD_WF17_ADDR(x), ((uint8_t)(v) << BP_LCD_WF17_BPCLCD17), BP_LCD_WF17_BPCLCD17, 1))
/*@}*/

/*!
 * @name Register LCD_WF17, field BPDLCD17[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF17_BPDLCD17 (3U)          /*!< Bit position for LCD_WF17_BPDLCD17. */
#define BM_LCD_WF17_BPDLCD17 (0x08U)       /*!< Bit mask for LCD_WF17_BPDLCD17. */
#define BS_LCD_WF17_BPDLCD17 (1U)          /*!< Bit field size in bits for LCD_WF17_BPDLCD17. */

/*! @brief Read current value of the LCD_WF17_BPDLCD17 field. */
#define BR_LCD_WF17_BPDLCD17(x) (BME_UBFX8(HW_LCD_WF17_ADDR(x), BP_LCD_WF17_BPDLCD17, BS_LCD_WF17_BPDLCD17))

/*! @brief Format value for bitfield LCD_WF17_BPDLCD17. */
#define BF_LCD_WF17_BPDLCD17(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF17_BPDLCD17) & BM_LCD_WF17_BPDLCD17)

/*! @brief Set the BPDLCD17 field to a new value. */
#define BW_LCD_WF17_BPDLCD17(x, v) (BME_BFI8(HW_LCD_WF17_ADDR(x), ((uint8_t)(v) << BP_LCD_WF17_BPDLCD17), BP_LCD_WF17_BPDLCD17, 1))
/*@}*/

/*!
 * @name Register LCD_WF17, field BPELCD17[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF17_BPELCD17 (4U)          /*!< Bit position for LCD_WF17_BPELCD17. */
#define BM_LCD_WF17_BPELCD17 (0x10U)       /*!< Bit mask for LCD_WF17_BPELCD17. */
#define BS_LCD_WF17_BPELCD17 (1U)          /*!< Bit field size in bits for LCD_WF17_BPELCD17. */

/*! @brief Read current value of the LCD_WF17_BPELCD17 field. */
#define BR_LCD_WF17_BPELCD17(x) (BME_UBFX8(HW_LCD_WF17_ADDR(x), BP_LCD_WF17_BPELCD17, BS_LCD_WF17_BPELCD17))

/*! @brief Format value for bitfield LCD_WF17_BPELCD17. */
#define BF_LCD_WF17_BPELCD17(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF17_BPELCD17) & BM_LCD_WF17_BPELCD17)

/*! @brief Set the BPELCD17 field to a new value. */
#define BW_LCD_WF17_BPELCD17(x, v) (BME_BFI8(HW_LCD_WF17_ADDR(x), ((uint8_t)(v) << BP_LCD_WF17_BPELCD17), BP_LCD_WF17_BPELCD17, 1))
/*@}*/

/*!
 * @name Register LCD_WF17, field BPFLCD17[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF17_BPFLCD17 (5U)          /*!< Bit position for LCD_WF17_BPFLCD17. */
#define BM_LCD_WF17_BPFLCD17 (0x20U)       /*!< Bit mask for LCD_WF17_BPFLCD17. */
#define BS_LCD_WF17_BPFLCD17 (1U)          /*!< Bit field size in bits for LCD_WF17_BPFLCD17. */

/*! @brief Read current value of the LCD_WF17_BPFLCD17 field. */
#define BR_LCD_WF17_BPFLCD17(x) (BME_UBFX8(HW_LCD_WF17_ADDR(x), BP_LCD_WF17_BPFLCD17, BS_LCD_WF17_BPFLCD17))

/*! @brief Format value for bitfield LCD_WF17_BPFLCD17. */
#define BF_LCD_WF17_BPFLCD17(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF17_BPFLCD17) & BM_LCD_WF17_BPFLCD17)

/*! @brief Set the BPFLCD17 field to a new value. */
#define BW_LCD_WF17_BPFLCD17(x, v) (BME_BFI8(HW_LCD_WF17_ADDR(x), ((uint8_t)(v) << BP_LCD_WF17_BPFLCD17), BP_LCD_WF17_BPFLCD17, 1))
/*@}*/

/*!
 * @name Register LCD_WF17, field BPGLCD17[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF17_BPGLCD17 (6U)          /*!< Bit position for LCD_WF17_BPGLCD17. */
#define BM_LCD_WF17_BPGLCD17 (0x40U)       /*!< Bit mask for LCD_WF17_BPGLCD17. */
#define BS_LCD_WF17_BPGLCD17 (1U)          /*!< Bit field size in bits for LCD_WF17_BPGLCD17. */

/*! @brief Read current value of the LCD_WF17_BPGLCD17 field. */
#define BR_LCD_WF17_BPGLCD17(x) (BME_UBFX8(HW_LCD_WF17_ADDR(x), BP_LCD_WF17_BPGLCD17, BS_LCD_WF17_BPGLCD17))

/*! @brief Format value for bitfield LCD_WF17_BPGLCD17. */
#define BF_LCD_WF17_BPGLCD17(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF17_BPGLCD17) & BM_LCD_WF17_BPGLCD17)

/*! @brief Set the BPGLCD17 field to a new value. */
#define BW_LCD_WF17_BPGLCD17(x, v) (BME_BFI8(HW_LCD_WF17_ADDR(x), ((uint8_t)(v) << BP_LCD_WF17_BPGLCD17), BP_LCD_WF17_BPGLCD17, 1))
/*@}*/

/*!
 * @name Register LCD_WF17, field BPHLCD17[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF17_BPHLCD17 (7U)          /*!< Bit position for LCD_WF17_BPHLCD17. */
#define BM_LCD_WF17_BPHLCD17 (0x80U)       /*!< Bit mask for LCD_WF17_BPHLCD17. */
#define BS_LCD_WF17_BPHLCD17 (1U)          /*!< Bit field size in bits for LCD_WF17_BPHLCD17. */

/*! @brief Read current value of the LCD_WF17_BPHLCD17 field. */
#define BR_LCD_WF17_BPHLCD17(x) (BME_UBFX8(HW_LCD_WF17_ADDR(x), BP_LCD_WF17_BPHLCD17, BS_LCD_WF17_BPHLCD17))

/*! @brief Format value for bitfield LCD_WF17_BPHLCD17. */
#define BF_LCD_WF17_BPHLCD17(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF17_BPHLCD17) & BM_LCD_WF17_BPHLCD17)

/*! @brief Set the BPHLCD17 field to a new value. */
#define BW_LCD_WF17_BPHLCD17(x, v) (BME_BFI8(HW_LCD_WF17_ADDR(x), ((uint8_t)(v) << BP_LCD_WF17_BPHLCD17), BP_LCD_WF17_BPHLCD17, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF18 - LCD Waveform Register 18.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF18 - LCD Waveform Register 18. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf18
{
    uint8_t U;
    struct _hw_lcd_wf18_bitfields
    {
        uint8_t BPALCD18 : 1;          /*!< [0]  */
        uint8_t BPBLCD18 : 1;          /*!< [1]  */
        uint8_t BPCLCD18 : 1;          /*!< [2]  */
        uint8_t BPDLCD18 : 1;          /*!< [3]  */
        uint8_t BPELCD18 : 1;          /*!< [4]  */
        uint8_t BPFLCD18 : 1;          /*!< [5]  */
        uint8_t BPGLCD18 : 1;          /*!< [6]  */
        uint8_t BPHLCD18 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf18_t;

/*!
 * @name Constants and macros for entire LCD_WF18 register
 */
/*@{*/
#define HW_LCD_WF18_ADDR(x)      ((uint32_t)(x) + 0x32U)

#define HW_LCD_WF18(x)           (*(__IO hw_lcd_wf18_t *) HW_LCD_WF18_ADDR(x))
#define HW_LCD_WF18_RD(x)        (HW_LCD_WF18(x).U)
#define HW_LCD_WF18_WR(x, v)     (HW_LCD_WF18(x).U = (v))
#define HW_LCD_WF18_SET(x, v)    (BME_OR8(HW_LCD_WF18_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF18_CLR(x, v)    (BME_AND8(HW_LCD_WF18_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF18_TOG(x, v)    (BME_XOR8(HW_LCD_WF18_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF18 bitfields
 */

/*!
 * @name Register LCD_WF18, field BPALCD18[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF18_BPALCD18 (0U)          /*!< Bit position for LCD_WF18_BPALCD18. */
#define BM_LCD_WF18_BPALCD18 (0x01U)       /*!< Bit mask for LCD_WF18_BPALCD18. */
#define BS_LCD_WF18_BPALCD18 (1U)          /*!< Bit field size in bits for LCD_WF18_BPALCD18. */

/*! @brief Read current value of the LCD_WF18_BPALCD18 field. */
#define BR_LCD_WF18_BPALCD18(x) (BME_UBFX8(HW_LCD_WF18_ADDR(x), BP_LCD_WF18_BPALCD18, BS_LCD_WF18_BPALCD18))

/*! @brief Format value for bitfield LCD_WF18_BPALCD18. */
#define BF_LCD_WF18_BPALCD18(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF18_BPALCD18) & BM_LCD_WF18_BPALCD18)

/*! @brief Set the BPALCD18 field to a new value. */
#define BW_LCD_WF18_BPALCD18(x, v) (BME_BFI8(HW_LCD_WF18_ADDR(x), ((uint8_t)(v) << BP_LCD_WF18_BPALCD18), BP_LCD_WF18_BPALCD18, 1))
/*@}*/

/*!
 * @name Register LCD_WF18, field BPBLCD18[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF18_BPBLCD18 (1U)          /*!< Bit position for LCD_WF18_BPBLCD18. */
#define BM_LCD_WF18_BPBLCD18 (0x02U)       /*!< Bit mask for LCD_WF18_BPBLCD18. */
#define BS_LCD_WF18_BPBLCD18 (1U)          /*!< Bit field size in bits for LCD_WF18_BPBLCD18. */

/*! @brief Read current value of the LCD_WF18_BPBLCD18 field. */
#define BR_LCD_WF18_BPBLCD18(x) (BME_UBFX8(HW_LCD_WF18_ADDR(x), BP_LCD_WF18_BPBLCD18, BS_LCD_WF18_BPBLCD18))

/*! @brief Format value for bitfield LCD_WF18_BPBLCD18. */
#define BF_LCD_WF18_BPBLCD18(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF18_BPBLCD18) & BM_LCD_WF18_BPBLCD18)

/*! @brief Set the BPBLCD18 field to a new value. */
#define BW_LCD_WF18_BPBLCD18(x, v) (BME_BFI8(HW_LCD_WF18_ADDR(x), ((uint8_t)(v) << BP_LCD_WF18_BPBLCD18), BP_LCD_WF18_BPBLCD18, 1))
/*@}*/

/*!
 * @name Register LCD_WF18, field BPCLCD18[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF18_BPCLCD18 (2U)          /*!< Bit position for LCD_WF18_BPCLCD18. */
#define BM_LCD_WF18_BPCLCD18 (0x04U)       /*!< Bit mask for LCD_WF18_BPCLCD18. */
#define BS_LCD_WF18_BPCLCD18 (1U)          /*!< Bit field size in bits for LCD_WF18_BPCLCD18. */

/*! @brief Read current value of the LCD_WF18_BPCLCD18 field. */
#define BR_LCD_WF18_BPCLCD18(x) (BME_UBFX8(HW_LCD_WF18_ADDR(x), BP_LCD_WF18_BPCLCD18, BS_LCD_WF18_BPCLCD18))

/*! @brief Format value for bitfield LCD_WF18_BPCLCD18. */
#define BF_LCD_WF18_BPCLCD18(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF18_BPCLCD18) & BM_LCD_WF18_BPCLCD18)

/*! @brief Set the BPCLCD18 field to a new value. */
#define BW_LCD_WF18_BPCLCD18(x, v) (BME_BFI8(HW_LCD_WF18_ADDR(x), ((uint8_t)(v) << BP_LCD_WF18_BPCLCD18), BP_LCD_WF18_BPCLCD18, 1))
/*@}*/

/*!
 * @name Register LCD_WF18, field BPDLCD18[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF18_BPDLCD18 (3U)          /*!< Bit position for LCD_WF18_BPDLCD18. */
#define BM_LCD_WF18_BPDLCD18 (0x08U)       /*!< Bit mask for LCD_WF18_BPDLCD18. */
#define BS_LCD_WF18_BPDLCD18 (1U)          /*!< Bit field size in bits for LCD_WF18_BPDLCD18. */

/*! @brief Read current value of the LCD_WF18_BPDLCD18 field. */
#define BR_LCD_WF18_BPDLCD18(x) (BME_UBFX8(HW_LCD_WF18_ADDR(x), BP_LCD_WF18_BPDLCD18, BS_LCD_WF18_BPDLCD18))

/*! @brief Format value for bitfield LCD_WF18_BPDLCD18. */
#define BF_LCD_WF18_BPDLCD18(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF18_BPDLCD18) & BM_LCD_WF18_BPDLCD18)

/*! @brief Set the BPDLCD18 field to a new value. */
#define BW_LCD_WF18_BPDLCD18(x, v) (BME_BFI8(HW_LCD_WF18_ADDR(x), ((uint8_t)(v) << BP_LCD_WF18_BPDLCD18), BP_LCD_WF18_BPDLCD18, 1))
/*@}*/

/*!
 * @name Register LCD_WF18, field BPELCD18[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF18_BPELCD18 (4U)          /*!< Bit position for LCD_WF18_BPELCD18. */
#define BM_LCD_WF18_BPELCD18 (0x10U)       /*!< Bit mask for LCD_WF18_BPELCD18. */
#define BS_LCD_WF18_BPELCD18 (1U)          /*!< Bit field size in bits for LCD_WF18_BPELCD18. */

/*! @brief Read current value of the LCD_WF18_BPELCD18 field. */
#define BR_LCD_WF18_BPELCD18(x) (BME_UBFX8(HW_LCD_WF18_ADDR(x), BP_LCD_WF18_BPELCD18, BS_LCD_WF18_BPELCD18))

/*! @brief Format value for bitfield LCD_WF18_BPELCD18. */
#define BF_LCD_WF18_BPELCD18(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF18_BPELCD18) & BM_LCD_WF18_BPELCD18)

/*! @brief Set the BPELCD18 field to a new value. */
#define BW_LCD_WF18_BPELCD18(x, v) (BME_BFI8(HW_LCD_WF18_ADDR(x), ((uint8_t)(v) << BP_LCD_WF18_BPELCD18), BP_LCD_WF18_BPELCD18, 1))
/*@}*/

/*!
 * @name Register LCD_WF18, field BPFLCD18[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF18_BPFLCD18 (5U)          /*!< Bit position for LCD_WF18_BPFLCD18. */
#define BM_LCD_WF18_BPFLCD18 (0x20U)       /*!< Bit mask for LCD_WF18_BPFLCD18. */
#define BS_LCD_WF18_BPFLCD18 (1U)          /*!< Bit field size in bits for LCD_WF18_BPFLCD18. */

/*! @brief Read current value of the LCD_WF18_BPFLCD18 field. */
#define BR_LCD_WF18_BPFLCD18(x) (BME_UBFX8(HW_LCD_WF18_ADDR(x), BP_LCD_WF18_BPFLCD18, BS_LCD_WF18_BPFLCD18))

/*! @brief Format value for bitfield LCD_WF18_BPFLCD18. */
#define BF_LCD_WF18_BPFLCD18(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF18_BPFLCD18) & BM_LCD_WF18_BPFLCD18)

/*! @brief Set the BPFLCD18 field to a new value. */
#define BW_LCD_WF18_BPFLCD18(x, v) (BME_BFI8(HW_LCD_WF18_ADDR(x), ((uint8_t)(v) << BP_LCD_WF18_BPFLCD18), BP_LCD_WF18_BPFLCD18, 1))
/*@}*/

/*!
 * @name Register LCD_WF18, field BPGLCD18[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF18_BPGLCD18 (6U)          /*!< Bit position for LCD_WF18_BPGLCD18. */
#define BM_LCD_WF18_BPGLCD18 (0x40U)       /*!< Bit mask for LCD_WF18_BPGLCD18. */
#define BS_LCD_WF18_BPGLCD18 (1U)          /*!< Bit field size in bits for LCD_WF18_BPGLCD18. */

/*! @brief Read current value of the LCD_WF18_BPGLCD18 field. */
#define BR_LCD_WF18_BPGLCD18(x) (BME_UBFX8(HW_LCD_WF18_ADDR(x), BP_LCD_WF18_BPGLCD18, BS_LCD_WF18_BPGLCD18))

/*! @brief Format value for bitfield LCD_WF18_BPGLCD18. */
#define BF_LCD_WF18_BPGLCD18(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF18_BPGLCD18) & BM_LCD_WF18_BPGLCD18)

/*! @brief Set the BPGLCD18 field to a new value. */
#define BW_LCD_WF18_BPGLCD18(x, v) (BME_BFI8(HW_LCD_WF18_ADDR(x), ((uint8_t)(v) << BP_LCD_WF18_BPGLCD18), BP_LCD_WF18_BPGLCD18, 1))
/*@}*/

/*!
 * @name Register LCD_WF18, field BPHLCD18[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF18_BPHLCD18 (7U)          /*!< Bit position for LCD_WF18_BPHLCD18. */
#define BM_LCD_WF18_BPHLCD18 (0x80U)       /*!< Bit mask for LCD_WF18_BPHLCD18. */
#define BS_LCD_WF18_BPHLCD18 (1U)          /*!< Bit field size in bits for LCD_WF18_BPHLCD18. */

/*! @brief Read current value of the LCD_WF18_BPHLCD18 field. */
#define BR_LCD_WF18_BPHLCD18(x) (BME_UBFX8(HW_LCD_WF18_ADDR(x), BP_LCD_WF18_BPHLCD18, BS_LCD_WF18_BPHLCD18))

/*! @brief Format value for bitfield LCD_WF18_BPHLCD18. */
#define BF_LCD_WF18_BPHLCD18(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF18_BPHLCD18) & BM_LCD_WF18_BPHLCD18)

/*! @brief Set the BPHLCD18 field to a new value. */
#define BW_LCD_WF18_BPHLCD18(x, v) (BME_BFI8(HW_LCD_WF18_ADDR(x), ((uint8_t)(v) << BP_LCD_WF18_BPHLCD18), BP_LCD_WF18_BPHLCD18, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF19 - LCD Waveform Register 19.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF19 - LCD Waveform Register 19. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf19
{
    uint8_t U;
    struct _hw_lcd_wf19_bitfields
    {
        uint8_t BPALCD19 : 1;          /*!< [0]  */
        uint8_t BPBLCD19 : 1;          /*!< [1]  */
        uint8_t BPCLCD19 : 1;          /*!< [2]  */
        uint8_t BPDLCD19 : 1;          /*!< [3]  */
        uint8_t BPELCD19 : 1;          /*!< [4]  */
        uint8_t BPFLCD19 : 1;          /*!< [5]  */
        uint8_t BPGLCD19 : 1;          /*!< [6]  */
        uint8_t BPHLCD19 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf19_t;

/*!
 * @name Constants and macros for entire LCD_WF19 register
 */
/*@{*/
#define HW_LCD_WF19_ADDR(x)      ((uint32_t)(x) + 0x33U)

#define HW_LCD_WF19(x)           (*(__IO hw_lcd_wf19_t *) HW_LCD_WF19_ADDR(x))
#define HW_LCD_WF19_RD(x)        (HW_LCD_WF19(x).U)
#define HW_LCD_WF19_WR(x, v)     (HW_LCD_WF19(x).U = (v))
#define HW_LCD_WF19_SET(x, v)    (BME_OR8(HW_LCD_WF19_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF19_CLR(x, v)    (BME_AND8(HW_LCD_WF19_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF19_TOG(x, v)    (BME_XOR8(HW_LCD_WF19_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF19 bitfields
 */

/*!
 * @name Register LCD_WF19, field BPALCD19[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF19_BPALCD19 (0U)          /*!< Bit position for LCD_WF19_BPALCD19. */
#define BM_LCD_WF19_BPALCD19 (0x01U)       /*!< Bit mask for LCD_WF19_BPALCD19. */
#define BS_LCD_WF19_BPALCD19 (1U)          /*!< Bit field size in bits for LCD_WF19_BPALCD19. */

/*! @brief Read current value of the LCD_WF19_BPALCD19 field. */
#define BR_LCD_WF19_BPALCD19(x) (BME_UBFX8(HW_LCD_WF19_ADDR(x), BP_LCD_WF19_BPALCD19, BS_LCD_WF19_BPALCD19))

/*! @brief Format value for bitfield LCD_WF19_BPALCD19. */
#define BF_LCD_WF19_BPALCD19(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF19_BPALCD19) & BM_LCD_WF19_BPALCD19)

/*! @brief Set the BPALCD19 field to a new value. */
#define BW_LCD_WF19_BPALCD19(x, v) (BME_BFI8(HW_LCD_WF19_ADDR(x), ((uint8_t)(v) << BP_LCD_WF19_BPALCD19), BP_LCD_WF19_BPALCD19, 1))
/*@}*/

/*!
 * @name Register LCD_WF19, field BPBLCD19[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF19_BPBLCD19 (1U)          /*!< Bit position for LCD_WF19_BPBLCD19. */
#define BM_LCD_WF19_BPBLCD19 (0x02U)       /*!< Bit mask for LCD_WF19_BPBLCD19. */
#define BS_LCD_WF19_BPBLCD19 (1U)          /*!< Bit field size in bits for LCD_WF19_BPBLCD19. */

/*! @brief Read current value of the LCD_WF19_BPBLCD19 field. */
#define BR_LCD_WF19_BPBLCD19(x) (BME_UBFX8(HW_LCD_WF19_ADDR(x), BP_LCD_WF19_BPBLCD19, BS_LCD_WF19_BPBLCD19))

/*! @brief Format value for bitfield LCD_WF19_BPBLCD19. */
#define BF_LCD_WF19_BPBLCD19(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF19_BPBLCD19) & BM_LCD_WF19_BPBLCD19)

/*! @brief Set the BPBLCD19 field to a new value. */
#define BW_LCD_WF19_BPBLCD19(x, v) (BME_BFI8(HW_LCD_WF19_ADDR(x), ((uint8_t)(v) << BP_LCD_WF19_BPBLCD19), BP_LCD_WF19_BPBLCD19, 1))
/*@}*/

/*!
 * @name Register LCD_WF19, field BPCLCD19[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF19_BPCLCD19 (2U)          /*!< Bit position for LCD_WF19_BPCLCD19. */
#define BM_LCD_WF19_BPCLCD19 (0x04U)       /*!< Bit mask for LCD_WF19_BPCLCD19. */
#define BS_LCD_WF19_BPCLCD19 (1U)          /*!< Bit field size in bits for LCD_WF19_BPCLCD19. */

/*! @brief Read current value of the LCD_WF19_BPCLCD19 field. */
#define BR_LCD_WF19_BPCLCD19(x) (BME_UBFX8(HW_LCD_WF19_ADDR(x), BP_LCD_WF19_BPCLCD19, BS_LCD_WF19_BPCLCD19))

/*! @brief Format value for bitfield LCD_WF19_BPCLCD19. */
#define BF_LCD_WF19_BPCLCD19(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF19_BPCLCD19) & BM_LCD_WF19_BPCLCD19)

/*! @brief Set the BPCLCD19 field to a new value. */
#define BW_LCD_WF19_BPCLCD19(x, v) (BME_BFI8(HW_LCD_WF19_ADDR(x), ((uint8_t)(v) << BP_LCD_WF19_BPCLCD19), BP_LCD_WF19_BPCLCD19, 1))
/*@}*/

/*!
 * @name Register LCD_WF19, field BPDLCD19[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF19_BPDLCD19 (3U)          /*!< Bit position for LCD_WF19_BPDLCD19. */
#define BM_LCD_WF19_BPDLCD19 (0x08U)       /*!< Bit mask for LCD_WF19_BPDLCD19. */
#define BS_LCD_WF19_BPDLCD19 (1U)          /*!< Bit field size in bits for LCD_WF19_BPDLCD19. */

/*! @brief Read current value of the LCD_WF19_BPDLCD19 field. */
#define BR_LCD_WF19_BPDLCD19(x) (BME_UBFX8(HW_LCD_WF19_ADDR(x), BP_LCD_WF19_BPDLCD19, BS_LCD_WF19_BPDLCD19))

/*! @brief Format value for bitfield LCD_WF19_BPDLCD19. */
#define BF_LCD_WF19_BPDLCD19(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF19_BPDLCD19) & BM_LCD_WF19_BPDLCD19)

/*! @brief Set the BPDLCD19 field to a new value. */
#define BW_LCD_WF19_BPDLCD19(x, v) (BME_BFI8(HW_LCD_WF19_ADDR(x), ((uint8_t)(v) << BP_LCD_WF19_BPDLCD19), BP_LCD_WF19_BPDLCD19, 1))
/*@}*/

/*!
 * @name Register LCD_WF19, field BPELCD19[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF19_BPELCD19 (4U)          /*!< Bit position for LCD_WF19_BPELCD19. */
#define BM_LCD_WF19_BPELCD19 (0x10U)       /*!< Bit mask for LCD_WF19_BPELCD19. */
#define BS_LCD_WF19_BPELCD19 (1U)          /*!< Bit field size in bits for LCD_WF19_BPELCD19. */

/*! @brief Read current value of the LCD_WF19_BPELCD19 field. */
#define BR_LCD_WF19_BPELCD19(x) (BME_UBFX8(HW_LCD_WF19_ADDR(x), BP_LCD_WF19_BPELCD19, BS_LCD_WF19_BPELCD19))

/*! @brief Format value for bitfield LCD_WF19_BPELCD19. */
#define BF_LCD_WF19_BPELCD19(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF19_BPELCD19) & BM_LCD_WF19_BPELCD19)

/*! @brief Set the BPELCD19 field to a new value. */
#define BW_LCD_WF19_BPELCD19(x, v) (BME_BFI8(HW_LCD_WF19_ADDR(x), ((uint8_t)(v) << BP_LCD_WF19_BPELCD19), BP_LCD_WF19_BPELCD19, 1))
/*@}*/

/*!
 * @name Register LCD_WF19, field BPFLCD19[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF19_BPFLCD19 (5U)          /*!< Bit position for LCD_WF19_BPFLCD19. */
#define BM_LCD_WF19_BPFLCD19 (0x20U)       /*!< Bit mask for LCD_WF19_BPFLCD19. */
#define BS_LCD_WF19_BPFLCD19 (1U)          /*!< Bit field size in bits for LCD_WF19_BPFLCD19. */

/*! @brief Read current value of the LCD_WF19_BPFLCD19 field. */
#define BR_LCD_WF19_BPFLCD19(x) (BME_UBFX8(HW_LCD_WF19_ADDR(x), BP_LCD_WF19_BPFLCD19, BS_LCD_WF19_BPFLCD19))

/*! @brief Format value for bitfield LCD_WF19_BPFLCD19. */
#define BF_LCD_WF19_BPFLCD19(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF19_BPFLCD19) & BM_LCD_WF19_BPFLCD19)

/*! @brief Set the BPFLCD19 field to a new value. */
#define BW_LCD_WF19_BPFLCD19(x, v) (BME_BFI8(HW_LCD_WF19_ADDR(x), ((uint8_t)(v) << BP_LCD_WF19_BPFLCD19), BP_LCD_WF19_BPFLCD19, 1))
/*@}*/

/*!
 * @name Register LCD_WF19, field BPGLCD19[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF19_BPGLCD19 (6U)          /*!< Bit position for LCD_WF19_BPGLCD19. */
#define BM_LCD_WF19_BPGLCD19 (0x40U)       /*!< Bit mask for LCD_WF19_BPGLCD19. */
#define BS_LCD_WF19_BPGLCD19 (1U)          /*!< Bit field size in bits for LCD_WF19_BPGLCD19. */

/*! @brief Read current value of the LCD_WF19_BPGLCD19 field. */
#define BR_LCD_WF19_BPGLCD19(x) (BME_UBFX8(HW_LCD_WF19_ADDR(x), BP_LCD_WF19_BPGLCD19, BS_LCD_WF19_BPGLCD19))

/*! @brief Format value for bitfield LCD_WF19_BPGLCD19. */
#define BF_LCD_WF19_BPGLCD19(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF19_BPGLCD19) & BM_LCD_WF19_BPGLCD19)

/*! @brief Set the BPGLCD19 field to a new value. */
#define BW_LCD_WF19_BPGLCD19(x, v) (BME_BFI8(HW_LCD_WF19_ADDR(x), ((uint8_t)(v) << BP_LCD_WF19_BPGLCD19), BP_LCD_WF19_BPGLCD19, 1))
/*@}*/

/*!
 * @name Register LCD_WF19, field BPHLCD19[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF19_BPHLCD19 (7U)          /*!< Bit position for LCD_WF19_BPHLCD19. */
#define BM_LCD_WF19_BPHLCD19 (0x80U)       /*!< Bit mask for LCD_WF19_BPHLCD19. */
#define BS_LCD_WF19_BPHLCD19 (1U)          /*!< Bit field size in bits for LCD_WF19_BPHLCD19. */

/*! @brief Read current value of the LCD_WF19_BPHLCD19 field. */
#define BR_LCD_WF19_BPHLCD19(x) (BME_UBFX8(HW_LCD_WF19_ADDR(x), BP_LCD_WF19_BPHLCD19, BS_LCD_WF19_BPHLCD19))

/*! @brief Format value for bitfield LCD_WF19_BPHLCD19. */
#define BF_LCD_WF19_BPHLCD19(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF19_BPHLCD19) & BM_LCD_WF19_BPHLCD19)

/*! @brief Set the BPHLCD19 field to a new value. */
#define BW_LCD_WF19_BPHLCD19(x, v) (BME_BFI8(HW_LCD_WF19_ADDR(x), ((uint8_t)(v) << BP_LCD_WF19_BPHLCD19), BP_LCD_WF19_BPHLCD19, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF20 - LCD Waveform Register 20.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF20 - LCD Waveform Register 20. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf20
{
    uint8_t U;
    struct _hw_lcd_wf20_bitfields
    {
        uint8_t BPALCD20 : 1;          /*!< [0]  */
        uint8_t BPBLCD20 : 1;          /*!< [1]  */
        uint8_t BPCLCD20 : 1;          /*!< [2]  */
        uint8_t BPDLCD20 : 1;          /*!< [3]  */
        uint8_t BPELCD20 : 1;          /*!< [4]  */
        uint8_t BPFLCD20 : 1;          /*!< [5]  */
        uint8_t BPGLCD20 : 1;          /*!< [6]  */
        uint8_t BPHLCD20 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf20_t;

/*!
 * @name Constants and macros for entire LCD_WF20 register
 */
/*@{*/
#define HW_LCD_WF20_ADDR(x)      ((uint32_t)(x) + 0x34U)

#define HW_LCD_WF20(x)           (*(__IO hw_lcd_wf20_t *) HW_LCD_WF20_ADDR(x))
#define HW_LCD_WF20_RD(x)        (HW_LCD_WF20(x).U)
#define HW_LCD_WF20_WR(x, v)     (HW_LCD_WF20(x).U = (v))
#define HW_LCD_WF20_SET(x, v)    (BME_OR8(HW_LCD_WF20_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF20_CLR(x, v)    (BME_AND8(HW_LCD_WF20_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF20_TOG(x, v)    (BME_XOR8(HW_LCD_WF20_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF20 bitfields
 */

/*!
 * @name Register LCD_WF20, field BPALCD20[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF20_BPALCD20 (0U)          /*!< Bit position for LCD_WF20_BPALCD20. */
#define BM_LCD_WF20_BPALCD20 (0x01U)       /*!< Bit mask for LCD_WF20_BPALCD20. */
#define BS_LCD_WF20_BPALCD20 (1U)          /*!< Bit field size in bits for LCD_WF20_BPALCD20. */

/*! @brief Read current value of the LCD_WF20_BPALCD20 field. */
#define BR_LCD_WF20_BPALCD20(x) (BME_UBFX8(HW_LCD_WF20_ADDR(x), BP_LCD_WF20_BPALCD20, BS_LCD_WF20_BPALCD20))

/*! @brief Format value for bitfield LCD_WF20_BPALCD20. */
#define BF_LCD_WF20_BPALCD20(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF20_BPALCD20) & BM_LCD_WF20_BPALCD20)

/*! @brief Set the BPALCD20 field to a new value. */
#define BW_LCD_WF20_BPALCD20(x, v) (BME_BFI8(HW_LCD_WF20_ADDR(x), ((uint8_t)(v) << BP_LCD_WF20_BPALCD20), BP_LCD_WF20_BPALCD20, 1))
/*@}*/

/*!
 * @name Register LCD_WF20, field BPBLCD20[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF20_BPBLCD20 (1U)          /*!< Bit position for LCD_WF20_BPBLCD20. */
#define BM_LCD_WF20_BPBLCD20 (0x02U)       /*!< Bit mask for LCD_WF20_BPBLCD20. */
#define BS_LCD_WF20_BPBLCD20 (1U)          /*!< Bit field size in bits for LCD_WF20_BPBLCD20. */

/*! @brief Read current value of the LCD_WF20_BPBLCD20 field. */
#define BR_LCD_WF20_BPBLCD20(x) (BME_UBFX8(HW_LCD_WF20_ADDR(x), BP_LCD_WF20_BPBLCD20, BS_LCD_WF20_BPBLCD20))

/*! @brief Format value for bitfield LCD_WF20_BPBLCD20. */
#define BF_LCD_WF20_BPBLCD20(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF20_BPBLCD20) & BM_LCD_WF20_BPBLCD20)

/*! @brief Set the BPBLCD20 field to a new value. */
#define BW_LCD_WF20_BPBLCD20(x, v) (BME_BFI8(HW_LCD_WF20_ADDR(x), ((uint8_t)(v) << BP_LCD_WF20_BPBLCD20), BP_LCD_WF20_BPBLCD20, 1))
/*@}*/

/*!
 * @name Register LCD_WF20, field BPCLCD20[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF20_BPCLCD20 (2U)          /*!< Bit position for LCD_WF20_BPCLCD20. */
#define BM_LCD_WF20_BPCLCD20 (0x04U)       /*!< Bit mask for LCD_WF20_BPCLCD20. */
#define BS_LCD_WF20_BPCLCD20 (1U)          /*!< Bit field size in bits for LCD_WF20_BPCLCD20. */

/*! @brief Read current value of the LCD_WF20_BPCLCD20 field. */
#define BR_LCD_WF20_BPCLCD20(x) (BME_UBFX8(HW_LCD_WF20_ADDR(x), BP_LCD_WF20_BPCLCD20, BS_LCD_WF20_BPCLCD20))

/*! @brief Format value for bitfield LCD_WF20_BPCLCD20. */
#define BF_LCD_WF20_BPCLCD20(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF20_BPCLCD20) & BM_LCD_WF20_BPCLCD20)

/*! @brief Set the BPCLCD20 field to a new value. */
#define BW_LCD_WF20_BPCLCD20(x, v) (BME_BFI8(HW_LCD_WF20_ADDR(x), ((uint8_t)(v) << BP_LCD_WF20_BPCLCD20), BP_LCD_WF20_BPCLCD20, 1))
/*@}*/

/*!
 * @name Register LCD_WF20, field BPDLCD20[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF20_BPDLCD20 (3U)          /*!< Bit position for LCD_WF20_BPDLCD20. */
#define BM_LCD_WF20_BPDLCD20 (0x08U)       /*!< Bit mask for LCD_WF20_BPDLCD20. */
#define BS_LCD_WF20_BPDLCD20 (1U)          /*!< Bit field size in bits for LCD_WF20_BPDLCD20. */

/*! @brief Read current value of the LCD_WF20_BPDLCD20 field. */
#define BR_LCD_WF20_BPDLCD20(x) (BME_UBFX8(HW_LCD_WF20_ADDR(x), BP_LCD_WF20_BPDLCD20, BS_LCD_WF20_BPDLCD20))

/*! @brief Format value for bitfield LCD_WF20_BPDLCD20. */
#define BF_LCD_WF20_BPDLCD20(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF20_BPDLCD20) & BM_LCD_WF20_BPDLCD20)

/*! @brief Set the BPDLCD20 field to a new value. */
#define BW_LCD_WF20_BPDLCD20(x, v) (BME_BFI8(HW_LCD_WF20_ADDR(x), ((uint8_t)(v) << BP_LCD_WF20_BPDLCD20), BP_LCD_WF20_BPDLCD20, 1))
/*@}*/

/*!
 * @name Register LCD_WF20, field BPELCD20[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF20_BPELCD20 (4U)          /*!< Bit position for LCD_WF20_BPELCD20. */
#define BM_LCD_WF20_BPELCD20 (0x10U)       /*!< Bit mask for LCD_WF20_BPELCD20. */
#define BS_LCD_WF20_BPELCD20 (1U)          /*!< Bit field size in bits for LCD_WF20_BPELCD20. */

/*! @brief Read current value of the LCD_WF20_BPELCD20 field. */
#define BR_LCD_WF20_BPELCD20(x) (BME_UBFX8(HW_LCD_WF20_ADDR(x), BP_LCD_WF20_BPELCD20, BS_LCD_WF20_BPELCD20))

/*! @brief Format value for bitfield LCD_WF20_BPELCD20. */
#define BF_LCD_WF20_BPELCD20(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF20_BPELCD20) & BM_LCD_WF20_BPELCD20)

/*! @brief Set the BPELCD20 field to a new value. */
#define BW_LCD_WF20_BPELCD20(x, v) (BME_BFI8(HW_LCD_WF20_ADDR(x), ((uint8_t)(v) << BP_LCD_WF20_BPELCD20), BP_LCD_WF20_BPELCD20, 1))
/*@}*/

/*!
 * @name Register LCD_WF20, field BPFLCD20[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF20_BPFLCD20 (5U)          /*!< Bit position for LCD_WF20_BPFLCD20. */
#define BM_LCD_WF20_BPFLCD20 (0x20U)       /*!< Bit mask for LCD_WF20_BPFLCD20. */
#define BS_LCD_WF20_BPFLCD20 (1U)          /*!< Bit field size in bits for LCD_WF20_BPFLCD20. */

/*! @brief Read current value of the LCD_WF20_BPFLCD20 field. */
#define BR_LCD_WF20_BPFLCD20(x) (BME_UBFX8(HW_LCD_WF20_ADDR(x), BP_LCD_WF20_BPFLCD20, BS_LCD_WF20_BPFLCD20))

/*! @brief Format value for bitfield LCD_WF20_BPFLCD20. */
#define BF_LCD_WF20_BPFLCD20(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF20_BPFLCD20) & BM_LCD_WF20_BPFLCD20)

/*! @brief Set the BPFLCD20 field to a new value. */
#define BW_LCD_WF20_BPFLCD20(x, v) (BME_BFI8(HW_LCD_WF20_ADDR(x), ((uint8_t)(v) << BP_LCD_WF20_BPFLCD20), BP_LCD_WF20_BPFLCD20, 1))
/*@}*/

/*!
 * @name Register LCD_WF20, field BPGLCD20[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF20_BPGLCD20 (6U)          /*!< Bit position for LCD_WF20_BPGLCD20. */
#define BM_LCD_WF20_BPGLCD20 (0x40U)       /*!< Bit mask for LCD_WF20_BPGLCD20. */
#define BS_LCD_WF20_BPGLCD20 (1U)          /*!< Bit field size in bits for LCD_WF20_BPGLCD20. */

/*! @brief Read current value of the LCD_WF20_BPGLCD20 field. */
#define BR_LCD_WF20_BPGLCD20(x) (BME_UBFX8(HW_LCD_WF20_ADDR(x), BP_LCD_WF20_BPGLCD20, BS_LCD_WF20_BPGLCD20))

/*! @brief Format value for bitfield LCD_WF20_BPGLCD20. */
#define BF_LCD_WF20_BPGLCD20(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF20_BPGLCD20) & BM_LCD_WF20_BPGLCD20)

/*! @brief Set the BPGLCD20 field to a new value. */
#define BW_LCD_WF20_BPGLCD20(x, v) (BME_BFI8(HW_LCD_WF20_ADDR(x), ((uint8_t)(v) << BP_LCD_WF20_BPGLCD20), BP_LCD_WF20_BPGLCD20, 1))
/*@}*/

/*!
 * @name Register LCD_WF20, field BPHLCD20[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF20_BPHLCD20 (7U)          /*!< Bit position for LCD_WF20_BPHLCD20. */
#define BM_LCD_WF20_BPHLCD20 (0x80U)       /*!< Bit mask for LCD_WF20_BPHLCD20. */
#define BS_LCD_WF20_BPHLCD20 (1U)          /*!< Bit field size in bits for LCD_WF20_BPHLCD20. */

/*! @brief Read current value of the LCD_WF20_BPHLCD20 field. */
#define BR_LCD_WF20_BPHLCD20(x) (BME_UBFX8(HW_LCD_WF20_ADDR(x), BP_LCD_WF20_BPHLCD20, BS_LCD_WF20_BPHLCD20))

/*! @brief Format value for bitfield LCD_WF20_BPHLCD20. */
#define BF_LCD_WF20_BPHLCD20(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF20_BPHLCD20) & BM_LCD_WF20_BPHLCD20)

/*! @brief Set the BPHLCD20 field to a new value. */
#define BW_LCD_WF20_BPHLCD20(x, v) (BME_BFI8(HW_LCD_WF20_ADDR(x), ((uint8_t)(v) << BP_LCD_WF20_BPHLCD20), BP_LCD_WF20_BPHLCD20, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF21 - LCD Waveform Register 21.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF21 - LCD Waveform Register 21. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf21
{
    uint8_t U;
    struct _hw_lcd_wf21_bitfields
    {
        uint8_t BPALCD21 : 1;          /*!< [0]  */
        uint8_t BPBLCD21 : 1;          /*!< [1]  */
        uint8_t BPCLCD21 : 1;          /*!< [2]  */
        uint8_t BPDLCD21 : 1;          /*!< [3]  */
        uint8_t BPELCD21 : 1;          /*!< [4]  */
        uint8_t BPFLCD21 : 1;          /*!< [5]  */
        uint8_t BPGLCD21 : 1;          /*!< [6]  */
        uint8_t BPHLCD21 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf21_t;

/*!
 * @name Constants and macros for entire LCD_WF21 register
 */
/*@{*/
#define HW_LCD_WF21_ADDR(x)      ((uint32_t)(x) + 0x35U)

#define HW_LCD_WF21(x)           (*(__IO hw_lcd_wf21_t *) HW_LCD_WF21_ADDR(x))
#define HW_LCD_WF21_RD(x)        (HW_LCD_WF21(x).U)
#define HW_LCD_WF21_WR(x, v)     (HW_LCD_WF21(x).U = (v))
#define HW_LCD_WF21_SET(x, v)    (BME_OR8(HW_LCD_WF21_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF21_CLR(x, v)    (BME_AND8(HW_LCD_WF21_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF21_TOG(x, v)    (BME_XOR8(HW_LCD_WF21_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF21 bitfields
 */

/*!
 * @name Register LCD_WF21, field BPALCD21[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF21_BPALCD21 (0U)          /*!< Bit position for LCD_WF21_BPALCD21. */
#define BM_LCD_WF21_BPALCD21 (0x01U)       /*!< Bit mask for LCD_WF21_BPALCD21. */
#define BS_LCD_WF21_BPALCD21 (1U)          /*!< Bit field size in bits for LCD_WF21_BPALCD21. */

/*! @brief Read current value of the LCD_WF21_BPALCD21 field. */
#define BR_LCD_WF21_BPALCD21(x) (BME_UBFX8(HW_LCD_WF21_ADDR(x), BP_LCD_WF21_BPALCD21, BS_LCD_WF21_BPALCD21))

/*! @brief Format value for bitfield LCD_WF21_BPALCD21. */
#define BF_LCD_WF21_BPALCD21(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF21_BPALCD21) & BM_LCD_WF21_BPALCD21)

/*! @brief Set the BPALCD21 field to a new value. */
#define BW_LCD_WF21_BPALCD21(x, v) (BME_BFI8(HW_LCD_WF21_ADDR(x), ((uint8_t)(v) << BP_LCD_WF21_BPALCD21), BP_LCD_WF21_BPALCD21, 1))
/*@}*/

/*!
 * @name Register LCD_WF21, field BPBLCD21[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF21_BPBLCD21 (1U)          /*!< Bit position for LCD_WF21_BPBLCD21. */
#define BM_LCD_WF21_BPBLCD21 (0x02U)       /*!< Bit mask for LCD_WF21_BPBLCD21. */
#define BS_LCD_WF21_BPBLCD21 (1U)          /*!< Bit field size in bits for LCD_WF21_BPBLCD21. */

/*! @brief Read current value of the LCD_WF21_BPBLCD21 field. */
#define BR_LCD_WF21_BPBLCD21(x) (BME_UBFX8(HW_LCD_WF21_ADDR(x), BP_LCD_WF21_BPBLCD21, BS_LCD_WF21_BPBLCD21))

/*! @brief Format value for bitfield LCD_WF21_BPBLCD21. */
#define BF_LCD_WF21_BPBLCD21(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF21_BPBLCD21) & BM_LCD_WF21_BPBLCD21)

/*! @brief Set the BPBLCD21 field to a new value. */
#define BW_LCD_WF21_BPBLCD21(x, v) (BME_BFI8(HW_LCD_WF21_ADDR(x), ((uint8_t)(v) << BP_LCD_WF21_BPBLCD21), BP_LCD_WF21_BPBLCD21, 1))
/*@}*/

/*!
 * @name Register LCD_WF21, field BPCLCD21[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF21_BPCLCD21 (2U)          /*!< Bit position for LCD_WF21_BPCLCD21. */
#define BM_LCD_WF21_BPCLCD21 (0x04U)       /*!< Bit mask for LCD_WF21_BPCLCD21. */
#define BS_LCD_WF21_BPCLCD21 (1U)          /*!< Bit field size in bits for LCD_WF21_BPCLCD21. */

/*! @brief Read current value of the LCD_WF21_BPCLCD21 field. */
#define BR_LCD_WF21_BPCLCD21(x) (BME_UBFX8(HW_LCD_WF21_ADDR(x), BP_LCD_WF21_BPCLCD21, BS_LCD_WF21_BPCLCD21))

/*! @brief Format value for bitfield LCD_WF21_BPCLCD21. */
#define BF_LCD_WF21_BPCLCD21(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF21_BPCLCD21) & BM_LCD_WF21_BPCLCD21)

/*! @brief Set the BPCLCD21 field to a new value. */
#define BW_LCD_WF21_BPCLCD21(x, v) (BME_BFI8(HW_LCD_WF21_ADDR(x), ((uint8_t)(v) << BP_LCD_WF21_BPCLCD21), BP_LCD_WF21_BPCLCD21, 1))
/*@}*/

/*!
 * @name Register LCD_WF21, field BPDLCD21[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF21_BPDLCD21 (3U)          /*!< Bit position for LCD_WF21_BPDLCD21. */
#define BM_LCD_WF21_BPDLCD21 (0x08U)       /*!< Bit mask for LCD_WF21_BPDLCD21. */
#define BS_LCD_WF21_BPDLCD21 (1U)          /*!< Bit field size in bits for LCD_WF21_BPDLCD21. */

/*! @brief Read current value of the LCD_WF21_BPDLCD21 field. */
#define BR_LCD_WF21_BPDLCD21(x) (BME_UBFX8(HW_LCD_WF21_ADDR(x), BP_LCD_WF21_BPDLCD21, BS_LCD_WF21_BPDLCD21))

/*! @brief Format value for bitfield LCD_WF21_BPDLCD21. */
#define BF_LCD_WF21_BPDLCD21(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF21_BPDLCD21) & BM_LCD_WF21_BPDLCD21)

/*! @brief Set the BPDLCD21 field to a new value. */
#define BW_LCD_WF21_BPDLCD21(x, v) (BME_BFI8(HW_LCD_WF21_ADDR(x), ((uint8_t)(v) << BP_LCD_WF21_BPDLCD21), BP_LCD_WF21_BPDLCD21, 1))
/*@}*/

/*!
 * @name Register LCD_WF21, field BPELCD21[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF21_BPELCD21 (4U)          /*!< Bit position for LCD_WF21_BPELCD21. */
#define BM_LCD_WF21_BPELCD21 (0x10U)       /*!< Bit mask for LCD_WF21_BPELCD21. */
#define BS_LCD_WF21_BPELCD21 (1U)          /*!< Bit field size in bits for LCD_WF21_BPELCD21. */

/*! @brief Read current value of the LCD_WF21_BPELCD21 field. */
#define BR_LCD_WF21_BPELCD21(x) (BME_UBFX8(HW_LCD_WF21_ADDR(x), BP_LCD_WF21_BPELCD21, BS_LCD_WF21_BPELCD21))

/*! @brief Format value for bitfield LCD_WF21_BPELCD21. */
#define BF_LCD_WF21_BPELCD21(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF21_BPELCD21) & BM_LCD_WF21_BPELCD21)

/*! @brief Set the BPELCD21 field to a new value. */
#define BW_LCD_WF21_BPELCD21(x, v) (BME_BFI8(HW_LCD_WF21_ADDR(x), ((uint8_t)(v) << BP_LCD_WF21_BPELCD21), BP_LCD_WF21_BPELCD21, 1))
/*@}*/

/*!
 * @name Register LCD_WF21, field BPFLCD21[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF21_BPFLCD21 (5U)          /*!< Bit position for LCD_WF21_BPFLCD21. */
#define BM_LCD_WF21_BPFLCD21 (0x20U)       /*!< Bit mask for LCD_WF21_BPFLCD21. */
#define BS_LCD_WF21_BPFLCD21 (1U)          /*!< Bit field size in bits for LCD_WF21_BPFLCD21. */

/*! @brief Read current value of the LCD_WF21_BPFLCD21 field. */
#define BR_LCD_WF21_BPFLCD21(x) (BME_UBFX8(HW_LCD_WF21_ADDR(x), BP_LCD_WF21_BPFLCD21, BS_LCD_WF21_BPFLCD21))

/*! @brief Format value for bitfield LCD_WF21_BPFLCD21. */
#define BF_LCD_WF21_BPFLCD21(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF21_BPFLCD21) & BM_LCD_WF21_BPFLCD21)

/*! @brief Set the BPFLCD21 field to a new value. */
#define BW_LCD_WF21_BPFLCD21(x, v) (BME_BFI8(HW_LCD_WF21_ADDR(x), ((uint8_t)(v) << BP_LCD_WF21_BPFLCD21), BP_LCD_WF21_BPFLCD21, 1))
/*@}*/

/*!
 * @name Register LCD_WF21, field BPGLCD21[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF21_BPGLCD21 (6U)          /*!< Bit position for LCD_WF21_BPGLCD21. */
#define BM_LCD_WF21_BPGLCD21 (0x40U)       /*!< Bit mask for LCD_WF21_BPGLCD21. */
#define BS_LCD_WF21_BPGLCD21 (1U)          /*!< Bit field size in bits for LCD_WF21_BPGLCD21. */

/*! @brief Read current value of the LCD_WF21_BPGLCD21 field. */
#define BR_LCD_WF21_BPGLCD21(x) (BME_UBFX8(HW_LCD_WF21_ADDR(x), BP_LCD_WF21_BPGLCD21, BS_LCD_WF21_BPGLCD21))

/*! @brief Format value for bitfield LCD_WF21_BPGLCD21. */
#define BF_LCD_WF21_BPGLCD21(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF21_BPGLCD21) & BM_LCD_WF21_BPGLCD21)

/*! @brief Set the BPGLCD21 field to a new value. */
#define BW_LCD_WF21_BPGLCD21(x, v) (BME_BFI8(HW_LCD_WF21_ADDR(x), ((uint8_t)(v) << BP_LCD_WF21_BPGLCD21), BP_LCD_WF21_BPGLCD21, 1))
/*@}*/

/*!
 * @name Register LCD_WF21, field BPHLCD21[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF21_BPHLCD21 (7U)          /*!< Bit position for LCD_WF21_BPHLCD21. */
#define BM_LCD_WF21_BPHLCD21 (0x80U)       /*!< Bit mask for LCD_WF21_BPHLCD21. */
#define BS_LCD_WF21_BPHLCD21 (1U)          /*!< Bit field size in bits for LCD_WF21_BPHLCD21. */

/*! @brief Read current value of the LCD_WF21_BPHLCD21 field. */
#define BR_LCD_WF21_BPHLCD21(x) (BME_UBFX8(HW_LCD_WF21_ADDR(x), BP_LCD_WF21_BPHLCD21, BS_LCD_WF21_BPHLCD21))

/*! @brief Format value for bitfield LCD_WF21_BPHLCD21. */
#define BF_LCD_WF21_BPHLCD21(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF21_BPHLCD21) & BM_LCD_WF21_BPHLCD21)

/*! @brief Set the BPHLCD21 field to a new value. */
#define BW_LCD_WF21_BPHLCD21(x, v) (BME_BFI8(HW_LCD_WF21_ADDR(x), ((uint8_t)(v) << BP_LCD_WF21_BPHLCD21), BP_LCD_WF21_BPHLCD21, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF22 - LCD Waveform Register 22.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF22 - LCD Waveform Register 22. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf22
{
    uint8_t U;
    struct _hw_lcd_wf22_bitfields
    {
        uint8_t BPALCD22 : 1;          /*!< [0]  */
        uint8_t BPBLCD22 : 1;          /*!< [1]  */
        uint8_t BPCLCD22 : 1;          /*!< [2]  */
        uint8_t BPDLCD22 : 1;          /*!< [3]  */
        uint8_t BPELCD22 : 1;          /*!< [4]  */
        uint8_t BPFLCD22 : 1;          /*!< [5]  */
        uint8_t BPGLCD22 : 1;          /*!< [6]  */
        uint8_t BPHLCD22 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf22_t;

/*!
 * @name Constants and macros for entire LCD_WF22 register
 */
/*@{*/
#define HW_LCD_WF22_ADDR(x)      ((uint32_t)(x) + 0x36U)

#define HW_LCD_WF22(x)           (*(__IO hw_lcd_wf22_t *) HW_LCD_WF22_ADDR(x))
#define HW_LCD_WF22_RD(x)        (HW_LCD_WF22(x).U)
#define HW_LCD_WF22_WR(x, v)     (HW_LCD_WF22(x).U = (v))
#define HW_LCD_WF22_SET(x, v)    (BME_OR8(HW_LCD_WF22_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF22_CLR(x, v)    (BME_AND8(HW_LCD_WF22_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF22_TOG(x, v)    (BME_XOR8(HW_LCD_WF22_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF22 bitfields
 */

/*!
 * @name Register LCD_WF22, field BPALCD22[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF22_BPALCD22 (0U)          /*!< Bit position for LCD_WF22_BPALCD22. */
#define BM_LCD_WF22_BPALCD22 (0x01U)       /*!< Bit mask for LCD_WF22_BPALCD22. */
#define BS_LCD_WF22_BPALCD22 (1U)          /*!< Bit field size in bits for LCD_WF22_BPALCD22. */

/*! @brief Read current value of the LCD_WF22_BPALCD22 field. */
#define BR_LCD_WF22_BPALCD22(x) (BME_UBFX8(HW_LCD_WF22_ADDR(x), BP_LCD_WF22_BPALCD22, BS_LCD_WF22_BPALCD22))

/*! @brief Format value for bitfield LCD_WF22_BPALCD22. */
#define BF_LCD_WF22_BPALCD22(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF22_BPALCD22) & BM_LCD_WF22_BPALCD22)

/*! @brief Set the BPALCD22 field to a new value. */
#define BW_LCD_WF22_BPALCD22(x, v) (BME_BFI8(HW_LCD_WF22_ADDR(x), ((uint8_t)(v) << BP_LCD_WF22_BPALCD22), BP_LCD_WF22_BPALCD22, 1))
/*@}*/

/*!
 * @name Register LCD_WF22, field BPBLCD22[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF22_BPBLCD22 (1U)          /*!< Bit position for LCD_WF22_BPBLCD22. */
#define BM_LCD_WF22_BPBLCD22 (0x02U)       /*!< Bit mask for LCD_WF22_BPBLCD22. */
#define BS_LCD_WF22_BPBLCD22 (1U)          /*!< Bit field size in bits for LCD_WF22_BPBLCD22. */

/*! @brief Read current value of the LCD_WF22_BPBLCD22 field. */
#define BR_LCD_WF22_BPBLCD22(x) (BME_UBFX8(HW_LCD_WF22_ADDR(x), BP_LCD_WF22_BPBLCD22, BS_LCD_WF22_BPBLCD22))

/*! @brief Format value for bitfield LCD_WF22_BPBLCD22. */
#define BF_LCD_WF22_BPBLCD22(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF22_BPBLCD22) & BM_LCD_WF22_BPBLCD22)

/*! @brief Set the BPBLCD22 field to a new value. */
#define BW_LCD_WF22_BPBLCD22(x, v) (BME_BFI8(HW_LCD_WF22_ADDR(x), ((uint8_t)(v) << BP_LCD_WF22_BPBLCD22), BP_LCD_WF22_BPBLCD22, 1))
/*@}*/

/*!
 * @name Register LCD_WF22, field BPCLCD22[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF22_BPCLCD22 (2U)          /*!< Bit position for LCD_WF22_BPCLCD22. */
#define BM_LCD_WF22_BPCLCD22 (0x04U)       /*!< Bit mask for LCD_WF22_BPCLCD22. */
#define BS_LCD_WF22_BPCLCD22 (1U)          /*!< Bit field size in bits for LCD_WF22_BPCLCD22. */

/*! @brief Read current value of the LCD_WF22_BPCLCD22 field. */
#define BR_LCD_WF22_BPCLCD22(x) (BME_UBFX8(HW_LCD_WF22_ADDR(x), BP_LCD_WF22_BPCLCD22, BS_LCD_WF22_BPCLCD22))

/*! @brief Format value for bitfield LCD_WF22_BPCLCD22. */
#define BF_LCD_WF22_BPCLCD22(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF22_BPCLCD22) & BM_LCD_WF22_BPCLCD22)

/*! @brief Set the BPCLCD22 field to a new value. */
#define BW_LCD_WF22_BPCLCD22(x, v) (BME_BFI8(HW_LCD_WF22_ADDR(x), ((uint8_t)(v) << BP_LCD_WF22_BPCLCD22), BP_LCD_WF22_BPCLCD22, 1))
/*@}*/

/*!
 * @name Register LCD_WF22, field BPDLCD22[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF22_BPDLCD22 (3U)          /*!< Bit position for LCD_WF22_BPDLCD22. */
#define BM_LCD_WF22_BPDLCD22 (0x08U)       /*!< Bit mask for LCD_WF22_BPDLCD22. */
#define BS_LCD_WF22_BPDLCD22 (1U)          /*!< Bit field size in bits for LCD_WF22_BPDLCD22. */

/*! @brief Read current value of the LCD_WF22_BPDLCD22 field. */
#define BR_LCD_WF22_BPDLCD22(x) (BME_UBFX8(HW_LCD_WF22_ADDR(x), BP_LCD_WF22_BPDLCD22, BS_LCD_WF22_BPDLCD22))

/*! @brief Format value for bitfield LCD_WF22_BPDLCD22. */
#define BF_LCD_WF22_BPDLCD22(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF22_BPDLCD22) & BM_LCD_WF22_BPDLCD22)

/*! @brief Set the BPDLCD22 field to a new value. */
#define BW_LCD_WF22_BPDLCD22(x, v) (BME_BFI8(HW_LCD_WF22_ADDR(x), ((uint8_t)(v) << BP_LCD_WF22_BPDLCD22), BP_LCD_WF22_BPDLCD22, 1))
/*@}*/

/*!
 * @name Register LCD_WF22, field BPELCD22[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF22_BPELCD22 (4U)          /*!< Bit position for LCD_WF22_BPELCD22. */
#define BM_LCD_WF22_BPELCD22 (0x10U)       /*!< Bit mask for LCD_WF22_BPELCD22. */
#define BS_LCD_WF22_BPELCD22 (1U)          /*!< Bit field size in bits for LCD_WF22_BPELCD22. */

/*! @brief Read current value of the LCD_WF22_BPELCD22 field. */
#define BR_LCD_WF22_BPELCD22(x) (BME_UBFX8(HW_LCD_WF22_ADDR(x), BP_LCD_WF22_BPELCD22, BS_LCD_WF22_BPELCD22))

/*! @brief Format value for bitfield LCD_WF22_BPELCD22. */
#define BF_LCD_WF22_BPELCD22(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF22_BPELCD22) & BM_LCD_WF22_BPELCD22)

/*! @brief Set the BPELCD22 field to a new value. */
#define BW_LCD_WF22_BPELCD22(x, v) (BME_BFI8(HW_LCD_WF22_ADDR(x), ((uint8_t)(v) << BP_LCD_WF22_BPELCD22), BP_LCD_WF22_BPELCD22, 1))
/*@}*/

/*!
 * @name Register LCD_WF22, field BPFLCD22[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF22_BPFLCD22 (5U)          /*!< Bit position for LCD_WF22_BPFLCD22. */
#define BM_LCD_WF22_BPFLCD22 (0x20U)       /*!< Bit mask for LCD_WF22_BPFLCD22. */
#define BS_LCD_WF22_BPFLCD22 (1U)          /*!< Bit field size in bits for LCD_WF22_BPFLCD22. */

/*! @brief Read current value of the LCD_WF22_BPFLCD22 field. */
#define BR_LCD_WF22_BPFLCD22(x) (BME_UBFX8(HW_LCD_WF22_ADDR(x), BP_LCD_WF22_BPFLCD22, BS_LCD_WF22_BPFLCD22))

/*! @brief Format value for bitfield LCD_WF22_BPFLCD22. */
#define BF_LCD_WF22_BPFLCD22(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF22_BPFLCD22) & BM_LCD_WF22_BPFLCD22)

/*! @brief Set the BPFLCD22 field to a new value. */
#define BW_LCD_WF22_BPFLCD22(x, v) (BME_BFI8(HW_LCD_WF22_ADDR(x), ((uint8_t)(v) << BP_LCD_WF22_BPFLCD22), BP_LCD_WF22_BPFLCD22, 1))
/*@}*/

/*!
 * @name Register LCD_WF22, field BPGLCD22[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF22_BPGLCD22 (6U)          /*!< Bit position for LCD_WF22_BPGLCD22. */
#define BM_LCD_WF22_BPGLCD22 (0x40U)       /*!< Bit mask for LCD_WF22_BPGLCD22. */
#define BS_LCD_WF22_BPGLCD22 (1U)          /*!< Bit field size in bits for LCD_WF22_BPGLCD22. */

/*! @brief Read current value of the LCD_WF22_BPGLCD22 field. */
#define BR_LCD_WF22_BPGLCD22(x) (BME_UBFX8(HW_LCD_WF22_ADDR(x), BP_LCD_WF22_BPGLCD22, BS_LCD_WF22_BPGLCD22))

/*! @brief Format value for bitfield LCD_WF22_BPGLCD22. */
#define BF_LCD_WF22_BPGLCD22(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF22_BPGLCD22) & BM_LCD_WF22_BPGLCD22)

/*! @brief Set the BPGLCD22 field to a new value. */
#define BW_LCD_WF22_BPGLCD22(x, v) (BME_BFI8(HW_LCD_WF22_ADDR(x), ((uint8_t)(v) << BP_LCD_WF22_BPGLCD22), BP_LCD_WF22_BPGLCD22, 1))
/*@}*/

/*!
 * @name Register LCD_WF22, field BPHLCD22[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF22_BPHLCD22 (7U)          /*!< Bit position for LCD_WF22_BPHLCD22. */
#define BM_LCD_WF22_BPHLCD22 (0x80U)       /*!< Bit mask for LCD_WF22_BPHLCD22. */
#define BS_LCD_WF22_BPHLCD22 (1U)          /*!< Bit field size in bits for LCD_WF22_BPHLCD22. */

/*! @brief Read current value of the LCD_WF22_BPHLCD22 field. */
#define BR_LCD_WF22_BPHLCD22(x) (BME_UBFX8(HW_LCD_WF22_ADDR(x), BP_LCD_WF22_BPHLCD22, BS_LCD_WF22_BPHLCD22))

/*! @brief Format value for bitfield LCD_WF22_BPHLCD22. */
#define BF_LCD_WF22_BPHLCD22(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF22_BPHLCD22) & BM_LCD_WF22_BPHLCD22)

/*! @brief Set the BPHLCD22 field to a new value. */
#define BW_LCD_WF22_BPHLCD22(x, v) (BME_BFI8(HW_LCD_WF22_ADDR(x), ((uint8_t)(v) << BP_LCD_WF22_BPHLCD22), BP_LCD_WF22_BPHLCD22, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF23 - LCD Waveform Register 23.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF23 - LCD Waveform Register 23. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf23
{
    uint8_t U;
    struct _hw_lcd_wf23_bitfields
    {
        uint8_t BPALCD23 : 1;          /*!< [0]  */
        uint8_t BPBLCD23 : 1;          /*!< [1]  */
        uint8_t BPCLCD23 : 1;          /*!< [2]  */
        uint8_t BPDLCD23 : 1;          /*!< [3]  */
        uint8_t BPELCD23 : 1;          /*!< [4]  */
        uint8_t BPFLCD23 : 1;          /*!< [5]  */
        uint8_t BPGLCD23 : 1;          /*!< [6]  */
        uint8_t BPHLCD23 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf23_t;

/*!
 * @name Constants and macros for entire LCD_WF23 register
 */
/*@{*/
#define HW_LCD_WF23_ADDR(x)      ((uint32_t)(x) + 0x37U)

#define HW_LCD_WF23(x)           (*(__IO hw_lcd_wf23_t *) HW_LCD_WF23_ADDR(x))
#define HW_LCD_WF23_RD(x)        (HW_LCD_WF23(x).U)
#define HW_LCD_WF23_WR(x, v)     (HW_LCD_WF23(x).U = (v))
#define HW_LCD_WF23_SET(x, v)    (BME_OR8(HW_LCD_WF23_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF23_CLR(x, v)    (BME_AND8(HW_LCD_WF23_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF23_TOG(x, v)    (BME_XOR8(HW_LCD_WF23_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF23 bitfields
 */

/*!
 * @name Register LCD_WF23, field BPALCD23[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF23_BPALCD23 (0U)          /*!< Bit position for LCD_WF23_BPALCD23. */
#define BM_LCD_WF23_BPALCD23 (0x01U)       /*!< Bit mask for LCD_WF23_BPALCD23. */
#define BS_LCD_WF23_BPALCD23 (1U)          /*!< Bit field size in bits for LCD_WF23_BPALCD23. */

/*! @brief Read current value of the LCD_WF23_BPALCD23 field. */
#define BR_LCD_WF23_BPALCD23(x) (BME_UBFX8(HW_LCD_WF23_ADDR(x), BP_LCD_WF23_BPALCD23, BS_LCD_WF23_BPALCD23))

/*! @brief Format value for bitfield LCD_WF23_BPALCD23. */
#define BF_LCD_WF23_BPALCD23(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF23_BPALCD23) & BM_LCD_WF23_BPALCD23)

/*! @brief Set the BPALCD23 field to a new value. */
#define BW_LCD_WF23_BPALCD23(x, v) (BME_BFI8(HW_LCD_WF23_ADDR(x), ((uint8_t)(v) << BP_LCD_WF23_BPALCD23), BP_LCD_WF23_BPALCD23, 1))
/*@}*/

/*!
 * @name Register LCD_WF23, field BPBLCD23[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF23_BPBLCD23 (1U)          /*!< Bit position for LCD_WF23_BPBLCD23. */
#define BM_LCD_WF23_BPBLCD23 (0x02U)       /*!< Bit mask for LCD_WF23_BPBLCD23. */
#define BS_LCD_WF23_BPBLCD23 (1U)          /*!< Bit field size in bits for LCD_WF23_BPBLCD23. */

/*! @brief Read current value of the LCD_WF23_BPBLCD23 field. */
#define BR_LCD_WF23_BPBLCD23(x) (BME_UBFX8(HW_LCD_WF23_ADDR(x), BP_LCD_WF23_BPBLCD23, BS_LCD_WF23_BPBLCD23))

/*! @brief Format value for bitfield LCD_WF23_BPBLCD23. */
#define BF_LCD_WF23_BPBLCD23(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF23_BPBLCD23) & BM_LCD_WF23_BPBLCD23)

/*! @brief Set the BPBLCD23 field to a new value. */
#define BW_LCD_WF23_BPBLCD23(x, v) (BME_BFI8(HW_LCD_WF23_ADDR(x), ((uint8_t)(v) << BP_LCD_WF23_BPBLCD23), BP_LCD_WF23_BPBLCD23, 1))
/*@}*/

/*!
 * @name Register LCD_WF23, field BPCLCD23[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF23_BPCLCD23 (2U)          /*!< Bit position for LCD_WF23_BPCLCD23. */
#define BM_LCD_WF23_BPCLCD23 (0x04U)       /*!< Bit mask for LCD_WF23_BPCLCD23. */
#define BS_LCD_WF23_BPCLCD23 (1U)          /*!< Bit field size in bits for LCD_WF23_BPCLCD23. */

/*! @brief Read current value of the LCD_WF23_BPCLCD23 field. */
#define BR_LCD_WF23_BPCLCD23(x) (BME_UBFX8(HW_LCD_WF23_ADDR(x), BP_LCD_WF23_BPCLCD23, BS_LCD_WF23_BPCLCD23))

/*! @brief Format value for bitfield LCD_WF23_BPCLCD23. */
#define BF_LCD_WF23_BPCLCD23(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF23_BPCLCD23) & BM_LCD_WF23_BPCLCD23)

/*! @brief Set the BPCLCD23 field to a new value. */
#define BW_LCD_WF23_BPCLCD23(x, v) (BME_BFI8(HW_LCD_WF23_ADDR(x), ((uint8_t)(v) << BP_LCD_WF23_BPCLCD23), BP_LCD_WF23_BPCLCD23, 1))
/*@}*/

/*!
 * @name Register LCD_WF23, field BPDLCD23[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF23_BPDLCD23 (3U)          /*!< Bit position for LCD_WF23_BPDLCD23. */
#define BM_LCD_WF23_BPDLCD23 (0x08U)       /*!< Bit mask for LCD_WF23_BPDLCD23. */
#define BS_LCD_WF23_BPDLCD23 (1U)          /*!< Bit field size in bits for LCD_WF23_BPDLCD23. */

/*! @brief Read current value of the LCD_WF23_BPDLCD23 field. */
#define BR_LCD_WF23_BPDLCD23(x) (BME_UBFX8(HW_LCD_WF23_ADDR(x), BP_LCD_WF23_BPDLCD23, BS_LCD_WF23_BPDLCD23))

/*! @brief Format value for bitfield LCD_WF23_BPDLCD23. */
#define BF_LCD_WF23_BPDLCD23(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF23_BPDLCD23) & BM_LCD_WF23_BPDLCD23)

/*! @brief Set the BPDLCD23 field to a new value. */
#define BW_LCD_WF23_BPDLCD23(x, v) (BME_BFI8(HW_LCD_WF23_ADDR(x), ((uint8_t)(v) << BP_LCD_WF23_BPDLCD23), BP_LCD_WF23_BPDLCD23, 1))
/*@}*/

/*!
 * @name Register LCD_WF23, field BPELCD23[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF23_BPELCD23 (4U)          /*!< Bit position for LCD_WF23_BPELCD23. */
#define BM_LCD_WF23_BPELCD23 (0x10U)       /*!< Bit mask for LCD_WF23_BPELCD23. */
#define BS_LCD_WF23_BPELCD23 (1U)          /*!< Bit field size in bits for LCD_WF23_BPELCD23. */

/*! @brief Read current value of the LCD_WF23_BPELCD23 field. */
#define BR_LCD_WF23_BPELCD23(x) (BME_UBFX8(HW_LCD_WF23_ADDR(x), BP_LCD_WF23_BPELCD23, BS_LCD_WF23_BPELCD23))

/*! @brief Format value for bitfield LCD_WF23_BPELCD23. */
#define BF_LCD_WF23_BPELCD23(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF23_BPELCD23) & BM_LCD_WF23_BPELCD23)

/*! @brief Set the BPELCD23 field to a new value. */
#define BW_LCD_WF23_BPELCD23(x, v) (BME_BFI8(HW_LCD_WF23_ADDR(x), ((uint8_t)(v) << BP_LCD_WF23_BPELCD23), BP_LCD_WF23_BPELCD23, 1))
/*@}*/

/*!
 * @name Register LCD_WF23, field BPFLCD23[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF23_BPFLCD23 (5U)          /*!< Bit position for LCD_WF23_BPFLCD23. */
#define BM_LCD_WF23_BPFLCD23 (0x20U)       /*!< Bit mask for LCD_WF23_BPFLCD23. */
#define BS_LCD_WF23_BPFLCD23 (1U)          /*!< Bit field size in bits for LCD_WF23_BPFLCD23. */

/*! @brief Read current value of the LCD_WF23_BPFLCD23 field. */
#define BR_LCD_WF23_BPFLCD23(x) (BME_UBFX8(HW_LCD_WF23_ADDR(x), BP_LCD_WF23_BPFLCD23, BS_LCD_WF23_BPFLCD23))

/*! @brief Format value for bitfield LCD_WF23_BPFLCD23. */
#define BF_LCD_WF23_BPFLCD23(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF23_BPFLCD23) & BM_LCD_WF23_BPFLCD23)

/*! @brief Set the BPFLCD23 field to a new value. */
#define BW_LCD_WF23_BPFLCD23(x, v) (BME_BFI8(HW_LCD_WF23_ADDR(x), ((uint8_t)(v) << BP_LCD_WF23_BPFLCD23), BP_LCD_WF23_BPFLCD23, 1))
/*@}*/

/*!
 * @name Register LCD_WF23, field BPGLCD23[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF23_BPGLCD23 (6U)          /*!< Bit position for LCD_WF23_BPGLCD23. */
#define BM_LCD_WF23_BPGLCD23 (0x40U)       /*!< Bit mask for LCD_WF23_BPGLCD23. */
#define BS_LCD_WF23_BPGLCD23 (1U)          /*!< Bit field size in bits for LCD_WF23_BPGLCD23. */

/*! @brief Read current value of the LCD_WF23_BPGLCD23 field. */
#define BR_LCD_WF23_BPGLCD23(x) (BME_UBFX8(HW_LCD_WF23_ADDR(x), BP_LCD_WF23_BPGLCD23, BS_LCD_WF23_BPGLCD23))

/*! @brief Format value for bitfield LCD_WF23_BPGLCD23. */
#define BF_LCD_WF23_BPGLCD23(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF23_BPGLCD23) & BM_LCD_WF23_BPGLCD23)

/*! @brief Set the BPGLCD23 field to a new value. */
#define BW_LCD_WF23_BPGLCD23(x, v) (BME_BFI8(HW_LCD_WF23_ADDR(x), ((uint8_t)(v) << BP_LCD_WF23_BPGLCD23), BP_LCD_WF23_BPGLCD23, 1))
/*@}*/

/*!
 * @name Register LCD_WF23, field BPHLCD23[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF23_BPHLCD23 (7U)          /*!< Bit position for LCD_WF23_BPHLCD23. */
#define BM_LCD_WF23_BPHLCD23 (0x80U)       /*!< Bit mask for LCD_WF23_BPHLCD23. */
#define BS_LCD_WF23_BPHLCD23 (1U)          /*!< Bit field size in bits for LCD_WF23_BPHLCD23. */

/*! @brief Read current value of the LCD_WF23_BPHLCD23 field. */
#define BR_LCD_WF23_BPHLCD23(x) (BME_UBFX8(HW_LCD_WF23_ADDR(x), BP_LCD_WF23_BPHLCD23, BS_LCD_WF23_BPHLCD23))

/*! @brief Format value for bitfield LCD_WF23_BPHLCD23. */
#define BF_LCD_WF23_BPHLCD23(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF23_BPHLCD23) & BM_LCD_WF23_BPHLCD23)

/*! @brief Set the BPHLCD23 field to a new value. */
#define BW_LCD_WF23_BPHLCD23(x, v) (BME_BFI8(HW_LCD_WF23_ADDR(x), ((uint8_t)(v) << BP_LCD_WF23_BPHLCD23), BP_LCD_WF23_BPHLCD23, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF24 - LCD Waveform Register 24.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF24 - LCD Waveform Register 24. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf24
{
    uint8_t U;
    struct _hw_lcd_wf24_bitfields
    {
        uint8_t BPALCD24 : 1;          /*!< [0]  */
        uint8_t BPBLCD24 : 1;          /*!< [1]  */
        uint8_t BPCLCD24 : 1;          /*!< [2]  */
        uint8_t BPDLCD24 : 1;          /*!< [3]  */
        uint8_t BPELCD24 : 1;          /*!< [4]  */
        uint8_t BPFLCD24 : 1;          /*!< [5]  */
        uint8_t BPGLCD24 : 1;          /*!< [6]  */
        uint8_t BPHLCD24 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf24_t;

/*!
 * @name Constants and macros for entire LCD_WF24 register
 */
/*@{*/
#define HW_LCD_WF24_ADDR(x)      ((uint32_t)(x) + 0x38U)

#define HW_LCD_WF24(x)           (*(__IO hw_lcd_wf24_t *) HW_LCD_WF24_ADDR(x))
#define HW_LCD_WF24_RD(x)        (HW_LCD_WF24(x).U)
#define HW_LCD_WF24_WR(x, v)     (HW_LCD_WF24(x).U = (v))
#define HW_LCD_WF24_SET(x, v)    (BME_OR8(HW_LCD_WF24_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF24_CLR(x, v)    (BME_AND8(HW_LCD_WF24_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF24_TOG(x, v)    (BME_XOR8(HW_LCD_WF24_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF24 bitfields
 */

/*!
 * @name Register LCD_WF24, field BPALCD24[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF24_BPALCD24 (0U)          /*!< Bit position for LCD_WF24_BPALCD24. */
#define BM_LCD_WF24_BPALCD24 (0x01U)       /*!< Bit mask for LCD_WF24_BPALCD24. */
#define BS_LCD_WF24_BPALCD24 (1U)          /*!< Bit field size in bits for LCD_WF24_BPALCD24. */

/*! @brief Read current value of the LCD_WF24_BPALCD24 field. */
#define BR_LCD_WF24_BPALCD24(x) (BME_UBFX8(HW_LCD_WF24_ADDR(x), BP_LCD_WF24_BPALCD24, BS_LCD_WF24_BPALCD24))

/*! @brief Format value for bitfield LCD_WF24_BPALCD24. */
#define BF_LCD_WF24_BPALCD24(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF24_BPALCD24) & BM_LCD_WF24_BPALCD24)

/*! @brief Set the BPALCD24 field to a new value. */
#define BW_LCD_WF24_BPALCD24(x, v) (BME_BFI8(HW_LCD_WF24_ADDR(x), ((uint8_t)(v) << BP_LCD_WF24_BPALCD24), BP_LCD_WF24_BPALCD24, 1))
/*@}*/

/*!
 * @name Register LCD_WF24, field BPBLCD24[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF24_BPBLCD24 (1U)          /*!< Bit position for LCD_WF24_BPBLCD24. */
#define BM_LCD_WF24_BPBLCD24 (0x02U)       /*!< Bit mask for LCD_WF24_BPBLCD24. */
#define BS_LCD_WF24_BPBLCD24 (1U)          /*!< Bit field size in bits for LCD_WF24_BPBLCD24. */

/*! @brief Read current value of the LCD_WF24_BPBLCD24 field. */
#define BR_LCD_WF24_BPBLCD24(x) (BME_UBFX8(HW_LCD_WF24_ADDR(x), BP_LCD_WF24_BPBLCD24, BS_LCD_WF24_BPBLCD24))

/*! @brief Format value for bitfield LCD_WF24_BPBLCD24. */
#define BF_LCD_WF24_BPBLCD24(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF24_BPBLCD24) & BM_LCD_WF24_BPBLCD24)

/*! @brief Set the BPBLCD24 field to a new value. */
#define BW_LCD_WF24_BPBLCD24(x, v) (BME_BFI8(HW_LCD_WF24_ADDR(x), ((uint8_t)(v) << BP_LCD_WF24_BPBLCD24), BP_LCD_WF24_BPBLCD24, 1))
/*@}*/

/*!
 * @name Register LCD_WF24, field BPCLCD24[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF24_BPCLCD24 (2U)          /*!< Bit position for LCD_WF24_BPCLCD24. */
#define BM_LCD_WF24_BPCLCD24 (0x04U)       /*!< Bit mask for LCD_WF24_BPCLCD24. */
#define BS_LCD_WF24_BPCLCD24 (1U)          /*!< Bit field size in bits for LCD_WF24_BPCLCD24. */

/*! @brief Read current value of the LCD_WF24_BPCLCD24 field. */
#define BR_LCD_WF24_BPCLCD24(x) (BME_UBFX8(HW_LCD_WF24_ADDR(x), BP_LCD_WF24_BPCLCD24, BS_LCD_WF24_BPCLCD24))

/*! @brief Format value for bitfield LCD_WF24_BPCLCD24. */
#define BF_LCD_WF24_BPCLCD24(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF24_BPCLCD24) & BM_LCD_WF24_BPCLCD24)

/*! @brief Set the BPCLCD24 field to a new value. */
#define BW_LCD_WF24_BPCLCD24(x, v) (BME_BFI8(HW_LCD_WF24_ADDR(x), ((uint8_t)(v) << BP_LCD_WF24_BPCLCD24), BP_LCD_WF24_BPCLCD24, 1))
/*@}*/

/*!
 * @name Register LCD_WF24, field BPDLCD24[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF24_BPDLCD24 (3U)          /*!< Bit position for LCD_WF24_BPDLCD24. */
#define BM_LCD_WF24_BPDLCD24 (0x08U)       /*!< Bit mask for LCD_WF24_BPDLCD24. */
#define BS_LCD_WF24_BPDLCD24 (1U)          /*!< Bit field size in bits for LCD_WF24_BPDLCD24. */

/*! @brief Read current value of the LCD_WF24_BPDLCD24 field. */
#define BR_LCD_WF24_BPDLCD24(x) (BME_UBFX8(HW_LCD_WF24_ADDR(x), BP_LCD_WF24_BPDLCD24, BS_LCD_WF24_BPDLCD24))

/*! @brief Format value for bitfield LCD_WF24_BPDLCD24. */
#define BF_LCD_WF24_BPDLCD24(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF24_BPDLCD24) & BM_LCD_WF24_BPDLCD24)

/*! @brief Set the BPDLCD24 field to a new value. */
#define BW_LCD_WF24_BPDLCD24(x, v) (BME_BFI8(HW_LCD_WF24_ADDR(x), ((uint8_t)(v) << BP_LCD_WF24_BPDLCD24), BP_LCD_WF24_BPDLCD24, 1))
/*@}*/

/*!
 * @name Register LCD_WF24, field BPELCD24[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF24_BPELCD24 (4U)          /*!< Bit position for LCD_WF24_BPELCD24. */
#define BM_LCD_WF24_BPELCD24 (0x10U)       /*!< Bit mask for LCD_WF24_BPELCD24. */
#define BS_LCD_WF24_BPELCD24 (1U)          /*!< Bit field size in bits for LCD_WF24_BPELCD24. */

/*! @brief Read current value of the LCD_WF24_BPELCD24 field. */
#define BR_LCD_WF24_BPELCD24(x) (BME_UBFX8(HW_LCD_WF24_ADDR(x), BP_LCD_WF24_BPELCD24, BS_LCD_WF24_BPELCD24))

/*! @brief Format value for bitfield LCD_WF24_BPELCD24. */
#define BF_LCD_WF24_BPELCD24(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF24_BPELCD24) & BM_LCD_WF24_BPELCD24)

/*! @brief Set the BPELCD24 field to a new value. */
#define BW_LCD_WF24_BPELCD24(x, v) (BME_BFI8(HW_LCD_WF24_ADDR(x), ((uint8_t)(v) << BP_LCD_WF24_BPELCD24), BP_LCD_WF24_BPELCD24, 1))
/*@}*/

/*!
 * @name Register LCD_WF24, field BPFLCD24[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF24_BPFLCD24 (5U)          /*!< Bit position for LCD_WF24_BPFLCD24. */
#define BM_LCD_WF24_BPFLCD24 (0x20U)       /*!< Bit mask for LCD_WF24_BPFLCD24. */
#define BS_LCD_WF24_BPFLCD24 (1U)          /*!< Bit field size in bits for LCD_WF24_BPFLCD24. */

/*! @brief Read current value of the LCD_WF24_BPFLCD24 field. */
#define BR_LCD_WF24_BPFLCD24(x) (BME_UBFX8(HW_LCD_WF24_ADDR(x), BP_LCD_WF24_BPFLCD24, BS_LCD_WF24_BPFLCD24))

/*! @brief Format value for bitfield LCD_WF24_BPFLCD24. */
#define BF_LCD_WF24_BPFLCD24(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF24_BPFLCD24) & BM_LCD_WF24_BPFLCD24)

/*! @brief Set the BPFLCD24 field to a new value. */
#define BW_LCD_WF24_BPFLCD24(x, v) (BME_BFI8(HW_LCD_WF24_ADDR(x), ((uint8_t)(v) << BP_LCD_WF24_BPFLCD24), BP_LCD_WF24_BPFLCD24, 1))
/*@}*/

/*!
 * @name Register LCD_WF24, field BPGLCD24[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF24_BPGLCD24 (6U)          /*!< Bit position for LCD_WF24_BPGLCD24. */
#define BM_LCD_WF24_BPGLCD24 (0x40U)       /*!< Bit mask for LCD_WF24_BPGLCD24. */
#define BS_LCD_WF24_BPGLCD24 (1U)          /*!< Bit field size in bits for LCD_WF24_BPGLCD24. */

/*! @brief Read current value of the LCD_WF24_BPGLCD24 field. */
#define BR_LCD_WF24_BPGLCD24(x) (BME_UBFX8(HW_LCD_WF24_ADDR(x), BP_LCD_WF24_BPGLCD24, BS_LCD_WF24_BPGLCD24))

/*! @brief Format value for bitfield LCD_WF24_BPGLCD24. */
#define BF_LCD_WF24_BPGLCD24(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF24_BPGLCD24) & BM_LCD_WF24_BPGLCD24)

/*! @brief Set the BPGLCD24 field to a new value. */
#define BW_LCD_WF24_BPGLCD24(x, v) (BME_BFI8(HW_LCD_WF24_ADDR(x), ((uint8_t)(v) << BP_LCD_WF24_BPGLCD24), BP_LCD_WF24_BPGLCD24, 1))
/*@}*/

/*!
 * @name Register LCD_WF24, field BPHLCD24[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF24_BPHLCD24 (7U)          /*!< Bit position for LCD_WF24_BPHLCD24. */
#define BM_LCD_WF24_BPHLCD24 (0x80U)       /*!< Bit mask for LCD_WF24_BPHLCD24. */
#define BS_LCD_WF24_BPHLCD24 (1U)          /*!< Bit field size in bits for LCD_WF24_BPHLCD24. */

/*! @brief Read current value of the LCD_WF24_BPHLCD24 field. */
#define BR_LCD_WF24_BPHLCD24(x) (BME_UBFX8(HW_LCD_WF24_ADDR(x), BP_LCD_WF24_BPHLCD24, BS_LCD_WF24_BPHLCD24))

/*! @brief Format value for bitfield LCD_WF24_BPHLCD24. */
#define BF_LCD_WF24_BPHLCD24(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF24_BPHLCD24) & BM_LCD_WF24_BPHLCD24)

/*! @brief Set the BPHLCD24 field to a new value. */
#define BW_LCD_WF24_BPHLCD24(x, v) (BME_BFI8(HW_LCD_WF24_ADDR(x), ((uint8_t)(v) << BP_LCD_WF24_BPHLCD24), BP_LCD_WF24_BPHLCD24, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF25 - LCD Waveform Register 25.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF25 - LCD Waveform Register 25. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf25
{
    uint8_t U;
    struct _hw_lcd_wf25_bitfields
    {
        uint8_t BPALCD25 : 1;          /*!< [0]  */
        uint8_t BPBLCD25 : 1;          /*!< [1]  */
        uint8_t BPCLCD25 : 1;          /*!< [2]  */
        uint8_t BPDLCD25 : 1;          /*!< [3]  */
        uint8_t BPELCD25 : 1;          /*!< [4]  */
        uint8_t BPFLCD25 : 1;          /*!< [5]  */
        uint8_t BPGLCD25 : 1;          /*!< [6]  */
        uint8_t BPHLCD25 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf25_t;

/*!
 * @name Constants and macros for entire LCD_WF25 register
 */
/*@{*/
#define HW_LCD_WF25_ADDR(x)      ((uint32_t)(x) + 0x39U)

#define HW_LCD_WF25(x)           (*(__IO hw_lcd_wf25_t *) HW_LCD_WF25_ADDR(x))
#define HW_LCD_WF25_RD(x)        (HW_LCD_WF25(x).U)
#define HW_LCD_WF25_WR(x, v)     (HW_LCD_WF25(x).U = (v))
#define HW_LCD_WF25_SET(x, v)    (BME_OR8(HW_LCD_WF25_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF25_CLR(x, v)    (BME_AND8(HW_LCD_WF25_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF25_TOG(x, v)    (BME_XOR8(HW_LCD_WF25_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF25 bitfields
 */

/*!
 * @name Register LCD_WF25, field BPALCD25[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF25_BPALCD25 (0U)          /*!< Bit position for LCD_WF25_BPALCD25. */
#define BM_LCD_WF25_BPALCD25 (0x01U)       /*!< Bit mask for LCD_WF25_BPALCD25. */
#define BS_LCD_WF25_BPALCD25 (1U)          /*!< Bit field size in bits for LCD_WF25_BPALCD25. */

/*! @brief Read current value of the LCD_WF25_BPALCD25 field. */
#define BR_LCD_WF25_BPALCD25(x) (BME_UBFX8(HW_LCD_WF25_ADDR(x), BP_LCD_WF25_BPALCD25, BS_LCD_WF25_BPALCD25))

/*! @brief Format value for bitfield LCD_WF25_BPALCD25. */
#define BF_LCD_WF25_BPALCD25(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF25_BPALCD25) & BM_LCD_WF25_BPALCD25)

/*! @brief Set the BPALCD25 field to a new value. */
#define BW_LCD_WF25_BPALCD25(x, v) (BME_BFI8(HW_LCD_WF25_ADDR(x), ((uint8_t)(v) << BP_LCD_WF25_BPALCD25), BP_LCD_WF25_BPALCD25, 1))
/*@}*/

/*!
 * @name Register LCD_WF25, field BPBLCD25[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF25_BPBLCD25 (1U)          /*!< Bit position for LCD_WF25_BPBLCD25. */
#define BM_LCD_WF25_BPBLCD25 (0x02U)       /*!< Bit mask for LCD_WF25_BPBLCD25. */
#define BS_LCD_WF25_BPBLCD25 (1U)          /*!< Bit field size in bits for LCD_WF25_BPBLCD25. */

/*! @brief Read current value of the LCD_WF25_BPBLCD25 field. */
#define BR_LCD_WF25_BPBLCD25(x) (BME_UBFX8(HW_LCD_WF25_ADDR(x), BP_LCD_WF25_BPBLCD25, BS_LCD_WF25_BPBLCD25))

/*! @brief Format value for bitfield LCD_WF25_BPBLCD25. */
#define BF_LCD_WF25_BPBLCD25(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF25_BPBLCD25) & BM_LCD_WF25_BPBLCD25)

/*! @brief Set the BPBLCD25 field to a new value. */
#define BW_LCD_WF25_BPBLCD25(x, v) (BME_BFI8(HW_LCD_WF25_ADDR(x), ((uint8_t)(v) << BP_LCD_WF25_BPBLCD25), BP_LCD_WF25_BPBLCD25, 1))
/*@}*/

/*!
 * @name Register LCD_WF25, field BPCLCD25[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF25_BPCLCD25 (2U)          /*!< Bit position for LCD_WF25_BPCLCD25. */
#define BM_LCD_WF25_BPCLCD25 (0x04U)       /*!< Bit mask for LCD_WF25_BPCLCD25. */
#define BS_LCD_WF25_BPCLCD25 (1U)          /*!< Bit field size in bits for LCD_WF25_BPCLCD25. */

/*! @brief Read current value of the LCD_WF25_BPCLCD25 field. */
#define BR_LCD_WF25_BPCLCD25(x) (BME_UBFX8(HW_LCD_WF25_ADDR(x), BP_LCD_WF25_BPCLCD25, BS_LCD_WF25_BPCLCD25))

/*! @brief Format value for bitfield LCD_WF25_BPCLCD25. */
#define BF_LCD_WF25_BPCLCD25(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF25_BPCLCD25) & BM_LCD_WF25_BPCLCD25)

/*! @brief Set the BPCLCD25 field to a new value. */
#define BW_LCD_WF25_BPCLCD25(x, v) (BME_BFI8(HW_LCD_WF25_ADDR(x), ((uint8_t)(v) << BP_LCD_WF25_BPCLCD25), BP_LCD_WF25_BPCLCD25, 1))
/*@}*/

/*!
 * @name Register LCD_WF25, field BPDLCD25[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF25_BPDLCD25 (3U)          /*!< Bit position for LCD_WF25_BPDLCD25. */
#define BM_LCD_WF25_BPDLCD25 (0x08U)       /*!< Bit mask for LCD_WF25_BPDLCD25. */
#define BS_LCD_WF25_BPDLCD25 (1U)          /*!< Bit field size in bits for LCD_WF25_BPDLCD25. */

/*! @brief Read current value of the LCD_WF25_BPDLCD25 field. */
#define BR_LCD_WF25_BPDLCD25(x) (BME_UBFX8(HW_LCD_WF25_ADDR(x), BP_LCD_WF25_BPDLCD25, BS_LCD_WF25_BPDLCD25))

/*! @brief Format value for bitfield LCD_WF25_BPDLCD25. */
#define BF_LCD_WF25_BPDLCD25(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF25_BPDLCD25) & BM_LCD_WF25_BPDLCD25)

/*! @brief Set the BPDLCD25 field to a new value. */
#define BW_LCD_WF25_BPDLCD25(x, v) (BME_BFI8(HW_LCD_WF25_ADDR(x), ((uint8_t)(v) << BP_LCD_WF25_BPDLCD25), BP_LCD_WF25_BPDLCD25, 1))
/*@}*/

/*!
 * @name Register LCD_WF25, field BPELCD25[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF25_BPELCD25 (4U)          /*!< Bit position for LCD_WF25_BPELCD25. */
#define BM_LCD_WF25_BPELCD25 (0x10U)       /*!< Bit mask for LCD_WF25_BPELCD25. */
#define BS_LCD_WF25_BPELCD25 (1U)          /*!< Bit field size in bits for LCD_WF25_BPELCD25. */

/*! @brief Read current value of the LCD_WF25_BPELCD25 field. */
#define BR_LCD_WF25_BPELCD25(x) (BME_UBFX8(HW_LCD_WF25_ADDR(x), BP_LCD_WF25_BPELCD25, BS_LCD_WF25_BPELCD25))

/*! @brief Format value for bitfield LCD_WF25_BPELCD25. */
#define BF_LCD_WF25_BPELCD25(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF25_BPELCD25) & BM_LCD_WF25_BPELCD25)

/*! @brief Set the BPELCD25 field to a new value. */
#define BW_LCD_WF25_BPELCD25(x, v) (BME_BFI8(HW_LCD_WF25_ADDR(x), ((uint8_t)(v) << BP_LCD_WF25_BPELCD25), BP_LCD_WF25_BPELCD25, 1))
/*@}*/

/*!
 * @name Register LCD_WF25, field BPFLCD25[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF25_BPFLCD25 (5U)          /*!< Bit position for LCD_WF25_BPFLCD25. */
#define BM_LCD_WF25_BPFLCD25 (0x20U)       /*!< Bit mask for LCD_WF25_BPFLCD25. */
#define BS_LCD_WF25_BPFLCD25 (1U)          /*!< Bit field size in bits for LCD_WF25_BPFLCD25. */

/*! @brief Read current value of the LCD_WF25_BPFLCD25 field. */
#define BR_LCD_WF25_BPFLCD25(x) (BME_UBFX8(HW_LCD_WF25_ADDR(x), BP_LCD_WF25_BPFLCD25, BS_LCD_WF25_BPFLCD25))

/*! @brief Format value for bitfield LCD_WF25_BPFLCD25. */
#define BF_LCD_WF25_BPFLCD25(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF25_BPFLCD25) & BM_LCD_WF25_BPFLCD25)

/*! @brief Set the BPFLCD25 field to a new value. */
#define BW_LCD_WF25_BPFLCD25(x, v) (BME_BFI8(HW_LCD_WF25_ADDR(x), ((uint8_t)(v) << BP_LCD_WF25_BPFLCD25), BP_LCD_WF25_BPFLCD25, 1))
/*@}*/

/*!
 * @name Register LCD_WF25, field BPGLCD25[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF25_BPGLCD25 (6U)          /*!< Bit position for LCD_WF25_BPGLCD25. */
#define BM_LCD_WF25_BPGLCD25 (0x40U)       /*!< Bit mask for LCD_WF25_BPGLCD25. */
#define BS_LCD_WF25_BPGLCD25 (1U)          /*!< Bit field size in bits for LCD_WF25_BPGLCD25. */

/*! @brief Read current value of the LCD_WF25_BPGLCD25 field. */
#define BR_LCD_WF25_BPGLCD25(x) (BME_UBFX8(HW_LCD_WF25_ADDR(x), BP_LCD_WF25_BPGLCD25, BS_LCD_WF25_BPGLCD25))

/*! @brief Format value for bitfield LCD_WF25_BPGLCD25. */
#define BF_LCD_WF25_BPGLCD25(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF25_BPGLCD25) & BM_LCD_WF25_BPGLCD25)

/*! @brief Set the BPGLCD25 field to a new value. */
#define BW_LCD_WF25_BPGLCD25(x, v) (BME_BFI8(HW_LCD_WF25_ADDR(x), ((uint8_t)(v) << BP_LCD_WF25_BPGLCD25), BP_LCD_WF25_BPGLCD25, 1))
/*@}*/

/*!
 * @name Register LCD_WF25, field BPHLCD25[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF25_BPHLCD25 (7U)          /*!< Bit position for LCD_WF25_BPHLCD25. */
#define BM_LCD_WF25_BPHLCD25 (0x80U)       /*!< Bit mask for LCD_WF25_BPHLCD25. */
#define BS_LCD_WF25_BPHLCD25 (1U)          /*!< Bit field size in bits for LCD_WF25_BPHLCD25. */

/*! @brief Read current value of the LCD_WF25_BPHLCD25 field. */
#define BR_LCD_WF25_BPHLCD25(x) (BME_UBFX8(HW_LCD_WF25_ADDR(x), BP_LCD_WF25_BPHLCD25, BS_LCD_WF25_BPHLCD25))

/*! @brief Format value for bitfield LCD_WF25_BPHLCD25. */
#define BF_LCD_WF25_BPHLCD25(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF25_BPHLCD25) & BM_LCD_WF25_BPHLCD25)

/*! @brief Set the BPHLCD25 field to a new value. */
#define BW_LCD_WF25_BPHLCD25(x, v) (BME_BFI8(HW_LCD_WF25_ADDR(x), ((uint8_t)(v) << BP_LCD_WF25_BPHLCD25), BP_LCD_WF25_BPHLCD25, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF26 - LCD Waveform Register 26.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF26 - LCD Waveform Register 26. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf26
{
    uint8_t U;
    struct _hw_lcd_wf26_bitfields
    {
        uint8_t BPALCD26 : 1;          /*!< [0]  */
        uint8_t BPBLCD26 : 1;          /*!< [1]  */
        uint8_t BPCLCD26 : 1;          /*!< [2]  */
        uint8_t BPDLCD26 : 1;          /*!< [3]  */
        uint8_t BPELCD26 : 1;          /*!< [4]  */
        uint8_t BPFLCD26 : 1;          /*!< [5]  */
        uint8_t BPGLCD26 : 1;          /*!< [6]  */
        uint8_t BPHLCD26 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf26_t;

/*!
 * @name Constants and macros for entire LCD_WF26 register
 */
/*@{*/
#define HW_LCD_WF26_ADDR(x)      ((uint32_t)(x) + 0x3AU)

#define HW_LCD_WF26(x)           (*(__IO hw_lcd_wf26_t *) HW_LCD_WF26_ADDR(x))
#define HW_LCD_WF26_RD(x)        (HW_LCD_WF26(x).U)
#define HW_LCD_WF26_WR(x, v)     (HW_LCD_WF26(x).U = (v))
#define HW_LCD_WF26_SET(x, v)    (BME_OR8(HW_LCD_WF26_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF26_CLR(x, v)    (BME_AND8(HW_LCD_WF26_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF26_TOG(x, v)    (BME_XOR8(HW_LCD_WF26_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF26 bitfields
 */

/*!
 * @name Register LCD_WF26, field BPALCD26[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF26_BPALCD26 (0U)          /*!< Bit position for LCD_WF26_BPALCD26. */
#define BM_LCD_WF26_BPALCD26 (0x01U)       /*!< Bit mask for LCD_WF26_BPALCD26. */
#define BS_LCD_WF26_BPALCD26 (1U)          /*!< Bit field size in bits for LCD_WF26_BPALCD26. */

/*! @brief Read current value of the LCD_WF26_BPALCD26 field. */
#define BR_LCD_WF26_BPALCD26(x) (BME_UBFX8(HW_LCD_WF26_ADDR(x), BP_LCD_WF26_BPALCD26, BS_LCD_WF26_BPALCD26))

/*! @brief Format value for bitfield LCD_WF26_BPALCD26. */
#define BF_LCD_WF26_BPALCD26(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF26_BPALCD26) & BM_LCD_WF26_BPALCD26)

/*! @brief Set the BPALCD26 field to a new value. */
#define BW_LCD_WF26_BPALCD26(x, v) (BME_BFI8(HW_LCD_WF26_ADDR(x), ((uint8_t)(v) << BP_LCD_WF26_BPALCD26), BP_LCD_WF26_BPALCD26, 1))
/*@}*/

/*!
 * @name Register LCD_WF26, field BPBLCD26[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF26_BPBLCD26 (1U)          /*!< Bit position for LCD_WF26_BPBLCD26. */
#define BM_LCD_WF26_BPBLCD26 (0x02U)       /*!< Bit mask for LCD_WF26_BPBLCD26. */
#define BS_LCD_WF26_BPBLCD26 (1U)          /*!< Bit field size in bits for LCD_WF26_BPBLCD26. */

/*! @brief Read current value of the LCD_WF26_BPBLCD26 field. */
#define BR_LCD_WF26_BPBLCD26(x) (BME_UBFX8(HW_LCD_WF26_ADDR(x), BP_LCD_WF26_BPBLCD26, BS_LCD_WF26_BPBLCD26))

/*! @brief Format value for bitfield LCD_WF26_BPBLCD26. */
#define BF_LCD_WF26_BPBLCD26(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF26_BPBLCD26) & BM_LCD_WF26_BPBLCD26)

/*! @brief Set the BPBLCD26 field to a new value. */
#define BW_LCD_WF26_BPBLCD26(x, v) (BME_BFI8(HW_LCD_WF26_ADDR(x), ((uint8_t)(v) << BP_LCD_WF26_BPBLCD26), BP_LCD_WF26_BPBLCD26, 1))
/*@}*/

/*!
 * @name Register LCD_WF26, field BPCLCD26[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF26_BPCLCD26 (2U)          /*!< Bit position for LCD_WF26_BPCLCD26. */
#define BM_LCD_WF26_BPCLCD26 (0x04U)       /*!< Bit mask for LCD_WF26_BPCLCD26. */
#define BS_LCD_WF26_BPCLCD26 (1U)          /*!< Bit field size in bits for LCD_WF26_BPCLCD26. */

/*! @brief Read current value of the LCD_WF26_BPCLCD26 field. */
#define BR_LCD_WF26_BPCLCD26(x) (BME_UBFX8(HW_LCD_WF26_ADDR(x), BP_LCD_WF26_BPCLCD26, BS_LCD_WF26_BPCLCD26))

/*! @brief Format value for bitfield LCD_WF26_BPCLCD26. */
#define BF_LCD_WF26_BPCLCD26(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF26_BPCLCD26) & BM_LCD_WF26_BPCLCD26)

/*! @brief Set the BPCLCD26 field to a new value. */
#define BW_LCD_WF26_BPCLCD26(x, v) (BME_BFI8(HW_LCD_WF26_ADDR(x), ((uint8_t)(v) << BP_LCD_WF26_BPCLCD26), BP_LCD_WF26_BPCLCD26, 1))
/*@}*/

/*!
 * @name Register LCD_WF26, field BPDLCD26[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF26_BPDLCD26 (3U)          /*!< Bit position for LCD_WF26_BPDLCD26. */
#define BM_LCD_WF26_BPDLCD26 (0x08U)       /*!< Bit mask for LCD_WF26_BPDLCD26. */
#define BS_LCD_WF26_BPDLCD26 (1U)          /*!< Bit field size in bits for LCD_WF26_BPDLCD26. */

/*! @brief Read current value of the LCD_WF26_BPDLCD26 field. */
#define BR_LCD_WF26_BPDLCD26(x) (BME_UBFX8(HW_LCD_WF26_ADDR(x), BP_LCD_WF26_BPDLCD26, BS_LCD_WF26_BPDLCD26))

/*! @brief Format value for bitfield LCD_WF26_BPDLCD26. */
#define BF_LCD_WF26_BPDLCD26(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF26_BPDLCD26) & BM_LCD_WF26_BPDLCD26)

/*! @brief Set the BPDLCD26 field to a new value. */
#define BW_LCD_WF26_BPDLCD26(x, v) (BME_BFI8(HW_LCD_WF26_ADDR(x), ((uint8_t)(v) << BP_LCD_WF26_BPDLCD26), BP_LCD_WF26_BPDLCD26, 1))
/*@}*/

/*!
 * @name Register LCD_WF26, field BPELCD26[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF26_BPELCD26 (4U)          /*!< Bit position for LCD_WF26_BPELCD26. */
#define BM_LCD_WF26_BPELCD26 (0x10U)       /*!< Bit mask for LCD_WF26_BPELCD26. */
#define BS_LCD_WF26_BPELCD26 (1U)          /*!< Bit field size in bits for LCD_WF26_BPELCD26. */

/*! @brief Read current value of the LCD_WF26_BPELCD26 field. */
#define BR_LCD_WF26_BPELCD26(x) (BME_UBFX8(HW_LCD_WF26_ADDR(x), BP_LCD_WF26_BPELCD26, BS_LCD_WF26_BPELCD26))

/*! @brief Format value for bitfield LCD_WF26_BPELCD26. */
#define BF_LCD_WF26_BPELCD26(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF26_BPELCD26) & BM_LCD_WF26_BPELCD26)

/*! @brief Set the BPELCD26 field to a new value. */
#define BW_LCD_WF26_BPELCD26(x, v) (BME_BFI8(HW_LCD_WF26_ADDR(x), ((uint8_t)(v) << BP_LCD_WF26_BPELCD26), BP_LCD_WF26_BPELCD26, 1))
/*@}*/

/*!
 * @name Register LCD_WF26, field BPFLCD26[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF26_BPFLCD26 (5U)          /*!< Bit position for LCD_WF26_BPFLCD26. */
#define BM_LCD_WF26_BPFLCD26 (0x20U)       /*!< Bit mask for LCD_WF26_BPFLCD26. */
#define BS_LCD_WF26_BPFLCD26 (1U)          /*!< Bit field size in bits for LCD_WF26_BPFLCD26. */

/*! @brief Read current value of the LCD_WF26_BPFLCD26 field. */
#define BR_LCD_WF26_BPFLCD26(x) (BME_UBFX8(HW_LCD_WF26_ADDR(x), BP_LCD_WF26_BPFLCD26, BS_LCD_WF26_BPFLCD26))

/*! @brief Format value for bitfield LCD_WF26_BPFLCD26. */
#define BF_LCD_WF26_BPFLCD26(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF26_BPFLCD26) & BM_LCD_WF26_BPFLCD26)

/*! @brief Set the BPFLCD26 field to a new value. */
#define BW_LCD_WF26_BPFLCD26(x, v) (BME_BFI8(HW_LCD_WF26_ADDR(x), ((uint8_t)(v) << BP_LCD_WF26_BPFLCD26), BP_LCD_WF26_BPFLCD26, 1))
/*@}*/

/*!
 * @name Register LCD_WF26, field BPGLCD26[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF26_BPGLCD26 (6U)          /*!< Bit position for LCD_WF26_BPGLCD26. */
#define BM_LCD_WF26_BPGLCD26 (0x40U)       /*!< Bit mask for LCD_WF26_BPGLCD26. */
#define BS_LCD_WF26_BPGLCD26 (1U)          /*!< Bit field size in bits for LCD_WF26_BPGLCD26. */

/*! @brief Read current value of the LCD_WF26_BPGLCD26 field. */
#define BR_LCD_WF26_BPGLCD26(x) (BME_UBFX8(HW_LCD_WF26_ADDR(x), BP_LCD_WF26_BPGLCD26, BS_LCD_WF26_BPGLCD26))

/*! @brief Format value for bitfield LCD_WF26_BPGLCD26. */
#define BF_LCD_WF26_BPGLCD26(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF26_BPGLCD26) & BM_LCD_WF26_BPGLCD26)

/*! @brief Set the BPGLCD26 field to a new value. */
#define BW_LCD_WF26_BPGLCD26(x, v) (BME_BFI8(HW_LCD_WF26_ADDR(x), ((uint8_t)(v) << BP_LCD_WF26_BPGLCD26), BP_LCD_WF26_BPGLCD26, 1))
/*@}*/

/*!
 * @name Register LCD_WF26, field BPHLCD26[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF26_BPHLCD26 (7U)          /*!< Bit position for LCD_WF26_BPHLCD26. */
#define BM_LCD_WF26_BPHLCD26 (0x80U)       /*!< Bit mask for LCD_WF26_BPHLCD26. */
#define BS_LCD_WF26_BPHLCD26 (1U)          /*!< Bit field size in bits for LCD_WF26_BPHLCD26. */

/*! @brief Read current value of the LCD_WF26_BPHLCD26 field. */
#define BR_LCD_WF26_BPHLCD26(x) (BME_UBFX8(HW_LCD_WF26_ADDR(x), BP_LCD_WF26_BPHLCD26, BS_LCD_WF26_BPHLCD26))

/*! @brief Format value for bitfield LCD_WF26_BPHLCD26. */
#define BF_LCD_WF26_BPHLCD26(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF26_BPHLCD26) & BM_LCD_WF26_BPHLCD26)

/*! @brief Set the BPHLCD26 field to a new value. */
#define BW_LCD_WF26_BPHLCD26(x, v) (BME_BFI8(HW_LCD_WF26_ADDR(x), ((uint8_t)(v) << BP_LCD_WF26_BPHLCD26), BP_LCD_WF26_BPHLCD26, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF27 - LCD Waveform Register 27.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF27 - LCD Waveform Register 27. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf27
{
    uint8_t U;
    struct _hw_lcd_wf27_bitfields
    {
        uint8_t BPALCD27 : 1;          /*!< [0]  */
        uint8_t BPBLCD27 : 1;          /*!< [1]  */
        uint8_t BPCLCD27 : 1;          /*!< [2]  */
        uint8_t BPDLCD27 : 1;          /*!< [3]  */
        uint8_t BPELCD27 : 1;          /*!< [4]  */
        uint8_t BPFLCD27 : 1;          /*!< [5]  */
        uint8_t BPGLCD27 : 1;          /*!< [6]  */
        uint8_t BPHLCD27 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf27_t;

/*!
 * @name Constants and macros for entire LCD_WF27 register
 */
/*@{*/
#define HW_LCD_WF27_ADDR(x)      ((uint32_t)(x) + 0x3BU)

#define HW_LCD_WF27(x)           (*(__IO hw_lcd_wf27_t *) HW_LCD_WF27_ADDR(x))
#define HW_LCD_WF27_RD(x)        (HW_LCD_WF27(x).U)
#define HW_LCD_WF27_WR(x, v)     (HW_LCD_WF27(x).U = (v))
#define HW_LCD_WF27_SET(x, v)    (BME_OR8(HW_LCD_WF27_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF27_CLR(x, v)    (BME_AND8(HW_LCD_WF27_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF27_TOG(x, v)    (BME_XOR8(HW_LCD_WF27_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF27 bitfields
 */

/*!
 * @name Register LCD_WF27, field BPALCD27[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF27_BPALCD27 (0U)          /*!< Bit position for LCD_WF27_BPALCD27. */
#define BM_LCD_WF27_BPALCD27 (0x01U)       /*!< Bit mask for LCD_WF27_BPALCD27. */
#define BS_LCD_WF27_BPALCD27 (1U)          /*!< Bit field size in bits for LCD_WF27_BPALCD27. */

/*! @brief Read current value of the LCD_WF27_BPALCD27 field. */
#define BR_LCD_WF27_BPALCD27(x) (BME_UBFX8(HW_LCD_WF27_ADDR(x), BP_LCD_WF27_BPALCD27, BS_LCD_WF27_BPALCD27))

/*! @brief Format value for bitfield LCD_WF27_BPALCD27. */
#define BF_LCD_WF27_BPALCD27(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF27_BPALCD27) & BM_LCD_WF27_BPALCD27)

/*! @brief Set the BPALCD27 field to a new value. */
#define BW_LCD_WF27_BPALCD27(x, v) (BME_BFI8(HW_LCD_WF27_ADDR(x), ((uint8_t)(v) << BP_LCD_WF27_BPALCD27), BP_LCD_WF27_BPALCD27, 1))
/*@}*/

/*!
 * @name Register LCD_WF27, field BPBLCD27[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF27_BPBLCD27 (1U)          /*!< Bit position for LCD_WF27_BPBLCD27. */
#define BM_LCD_WF27_BPBLCD27 (0x02U)       /*!< Bit mask for LCD_WF27_BPBLCD27. */
#define BS_LCD_WF27_BPBLCD27 (1U)          /*!< Bit field size in bits for LCD_WF27_BPBLCD27. */

/*! @brief Read current value of the LCD_WF27_BPBLCD27 field. */
#define BR_LCD_WF27_BPBLCD27(x) (BME_UBFX8(HW_LCD_WF27_ADDR(x), BP_LCD_WF27_BPBLCD27, BS_LCD_WF27_BPBLCD27))

/*! @brief Format value for bitfield LCD_WF27_BPBLCD27. */
#define BF_LCD_WF27_BPBLCD27(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF27_BPBLCD27) & BM_LCD_WF27_BPBLCD27)

/*! @brief Set the BPBLCD27 field to a new value. */
#define BW_LCD_WF27_BPBLCD27(x, v) (BME_BFI8(HW_LCD_WF27_ADDR(x), ((uint8_t)(v) << BP_LCD_WF27_BPBLCD27), BP_LCD_WF27_BPBLCD27, 1))
/*@}*/

/*!
 * @name Register LCD_WF27, field BPCLCD27[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF27_BPCLCD27 (2U)          /*!< Bit position for LCD_WF27_BPCLCD27. */
#define BM_LCD_WF27_BPCLCD27 (0x04U)       /*!< Bit mask for LCD_WF27_BPCLCD27. */
#define BS_LCD_WF27_BPCLCD27 (1U)          /*!< Bit field size in bits for LCD_WF27_BPCLCD27. */

/*! @brief Read current value of the LCD_WF27_BPCLCD27 field. */
#define BR_LCD_WF27_BPCLCD27(x) (BME_UBFX8(HW_LCD_WF27_ADDR(x), BP_LCD_WF27_BPCLCD27, BS_LCD_WF27_BPCLCD27))

/*! @brief Format value for bitfield LCD_WF27_BPCLCD27. */
#define BF_LCD_WF27_BPCLCD27(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF27_BPCLCD27) & BM_LCD_WF27_BPCLCD27)

/*! @brief Set the BPCLCD27 field to a new value. */
#define BW_LCD_WF27_BPCLCD27(x, v) (BME_BFI8(HW_LCD_WF27_ADDR(x), ((uint8_t)(v) << BP_LCD_WF27_BPCLCD27), BP_LCD_WF27_BPCLCD27, 1))
/*@}*/

/*!
 * @name Register LCD_WF27, field BPDLCD27[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF27_BPDLCD27 (3U)          /*!< Bit position for LCD_WF27_BPDLCD27. */
#define BM_LCD_WF27_BPDLCD27 (0x08U)       /*!< Bit mask for LCD_WF27_BPDLCD27. */
#define BS_LCD_WF27_BPDLCD27 (1U)          /*!< Bit field size in bits for LCD_WF27_BPDLCD27. */

/*! @brief Read current value of the LCD_WF27_BPDLCD27 field. */
#define BR_LCD_WF27_BPDLCD27(x) (BME_UBFX8(HW_LCD_WF27_ADDR(x), BP_LCD_WF27_BPDLCD27, BS_LCD_WF27_BPDLCD27))

/*! @brief Format value for bitfield LCD_WF27_BPDLCD27. */
#define BF_LCD_WF27_BPDLCD27(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF27_BPDLCD27) & BM_LCD_WF27_BPDLCD27)

/*! @brief Set the BPDLCD27 field to a new value. */
#define BW_LCD_WF27_BPDLCD27(x, v) (BME_BFI8(HW_LCD_WF27_ADDR(x), ((uint8_t)(v) << BP_LCD_WF27_BPDLCD27), BP_LCD_WF27_BPDLCD27, 1))
/*@}*/

/*!
 * @name Register LCD_WF27, field BPELCD27[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF27_BPELCD27 (4U)          /*!< Bit position for LCD_WF27_BPELCD27. */
#define BM_LCD_WF27_BPELCD27 (0x10U)       /*!< Bit mask for LCD_WF27_BPELCD27. */
#define BS_LCD_WF27_BPELCD27 (1U)          /*!< Bit field size in bits for LCD_WF27_BPELCD27. */

/*! @brief Read current value of the LCD_WF27_BPELCD27 field. */
#define BR_LCD_WF27_BPELCD27(x) (BME_UBFX8(HW_LCD_WF27_ADDR(x), BP_LCD_WF27_BPELCD27, BS_LCD_WF27_BPELCD27))

/*! @brief Format value for bitfield LCD_WF27_BPELCD27. */
#define BF_LCD_WF27_BPELCD27(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF27_BPELCD27) & BM_LCD_WF27_BPELCD27)

/*! @brief Set the BPELCD27 field to a new value. */
#define BW_LCD_WF27_BPELCD27(x, v) (BME_BFI8(HW_LCD_WF27_ADDR(x), ((uint8_t)(v) << BP_LCD_WF27_BPELCD27), BP_LCD_WF27_BPELCD27, 1))
/*@}*/

/*!
 * @name Register LCD_WF27, field BPFLCD27[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF27_BPFLCD27 (5U)          /*!< Bit position for LCD_WF27_BPFLCD27. */
#define BM_LCD_WF27_BPFLCD27 (0x20U)       /*!< Bit mask for LCD_WF27_BPFLCD27. */
#define BS_LCD_WF27_BPFLCD27 (1U)          /*!< Bit field size in bits for LCD_WF27_BPFLCD27. */

/*! @brief Read current value of the LCD_WF27_BPFLCD27 field. */
#define BR_LCD_WF27_BPFLCD27(x) (BME_UBFX8(HW_LCD_WF27_ADDR(x), BP_LCD_WF27_BPFLCD27, BS_LCD_WF27_BPFLCD27))

/*! @brief Format value for bitfield LCD_WF27_BPFLCD27. */
#define BF_LCD_WF27_BPFLCD27(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF27_BPFLCD27) & BM_LCD_WF27_BPFLCD27)

/*! @brief Set the BPFLCD27 field to a new value. */
#define BW_LCD_WF27_BPFLCD27(x, v) (BME_BFI8(HW_LCD_WF27_ADDR(x), ((uint8_t)(v) << BP_LCD_WF27_BPFLCD27), BP_LCD_WF27_BPFLCD27, 1))
/*@}*/

/*!
 * @name Register LCD_WF27, field BPGLCD27[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF27_BPGLCD27 (6U)          /*!< Bit position for LCD_WF27_BPGLCD27. */
#define BM_LCD_WF27_BPGLCD27 (0x40U)       /*!< Bit mask for LCD_WF27_BPGLCD27. */
#define BS_LCD_WF27_BPGLCD27 (1U)          /*!< Bit field size in bits for LCD_WF27_BPGLCD27. */

/*! @brief Read current value of the LCD_WF27_BPGLCD27 field. */
#define BR_LCD_WF27_BPGLCD27(x) (BME_UBFX8(HW_LCD_WF27_ADDR(x), BP_LCD_WF27_BPGLCD27, BS_LCD_WF27_BPGLCD27))

/*! @brief Format value for bitfield LCD_WF27_BPGLCD27. */
#define BF_LCD_WF27_BPGLCD27(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF27_BPGLCD27) & BM_LCD_WF27_BPGLCD27)

/*! @brief Set the BPGLCD27 field to a new value. */
#define BW_LCD_WF27_BPGLCD27(x, v) (BME_BFI8(HW_LCD_WF27_ADDR(x), ((uint8_t)(v) << BP_LCD_WF27_BPGLCD27), BP_LCD_WF27_BPGLCD27, 1))
/*@}*/

/*!
 * @name Register LCD_WF27, field BPHLCD27[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF27_BPHLCD27 (7U)          /*!< Bit position for LCD_WF27_BPHLCD27. */
#define BM_LCD_WF27_BPHLCD27 (0x80U)       /*!< Bit mask for LCD_WF27_BPHLCD27. */
#define BS_LCD_WF27_BPHLCD27 (1U)          /*!< Bit field size in bits for LCD_WF27_BPHLCD27. */

/*! @brief Read current value of the LCD_WF27_BPHLCD27 field. */
#define BR_LCD_WF27_BPHLCD27(x) (BME_UBFX8(HW_LCD_WF27_ADDR(x), BP_LCD_WF27_BPHLCD27, BS_LCD_WF27_BPHLCD27))

/*! @brief Format value for bitfield LCD_WF27_BPHLCD27. */
#define BF_LCD_WF27_BPHLCD27(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF27_BPHLCD27) & BM_LCD_WF27_BPHLCD27)

/*! @brief Set the BPHLCD27 field to a new value. */
#define BW_LCD_WF27_BPHLCD27(x, v) (BME_BFI8(HW_LCD_WF27_ADDR(x), ((uint8_t)(v) << BP_LCD_WF27_BPHLCD27), BP_LCD_WF27_BPHLCD27, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF28 - LCD Waveform Register 28.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF28 - LCD Waveform Register 28. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf28
{
    uint8_t U;
    struct _hw_lcd_wf28_bitfields
    {
        uint8_t BPALCD28 : 1;          /*!< [0]  */
        uint8_t BPBLCD28 : 1;          /*!< [1]  */
        uint8_t BPCLCD28 : 1;          /*!< [2]  */
        uint8_t BPDLCD28 : 1;          /*!< [3]  */
        uint8_t BPELCD28 : 1;          /*!< [4]  */
        uint8_t BPFLCD28 : 1;          /*!< [5]  */
        uint8_t BPGLCD28 : 1;          /*!< [6]  */
        uint8_t BPHLCD28 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf28_t;

/*!
 * @name Constants and macros for entire LCD_WF28 register
 */
/*@{*/
#define HW_LCD_WF28_ADDR(x)      ((uint32_t)(x) + 0x3CU)

#define HW_LCD_WF28(x)           (*(__IO hw_lcd_wf28_t *) HW_LCD_WF28_ADDR(x))
#define HW_LCD_WF28_RD(x)        (HW_LCD_WF28(x).U)
#define HW_LCD_WF28_WR(x, v)     (HW_LCD_WF28(x).U = (v))
#define HW_LCD_WF28_SET(x, v)    (BME_OR8(HW_LCD_WF28_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF28_CLR(x, v)    (BME_AND8(HW_LCD_WF28_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF28_TOG(x, v)    (BME_XOR8(HW_LCD_WF28_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF28 bitfields
 */

/*!
 * @name Register LCD_WF28, field BPALCD28[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF28_BPALCD28 (0U)          /*!< Bit position for LCD_WF28_BPALCD28. */
#define BM_LCD_WF28_BPALCD28 (0x01U)       /*!< Bit mask for LCD_WF28_BPALCD28. */
#define BS_LCD_WF28_BPALCD28 (1U)          /*!< Bit field size in bits for LCD_WF28_BPALCD28. */

/*! @brief Read current value of the LCD_WF28_BPALCD28 field. */
#define BR_LCD_WF28_BPALCD28(x) (BME_UBFX8(HW_LCD_WF28_ADDR(x), BP_LCD_WF28_BPALCD28, BS_LCD_WF28_BPALCD28))

/*! @brief Format value for bitfield LCD_WF28_BPALCD28. */
#define BF_LCD_WF28_BPALCD28(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF28_BPALCD28) & BM_LCD_WF28_BPALCD28)

/*! @brief Set the BPALCD28 field to a new value. */
#define BW_LCD_WF28_BPALCD28(x, v) (BME_BFI8(HW_LCD_WF28_ADDR(x), ((uint8_t)(v) << BP_LCD_WF28_BPALCD28), BP_LCD_WF28_BPALCD28, 1))
/*@}*/

/*!
 * @name Register LCD_WF28, field BPBLCD28[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF28_BPBLCD28 (1U)          /*!< Bit position for LCD_WF28_BPBLCD28. */
#define BM_LCD_WF28_BPBLCD28 (0x02U)       /*!< Bit mask for LCD_WF28_BPBLCD28. */
#define BS_LCD_WF28_BPBLCD28 (1U)          /*!< Bit field size in bits for LCD_WF28_BPBLCD28. */

/*! @brief Read current value of the LCD_WF28_BPBLCD28 field. */
#define BR_LCD_WF28_BPBLCD28(x) (BME_UBFX8(HW_LCD_WF28_ADDR(x), BP_LCD_WF28_BPBLCD28, BS_LCD_WF28_BPBLCD28))

/*! @brief Format value for bitfield LCD_WF28_BPBLCD28. */
#define BF_LCD_WF28_BPBLCD28(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF28_BPBLCD28) & BM_LCD_WF28_BPBLCD28)

/*! @brief Set the BPBLCD28 field to a new value. */
#define BW_LCD_WF28_BPBLCD28(x, v) (BME_BFI8(HW_LCD_WF28_ADDR(x), ((uint8_t)(v) << BP_LCD_WF28_BPBLCD28), BP_LCD_WF28_BPBLCD28, 1))
/*@}*/

/*!
 * @name Register LCD_WF28, field BPCLCD28[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF28_BPCLCD28 (2U)          /*!< Bit position for LCD_WF28_BPCLCD28. */
#define BM_LCD_WF28_BPCLCD28 (0x04U)       /*!< Bit mask for LCD_WF28_BPCLCD28. */
#define BS_LCD_WF28_BPCLCD28 (1U)          /*!< Bit field size in bits for LCD_WF28_BPCLCD28. */

/*! @brief Read current value of the LCD_WF28_BPCLCD28 field. */
#define BR_LCD_WF28_BPCLCD28(x) (BME_UBFX8(HW_LCD_WF28_ADDR(x), BP_LCD_WF28_BPCLCD28, BS_LCD_WF28_BPCLCD28))

/*! @brief Format value for bitfield LCD_WF28_BPCLCD28. */
#define BF_LCD_WF28_BPCLCD28(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF28_BPCLCD28) & BM_LCD_WF28_BPCLCD28)

/*! @brief Set the BPCLCD28 field to a new value. */
#define BW_LCD_WF28_BPCLCD28(x, v) (BME_BFI8(HW_LCD_WF28_ADDR(x), ((uint8_t)(v) << BP_LCD_WF28_BPCLCD28), BP_LCD_WF28_BPCLCD28, 1))
/*@}*/

/*!
 * @name Register LCD_WF28, field BPDLCD28[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF28_BPDLCD28 (3U)          /*!< Bit position for LCD_WF28_BPDLCD28. */
#define BM_LCD_WF28_BPDLCD28 (0x08U)       /*!< Bit mask for LCD_WF28_BPDLCD28. */
#define BS_LCD_WF28_BPDLCD28 (1U)          /*!< Bit field size in bits for LCD_WF28_BPDLCD28. */

/*! @brief Read current value of the LCD_WF28_BPDLCD28 field. */
#define BR_LCD_WF28_BPDLCD28(x) (BME_UBFX8(HW_LCD_WF28_ADDR(x), BP_LCD_WF28_BPDLCD28, BS_LCD_WF28_BPDLCD28))

/*! @brief Format value for bitfield LCD_WF28_BPDLCD28. */
#define BF_LCD_WF28_BPDLCD28(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF28_BPDLCD28) & BM_LCD_WF28_BPDLCD28)

/*! @brief Set the BPDLCD28 field to a new value. */
#define BW_LCD_WF28_BPDLCD28(x, v) (BME_BFI8(HW_LCD_WF28_ADDR(x), ((uint8_t)(v) << BP_LCD_WF28_BPDLCD28), BP_LCD_WF28_BPDLCD28, 1))
/*@}*/

/*!
 * @name Register LCD_WF28, field BPELCD28[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF28_BPELCD28 (4U)          /*!< Bit position for LCD_WF28_BPELCD28. */
#define BM_LCD_WF28_BPELCD28 (0x10U)       /*!< Bit mask for LCD_WF28_BPELCD28. */
#define BS_LCD_WF28_BPELCD28 (1U)          /*!< Bit field size in bits for LCD_WF28_BPELCD28. */

/*! @brief Read current value of the LCD_WF28_BPELCD28 field. */
#define BR_LCD_WF28_BPELCD28(x) (BME_UBFX8(HW_LCD_WF28_ADDR(x), BP_LCD_WF28_BPELCD28, BS_LCD_WF28_BPELCD28))

/*! @brief Format value for bitfield LCD_WF28_BPELCD28. */
#define BF_LCD_WF28_BPELCD28(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF28_BPELCD28) & BM_LCD_WF28_BPELCD28)

/*! @brief Set the BPELCD28 field to a new value. */
#define BW_LCD_WF28_BPELCD28(x, v) (BME_BFI8(HW_LCD_WF28_ADDR(x), ((uint8_t)(v) << BP_LCD_WF28_BPELCD28), BP_LCD_WF28_BPELCD28, 1))
/*@}*/

/*!
 * @name Register LCD_WF28, field BPFLCD28[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF28_BPFLCD28 (5U)          /*!< Bit position for LCD_WF28_BPFLCD28. */
#define BM_LCD_WF28_BPFLCD28 (0x20U)       /*!< Bit mask for LCD_WF28_BPFLCD28. */
#define BS_LCD_WF28_BPFLCD28 (1U)          /*!< Bit field size in bits for LCD_WF28_BPFLCD28. */

/*! @brief Read current value of the LCD_WF28_BPFLCD28 field. */
#define BR_LCD_WF28_BPFLCD28(x) (BME_UBFX8(HW_LCD_WF28_ADDR(x), BP_LCD_WF28_BPFLCD28, BS_LCD_WF28_BPFLCD28))

/*! @brief Format value for bitfield LCD_WF28_BPFLCD28. */
#define BF_LCD_WF28_BPFLCD28(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF28_BPFLCD28) & BM_LCD_WF28_BPFLCD28)

/*! @brief Set the BPFLCD28 field to a new value. */
#define BW_LCD_WF28_BPFLCD28(x, v) (BME_BFI8(HW_LCD_WF28_ADDR(x), ((uint8_t)(v) << BP_LCD_WF28_BPFLCD28), BP_LCD_WF28_BPFLCD28, 1))
/*@}*/

/*!
 * @name Register LCD_WF28, field BPGLCD28[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF28_BPGLCD28 (6U)          /*!< Bit position for LCD_WF28_BPGLCD28. */
#define BM_LCD_WF28_BPGLCD28 (0x40U)       /*!< Bit mask for LCD_WF28_BPGLCD28. */
#define BS_LCD_WF28_BPGLCD28 (1U)          /*!< Bit field size in bits for LCD_WF28_BPGLCD28. */

/*! @brief Read current value of the LCD_WF28_BPGLCD28 field. */
#define BR_LCD_WF28_BPGLCD28(x) (BME_UBFX8(HW_LCD_WF28_ADDR(x), BP_LCD_WF28_BPGLCD28, BS_LCD_WF28_BPGLCD28))

/*! @brief Format value for bitfield LCD_WF28_BPGLCD28. */
#define BF_LCD_WF28_BPGLCD28(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF28_BPGLCD28) & BM_LCD_WF28_BPGLCD28)

/*! @brief Set the BPGLCD28 field to a new value. */
#define BW_LCD_WF28_BPGLCD28(x, v) (BME_BFI8(HW_LCD_WF28_ADDR(x), ((uint8_t)(v) << BP_LCD_WF28_BPGLCD28), BP_LCD_WF28_BPGLCD28, 1))
/*@}*/

/*!
 * @name Register LCD_WF28, field BPHLCD28[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF28_BPHLCD28 (7U)          /*!< Bit position for LCD_WF28_BPHLCD28. */
#define BM_LCD_WF28_BPHLCD28 (0x80U)       /*!< Bit mask for LCD_WF28_BPHLCD28. */
#define BS_LCD_WF28_BPHLCD28 (1U)          /*!< Bit field size in bits for LCD_WF28_BPHLCD28. */

/*! @brief Read current value of the LCD_WF28_BPHLCD28 field. */
#define BR_LCD_WF28_BPHLCD28(x) (BME_UBFX8(HW_LCD_WF28_ADDR(x), BP_LCD_WF28_BPHLCD28, BS_LCD_WF28_BPHLCD28))

/*! @brief Format value for bitfield LCD_WF28_BPHLCD28. */
#define BF_LCD_WF28_BPHLCD28(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF28_BPHLCD28) & BM_LCD_WF28_BPHLCD28)

/*! @brief Set the BPHLCD28 field to a new value. */
#define BW_LCD_WF28_BPHLCD28(x, v) (BME_BFI8(HW_LCD_WF28_ADDR(x), ((uint8_t)(v) << BP_LCD_WF28_BPHLCD28), BP_LCD_WF28_BPHLCD28, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF29 - LCD Waveform Register 29.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF29 - LCD Waveform Register 29. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf29
{
    uint8_t U;
    struct _hw_lcd_wf29_bitfields
    {
        uint8_t BPALCD29 : 1;          /*!< [0]  */
        uint8_t BPBLCD29 : 1;          /*!< [1]  */
        uint8_t BPCLCD29 : 1;          /*!< [2]  */
        uint8_t BPDLCD29 : 1;          /*!< [3]  */
        uint8_t BPELCD29 : 1;          /*!< [4]  */
        uint8_t BPFLCD29 : 1;          /*!< [5]  */
        uint8_t BPGLCD29 : 1;          /*!< [6]  */
        uint8_t BPHLCD29 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf29_t;

/*!
 * @name Constants and macros for entire LCD_WF29 register
 */
/*@{*/
#define HW_LCD_WF29_ADDR(x)      ((uint32_t)(x) + 0x3DU)

#define HW_LCD_WF29(x)           (*(__IO hw_lcd_wf29_t *) HW_LCD_WF29_ADDR(x))
#define HW_LCD_WF29_RD(x)        (HW_LCD_WF29(x).U)
#define HW_LCD_WF29_WR(x, v)     (HW_LCD_WF29(x).U = (v))
#define HW_LCD_WF29_SET(x, v)    (BME_OR8(HW_LCD_WF29_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF29_CLR(x, v)    (BME_AND8(HW_LCD_WF29_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF29_TOG(x, v)    (BME_XOR8(HW_LCD_WF29_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF29 bitfields
 */

/*!
 * @name Register LCD_WF29, field BPALCD29[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF29_BPALCD29 (0U)          /*!< Bit position for LCD_WF29_BPALCD29. */
#define BM_LCD_WF29_BPALCD29 (0x01U)       /*!< Bit mask for LCD_WF29_BPALCD29. */
#define BS_LCD_WF29_BPALCD29 (1U)          /*!< Bit field size in bits for LCD_WF29_BPALCD29. */

/*! @brief Read current value of the LCD_WF29_BPALCD29 field. */
#define BR_LCD_WF29_BPALCD29(x) (BME_UBFX8(HW_LCD_WF29_ADDR(x), BP_LCD_WF29_BPALCD29, BS_LCD_WF29_BPALCD29))

/*! @brief Format value for bitfield LCD_WF29_BPALCD29. */
#define BF_LCD_WF29_BPALCD29(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF29_BPALCD29) & BM_LCD_WF29_BPALCD29)

/*! @brief Set the BPALCD29 field to a new value. */
#define BW_LCD_WF29_BPALCD29(x, v) (BME_BFI8(HW_LCD_WF29_ADDR(x), ((uint8_t)(v) << BP_LCD_WF29_BPALCD29), BP_LCD_WF29_BPALCD29, 1))
/*@}*/

/*!
 * @name Register LCD_WF29, field BPBLCD29[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF29_BPBLCD29 (1U)          /*!< Bit position for LCD_WF29_BPBLCD29. */
#define BM_LCD_WF29_BPBLCD29 (0x02U)       /*!< Bit mask for LCD_WF29_BPBLCD29. */
#define BS_LCD_WF29_BPBLCD29 (1U)          /*!< Bit field size in bits for LCD_WF29_BPBLCD29. */

/*! @brief Read current value of the LCD_WF29_BPBLCD29 field. */
#define BR_LCD_WF29_BPBLCD29(x) (BME_UBFX8(HW_LCD_WF29_ADDR(x), BP_LCD_WF29_BPBLCD29, BS_LCD_WF29_BPBLCD29))

/*! @brief Format value for bitfield LCD_WF29_BPBLCD29. */
#define BF_LCD_WF29_BPBLCD29(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF29_BPBLCD29) & BM_LCD_WF29_BPBLCD29)

/*! @brief Set the BPBLCD29 field to a new value. */
#define BW_LCD_WF29_BPBLCD29(x, v) (BME_BFI8(HW_LCD_WF29_ADDR(x), ((uint8_t)(v) << BP_LCD_WF29_BPBLCD29), BP_LCD_WF29_BPBLCD29, 1))
/*@}*/

/*!
 * @name Register LCD_WF29, field BPCLCD29[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF29_BPCLCD29 (2U)          /*!< Bit position for LCD_WF29_BPCLCD29. */
#define BM_LCD_WF29_BPCLCD29 (0x04U)       /*!< Bit mask for LCD_WF29_BPCLCD29. */
#define BS_LCD_WF29_BPCLCD29 (1U)          /*!< Bit field size in bits for LCD_WF29_BPCLCD29. */

/*! @brief Read current value of the LCD_WF29_BPCLCD29 field. */
#define BR_LCD_WF29_BPCLCD29(x) (BME_UBFX8(HW_LCD_WF29_ADDR(x), BP_LCD_WF29_BPCLCD29, BS_LCD_WF29_BPCLCD29))

/*! @brief Format value for bitfield LCD_WF29_BPCLCD29. */
#define BF_LCD_WF29_BPCLCD29(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF29_BPCLCD29) & BM_LCD_WF29_BPCLCD29)

/*! @brief Set the BPCLCD29 field to a new value. */
#define BW_LCD_WF29_BPCLCD29(x, v) (BME_BFI8(HW_LCD_WF29_ADDR(x), ((uint8_t)(v) << BP_LCD_WF29_BPCLCD29), BP_LCD_WF29_BPCLCD29, 1))
/*@}*/

/*!
 * @name Register LCD_WF29, field BPDLCD29[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF29_BPDLCD29 (3U)          /*!< Bit position for LCD_WF29_BPDLCD29. */
#define BM_LCD_WF29_BPDLCD29 (0x08U)       /*!< Bit mask for LCD_WF29_BPDLCD29. */
#define BS_LCD_WF29_BPDLCD29 (1U)          /*!< Bit field size in bits for LCD_WF29_BPDLCD29. */

/*! @brief Read current value of the LCD_WF29_BPDLCD29 field. */
#define BR_LCD_WF29_BPDLCD29(x) (BME_UBFX8(HW_LCD_WF29_ADDR(x), BP_LCD_WF29_BPDLCD29, BS_LCD_WF29_BPDLCD29))

/*! @brief Format value for bitfield LCD_WF29_BPDLCD29. */
#define BF_LCD_WF29_BPDLCD29(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF29_BPDLCD29) & BM_LCD_WF29_BPDLCD29)

/*! @brief Set the BPDLCD29 field to a new value. */
#define BW_LCD_WF29_BPDLCD29(x, v) (BME_BFI8(HW_LCD_WF29_ADDR(x), ((uint8_t)(v) << BP_LCD_WF29_BPDLCD29), BP_LCD_WF29_BPDLCD29, 1))
/*@}*/

/*!
 * @name Register LCD_WF29, field BPELCD29[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF29_BPELCD29 (4U)          /*!< Bit position for LCD_WF29_BPELCD29. */
#define BM_LCD_WF29_BPELCD29 (0x10U)       /*!< Bit mask for LCD_WF29_BPELCD29. */
#define BS_LCD_WF29_BPELCD29 (1U)          /*!< Bit field size in bits for LCD_WF29_BPELCD29. */

/*! @brief Read current value of the LCD_WF29_BPELCD29 field. */
#define BR_LCD_WF29_BPELCD29(x) (BME_UBFX8(HW_LCD_WF29_ADDR(x), BP_LCD_WF29_BPELCD29, BS_LCD_WF29_BPELCD29))

/*! @brief Format value for bitfield LCD_WF29_BPELCD29. */
#define BF_LCD_WF29_BPELCD29(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF29_BPELCD29) & BM_LCD_WF29_BPELCD29)

/*! @brief Set the BPELCD29 field to a new value. */
#define BW_LCD_WF29_BPELCD29(x, v) (BME_BFI8(HW_LCD_WF29_ADDR(x), ((uint8_t)(v) << BP_LCD_WF29_BPELCD29), BP_LCD_WF29_BPELCD29, 1))
/*@}*/

/*!
 * @name Register LCD_WF29, field BPFLCD29[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF29_BPFLCD29 (5U)          /*!< Bit position for LCD_WF29_BPFLCD29. */
#define BM_LCD_WF29_BPFLCD29 (0x20U)       /*!< Bit mask for LCD_WF29_BPFLCD29. */
#define BS_LCD_WF29_BPFLCD29 (1U)          /*!< Bit field size in bits for LCD_WF29_BPFLCD29. */

/*! @brief Read current value of the LCD_WF29_BPFLCD29 field. */
#define BR_LCD_WF29_BPFLCD29(x) (BME_UBFX8(HW_LCD_WF29_ADDR(x), BP_LCD_WF29_BPFLCD29, BS_LCD_WF29_BPFLCD29))

/*! @brief Format value for bitfield LCD_WF29_BPFLCD29. */
#define BF_LCD_WF29_BPFLCD29(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF29_BPFLCD29) & BM_LCD_WF29_BPFLCD29)

/*! @brief Set the BPFLCD29 field to a new value. */
#define BW_LCD_WF29_BPFLCD29(x, v) (BME_BFI8(HW_LCD_WF29_ADDR(x), ((uint8_t)(v) << BP_LCD_WF29_BPFLCD29), BP_LCD_WF29_BPFLCD29, 1))
/*@}*/

/*!
 * @name Register LCD_WF29, field BPGLCD29[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF29_BPGLCD29 (6U)          /*!< Bit position for LCD_WF29_BPGLCD29. */
#define BM_LCD_WF29_BPGLCD29 (0x40U)       /*!< Bit mask for LCD_WF29_BPGLCD29. */
#define BS_LCD_WF29_BPGLCD29 (1U)          /*!< Bit field size in bits for LCD_WF29_BPGLCD29. */

/*! @brief Read current value of the LCD_WF29_BPGLCD29 field. */
#define BR_LCD_WF29_BPGLCD29(x) (BME_UBFX8(HW_LCD_WF29_ADDR(x), BP_LCD_WF29_BPGLCD29, BS_LCD_WF29_BPGLCD29))

/*! @brief Format value for bitfield LCD_WF29_BPGLCD29. */
#define BF_LCD_WF29_BPGLCD29(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF29_BPGLCD29) & BM_LCD_WF29_BPGLCD29)

/*! @brief Set the BPGLCD29 field to a new value. */
#define BW_LCD_WF29_BPGLCD29(x, v) (BME_BFI8(HW_LCD_WF29_ADDR(x), ((uint8_t)(v) << BP_LCD_WF29_BPGLCD29), BP_LCD_WF29_BPGLCD29, 1))
/*@}*/

/*!
 * @name Register LCD_WF29, field BPHLCD29[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF29_BPHLCD29 (7U)          /*!< Bit position for LCD_WF29_BPHLCD29. */
#define BM_LCD_WF29_BPHLCD29 (0x80U)       /*!< Bit mask for LCD_WF29_BPHLCD29. */
#define BS_LCD_WF29_BPHLCD29 (1U)          /*!< Bit field size in bits for LCD_WF29_BPHLCD29. */

/*! @brief Read current value of the LCD_WF29_BPHLCD29 field. */
#define BR_LCD_WF29_BPHLCD29(x) (BME_UBFX8(HW_LCD_WF29_ADDR(x), BP_LCD_WF29_BPHLCD29, BS_LCD_WF29_BPHLCD29))

/*! @brief Format value for bitfield LCD_WF29_BPHLCD29. */
#define BF_LCD_WF29_BPHLCD29(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF29_BPHLCD29) & BM_LCD_WF29_BPHLCD29)

/*! @brief Set the BPHLCD29 field to a new value. */
#define BW_LCD_WF29_BPHLCD29(x, v) (BME_BFI8(HW_LCD_WF29_ADDR(x), ((uint8_t)(v) << BP_LCD_WF29_BPHLCD29), BP_LCD_WF29_BPHLCD29, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF30 - LCD Waveform Register 30.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF30 - LCD Waveform Register 30. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf30
{
    uint8_t U;
    struct _hw_lcd_wf30_bitfields
    {
        uint8_t BPALCD30 : 1;          /*!< [0]  */
        uint8_t BPBLCD30 : 1;          /*!< [1]  */
        uint8_t BPCLCD30 : 1;          /*!< [2]  */
        uint8_t BPDLCD30 : 1;          /*!< [3]  */
        uint8_t BPELCD30 : 1;          /*!< [4]  */
        uint8_t BPFLCD30 : 1;          /*!< [5]  */
        uint8_t BPGLCD30 : 1;          /*!< [6]  */
        uint8_t BPHLCD30 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf30_t;

/*!
 * @name Constants and macros for entire LCD_WF30 register
 */
/*@{*/
#define HW_LCD_WF30_ADDR(x)      ((uint32_t)(x) + 0x3EU)

#define HW_LCD_WF30(x)           (*(__IO hw_lcd_wf30_t *) HW_LCD_WF30_ADDR(x))
#define HW_LCD_WF30_RD(x)        (HW_LCD_WF30(x).U)
#define HW_LCD_WF30_WR(x, v)     (HW_LCD_WF30(x).U = (v))
#define HW_LCD_WF30_SET(x, v)    (BME_OR8(HW_LCD_WF30_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF30_CLR(x, v)    (BME_AND8(HW_LCD_WF30_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF30_TOG(x, v)    (BME_XOR8(HW_LCD_WF30_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF30 bitfields
 */

/*!
 * @name Register LCD_WF30, field BPALCD30[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF30_BPALCD30 (0U)          /*!< Bit position for LCD_WF30_BPALCD30. */
#define BM_LCD_WF30_BPALCD30 (0x01U)       /*!< Bit mask for LCD_WF30_BPALCD30. */
#define BS_LCD_WF30_BPALCD30 (1U)          /*!< Bit field size in bits for LCD_WF30_BPALCD30. */

/*! @brief Read current value of the LCD_WF30_BPALCD30 field. */
#define BR_LCD_WF30_BPALCD30(x) (BME_UBFX8(HW_LCD_WF30_ADDR(x), BP_LCD_WF30_BPALCD30, BS_LCD_WF30_BPALCD30))

/*! @brief Format value for bitfield LCD_WF30_BPALCD30. */
#define BF_LCD_WF30_BPALCD30(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF30_BPALCD30) & BM_LCD_WF30_BPALCD30)

/*! @brief Set the BPALCD30 field to a new value. */
#define BW_LCD_WF30_BPALCD30(x, v) (BME_BFI8(HW_LCD_WF30_ADDR(x), ((uint8_t)(v) << BP_LCD_WF30_BPALCD30), BP_LCD_WF30_BPALCD30, 1))
/*@}*/

/*!
 * @name Register LCD_WF30, field BPBLCD30[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF30_BPBLCD30 (1U)          /*!< Bit position for LCD_WF30_BPBLCD30. */
#define BM_LCD_WF30_BPBLCD30 (0x02U)       /*!< Bit mask for LCD_WF30_BPBLCD30. */
#define BS_LCD_WF30_BPBLCD30 (1U)          /*!< Bit field size in bits for LCD_WF30_BPBLCD30. */

/*! @brief Read current value of the LCD_WF30_BPBLCD30 field. */
#define BR_LCD_WF30_BPBLCD30(x) (BME_UBFX8(HW_LCD_WF30_ADDR(x), BP_LCD_WF30_BPBLCD30, BS_LCD_WF30_BPBLCD30))

/*! @brief Format value for bitfield LCD_WF30_BPBLCD30. */
#define BF_LCD_WF30_BPBLCD30(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF30_BPBLCD30) & BM_LCD_WF30_BPBLCD30)

/*! @brief Set the BPBLCD30 field to a new value. */
#define BW_LCD_WF30_BPBLCD30(x, v) (BME_BFI8(HW_LCD_WF30_ADDR(x), ((uint8_t)(v) << BP_LCD_WF30_BPBLCD30), BP_LCD_WF30_BPBLCD30, 1))
/*@}*/

/*!
 * @name Register LCD_WF30, field BPCLCD30[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF30_BPCLCD30 (2U)          /*!< Bit position for LCD_WF30_BPCLCD30. */
#define BM_LCD_WF30_BPCLCD30 (0x04U)       /*!< Bit mask for LCD_WF30_BPCLCD30. */
#define BS_LCD_WF30_BPCLCD30 (1U)          /*!< Bit field size in bits for LCD_WF30_BPCLCD30. */

/*! @brief Read current value of the LCD_WF30_BPCLCD30 field. */
#define BR_LCD_WF30_BPCLCD30(x) (BME_UBFX8(HW_LCD_WF30_ADDR(x), BP_LCD_WF30_BPCLCD30, BS_LCD_WF30_BPCLCD30))

/*! @brief Format value for bitfield LCD_WF30_BPCLCD30. */
#define BF_LCD_WF30_BPCLCD30(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF30_BPCLCD30) & BM_LCD_WF30_BPCLCD30)

/*! @brief Set the BPCLCD30 field to a new value. */
#define BW_LCD_WF30_BPCLCD30(x, v) (BME_BFI8(HW_LCD_WF30_ADDR(x), ((uint8_t)(v) << BP_LCD_WF30_BPCLCD30), BP_LCD_WF30_BPCLCD30, 1))
/*@}*/

/*!
 * @name Register LCD_WF30, field BPDLCD30[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF30_BPDLCD30 (3U)          /*!< Bit position for LCD_WF30_BPDLCD30. */
#define BM_LCD_WF30_BPDLCD30 (0x08U)       /*!< Bit mask for LCD_WF30_BPDLCD30. */
#define BS_LCD_WF30_BPDLCD30 (1U)          /*!< Bit field size in bits for LCD_WF30_BPDLCD30. */

/*! @brief Read current value of the LCD_WF30_BPDLCD30 field. */
#define BR_LCD_WF30_BPDLCD30(x) (BME_UBFX8(HW_LCD_WF30_ADDR(x), BP_LCD_WF30_BPDLCD30, BS_LCD_WF30_BPDLCD30))

/*! @brief Format value for bitfield LCD_WF30_BPDLCD30. */
#define BF_LCD_WF30_BPDLCD30(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF30_BPDLCD30) & BM_LCD_WF30_BPDLCD30)

/*! @brief Set the BPDLCD30 field to a new value. */
#define BW_LCD_WF30_BPDLCD30(x, v) (BME_BFI8(HW_LCD_WF30_ADDR(x), ((uint8_t)(v) << BP_LCD_WF30_BPDLCD30), BP_LCD_WF30_BPDLCD30, 1))
/*@}*/

/*!
 * @name Register LCD_WF30, field BPELCD30[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF30_BPELCD30 (4U)          /*!< Bit position for LCD_WF30_BPELCD30. */
#define BM_LCD_WF30_BPELCD30 (0x10U)       /*!< Bit mask for LCD_WF30_BPELCD30. */
#define BS_LCD_WF30_BPELCD30 (1U)          /*!< Bit field size in bits for LCD_WF30_BPELCD30. */

/*! @brief Read current value of the LCD_WF30_BPELCD30 field. */
#define BR_LCD_WF30_BPELCD30(x) (BME_UBFX8(HW_LCD_WF30_ADDR(x), BP_LCD_WF30_BPELCD30, BS_LCD_WF30_BPELCD30))

/*! @brief Format value for bitfield LCD_WF30_BPELCD30. */
#define BF_LCD_WF30_BPELCD30(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF30_BPELCD30) & BM_LCD_WF30_BPELCD30)

/*! @brief Set the BPELCD30 field to a new value. */
#define BW_LCD_WF30_BPELCD30(x, v) (BME_BFI8(HW_LCD_WF30_ADDR(x), ((uint8_t)(v) << BP_LCD_WF30_BPELCD30), BP_LCD_WF30_BPELCD30, 1))
/*@}*/

/*!
 * @name Register LCD_WF30, field BPFLCD30[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF30_BPFLCD30 (5U)          /*!< Bit position for LCD_WF30_BPFLCD30. */
#define BM_LCD_WF30_BPFLCD30 (0x20U)       /*!< Bit mask for LCD_WF30_BPFLCD30. */
#define BS_LCD_WF30_BPFLCD30 (1U)          /*!< Bit field size in bits for LCD_WF30_BPFLCD30. */

/*! @brief Read current value of the LCD_WF30_BPFLCD30 field. */
#define BR_LCD_WF30_BPFLCD30(x) (BME_UBFX8(HW_LCD_WF30_ADDR(x), BP_LCD_WF30_BPFLCD30, BS_LCD_WF30_BPFLCD30))

/*! @brief Format value for bitfield LCD_WF30_BPFLCD30. */
#define BF_LCD_WF30_BPFLCD30(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF30_BPFLCD30) & BM_LCD_WF30_BPFLCD30)

/*! @brief Set the BPFLCD30 field to a new value. */
#define BW_LCD_WF30_BPFLCD30(x, v) (BME_BFI8(HW_LCD_WF30_ADDR(x), ((uint8_t)(v) << BP_LCD_WF30_BPFLCD30), BP_LCD_WF30_BPFLCD30, 1))
/*@}*/

/*!
 * @name Register LCD_WF30, field BPGLCD30[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF30_BPGLCD30 (6U)          /*!< Bit position for LCD_WF30_BPGLCD30. */
#define BM_LCD_WF30_BPGLCD30 (0x40U)       /*!< Bit mask for LCD_WF30_BPGLCD30. */
#define BS_LCD_WF30_BPGLCD30 (1U)          /*!< Bit field size in bits for LCD_WF30_BPGLCD30. */

/*! @brief Read current value of the LCD_WF30_BPGLCD30 field. */
#define BR_LCD_WF30_BPGLCD30(x) (BME_UBFX8(HW_LCD_WF30_ADDR(x), BP_LCD_WF30_BPGLCD30, BS_LCD_WF30_BPGLCD30))

/*! @brief Format value for bitfield LCD_WF30_BPGLCD30. */
#define BF_LCD_WF30_BPGLCD30(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF30_BPGLCD30) & BM_LCD_WF30_BPGLCD30)

/*! @brief Set the BPGLCD30 field to a new value. */
#define BW_LCD_WF30_BPGLCD30(x, v) (BME_BFI8(HW_LCD_WF30_ADDR(x), ((uint8_t)(v) << BP_LCD_WF30_BPGLCD30), BP_LCD_WF30_BPGLCD30, 1))
/*@}*/

/*!
 * @name Register LCD_WF30, field BPHLCD30[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF30_BPHLCD30 (7U)          /*!< Bit position for LCD_WF30_BPHLCD30. */
#define BM_LCD_WF30_BPHLCD30 (0x80U)       /*!< Bit mask for LCD_WF30_BPHLCD30. */
#define BS_LCD_WF30_BPHLCD30 (1U)          /*!< Bit field size in bits for LCD_WF30_BPHLCD30. */

/*! @brief Read current value of the LCD_WF30_BPHLCD30 field. */
#define BR_LCD_WF30_BPHLCD30(x) (BME_UBFX8(HW_LCD_WF30_ADDR(x), BP_LCD_WF30_BPHLCD30, BS_LCD_WF30_BPHLCD30))

/*! @brief Format value for bitfield LCD_WF30_BPHLCD30. */
#define BF_LCD_WF30_BPHLCD30(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF30_BPHLCD30) & BM_LCD_WF30_BPHLCD30)

/*! @brief Set the BPHLCD30 field to a new value. */
#define BW_LCD_WF30_BPHLCD30(x, v) (BME_BFI8(HW_LCD_WF30_ADDR(x), ((uint8_t)(v) << BP_LCD_WF30_BPHLCD30), BP_LCD_WF30_BPHLCD30, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF31 - LCD Waveform Register 31.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF31 - LCD Waveform Register 31. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf31
{
    uint8_t U;
    struct _hw_lcd_wf31_bitfields
    {
        uint8_t BPALCD31 : 1;          /*!< [0]  */
        uint8_t BPBLCD31 : 1;          /*!< [1]  */
        uint8_t BPCLCD31 : 1;          /*!< [2]  */
        uint8_t BPDLCD31 : 1;          /*!< [3]  */
        uint8_t BPELCD31 : 1;          /*!< [4]  */
        uint8_t BPFLCD31 : 1;          /*!< [5]  */
        uint8_t BPGLCD31 : 1;          /*!< [6]  */
        uint8_t BPHLCD31 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf31_t;

/*!
 * @name Constants and macros for entire LCD_WF31 register
 */
/*@{*/
#define HW_LCD_WF31_ADDR(x)      ((uint32_t)(x) + 0x3FU)

#define HW_LCD_WF31(x)           (*(__IO hw_lcd_wf31_t *) HW_LCD_WF31_ADDR(x))
#define HW_LCD_WF31_RD(x)        (HW_LCD_WF31(x).U)
#define HW_LCD_WF31_WR(x, v)     (HW_LCD_WF31(x).U = (v))
#define HW_LCD_WF31_SET(x, v)    (BME_OR8(HW_LCD_WF31_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF31_CLR(x, v)    (BME_AND8(HW_LCD_WF31_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF31_TOG(x, v)    (BME_XOR8(HW_LCD_WF31_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF31 bitfields
 */

/*!
 * @name Register LCD_WF31, field BPALCD31[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF31_BPALCD31 (0U)          /*!< Bit position for LCD_WF31_BPALCD31. */
#define BM_LCD_WF31_BPALCD31 (0x01U)       /*!< Bit mask for LCD_WF31_BPALCD31. */
#define BS_LCD_WF31_BPALCD31 (1U)          /*!< Bit field size in bits for LCD_WF31_BPALCD31. */

/*! @brief Read current value of the LCD_WF31_BPALCD31 field. */
#define BR_LCD_WF31_BPALCD31(x) (BME_UBFX8(HW_LCD_WF31_ADDR(x), BP_LCD_WF31_BPALCD31, BS_LCD_WF31_BPALCD31))

/*! @brief Format value for bitfield LCD_WF31_BPALCD31. */
#define BF_LCD_WF31_BPALCD31(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF31_BPALCD31) & BM_LCD_WF31_BPALCD31)

/*! @brief Set the BPALCD31 field to a new value. */
#define BW_LCD_WF31_BPALCD31(x, v) (BME_BFI8(HW_LCD_WF31_ADDR(x), ((uint8_t)(v) << BP_LCD_WF31_BPALCD31), BP_LCD_WF31_BPALCD31, 1))
/*@}*/

/*!
 * @name Register LCD_WF31, field BPBLCD31[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF31_BPBLCD31 (1U)          /*!< Bit position for LCD_WF31_BPBLCD31. */
#define BM_LCD_WF31_BPBLCD31 (0x02U)       /*!< Bit mask for LCD_WF31_BPBLCD31. */
#define BS_LCD_WF31_BPBLCD31 (1U)          /*!< Bit field size in bits for LCD_WF31_BPBLCD31. */

/*! @brief Read current value of the LCD_WF31_BPBLCD31 field. */
#define BR_LCD_WF31_BPBLCD31(x) (BME_UBFX8(HW_LCD_WF31_ADDR(x), BP_LCD_WF31_BPBLCD31, BS_LCD_WF31_BPBLCD31))

/*! @brief Format value for bitfield LCD_WF31_BPBLCD31. */
#define BF_LCD_WF31_BPBLCD31(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF31_BPBLCD31) & BM_LCD_WF31_BPBLCD31)

/*! @brief Set the BPBLCD31 field to a new value. */
#define BW_LCD_WF31_BPBLCD31(x, v) (BME_BFI8(HW_LCD_WF31_ADDR(x), ((uint8_t)(v) << BP_LCD_WF31_BPBLCD31), BP_LCD_WF31_BPBLCD31, 1))
/*@}*/

/*!
 * @name Register LCD_WF31, field BPCLCD31[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF31_BPCLCD31 (2U)          /*!< Bit position for LCD_WF31_BPCLCD31. */
#define BM_LCD_WF31_BPCLCD31 (0x04U)       /*!< Bit mask for LCD_WF31_BPCLCD31. */
#define BS_LCD_WF31_BPCLCD31 (1U)          /*!< Bit field size in bits for LCD_WF31_BPCLCD31. */

/*! @brief Read current value of the LCD_WF31_BPCLCD31 field. */
#define BR_LCD_WF31_BPCLCD31(x) (BME_UBFX8(HW_LCD_WF31_ADDR(x), BP_LCD_WF31_BPCLCD31, BS_LCD_WF31_BPCLCD31))

/*! @brief Format value for bitfield LCD_WF31_BPCLCD31. */
#define BF_LCD_WF31_BPCLCD31(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF31_BPCLCD31) & BM_LCD_WF31_BPCLCD31)

/*! @brief Set the BPCLCD31 field to a new value. */
#define BW_LCD_WF31_BPCLCD31(x, v) (BME_BFI8(HW_LCD_WF31_ADDR(x), ((uint8_t)(v) << BP_LCD_WF31_BPCLCD31), BP_LCD_WF31_BPCLCD31, 1))
/*@}*/

/*!
 * @name Register LCD_WF31, field BPDLCD31[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF31_BPDLCD31 (3U)          /*!< Bit position for LCD_WF31_BPDLCD31. */
#define BM_LCD_WF31_BPDLCD31 (0x08U)       /*!< Bit mask for LCD_WF31_BPDLCD31. */
#define BS_LCD_WF31_BPDLCD31 (1U)          /*!< Bit field size in bits for LCD_WF31_BPDLCD31. */

/*! @brief Read current value of the LCD_WF31_BPDLCD31 field. */
#define BR_LCD_WF31_BPDLCD31(x) (BME_UBFX8(HW_LCD_WF31_ADDR(x), BP_LCD_WF31_BPDLCD31, BS_LCD_WF31_BPDLCD31))

/*! @brief Format value for bitfield LCD_WF31_BPDLCD31. */
#define BF_LCD_WF31_BPDLCD31(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF31_BPDLCD31) & BM_LCD_WF31_BPDLCD31)

/*! @brief Set the BPDLCD31 field to a new value. */
#define BW_LCD_WF31_BPDLCD31(x, v) (BME_BFI8(HW_LCD_WF31_ADDR(x), ((uint8_t)(v) << BP_LCD_WF31_BPDLCD31), BP_LCD_WF31_BPDLCD31, 1))
/*@}*/

/*!
 * @name Register LCD_WF31, field BPELCD31[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF31_BPELCD31 (4U)          /*!< Bit position for LCD_WF31_BPELCD31. */
#define BM_LCD_WF31_BPELCD31 (0x10U)       /*!< Bit mask for LCD_WF31_BPELCD31. */
#define BS_LCD_WF31_BPELCD31 (1U)          /*!< Bit field size in bits for LCD_WF31_BPELCD31. */

/*! @brief Read current value of the LCD_WF31_BPELCD31 field. */
#define BR_LCD_WF31_BPELCD31(x) (BME_UBFX8(HW_LCD_WF31_ADDR(x), BP_LCD_WF31_BPELCD31, BS_LCD_WF31_BPELCD31))

/*! @brief Format value for bitfield LCD_WF31_BPELCD31. */
#define BF_LCD_WF31_BPELCD31(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF31_BPELCD31) & BM_LCD_WF31_BPELCD31)

/*! @brief Set the BPELCD31 field to a new value. */
#define BW_LCD_WF31_BPELCD31(x, v) (BME_BFI8(HW_LCD_WF31_ADDR(x), ((uint8_t)(v) << BP_LCD_WF31_BPELCD31), BP_LCD_WF31_BPELCD31, 1))
/*@}*/

/*!
 * @name Register LCD_WF31, field BPFLCD31[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF31_BPFLCD31 (5U)          /*!< Bit position for LCD_WF31_BPFLCD31. */
#define BM_LCD_WF31_BPFLCD31 (0x20U)       /*!< Bit mask for LCD_WF31_BPFLCD31. */
#define BS_LCD_WF31_BPFLCD31 (1U)          /*!< Bit field size in bits for LCD_WF31_BPFLCD31. */

/*! @brief Read current value of the LCD_WF31_BPFLCD31 field. */
#define BR_LCD_WF31_BPFLCD31(x) (BME_UBFX8(HW_LCD_WF31_ADDR(x), BP_LCD_WF31_BPFLCD31, BS_LCD_WF31_BPFLCD31))

/*! @brief Format value for bitfield LCD_WF31_BPFLCD31. */
#define BF_LCD_WF31_BPFLCD31(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF31_BPFLCD31) & BM_LCD_WF31_BPFLCD31)

/*! @brief Set the BPFLCD31 field to a new value. */
#define BW_LCD_WF31_BPFLCD31(x, v) (BME_BFI8(HW_LCD_WF31_ADDR(x), ((uint8_t)(v) << BP_LCD_WF31_BPFLCD31), BP_LCD_WF31_BPFLCD31, 1))
/*@}*/

/*!
 * @name Register LCD_WF31, field BPGLCD31[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF31_BPGLCD31 (6U)          /*!< Bit position for LCD_WF31_BPGLCD31. */
#define BM_LCD_WF31_BPGLCD31 (0x40U)       /*!< Bit mask for LCD_WF31_BPGLCD31. */
#define BS_LCD_WF31_BPGLCD31 (1U)          /*!< Bit field size in bits for LCD_WF31_BPGLCD31. */

/*! @brief Read current value of the LCD_WF31_BPGLCD31 field. */
#define BR_LCD_WF31_BPGLCD31(x) (BME_UBFX8(HW_LCD_WF31_ADDR(x), BP_LCD_WF31_BPGLCD31, BS_LCD_WF31_BPGLCD31))

/*! @brief Format value for bitfield LCD_WF31_BPGLCD31. */
#define BF_LCD_WF31_BPGLCD31(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF31_BPGLCD31) & BM_LCD_WF31_BPGLCD31)

/*! @brief Set the BPGLCD31 field to a new value. */
#define BW_LCD_WF31_BPGLCD31(x, v) (BME_BFI8(HW_LCD_WF31_ADDR(x), ((uint8_t)(v) << BP_LCD_WF31_BPGLCD31), BP_LCD_WF31_BPGLCD31, 1))
/*@}*/

/*!
 * @name Register LCD_WF31, field BPHLCD31[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF31_BPHLCD31 (7U)          /*!< Bit position for LCD_WF31_BPHLCD31. */
#define BM_LCD_WF31_BPHLCD31 (0x80U)       /*!< Bit mask for LCD_WF31_BPHLCD31. */
#define BS_LCD_WF31_BPHLCD31 (1U)          /*!< Bit field size in bits for LCD_WF31_BPHLCD31. */

/*! @brief Read current value of the LCD_WF31_BPHLCD31 field. */
#define BR_LCD_WF31_BPHLCD31(x) (BME_UBFX8(HW_LCD_WF31_ADDR(x), BP_LCD_WF31_BPHLCD31, BS_LCD_WF31_BPHLCD31))

/*! @brief Format value for bitfield LCD_WF31_BPHLCD31. */
#define BF_LCD_WF31_BPHLCD31(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF31_BPHLCD31) & BM_LCD_WF31_BPHLCD31)

/*! @brief Set the BPHLCD31 field to a new value. */
#define BW_LCD_WF31_BPHLCD31(x, v) (BME_BFI8(HW_LCD_WF31_ADDR(x), ((uint8_t)(v) << BP_LCD_WF31_BPHLCD31), BP_LCD_WF31_BPHLCD31, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF32 - LCD Waveform Register 32.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF32 - LCD Waveform Register 32. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf32
{
    uint8_t U;
    struct _hw_lcd_wf32_bitfields
    {
        uint8_t BPALCD32 : 1;          /*!< [0]  */
        uint8_t BPBLCD32 : 1;          /*!< [1]  */
        uint8_t BPCLCD32 : 1;          /*!< [2]  */
        uint8_t BPDLCD32 : 1;          /*!< [3]  */
        uint8_t BPELCD32 : 1;          /*!< [4]  */
        uint8_t BPFLCD32 : 1;          /*!< [5]  */
        uint8_t BPGLCD32 : 1;          /*!< [6]  */
        uint8_t BPHLCD32 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf32_t;

/*!
 * @name Constants and macros for entire LCD_WF32 register
 */
/*@{*/
#define HW_LCD_WF32_ADDR(x)      ((uint32_t)(x) + 0x40U)

#define HW_LCD_WF32(x)           (*(__IO hw_lcd_wf32_t *) HW_LCD_WF32_ADDR(x))
#define HW_LCD_WF32_RD(x)        (HW_LCD_WF32(x).U)
#define HW_LCD_WF32_WR(x, v)     (HW_LCD_WF32(x).U = (v))
#define HW_LCD_WF32_SET(x, v)    (BME_OR8(HW_LCD_WF32_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF32_CLR(x, v)    (BME_AND8(HW_LCD_WF32_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF32_TOG(x, v)    (BME_XOR8(HW_LCD_WF32_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF32 bitfields
 */

/*!
 * @name Register LCD_WF32, field BPALCD32[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF32_BPALCD32 (0U)          /*!< Bit position for LCD_WF32_BPALCD32. */
#define BM_LCD_WF32_BPALCD32 (0x01U)       /*!< Bit mask for LCD_WF32_BPALCD32. */
#define BS_LCD_WF32_BPALCD32 (1U)          /*!< Bit field size in bits for LCD_WF32_BPALCD32. */

/*! @brief Read current value of the LCD_WF32_BPALCD32 field. */
#define BR_LCD_WF32_BPALCD32(x) (BME_UBFX8(HW_LCD_WF32_ADDR(x), BP_LCD_WF32_BPALCD32, BS_LCD_WF32_BPALCD32))

/*! @brief Format value for bitfield LCD_WF32_BPALCD32. */
#define BF_LCD_WF32_BPALCD32(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF32_BPALCD32) & BM_LCD_WF32_BPALCD32)

/*! @brief Set the BPALCD32 field to a new value. */
#define BW_LCD_WF32_BPALCD32(x, v) (BME_BFI8(HW_LCD_WF32_ADDR(x), ((uint8_t)(v) << BP_LCD_WF32_BPALCD32), BP_LCD_WF32_BPALCD32, 1))
/*@}*/

/*!
 * @name Register LCD_WF32, field BPBLCD32[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF32_BPBLCD32 (1U)          /*!< Bit position for LCD_WF32_BPBLCD32. */
#define BM_LCD_WF32_BPBLCD32 (0x02U)       /*!< Bit mask for LCD_WF32_BPBLCD32. */
#define BS_LCD_WF32_BPBLCD32 (1U)          /*!< Bit field size in bits for LCD_WF32_BPBLCD32. */

/*! @brief Read current value of the LCD_WF32_BPBLCD32 field. */
#define BR_LCD_WF32_BPBLCD32(x) (BME_UBFX8(HW_LCD_WF32_ADDR(x), BP_LCD_WF32_BPBLCD32, BS_LCD_WF32_BPBLCD32))

/*! @brief Format value for bitfield LCD_WF32_BPBLCD32. */
#define BF_LCD_WF32_BPBLCD32(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF32_BPBLCD32) & BM_LCD_WF32_BPBLCD32)

/*! @brief Set the BPBLCD32 field to a new value. */
#define BW_LCD_WF32_BPBLCD32(x, v) (BME_BFI8(HW_LCD_WF32_ADDR(x), ((uint8_t)(v) << BP_LCD_WF32_BPBLCD32), BP_LCD_WF32_BPBLCD32, 1))
/*@}*/

/*!
 * @name Register LCD_WF32, field BPCLCD32[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF32_BPCLCD32 (2U)          /*!< Bit position for LCD_WF32_BPCLCD32. */
#define BM_LCD_WF32_BPCLCD32 (0x04U)       /*!< Bit mask for LCD_WF32_BPCLCD32. */
#define BS_LCD_WF32_BPCLCD32 (1U)          /*!< Bit field size in bits for LCD_WF32_BPCLCD32. */

/*! @brief Read current value of the LCD_WF32_BPCLCD32 field. */
#define BR_LCD_WF32_BPCLCD32(x) (BME_UBFX8(HW_LCD_WF32_ADDR(x), BP_LCD_WF32_BPCLCD32, BS_LCD_WF32_BPCLCD32))

/*! @brief Format value for bitfield LCD_WF32_BPCLCD32. */
#define BF_LCD_WF32_BPCLCD32(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF32_BPCLCD32) & BM_LCD_WF32_BPCLCD32)

/*! @brief Set the BPCLCD32 field to a new value. */
#define BW_LCD_WF32_BPCLCD32(x, v) (BME_BFI8(HW_LCD_WF32_ADDR(x), ((uint8_t)(v) << BP_LCD_WF32_BPCLCD32), BP_LCD_WF32_BPCLCD32, 1))
/*@}*/

/*!
 * @name Register LCD_WF32, field BPDLCD32[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF32_BPDLCD32 (3U)          /*!< Bit position for LCD_WF32_BPDLCD32. */
#define BM_LCD_WF32_BPDLCD32 (0x08U)       /*!< Bit mask for LCD_WF32_BPDLCD32. */
#define BS_LCD_WF32_BPDLCD32 (1U)          /*!< Bit field size in bits for LCD_WF32_BPDLCD32. */

/*! @brief Read current value of the LCD_WF32_BPDLCD32 field. */
#define BR_LCD_WF32_BPDLCD32(x) (BME_UBFX8(HW_LCD_WF32_ADDR(x), BP_LCD_WF32_BPDLCD32, BS_LCD_WF32_BPDLCD32))

/*! @brief Format value for bitfield LCD_WF32_BPDLCD32. */
#define BF_LCD_WF32_BPDLCD32(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF32_BPDLCD32) & BM_LCD_WF32_BPDLCD32)

/*! @brief Set the BPDLCD32 field to a new value. */
#define BW_LCD_WF32_BPDLCD32(x, v) (BME_BFI8(HW_LCD_WF32_ADDR(x), ((uint8_t)(v) << BP_LCD_WF32_BPDLCD32), BP_LCD_WF32_BPDLCD32, 1))
/*@}*/

/*!
 * @name Register LCD_WF32, field BPELCD32[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF32_BPELCD32 (4U)          /*!< Bit position for LCD_WF32_BPELCD32. */
#define BM_LCD_WF32_BPELCD32 (0x10U)       /*!< Bit mask for LCD_WF32_BPELCD32. */
#define BS_LCD_WF32_BPELCD32 (1U)          /*!< Bit field size in bits for LCD_WF32_BPELCD32. */

/*! @brief Read current value of the LCD_WF32_BPELCD32 field. */
#define BR_LCD_WF32_BPELCD32(x) (BME_UBFX8(HW_LCD_WF32_ADDR(x), BP_LCD_WF32_BPELCD32, BS_LCD_WF32_BPELCD32))

/*! @brief Format value for bitfield LCD_WF32_BPELCD32. */
#define BF_LCD_WF32_BPELCD32(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF32_BPELCD32) & BM_LCD_WF32_BPELCD32)

/*! @brief Set the BPELCD32 field to a new value. */
#define BW_LCD_WF32_BPELCD32(x, v) (BME_BFI8(HW_LCD_WF32_ADDR(x), ((uint8_t)(v) << BP_LCD_WF32_BPELCD32), BP_LCD_WF32_BPELCD32, 1))
/*@}*/

/*!
 * @name Register LCD_WF32, field BPFLCD32[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF32_BPFLCD32 (5U)          /*!< Bit position for LCD_WF32_BPFLCD32. */
#define BM_LCD_WF32_BPFLCD32 (0x20U)       /*!< Bit mask for LCD_WF32_BPFLCD32. */
#define BS_LCD_WF32_BPFLCD32 (1U)          /*!< Bit field size in bits for LCD_WF32_BPFLCD32. */

/*! @brief Read current value of the LCD_WF32_BPFLCD32 field. */
#define BR_LCD_WF32_BPFLCD32(x) (BME_UBFX8(HW_LCD_WF32_ADDR(x), BP_LCD_WF32_BPFLCD32, BS_LCD_WF32_BPFLCD32))

/*! @brief Format value for bitfield LCD_WF32_BPFLCD32. */
#define BF_LCD_WF32_BPFLCD32(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF32_BPFLCD32) & BM_LCD_WF32_BPFLCD32)

/*! @brief Set the BPFLCD32 field to a new value. */
#define BW_LCD_WF32_BPFLCD32(x, v) (BME_BFI8(HW_LCD_WF32_ADDR(x), ((uint8_t)(v) << BP_LCD_WF32_BPFLCD32), BP_LCD_WF32_BPFLCD32, 1))
/*@}*/

/*!
 * @name Register LCD_WF32, field BPGLCD32[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF32_BPGLCD32 (6U)          /*!< Bit position for LCD_WF32_BPGLCD32. */
#define BM_LCD_WF32_BPGLCD32 (0x40U)       /*!< Bit mask for LCD_WF32_BPGLCD32. */
#define BS_LCD_WF32_BPGLCD32 (1U)          /*!< Bit field size in bits for LCD_WF32_BPGLCD32. */

/*! @brief Read current value of the LCD_WF32_BPGLCD32 field. */
#define BR_LCD_WF32_BPGLCD32(x) (BME_UBFX8(HW_LCD_WF32_ADDR(x), BP_LCD_WF32_BPGLCD32, BS_LCD_WF32_BPGLCD32))

/*! @brief Format value for bitfield LCD_WF32_BPGLCD32. */
#define BF_LCD_WF32_BPGLCD32(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF32_BPGLCD32) & BM_LCD_WF32_BPGLCD32)

/*! @brief Set the BPGLCD32 field to a new value. */
#define BW_LCD_WF32_BPGLCD32(x, v) (BME_BFI8(HW_LCD_WF32_ADDR(x), ((uint8_t)(v) << BP_LCD_WF32_BPGLCD32), BP_LCD_WF32_BPGLCD32, 1))
/*@}*/

/*!
 * @name Register LCD_WF32, field BPHLCD32[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF32_BPHLCD32 (7U)          /*!< Bit position for LCD_WF32_BPHLCD32. */
#define BM_LCD_WF32_BPHLCD32 (0x80U)       /*!< Bit mask for LCD_WF32_BPHLCD32. */
#define BS_LCD_WF32_BPHLCD32 (1U)          /*!< Bit field size in bits for LCD_WF32_BPHLCD32. */

/*! @brief Read current value of the LCD_WF32_BPHLCD32 field. */
#define BR_LCD_WF32_BPHLCD32(x) (BME_UBFX8(HW_LCD_WF32_ADDR(x), BP_LCD_WF32_BPHLCD32, BS_LCD_WF32_BPHLCD32))

/*! @brief Format value for bitfield LCD_WF32_BPHLCD32. */
#define BF_LCD_WF32_BPHLCD32(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF32_BPHLCD32) & BM_LCD_WF32_BPHLCD32)

/*! @brief Set the BPHLCD32 field to a new value. */
#define BW_LCD_WF32_BPHLCD32(x, v) (BME_BFI8(HW_LCD_WF32_ADDR(x), ((uint8_t)(v) << BP_LCD_WF32_BPHLCD32), BP_LCD_WF32_BPHLCD32, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF33 - LCD Waveform Register 33.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF33 - LCD Waveform Register 33. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf33
{
    uint8_t U;
    struct _hw_lcd_wf33_bitfields
    {
        uint8_t BPALCD33 : 1;          /*!< [0]  */
        uint8_t BPBLCD33 : 1;          /*!< [1]  */
        uint8_t BPCLCD33 : 1;          /*!< [2]  */
        uint8_t BPDLCD33 : 1;          /*!< [3]  */
        uint8_t BPELCD33 : 1;          /*!< [4]  */
        uint8_t BPFLCD33 : 1;          /*!< [5]  */
        uint8_t BPGLCD33 : 1;          /*!< [6]  */
        uint8_t BPHLCD33 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf33_t;

/*!
 * @name Constants and macros for entire LCD_WF33 register
 */
/*@{*/
#define HW_LCD_WF33_ADDR(x)      ((uint32_t)(x) + 0x41U)

#define HW_LCD_WF33(x)           (*(__IO hw_lcd_wf33_t *) HW_LCD_WF33_ADDR(x))
#define HW_LCD_WF33_RD(x)        (HW_LCD_WF33(x).U)
#define HW_LCD_WF33_WR(x, v)     (HW_LCD_WF33(x).U = (v))
#define HW_LCD_WF33_SET(x, v)    (BME_OR8(HW_LCD_WF33_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF33_CLR(x, v)    (BME_AND8(HW_LCD_WF33_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF33_TOG(x, v)    (BME_XOR8(HW_LCD_WF33_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF33 bitfields
 */

/*!
 * @name Register LCD_WF33, field BPALCD33[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF33_BPALCD33 (0U)          /*!< Bit position for LCD_WF33_BPALCD33. */
#define BM_LCD_WF33_BPALCD33 (0x01U)       /*!< Bit mask for LCD_WF33_BPALCD33. */
#define BS_LCD_WF33_BPALCD33 (1U)          /*!< Bit field size in bits for LCD_WF33_BPALCD33. */

/*! @brief Read current value of the LCD_WF33_BPALCD33 field. */
#define BR_LCD_WF33_BPALCD33(x) (BME_UBFX8(HW_LCD_WF33_ADDR(x), BP_LCD_WF33_BPALCD33, BS_LCD_WF33_BPALCD33))

/*! @brief Format value for bitfield LCD_WF33_BPALCD33. */
#define BF_LCD_WF33_BPALCD33(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF33_BPALCD33) & BM_LCD_WF33_BPALCD33)

/*! @brief Set the BPALCD33 field to a new value. */
#define BW_LCD_WF33_BPALCD33(x, v) (BME_BFI8(HW_LCD_WF33_ADDR(x), ((uint8_t)(v) << BP_LCD_WF33_BPALCD33), BP_LCD_WF33_BPALCD33, 1))
/*@}*/

/*!
 * @name Register LCD_WF33, field BPBLCD33[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF33_BPBLCD33 (1U)          /*!< Bit position for LCD_WF33_BPBLCD33. */
#define BM_LCD_WF33_BPBLCD33 (0x02U)       /*!< Bit mask for LCD_WF33_BPBLCD33. */
#define BS_LCD_WF33_BPBLCD33 (1U)          /*!< Bit field size in bits for LCD_WF33_BPBLCD33. */

/*! @brief Read current value of the LCD_WF33_BPBLCD33 field. */
#define BR_LCD_WF33_BPBLCD33(x) (BME_UBFX8(HW_LCD_WF33_ADDR(x), BP_LCD_WF33_BPBLCD33, BS_LCD_WF33_BPBLCD33))

/*! @brief Format value for bitfield LCD_WF33_BPBLCD33. */
#define BF_LCD_WF33_BPBLCD33(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF33_BPBLCD33) & BM_LCD_WF33_BPBLCD33)

/*! @brief Set the BPBLCD33 field to a new value. */
#define BW_LCD_WF33_BPBLCD33(x, v) (BME_BFI8(HW_LCD_WF33_ADDR(x), ((uint8_t)(v) << BP_LCD_WF33_BPBLCD33), BP_LCD_WF33_BPBLCD33, 1))
/*@}*/

/*!
 * @name Register LCD_WF33, field BPCLCD33[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF33_BPCLCD33 (2U)          /*!< Bit position for LCD_WF33_BPCLCD33. */
#define BM_LCD_WF33_BPCLCD33 (0x04U)       /*!< Bit mask for LCD_WF33_BPCLCD33. */
#define BS_LCD_WF33_BPCLCD33 (1U)          /*!< Bit field size in bits for LCD_WF33_BPCLCD33. */

/*! @brief Read current value of the LCD_WF33_BPCLCD33 field. */
#define BR_LCD_WF33_BPCLCD33(x) (BME_UBFX8(HW_LCD_WF33_ADDR(x), BP_LCD_WF33_BPCLCD33, BS_LCD_WF33_BPCLCD33))

/*! @brief Format value for bitfield LCD_WF33_BPCLCD33. */
#define BF_LCD_WF33_BPCLCD33(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF33_BPCLCD33) & BM_LCD_WF33_BPCLCD33)

/*! @brief Set the BPCLCD33 field to a new value. */
#define BW_LCD_WF33_BPCLCD33(x, v) (BME_BFI8(HW_LCD_WF33_ADDR(x), ((uint8_t)(v) << BP_LCD_WF33_BPCLCD33), BP_LCD_WF33_BPCLCD33, 1))
/*@}*/

/*!
 * @name Register LCD_WF33, field BPDLCD33[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF33_BPDLCD33 (3U)          /*!< Bit position for LCD_WF33_BPDLCD33. */
#define BM_LCD_WF33_BPDLCD33 (0x08U)       /*!< Bit mask for LCD_WF33_BPDLCD33. */
#define BS_LCD_WF33_BPDLCD33 (1U)          /*!< Bit field size in bits for LCD_WF33_BPDLCD33. */

/*! @brief Read current value of the LCD_WF33_BPDLCD33 field. */
#define BR_LCD_WF33_BPDLCD33(x) (BME_UBFX8(HW_LCD_WF33_ADDR(x), BP_LCD_WF33_BPDLCD33, BS_LCD_WF33_BPDLCD33))

/*! @brief Format value for bitfield LCD_WF33_BPDLCD33. */
#define BF_LCD_WF33_BPDLCD33(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF33_BPDLCD33) & BM_LCD_WF33_BPDLCD33)

/*! @brief Set the BPDLCD33 field to a new value. */
#define BW_LCD_WF33_BPDLCD33(x, v) (BME_BFI8(HW_LCD_WF33_ADDR(x), ((uint8_t)(v) << BP_LCD_WF33_BPDLCD33), BP_LCD_WF33_BPDLCD33, 1))
/*@}*/

/*!
 * @name Register LCD_WF33, field BPELCD33[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF33_BPELCD33 (4U)          /*!< Bit position for LCD_WF33_BPELCD33. */
#define BM_LCD_WF33_BPELCD33 (0x10U)       /*!< Bit mask for LCD_WF33_BPELCD33. */
#define BS_LCD_WF33_BPELCD33 (1U)          /*!< Bit field size in bits for LCD_WF33_BPELCD33. */

/*! @brief Read current value of the LCD_WF33_BPELCD33 field. */
#define BR_LCD_WF33_BPELCD33(x) (BME_UBFX8(HW_LCD_WF33_ADDR(x), BP_LCD_WF33_BPELCD33, BS_LCD_WF33_BPELCD33))

/*! @brief Format value for bitfield LCD_WF33_BPELCD33. */
#define BF_LCD_WF33_BPELCD33(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF33_BPELCD33) & BM_LCD_WF33_BPELCD33)

/*! @brief Set the BPELCD33 field to a new value. */
#define BW_LCD_WF33_BPELCD33(x, v) (BME_BFI8(HW_LCD_WF33_ADDR(x), ((uint8_t)(v) << BP_LCD_WF33_BPELCD33), BP_LCD_WF33_BPELCD33, 1))
/*@}*/

/*!
 * @name Register LCD_WF33, field BPFLCD33[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF33_BPFLCD33 (5U)          /*!< Bit position for LCD_WF33_BPFLCD33. */
#define BM_LCD_WF33_BPFLCD33 (0x20U)       /*!< Bit mask for LCD_WF33_BPFLCD33. */
#define BS_LCD_WF33_BPFLCD33 (1U)          /*!< Bit field size in bits for LCD_WF33_BPFLCD33. */

/*! @brief Read current value of the LCD_WF33_BPFLCD33 field. */
#define BR_LCD_WF33_BPFLCD33(x) (BME_UBFX8(HW_LCD_WF33_ADDR(x), BP_LCD_WF33_BPFLCD33, BS_LCD_WF33_BPFLCD33))

/*! @brief Format value for bitfield LCD_WF33_BPFLCD33. */
#define BF_LCD_WF33_BPFLCD33(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF33_BPFLCD33) & BM_LCD_WF33_BPFLCD33)

/*! @brief Set the BPFLCD33 field to a new value. */
#define BW_LCD_WF33_BPFLCD33(x, v) (BME_BFI8(HW_LCD_WF33_ADDR(x), ((uint8_t)(v) << BP_LCD_WF33_BPFLCD33), BP_LCD_WF33_BPFLCD33, 1))
/*@}*/

/*!
 * @name Register LCD_WF33, field BPGLCD33[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF33_BPGLCD33 (6U)          /*!< Bit position for LCD_WF33_BPGLCD33. */
#define BM_LCD_WF33_BPGLCD33 (0x40U)       /*!< Bit mask for LCD_WF33_BPGLCD33. */
#define BS_LCD_WF33_BPGLCD33 (1U)          /*!< Bit field size in bits for LCD_WF33_BPGLCD33. */

/*! @brief Read current value of the LCD_WF33_BPGLCD33 field. */
#define BR_LCD_WF33_BPGLCD33(x) (BME_UBFX8(HW_LCD_WF33_ADDR(x), BP_LCD_WF33_BPGLCD33, BS_LCD_WF33_BPGLCD33))

/*! @brief Format value for bitfield LCD_WF33_BPGLCD33. */
#define BF_LCD_WF33_BPGLCD33(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF33_BPGLCD33) & BM_LCD_WF33_BPGLCD33)

/*! @brief Set the BPGLCD33 field to a new value. */
#define BW_LCD_WF33_BPGLCD33(x, v) (BME_BFI8(HW_LCD_WF33_ADDR(x), ((uint8_t)(v) << BP_LCD_WF33_BPGLCD33), BP_LCD_WF33_BPGLCD33, 1))
/*@}*/

/*!
 * @name Register LCD_WF33, field BPHLCD33[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF33_BPHLCD33 (7U)          /*!< Bit position for LCD_WF33_BPHLCD33. */
#define BM_LCD_WF33_BPHLCD33 (0x80U)       /*!< Bit mask for LCD_WF33_BPHLCD33. */
#define BS_LCD_WF33_BPHLCD33 (1U)          /*!< Bit field size in bits for LCD_WF33_BPHLCD33. */

/*! @brief Read current value of the LCD_WF33_BPHLCD33 field. */
#define BR_LCD_WF33_BPHLCD33(x) (BME_UBFX8(HW_LCD_WF33_ADDR(x), BP_LCD_WF33_BPHLCD33, BS_LCD_WF33_BPHLCD33))

/*! @brief Format value for bitfield LCD_WF33_BPHLCD33. */
#define BF_LCD_WF33_BPHLCD33(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF33_BPHLCD33) & BM_LCD_WF33_BPHLCD33)

/*! @brief Set the BPHLCD33 field to a new value. */
#define BW_LCD_WF33_BPHLCD33(x, v) (BME_BFI8(HW_LCD_WF33_ADDR(x), ((uint8_t)(v) << BP_LCD_WF33_BPHLCD33), BP_LCD_WF33_BPHLCD33, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF34 - LCD Waveform Register 34.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF34 - LCD Waveform Register 34. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf34
{
    uint8_t U;
    struct _hw_lcd_wf34_bitfields
    {
        uint8_t BPALCD34 : 1;          /*!< [0]  */
        uint8_t BPBLCD34 : 1;          /*!< [1]  */
        uint8_t BPCLCD34 : 1;          /*!< [2]  */
        uint8_t BPDLCD34 : 1;          /*!< [3]  */
        uint8_t BPELCD34 : 1;          /*!< [4]  */
        uint8_t BPFLCD34 : 1;          /*!< [5]  */
        uint8_t BPGLCD34 : 1;          /*!< [6]  */
        uint8_t BPHLCD34 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf34_t;

/*!
 * @name Constants and macros for entire LCD_WF34 register
 */
/*@{*/
#define HW_LCD_WF34_ADDR(x)      ((uint32_t)(x) + 0x42U)

#define HW_LCD_WF34(x)           (*(__IO hw_lcd_wf34_t *) HW_LCD_WF34_ADDR(x))
#define HW_LCD_WF34_RD(x)        (HW_LCD_WF34(x).U)
#define HW_LCD_WF34_WR(x, v)     (HW_LCD_WF34(x).U = (v))
#define HW_LCD_WF34_SET(x, v)    (BME_OR8(HW_LCD_WF34_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF34_CLR(x, v)    (BME_AND8(HW_LCD_WF34_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF34_TOG(x, v)    (BME_XOR8(HW_LCD_WF34_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF34 bitfields
 */

/*!
 * @name Register LCD_WF34, field BPALCD34[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF34_BPALCD34 (0U)          /*!< Bit position for LCD_WF34_BPALCD34. */
#define BM_LCD_WF34_BPALCD34 (0x01U)       /*!< Bit mask for LCD_WF34_BPALCD34. */
#define BS_LCD_WF34_BPALCD34 (1U)          /*!< Bit field size in bits for LCD_WF34_BPALCD34. */

/*! @brief Read current value of the LCD_WF34_BPALCD34 field. */
#define BR_LCD_WF34_BPALCD34(x) (BME_UBFX8(HW_LCD_WF34_ADDR(x), BP_LCD_WF34_BPALCD34, BS_LCD_WF34_BPALCD34))

/*! @brief Format value for bitfield LCD_WF34_BPALCD34. */
#define BF_LCD_WF34_BPALCD34(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF34_BPALCD34) & BM_LCD_WF34_BPALCD34)

/*! @brief Set the BPALCD34 field to a new value. */
#define BW_LCD_WF34_BPALCD34(x, v) (BME_BFI8(HW_LCD_WF34_ADDR(x), ((uint8_t)(v) << BP_LCD_WF34_BPALCD34), BP_LCD_WF34_BPALCD34, 1))
/*@}*/

/*!
 * @name Register LCD_WF34, field BPBLCD34[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF34_BPBLCD34 (1U)          /*!< Bit position for LCD_WF34_BPBLCD34. */
#define BM_LCD_WF34_BPBLCD34 (0x02U)       /*!< Bit mask for LCD_WF34_BPBLCD34. */
#define BS_LCD_WF34_BPBLCD34 (1U)          /*!< Bit field size in bits for LCD_WF34_BPBLCD34. */

/*! @brief Read current value of the LCD_WF34_BPBLCD34 field. */
#define BR_LCD_WF34_BPBLCD34(x) (BME_UBFX8(HW_LCD_WF34_ADDR(x), BP_LCD_WF34_BPBLCD34, BS_LCD_WF34_BPBLCD34))

/*! @brief Format value for bitfield LCD_WF34_BPBLCD34. */
#define BF_LCD_WF34_BPBLCD34(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF34_BPBLCD34) & BM_LCD_WF34_BPBLCD34)

/*! @brief Set the BPBLCD34 field to a new value. */
#define BW_LCD_WF34_BPBLCD34(x, v) (BME_BFI8(HW_LCD_WF34_ADDR(x), ((uint8_t)(v) << BP_LCD_WF34_BPBLCD34), BP_LCD_WF34_BPBLCD34, 1))
/*@}*/

/*!
 * @name Register LCD_WF34, field BPCLCD34[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF34_BPCLCD34 (2U)          /*!< Bit position for LCD_WF34_BPCLCD34. */
#define BM_LCD_WF34_BPCLCD34 (0x04U)       /*!< Bit mask for LCD_WF34_BPCLCD34. */
#define BS_LCD_WF34_BPCLCD34 (1U)          /*!< Bit field size in bits for LCD_WF34_BPCLCD34. */

/*! @brief Read current value of the LCD_WF34_BPCLCD34 field. */
#define BR_LCD_WF34_BPCLCD34(x) (BME_UBFX8(HW_LCD_WF34_ADDR(x), BP_LCD_WF34_BPCLCD34, BS_LCD_WF34_BPCLCD34))

/*! @brief Format value for bitfield LCD_WF34_BPCLCD34. */
#define BF_LCD_WF34_BPCLCD34(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF34_BPCLCD34) & BM_LCD_WF34_BPCLCD34)

/*! @brief Set the BPCLCD34 field to a new value. */
#define BW_LCD_WF34_BPCLCD34(x, v) (BME_BFI8(HW_LCD_WF34_ADDR(x), ((uint8_t)(v) << BP_LCD_WF34_BPCLCD34), BP_LCD_WF34_BPCLCD34, 1))
/*@}*/

/*!
 * @name Register LCD_WF34, field BPDLCD34[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF34_BPDLCD34 (3U)          /*!< Bit position for LCD_WF34_BPDLCD34. */
#define BM_LCD_WF34_BPDLCD34 (0x08U)       /*!< Bit mask for LCD_WF34_BPDLCD34. */
#define BS_LCD_WF34_BPDLCD34 (1U)          /*!< Bit field size in bits for LCD_WF34_BPDLCD34. */

/*! @brief Read current value of the LCD_WF34_BPDLCD34 field. */
#define BR_LCD_WF34_BPDLCD34(x) (BME_UBFX8(HW_LCD_WF34_ADDR(x), BP_LCD_WF34_BPDLCD34, BS_LCD_WF34_BPDLCD34))

/*! @brief Format value for bitfield LCD_WF34_BPDLCD34. */
#define BF_LCD_WF34_BPDLCD34(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF34_BPDLCD34) & BM_LCD_WF34_BPDLCD34)

/*! @brief Set the BPDLCD34 field to a new value. */
#define BW_LCD_WF34_BPDLCD34(x, v) (BME_BFI8(HW_LCD_WF34_ADDR(x), ((uint8_t)(v) << BP_LCD_WF34_BPDLCD34), BP_LCD_WF34_BPDLCD34, 1))
/*@}*/

/*!
 * @name Register LCD_WF34, field BPELCD34[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF34_BPELCD34 (4U)          /*!< Bit position for LCD_WF34_BPELCD34. */
#define BM_LCD_WF34_BPELCD34 (0x10U)       /*!< Bit mask for LCD_WF34_BPELCD34. */
#define BS_LCD_WF34_BPELCD34 (1U)          /*!< Bit field size in bits for LCD_WF34_BPELCD34. */

/*! @brief Read current value of the LCD_WF34_BPELCD34 field. */
#define BR_LCD_WF34_BPELCD34(x) (BME_UBFX8(HW_LCD_WF34_ADDR(x), BP_LCD_WF34_BPELCD34, BS_LCD_WF34_BPELCD34))

/*! @brief Format value for bitfield LCD_WF34_BPELCD34. */
#define BF_LCD_WF34_BPELCD34(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF34_BPELCD34) & BM_LCD_WF34_BPELCD34)

/*! @brief Set the BPELCD34 field to a new value. */
#define BW_LCD_WF34_BPELCD34(x, v) (BME_BFI8(HW_LCD_WF34_ADDR(x), ((uint8_t)(v) << BP_LCD_WF34_BPELCD34), BP_LCD_WF34_BPELCD34, 1))
/*@}*/

/*!
 * @name Register LCD_WF34, field BPFLCD34[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF34_BPFLCD34 (5U)          /*!< Bit position for LCD_WF34_BPFLCD34. */
#define BM_LCD_WF34_BPFLCD34 (0x20U)       /*!< Bit mask for LCD_WF34_BPFLCD34. */
#define BS_LCD_WF34_BPFLCD34 (1U)          /*!< Bit field size in bits for LCD_WF34_BPFLCD34. */

/*! @brief Read current value of the LCD_WF34_BPFLCD34 field. */
#define BR_LCD_WF34_BPFLCD34(x) (BME_UBFX8(HW_LCD_WF34_ADDR(x), BP_LCD_WF34_BPFLCD34, BS_LCD_WF34_BPFLCD34))

/*! @brief Format value for bitfield LCD_WF34_BPFLCD34. */
#define BF_LCD_WF34_BPFLCD34(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF34_BPFLCD34) & BM_LCD_WF34_BPFLCD34)

/*! @brief Set the BPFLCD34 field to a new value. */
#define BW_LCD_WF34_BPFLCD34(x, v) (BME_BFI8(HW_LCD_WF34_ADDR(x), ((uint8_t)(v) << BP_LCD_WF34_BPFLCD34), BP_LCD_WF34_BPFLCD34, 1))
/*@}*/

/*!
 * @name Register LCD_WF34, field BPGLCD34[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF34_BPGLCD34 (6U)          /*!< Bit position for LCD_WF34_BPGLCD34. */
#define BM_LCD_WF34_BPGLCD34 (0x40U)       /*!< Bit mask for LCD_WF34_BPGLCD34. */
#define BS_LCD_WF34_BPGLCD34 (1U)          /*!< Bit field size in bits for LCD_WF34_BPGLCD34. */

/*! @brief Read current value of the LCD_WF34_BPGLCD34 field. */
#define BR_LCD_WF34_BPGLCD34(x) (BME_UBFX8(HW_LCD_WF34_ADDR(x), BP_LCD_WF34_BPGLCD34, BS_LCD_WF34_BPGLCD34))

/*! @brief Format value for bitfield LCD_WF34_BPGLCD34. */
#define BF_LCD_WF34_BPGLCD34(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF34_BPGLCD34) & BM_LCD_WF34_BPGLCD34)

/*! @brief Set the BPGLCD34 field to a new value. */
#define BW_LCD_WF34_BPGLCD34(x, v) (BME_BFI8(HW_LCD_WF34_ADDR(x), ((uint8_t)(v) << BP_LCD_WF34_BPGLCD34), BP_LCD_WF34_BPGLCD34, 1))
/*@}*/

/*!
 * @name Register LCD_WF34, field BPHLCD34[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF34_BPHLCD34 (7U)          /*!< Bit position for LCD_WF34_BPHLCD34. */
#define BM_LCD_WF34_BPHLCD34 (0x80U)       /*!< Bit mask for LCD_WF34_BPHLCD34. */
#define BS_LCD_WF34_BPHLCD34 (1U)          /*!< Bit field size in bits for LCD_WF34_BPHLCD34. */

/*! @brief Read current value of the LCD_WF34_BPHLCD34 field. */
#define BR_LCD_WF34_BPHLCD34(x) (BME_UBFX8(HW_LCD_WF34_ADDR(x), BP_LCD_WF34_BPHLCD34, BS_LCD_WF34_BPHLCD34))

/*! @brief Format value for bitfield LCD_WF34_BPHLCD34. */
#define BF_LCD_WF34_BPHLCD34(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF34_BPHLCD34) & BM_LCD_WF34_BPHLCD34)

/*! @brief Set the BPHLCD34 field to a new value. */
#define BW_LCD_WF34_BPHLCD34(x, v) (BME_BFI8(HW_LCD_WF34_ADDR(x), ((uint8_t)(v) << BP_LCD_WF34_BPHLCD34), BP_LCD_WF34_BPHLCD34, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF35 - LCD Waveform Register 35.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF35 - LCD Waveform Register 35. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf35
{
    uint8_t U;
    struct _hw_lcd_wf35_bitfields
    {
        uint8_t BPALCD35 : 1;          /*!< [0]  */
        uint8_t BPBLCD35 : 1;          /*!< [1]  */
        uint8_t BPCLCD35 : 1;          /*!< [2]  */
        uint8_t BPDLCD35 : 1;          /*!< [3]  */
        uint8_t BPELCD35 : 1;          /*!< [4]  */
        uint8_t BPFLCD35 : 1;          /*!< [5]  */
        uint8_t BPGLCD35 : 1;          /*!< [6]  */
        uint8_t BPHLCD35 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf35_t;

/*!
 * @name Constants and macros for entire LCD_WF35 register
 */
/*@{*/
#define HW_LCD_WF35_ADDR(x)      ((uint32_t)(x) + 0x43U)

#define HW_LCD_WF35(x)           (*(__IO hw_lcd_wf35_t *) HW_LCD_WF35_ADDR(x))
#define HW_LCD_WF35_RD(x)        (HW_LCD_WF35(x).U)
#define HW_LCD_WF35_WR(x, v)     (HW_LCD_WF35(x).U = (v))
#define HW_LCD_WF35_SET(x, v)    (BME_OR8(HW_LCD_WF35_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF35_CLR(x, v)    (BME_AND8(HW_LCD_WF35_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF35_TOG(x, v)    (BME_XOR8(HW_LCD_WF35_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF35 bitfields
 */

/*!
 * @name Register LCD_WF35, field BPALCD35[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF35_BPALCD35 (0U)          /*!< Bit position for LCD_WF35_BPALCD35. */
#define BM_LCD_WF35_BPALCD35 (0x01U)       /*!< Bit mask for LCD_WF35_BPALCD35. */
#define BS_LCD_WF35_BPALCD35 (1U)          /*!< Bit field size in bits for LCD_WF35_BPALCD35. */

/*! @brief Read current value of the LCD_WF35_BPALCD35 field. */
#define BR_LCD_WF35_BPALCD35(x) (BME_UBFX8(HW_LCD_WF35_ADDR(x), BP_LCD_WF35_BPALCD35, BS_LCD_WF35_BPALCD35))

/*! @brief Format value for bitfield LCD_WF35_BPALCD35. */
#define BF_LCD_WF35_BPALCD35(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF35_BPALCD35) & BM_LCD_WF35_BPALCD35)

/*! @brief Set the BPALCD35 field to a new value. */
#define BW_LCD_WF35_BPALCD35(x, v) (BME_BFI8(HW_LCD_WF35_ADDR(x), ((uint8_t)(v) << BP_LCD_WF35_BPALCD35), BP_LCD_WF35_BPALCD35, 1))
/*@}*/

/*!
 * @name Register LCD_WF35, field BPBLCD35[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF35_BPBLCD35 (1U)          /*!< Bit position for LCD_WF35_BPBLCD35. */
#define BM_LCD_WF35_BPBLCD35 (0x02U)       /*!< Bit mask for LCD_WF35_BPBLCD35. */
#define BS_LCD_WF35_BPBLCD35 (1U)          /*!< Bit field size in bits for LCD_WF35_BPBLCD35. */

/*! @brief Read current value of the LCD_WF35_BPBLCD35 field. */
#define BR_LCD_WF35_BPBLCD35(x) (BME_UBFX8(HW_LCD_WF35_ADDR(x), BP_LCD_WF35_BPBLCD35, BS_LCD_WF35_BPBLCD35))

/*! @brief Format value for bitfield LCD_WF35_BPBLCD35. */
#define BF_LCD_WF35_BPBLCD35(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF35_BPBLCD35) & BM_LCD_WF35_BPBLCD35)

/*! @brief Set the BPBLCD35 field to a new value. */
#define BW_LCD_WF35_BPBLCD35(x, v) (BME_BFI8(HW_LCD_WF35_ADDR(x), ((uint8_t)(v) << BP_LCD_WF35_BPBLCD35), BP_LCD_WF35_BPBLCD35, 1))
/*@}*/

/*!
 * @name Register LCD_WF35, field BPCLCD35[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF35_BPCLCD35 (2U)          /*!< Bit position for LCD_WF35_BPCLCD35. */
#define BM_LCD_WF35_BPCLCD35 (0x04U)       /*!< Bit mask for LCD_WF35_BPCLCD35. */
#define BS_LCD_WF35_BPCLCD35 (1U)          /*!< Bit field size in bits for LCD_WF35_BPCLCD35. */

/*! @brief Read current value of the LCD_WF35_BPCLCD35 field. */
#define BR_LCD_WF35_BPCLCD35(x) (BME_UBFX8(HW_LCD_WF35_ADDR(x), BP_LCD_WF35_BPCLCD35, BS_LCD_WF35_BPCLCD35))

/*! @brief Format value for bitfield LCD_WF35_BPCLCD35. */
#define BF_LCD_WF35_BPCLCD35(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF35_BPCLCD35) & BM_LCD_WF35_BPCLCD35)

/*! @brief Set the BPCLCD35 field to a new value. */
#define BW_LCD_WF35_BPCLCD35(x, v) (BME_BFI8(HW_LCD_WF35_ADDR(x), ((uint8_t)(v) << BP_LCD_WF35_BPCLCD35), BP_LCD_WF35_BPCLCD35, 1))
/*@}*/

/*!
 * @name Register LCD_WF35, field BPDLCD35[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF35_BPDLCD35 (3U)          /*!< Bit position for LCD_WF35_BPDLCD35. */
#define BM_LCD_WF35_BPDLCD35 (0x08U)       /*!< Bit mask for LCD_WF35_BPDLCD35. */
#define BS_LCD_WF35_BPDLCD35 (1U)          /*!< Bit field size in bits for LCD_WF35_BPDLCD35. */

/*! @brief Read current value of the LCD_WF35_BPDLCD35 field. */
#define BR_LCD_WF35_BPDLCD35(x) (BME_UBFX8(HW_LCD_WF35_ADDR(x), BP_LCD_WF35_BPDLCD35, BS_LCD_WF35_BPDLCD35))

/*! @brief Format value for bitfield LCD_WF35_BPDLCD35. */
#define BF_LCD_WF35_BPDLCD35(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF35_BPDLCD35) & BM_LCD_WF35_BPDLCD35)

/*! @brief Set the BPDLCD35 field to a new value. */
#define BW_LCD_WF35_BPDLCD35(x, v) (BME_BFI8(HW_LCD_WF35_ADDR(x), ((uint8_t)(v) << BP_LCD_WF35_BPDLCD35), BP_LCD_WF35_BPDLCD35, 1))
/*@}*/

/*!
 * @name Register LCD_WF35, field BPELCD35[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF35_BPELCD35 (4U)          /*!< Bit position for LCD_WF35_BPELCD35. */
#define BM_LCD_WF35_BPELCD35 (0x10U)       /*!< Bit mask for LCD_WF35_BPELCD35. */
#define BS_LCD_WF35_BPELCD35 (1U)          /*!< Bit field size in bits for LCD_WF35_BPELCD35. */

/*! @brief Read current value of the LCD_WF35_BPELCD35 field. */
#define BR_LCD_WF35_BPELCD35(x) (BME_UBFX8(HW_LCD_WF35_ADDR(x), BP_LCD_WF35_BPELCD35, BS_LCD_WF35_BPELCD35))

/*! @brief Format value for bitfield LCD_WF35_BPELCD35. */
#define BF_LCD_WF35_BPELCD35(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF35_BPELCD35) & BM_LCD_WF35_BPELCD35)

/*! @brief Set the BPELCD35 field to a new value. */
#define BW_LCD_WF35_BPELCD35(x, v) (BME_BFI8(HW_LCD_WF35_ADDR(x), ((uint8_t)(v) << BP_LCD_WF35_BPELCD35), BP_LCD_WF35_BPELCD35, 1))
/*@}*/

/*!
 * @name Register LCD_WF35, field BPFLCD35[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF35_BPFLCD35 (5U)          /*!< Bit position for LCD_WF35_BPFLCD35. */
#define BM_LCD_WF35_BPFLCD35 (0x20U)       /*!< Bit mask for LCD_WF35_BPFLCD35. */
#define BS_LCD_WF35_BPFLCD35 (1U)          /*!< Bit field size in bits for LCD_WF35_BPFLCD35. */

/*! @brief Read current value of the LCD_WF35_BPFLCD35 field. */
#define BR_LCD_WF35_BPFLCD35(x) (BME_UBFX8(HW_LCD_WF35_ADDR(x), BP_LCD_WF35_BPFLCD35, BS_LCD_WF35_BPFLCD35))

/*! @brief Format value for bitfield LCD_WF35_BPFLCD35. */
#define BF_LCD_WF35_BPFLCD35(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF35_BPFLCD35) & BM_LCD_WF35_BPFLCD35)

/*! @brief Set the BPFLCD35 field to a new value. */
#define BW_LCD_WF35_BPFLCD35(x, v) (BME_BFI8(HW_LCD_WF35_ADDR(x), ((uint8_t)(v) << BP_LCD_WF35_BPFLCD35), BP_LCD_WF35_BPFLCD35, 1))
/*@}*/

/*!
 * @name Register LCD_WF35, field BPGLCD35[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF35_BPGLCD35 (6U)          /*!< Bit position for LCD_WF35_BPGLCD35. */
#define BM_LCD_WF35_BPGLCD35 (0x40U)       /*!< Bit mask for LCD_WF35_BPGLCD35. */
#define BS_LCD_WF35_BPGLCD35 (1U)          /*!< Bit field size in bits for LCD_WF35_BPGLCD35. */

/*! @brief Read current value of the LCD_WF35_BPGLCD35 field. */
#define BR_LCD_WF35_BPGLCD35(x) (BME_UBFX8(HW_LCD_WF35_ADDR(x), BP_LCD_WF35_BPGLCD35, BS_LCD_WF35_BPGLCD35))

/*! @brief Format value for bitfield LCD_WF35_BPGLCD35. */
#define BF_LCD_WF35_BPGLCD35(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF35_BPGLCD35) & BM_LCD_WF35_BPGLCD35)

/*! @brief Set the BPGLCD35 field to a new value. */
#define BW_LCD_WF35_BPGLCD35(x, v) (BME_BFI8(HW_LCD_WF35_ADDR(x), ((uint8_t)(v) << BP_LCD_WF35_BPGLCD35), BP_LCD_WF35_BPGLCD35, 1))
/*@}*/

/*!
 * @name Register LCD_WF35, field BPHLCD35[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF35_BPHLCD35 (7U)          /*!< Bit position for LCD_WF35_BPHLCD35. */
#define BM_LCD_WF35_BPHLCD35 (0x80U)       /*!< Bit mask for LCD_WF35_BPHLCD35. */
#define BS_LCD_WF35_BPHLCD35 (1U)          /*!< Bit field size in bits for LCD_WF35_BPHLCD35. */

/*! @brief Read current value of the LCD_WF35_BPHLCD35 field. */
#define BR_LCD_WF35_BPHLCD35(x) (BME_UBFX8(HW_LCD_WF35_ADDR(x), BP_LCD_WF35_BPHLCD35, BS_LCD_WF35_BPHLCD35))

/*! @brief Format value for bitfield LCD_WF35_BPHLCD35. */
#define BF_LCD_WF35_BPHLCD35(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF35_BPHLCD35) & BM_LCD_WF35_BPHLCD35)

/*! @brief Set the BPHLCD35 field to a new value. */
#define BW_LCD_WF35_BPHLCD35(x, v) (BME_BFI8(HW_LCD_WF35_ADDR(x), ((uint8_t)(v) << BP_LCD_WF35_BPHLCD35), BP_LCD_WF35_BPHLCD35, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF36 - LCD Waveform Register 36.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF36 - LCD Waveform Register 36. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf36
{
    uint8_t U;
    struct _hw_lcd_wf36_bitfields
    {
        uint8_t BPALCD36 : 1;          /*!< [0]  */
        uint8_t BPBLCD36 : 1;          /*!< [1]  */
        uint8_t BPCLCD36 : 1;          /*!< [2]  */
        uint8_t BPDLCD36 : 1;          /*!< [3]  */
        uint8_t BPELCD36 : 1;          /*!< [4]  */
        uint8_t BPFLCD36 : 1;          /*!< [5]  */
        uint8_t BPGLCD36 : 1;          /*!< [6]  */
        uint8_t BPHLCD36 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf36_t;

/*!
 * @name Constants and macros for entire LCD_WF36 register
 */
/*@{*/
#define HW_LCD_WF36_ADDR(x)      ((uint32_t)(x) + 0x44U)

#define HW_LCD_WF36(x)           (*(__IO hw_lcd_wf36_t *) HW_LCD_WF36_ADDR(x))
#define HW_LCD_WF36_RD(x)        (HW_LCD_WF36(x).U)
#define HW_LCD_WF36_WR(x, v)     (HW_LCD_WF36(x).U = (v))
#define HW_LCD_WF36_SET(x, v)    (BME_OR8(HW_LCD_WF36_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF36_CLR(x, v)    (BME_AND8(HW_LCD_WF36_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF36_TOG(x, v)    (BME_XOR8(HW_LCD_WF36_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF36 bitfields
 */

/*!
 * @name Register LCD_WF36, field BPALCD36[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF36_BPALCD36 (0U)          /*!< Bit position for LCD_WF36_BPALCD36. */
#define BM_LCD_WF36_BPALCD36 (0x01U)       /*!< Bit mask for LCD_WF36_BPALCD36. */
#define BS_LCD_WF36_BPALCD36 (1U)          /*!< Bit field size in bits for LCD_WF36_BPALCD36. */

/*! @brief Read current value of the LCD_WF36_BPALCD36 field. */
#define BR_LCD_WF36_BPALCD36(x) (BME_UBFX8(HW_LCD_WF36_ADDR(x), BP_LCD_WF36_BPALCD36, BS_LCD_WF36_BPALCD36))

/*! @brief Format value for bitfield LCD_WF36_BPALCD36. */
#define BF_LCD_WF36_BPALCD36(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF36_BPALCD36) & BM_LCD_WF36_BPALCD36)

/*! @brief Set the BPALCD36 field to a new value. */
#define BW_LCD_WF36_BPALCD36(x, v) (BME_BFI8(HW_LCD_WF36_ADDR(x), ((uint8_t)(v) << BP_LCD_WF36_BPALCD36), BP_LCD_WF36_BPALCD36, 1))
/*@}*/

/*!
 * @name Register LCD_WF36, field BPBLCD36[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF36_BPBLCD36 (1U)          /*!< Bit position for LCD_WF36_BPBLCD36. */
#define BM_LCD_WF36_BPBLCD36 (0x02U)       /*!< Bit mask for LCD_WF36_BPBLCD36. */
#define BS_LCD_WF36_BPBLCD36 (1U)          /*!< Bit field size in bits for LCD_WF36_BPBLCD36. */

/*! @brief Read current value of the LCD_WF36_BPBLCD36 field. */
#define BR_LCD_WF36_BPBLCD36(x) (BME_UBFX8(HW_LCD_WF36_ADDR(x), BP_LCD_WF36_BPBLCD36, BS_LCD_WF36_BPBLCD36))

/*! @brief Format value for bitfield LCD_WF36_BPBLCD36. */
#define BF_LCD_WF36_BPBLCD36(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF36_BPBLCD36) & BM_LCD_WF36_BPBLCD36)

/*! @brief Set the BPBLCD36 field to a new value. */
#define BW_LCD_WF36_BPBLCD36(x, v) (BME_BFI8(HW_LCD_WF36_ADDR(x), ((uint8_t)(v) << BP_LCD_WF36_BPBLCD36), BP_LCD_WF36_BPBLCD36, 1))
/*@}*/

/*!
 * @name Register LCD_WF36, field BPCLCD36[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF36_BPCLCD36 (2U)          /*!< Bit position for LCD_WF36_BPCLCD36. */
#define BM_LCD_WF36_BPCLCD36 (0x04U)       /*!< Bit mask for LCD_WF36_BPCLCD36. */
#define BS_LCD_WF36_BPCLCD36 (1U)          /*!< Bit field size in bits for LCD_WF36_BPCLCD36. */

/*! @brief Read current value of the LCD_WF36_BPCLCD36 field. */
#define BR_LCD_WF36_BPCLCD36(x) (BME_UBFX8(HW_LCD_WF36_ADDR(x), BP_LCD_WF36_BPCLCD36, BS_LCD_WF36_BPCLCD36))

/*! @brief Format value for bitfield LCD_WF36_BPCLCD36. */
#define BF_LCD_WF36_BPCLCD36(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF36_BPCLCD36) & BM_LCD_WF36_BPCLCD36)

/*! @brief Set the BPCLCD36 field to a new value. */
#define BW_LCD_WF36_BPCLCD36(x, v) (BME_BFI8(HW_LCD_WF36_ADDR(x), ((uint8_t)(v) << BP_LCD_WF36_BPCLCD36), BP_LCD_WF36_BPCLCD36, 1))
/*@}*/

/*!
 * @name Register LCD_WF36, field BPDLCD36[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF36_BPDLCD36 (3U)          /*!< Bit position for LCD_WF36_BPDLCD36. */
#define BM_LCD_WF36_BPDLCD36 (0x08U)       /*!< Bit mask for LCD_WF36_BPDLCD36. */
#define BS_LCD_WF36_BPDLCD36 (1U)          /*!< Bit field size in bits for LCD_WF36_BPDLCD36. */

/*! @brief Read current value of the LCD_WF36_BPDLCD36 field. */
#define BR_LCD_WF36_BPDLCD36(x) (BME_UBFX8(HW_LCD_WF36_ADDR(x), BP_LCD_WF36_BPDLCD36, BS_LCD_WF36_BPDLCD36))

/*! @brief Format value for bitfield LCD_WF36_BPDLCD36. */
#define BF_LCD_WF36_BPDLCD36(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF36_BPDLCD36) & BM_LCD_WF36_BPDLCD36)

/*! @brief Set the BPDLCD36 field to a new value. */
#define BW_LCD_WF36_BPDLCD36(x, v) (BME_BFI8(HW_LCD_WF36_ADDR(x), ((uint8_t)(v) << BP_LCD_WF36_BPDLCD36), BP_LCD_WF36_BPDLCD36, 1))
/*@}*/

/*!
 * @name Register LCD_WF36, field BPELCD36[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF36_BPELCD36 (4U)          /*!< Bit position for LCD_WF36_BPELCD36. */
#define BM_LCD_WF36_BPELCD36 (0x10U)       /*!< Bit mask for LCD_WF36_BPELCD36. */
#define BS_LCD_WF36_BPELCD36 (1U)          /*!< Bit field size in bits for LCD_WF36_BPELCD36. */

/*! @brief Read current value of the LCD_WF36_BPELCD36 field. */
#define BR_LCD_WF36_BPELCD36(x) (BME_UBFX8(HW_LCD_WF36_ADDR(x), BP_LCD_WF36_BPELCD36, BS_LCD_WF36_BPELCD36))

/*! @brief Format value for bitfield LCD_WF36_BPELCD36. */
#define BF_LCD_WF36_BPELCD36(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF36_BPELCD36) & BM_LCD_WF36_BPELCD36)

/*! @brief Set the BPELCD36 field to a new value. */
#define BW_LCD_WF36_BPELCD36(x, v) (BME_BFI8(HW_LCD_WF36_ADDR(x), ((uint8_t)(v) << BP_LCD_WF36_BPELCD36), BP_LCD_WF36_BPELCD36, 1))
/*@}*/

/*!
 * @name Register LCD_WF36, field BPFLCD36[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF36_BPFLCD36 (5U)          /*!< Bit position for LCD_WF36_BPFLCD36. */
#define BM_LCD_WF36_BPFLCD36 (0x20U)       /*!< Bit mask for LCD_WF36_BPFLCD36. */
#define BS_LCD_WF36_BPFLCD36 (1U)          /*!< Bit field size in bits for LCD_WF36_BPFLCD36. */

/*! @brief Read current value of the LCD_WF36_BPFLCD36 field. */
#define BR_LCD_WF36_BPFLCD36(x) (BME_UBFX8(HW_LCD_WF36_ADDR(x), BP_LCD_WF36_BPFLCD36, BS_LCD_WF36_BPFLCD36))

/*! @brief Format value for bitfield LCD_WF36_BPFLCD36. */
#define BF_LCD_WF36_BPFLCD36(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF36_BPFLCD36) & BM_LCD_WF36_BPFLCD36)

/*! @brief Set the BPFLCD36 field to a new value. */
#define BW_LCD_WF36_BPFLCD36(x, v) (BME_BFI8(HW_LCD_WF36_ADDR(x), ((uint8_t)(v) << BP_LCD_WF36_BPFLCD36), BP_LCD_WF36_BPFLCD36, 1))
/*@}*/

/*!
 * @name Register LCD_WF36, field BPGLCD36[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF36_BPGLCD36 (6U)          /*!< Bit position for LCD_WF36_BPGLCD36. */
#define BM_LCD_WF36_BPGLCD36 (0x40U)       /*!< Bit mask for LCD_WF36_BPGLCD36. */
#define BS_LCD_WF36_BPGLCD36 (1U)          /*!< Bit field size in bits for LCD_WF36_BPGLCD36. */

/*! @brief Read current value of the LCD_WF36_BPGLCD36 field. */
#define BR_LCD_WF36_BPGLCD36(x) (BME_UBFX8(HW_LCD_WF36_ADDR(x), BP_LCD_WF36_BPGLCD36, BS_LCD_WF36_BPGLCD36))

/*! @brief Format value for bitfield LCD_WF36_BPGLCD36. */
#define BF_LCD_WF36_BPGLCD36(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF36_BPGLCD36) & BM_LCD_WF36_BPGLCD36)

/*! @brief Set the BPGLCD36 field to a new value. */
#define BW_LCD_WF36_BPGLCD36(x, v) (BME_BFI8(HW_LCD_WF36_ADDR(x), ((uint8_t)(v) << BP_LCD_WF36_BPGLCD36), BP_LCD_WF36_BPGLCD36, 1))
/*@}*/

/*!
 * @name Register LCD_WF36, field BPHLCD36[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF36_BPHLCD36 (7U)          /*!< Bit position for LCD_WF36_BPHLCD36. */
#define BM_LCD_WF36_BPHLCD36 (0x80U)       /*!< Bit mask for LCD_WF36_BPHLCD36. */
#define BS_LCD_WF36_BPHLCD36 (1U)          /*!< Bit field size in bits for LCD_WF36_BPHLCD36. */

/*! @brief Read current value of the LCD_WF36_BPHLCD36 field. */
#define BR_LCD_WF36_BPHLCD36(x) (BME_UBFX8(HW_LCD_WF36_ADDR(x), BP_LCD_WF36_BPHLCD36, BS_LCD_WF36_BPHLCD36))

/*! @brief Format value for bitfield LCD_WF36_BPHLCD36. */
#define BF_LCD_WF36_BPHLCD36(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF36_BPHLCD36) & BM_LCD_WF36_BPHLCD36)

/*! @brief Set the BPHLCD36 field to a new value. */
#define BW_LCD_WF36_BPHLCD36(x, v) (BME_BFI8(HW_LCD_WF36_ADDR(x), ((uint8_t)(v) << BP_LCD_WF36_BPHLCD36), BP_LCD_WF36_BPHLCD36, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF37 - LCD Waveform Register 37.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF37 - LCD Waveform Register 37. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf37
{
    uint8_t U;
    struct _hw_lcd_wf37_bitfields
    {
        uint8_t BPALCD37 : 1;          /*!< [0]  */
        uint8_t BPBLCD37 : 1;          /*!< [1]  */
        uint8_t BPCLCD37 : 1;          /*!< [2]  */
        uint8_t BPDLCD37 : 1;          /*!< [3]  */
        uint8_t BPELCD37 : 1;          /*!< [4]  */
        uint8_t BPFLCD37 : 1;          /*!< [5]  */
        uint8_t BPGLCD37 : 1;          /*!< [6]  */
        uint8_t BPHLCD37 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf37_t;

/*!
 * @name Constants and macros for entire LCD_WF37 register
 */
/*@{*/
#define HW_LCD_WF37_ADDR(x)      ((uint32_t)(x) + 0x45U)

#define HW_LCD_WF37(x)           (*(__IO hw_lcd_wf37_t *) HW_LCD_WF37_ADDR(x))
#define HW_LCD_WF37_RD(x)        (HW_LCD_WF37(x).U)
#define HW_LCD_WF37_WR(x, v)     (HW_LCD_WF37(x).U = (v))
#define HW_LCD_WF37_SET(x, v)    (BME_OR8(HW_LCD_WF37_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF37_CLR(x, v)    (BME_AND8(HW_LCD_WF37_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF37_TOG(x, v)    (BME_XOR8(HW_LCD_WF37_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF37 bitfields
 */

/*!
 * @name Register LCD_WF37, field BPALCD37[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF37_BPALCD37 (0U)          /*!< Bit position for LCD_WF37_BPALCD37. */
#define BM_LCD_WF37_BPALCD37 (0x01U)       /*!< Bit mask for LCD_WF37_BPALCD37. */
#define BS_LCD_WF37_BPALCD37 (1U)          /*!< Bit field size in bits for LCD_WF37_BPALCD37. */

/*! @brief Read current value of the LCD_WF37_BPALCD37 field. */
#define BR_LCD_WF37_BPALCD37(x) (BME_UBFX8(HW_LCD_WF37_ADDR(x), BP_LCD_WF37_BPALCD37, BS_LCD_WF37_BPALCD37))

/*! @brief Format value for bitfield LCD_WF37_BPALCD37. */
#define BF_LCD_WF37_BPALCD37(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF37_BPALCD37) & BM_LCD_WF37_BPALCD37)

/*! @brief Set the BPALCD37 field to a new value. */
#define BW_LCD_WF37_BPALCD37(x, v) (BME_BFI8(HW_LCD_WF37_ADDR(x), ((uint8_t)(v) << BP_LCD_WF37_BPALCD37), BP_LCD_WF37_BPALCD37, 1))
/*@}*/

/*!
 * @name Register LCD_WF37, field BPBLCD37[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF37_BPBLCD37 (1U)          /*!< Bit position for LCD_WF37_BPBLCD37. */
#define BM_LCD_WF37_BPBLCD37 (0x02U)       /*!< Bit mask for LCD_WF37_BPBLCD37. */
#define BS_LCD_WF37_BPBLCD37 (1U)          /*!< Bit field size in bits for LCD_WF37_BPBLCD37. */

/*! @brief Read current value of the LCD_WF37_BPBLCD37 field. */
#define BR_LCD_WF37_BPBLCD37(x) (BME_UBFX8(HW_LCD_WF37_ADDR(x), BP_LCD_WF37_BPBLCD37, BS_LCD_WF37_BPBLCD37))

/*! @brief Format value for bitfield LCD_WF37_BPBLCD37. */
#define BF_LCD_WF37_BPBLCD37(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF37_BPBLCD37) & BM_LCD_WF37_BPBLCD37)

/*! @brief Set the BPBLCD37 field to a new value. */
#define BW_LCD_WF37_BPBLCD37(x, v) (BME_BFI8(HW_LCD_WF37_ADDR(x), ((uint8_t)(v) << BP_LCD_WF37_BPBLCD37), BP_LCD_WF37_BPBLCD37, 1))
/*@}*/

/*!
 * @name Register LCD_WF37, field BPCLCD37[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF37_BPCLCD37 (2U)          /*!< Bit position for LCD_WF37_BPCLCD37. */
#define BM_LCD_WF37_BPCLCD37 (0x04U)       /*!< Bit mask for LCD_WF37_BPCLCD37. */
#define BS_LCD_WF37_BPCLCD37 (1U)          /*!< Bit field size in bits for LCD_WF37_BPCLCD37. */

/*! @brief Read current value of the LCD_WF37_BPCLCD37 field. */
#define BR_LCD_WF37_BPCLCD37(x) (BME_UBFX8(HW_LCD_WF37_ADDR(x), BP_LCD_WF37_BPCLCD37, BS_LCD_WF37_BPCLCD37))

/*! @brief Format value for bitfield LCD_WF37_BPCLCD37. */
#define BF_LCD_WF37_BPCLCD37(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF37_BPCLCD37) & BM_LCD_WF37_BPCLCD37)

/*! @brief Set the BPCLCD37 field to a new value. */
#define BW_LCD_WF37_BPCLCD37(x, v) (BME_BFI8(HW_LCD_WF37_ADDR(x), ((uint8_t)(v) << BP_LCD_WF37_BPCLCD37), BP_LCD_WF37_BPCLCD37, 1))
/*@}*/

/*!
 * @name Register LCD_WF37, field BPDLCD37[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF37_BPDLCD37 (3U)          /*!< Bit position for LCD_WF37_BPDLCD37. */
#define BM_LCD_WF37_BPDLCD37 (0x08U)       /*!< Bit mask for LCD_WF37_BPDLCD37. */
#define BS_LCD_WF37_BPDLCD37 (1U)          /*!< Bit field size in bits for LCD_WF37_BPDLCD37. */

/*! @brief Read current value of the LCD_WF37_BPDLCD37 field. */
#define BR_LCD_WF37_BPDLCD37(x) (BME_UBFX8(HW_LCD_WF37_ADDR(x), BP_LCD_WF37_BPDLCD37, BS_LCD_WF37_BPDLCD37))

/*! @brief Format value for bitfield LCD_WF37_BPDLCD37. */
#define BF_LCD_WF37_BPDLCD37(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF37_BPDLCD37) & BM_LCD_WF37_BPDLCD37)

/*! @brief Set the BPDLCD37 field to a new value. */
#define BW_LCD_WF37_BPDLCD37(x, v) (BME_BFI8(HW_LCD_WF37_ADDR(x), ((uint8_t)(v) << BP_LCD_WF37_BPDLCD37), BP_LCD_WF37_BPDLCD37, 1))
/*@}*/

/*!
 * @name Register LCD_WF37, field BPELCD37[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF37_BPELCD37 (4U)          /*!< Bit position for LCD_WF37_BPELCD37. */
#define BM_LCD_WF37_BPELCD37 (0x10U)       /*!< Bit mask for LCD_WF37_BPELCD37. */
#define BS_LCD_WF37_BPELCD37 (1U)          /*!< Bit field size in bits for LCD_WF37_BPELCD37. */

/*! @brief Read current value of the LCD_WF37_BPELCD37 field. */
#define BR_LCD_WF37_BPELCD37(x) (BME_UBFX8(HW_LCD_WF37_ADDR(x), BP_LCD_WF37_BPELCD37, BS_LCD_WF37_BPELCD37))

/*! @brief Format value for bitfield LCD_WF37_BPELCD37. */
#define BF_LCD_WF37_BPELCD37(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF37_BPELCD37) & BM_LCD_WF37_BPELCD37)

/*! @brief Set the BPELCD37 field to a new value. */
#define BW_LCD_WF37_BPELCD37(x, v) (BME_BFI8(HW_LCD_WF37_ADDR(x), ((uint8_t)(v) << BP_LCD_WF37_BPELCD37), BP_LCD_WF37_BPELCD37, 1))
/*@}*/

/*!
 * @name Register LCD_WF37, field BPFLCD37[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF37_BPFLCD37 (5U)          /*!< Bit position for LCD_WF37_BPFLCD37. */
#define BM_LCD_WF37_BPFLCD37 (0x20U)       /*!< Bit mask for LCD_WF37_BPFLCD37. */
#define BS_LCD_WF37_BPFLCD37 (1U)          /*!< Bit field size in bits for LCD_WF37_BPFLCD37. */

/*! @brief Read current value of the LCD_WF37_BPFLCD37 field. */
#define BR_LCD_WF37_BPFLCD37(x) (BME_UBFX8(HW_LCD_WF37_ADDR(x), BP_LCD_WF37_BPFLCD37, BS_LCD_WF37_BPFLCD37))

/*! @brief Format value for bitfield LCD_WF37_BPFLCD37. */
#define BF_LCD_WF37_BPFLCD37(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF37_BPFLCD37) & BM_LCD_WF37_BPFLCD37)

/*! @brief Set the BPFLCD37 field to a new value. */
#define BW_LCD_WF37_BPFLCD37(x, v) (BME_BFI8(HW_LCD_WF37_ADDR(x), ((uint8_t)(v) << BP_LCD_WF37_BPFLCD37), BP_LCD_WF37_BPFLCD37, 1))
/*@}*/

/*!
 * @name Register LCD_WF37, field BPGLCD37[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF37_BPGLCD37 (6U)          /*!< Bit position for LCD_WF37_BPGLCD37. */
#define BM_LCD_WF37_BPGLCD37 (0x40U)       /*!< Bit mask for LCD_WF37_BPGLCD37. */
#define BS_LCD_WF37_BPGLCD37 (1U)          /*!< Bit field size in bits for LCD_WF37_BPGLCD37. */

/*! @brief Read current value of the LCD_WF37_BPGLCD37 field. */
#define BR_LCD_WF37_BPGLCD37(x) (BME_UBFX8(HW_LCD_WF37_ADDR(x), BP_LCD_WF37_BPGLCD37, BS_LCD_WF37_BPGLCD37))

/*! @brief Format value for bitfield LCD_WF37_BPGLCD37. */
#define BF_LCD_WF37_BPGLCD37(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF37_BPGLCD37) & BM_LCD_WF37_BPGLCD37)

/*! @brief Set the BPGLCD37 field to a new value. */
#define BW_LCD_WF37_BPGLCD37(x, v) (BME_BFI8(HW_LCD_WF37_ADDR(x), ((uint8_t)(v) << BP_LCD_WF37_BPGLCD37), BP_LCD_WF37_BPGLCD37, 1))
/*@}*/

/*!
 * @name Register LCD_WF37, field BPHLCD37[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF37_BPHLCD37 (7U)          /*!< Bit position for LCD_WF37_BPHLCD37. */
#define BM_LCD_WF37_BPHLCD37 (0x80U)       /*!< Bit mask for LCD_WF37_BPHLCD37. */
#define BS_LCD_WF37_BPHLCD37 (1U)          /*!< Bit field size in bits for LCD_WF37_BPHLCD37. */

/*! @brief Read current value of the LCD_WF37_BPHLCD37 field. */
#define BR_LCD_WF37_BPHLCD37(x) (BME_UBFX8(HW_LCD_WF37_ADDR(x), BP_LCD_WF37_BPHLCD37, BS_LCD_WF37_BPHLCD37))

/*! @brief Format value for bitfield LCD_WF37_BPHLCD37. */
#define BF_LCD_WF37_BPHLCD37(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF37_BPHLCD37) & BM_LCD_WF37_BPHLCD37)

/*! @brief Set the BPHLCD37 field to a new value. */
#define BW_LCD_WF37_BPHLCD37(x, v) (BME_BFI8(HW_LCD_WF37_ADDR(x), ((uint8_t)(v) << BP_LCD_WF37_BPHLCD37), BP_LCD_WF37_BPHLCD37, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF38 - LCD Waveform Register 38.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF38 - LCD Waveform Register 38. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf38
{
    uint8_t U;
    struct _hw_lcd_wf38_bitfields
    {
        uint8_t BPALCD38 : 1;          /*!< [0]  */
        uint8_t BPBLCD38 : 1;          /*!< [1]  */
        uint8_t BPCLCD38 : 1;          /*!< [2]  */
        uint8_t BPDLCD38 : 1;          /*!< [3]  */
        uint8_t BPELCD38 : 1;          /*!< [4]  */
        uint8_t BPFLCD38 : 1;          /*!< [5]  */
        uint8_t BPGLCD38 : 1;          /*!< [6]  */
        uint8_t BPHLCD38 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf38_t;

/*!
 * @name Constants and macros for entire LCD_WF38 register
 */
/*@{*/
#define HW_LCD_WF38_ADDR(x)      ((uint32_t)(x) + 0x46U)

#define HW_LCD_WF38(x)           (*(__IO hw_lcd_wf38_t *) HW_LCD_WF38_ADDR(x))
#define HW_LCD_WF38_RD(x)        (HW_LCD_WF38(x).U)
#define HW_LCD_WF38_WR(x, v)     (HW_LCD_WF38(x).U = (v))
#define HW_LCD_WF38_SET(x, v)    (BME_OR8(HW_LCD_WF38_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF38_CLR(x, v)    (BME_AND8(HW_LCD_WF38_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF38_TOG(x, v)    (BME_XOR8(HW_LCD_WF38_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF38 bitfields
 */

/*!
 * @name Register LCD_WF38, field BPALCD38[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF38_BPALCD38 (0U)          /*!< Bit position for LCD_WF38_BPALCD38. */
#define BM_LCD_WF38_BPALCD38 (0x01U)       /*!< Bit mask for LCD_WF38_BPALCD38. */
#define BS_LCD_WF38_BPALCD38 (1U)          /*!< Bit field size in bits for LCD_WF38_BPALCD38. */

/*! @brief Read current value of the LCD_WF38_BPALCD38 field. */
#define BR_LCD_WF38_BPALCD38(x) (BME_UBFX8(HW_LCD_WF38_ADDR(x), BP_LCD_WF38_BPALCD38, BS_LCD_WF38_BPALCD38))

/*! @brief Format value for bitfield LCD_WF38_BPALCD38. */
#define BF_LCD_WF38_BPALCD38(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF38_BPALCD38) & BM_LCD_WF38_BPALCD38)

/*! @brief Set the BPALCD38 field to a new value. */
#define BW_LCD_WF38_BPALCD38(x, v) (BME_BFI8(HW_LCD_WF38_ADDR(x), ((uint8_t)(v) << BP_LCD_WF38_BPALCD38), BP_LCD_WF38_BPALCD38, 1))
/*@}*/

/*!
 * @name Register LCD_WF38, field BPBLCD38[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF38_BPBLCD38 (1U)          /*!< Bit position for LCD_WF38_BPBLCD38. */
#define BM_LCD_WF38_BPBLCD38 (0x02U)       /*!< Bit mask for LCD_WF38_BPBLCD38. */
#define BS_LCD_WF38_BPBLCD38 (1U)          /*!< Bit field size in bits for LCD_WF38_BPBLCD38. */

/*! @brief Read current value of the LCD_WF38_BPBLCD38 field. */
#define BR_LCD_WF38_BPBLCD38(x) (BME_UBFX8(HW_LCD_WF38_ADDR(x), BP_LCD_WF38_BPBLCD38, BS_LCD_WF38_BPBLCD38))

/*! @brief Format value for bitfield LCD_WF38_BPBLCD38. */
#define BF_LCD_WF38_BPBLCD38(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF38_BPBLCD38) & BM_LCD_WF38_BPBLCD38)

/*! @brief Set the BPBLCD38 field to a new value. */
#define BW_LCD_WF38_BPBLCD38(x, v) (BME_BFI8(HW_LCD_WF38_ADDR(x), ((uint8_t)(v) << BP_LCD_WF38_BPBLCD38), BP_LCD_WF38_BPBLCD38, 1))
/*@}*/

/*!
 * @name Register LCD_WF38, field BPCLCD38[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF38_BPCLCD38 (2U)          /*!< Bit position for LCD_WF38_BPCLCD38. */
#define BM_LCD_WF38_BPCLCD38 (0x04U)       /*!< Bit mask for LCD_WF38_BPCLCD38. */
#define BS_LCD_WF38_BPCLCD38 (1U)          /*!< Bit field size in bits for LCD_WF38_BPCLCD38. */

/*! @brief Read current value of the LCD_WF38_BPCLCD38 field. */
#define BR_LCD_WF38_BPCLCD38(x) (BME_UBFX8(HW_LCD_WF38_ADDR(x), BP_LCD_WF38_BPCLCD38, BS_LCD_WF38_BPCLCD38))

/*! @brief Format value for bitfield LCD_WF38_BPCLCD38. */
#define BF_LCD_WF38_BPCLCD38(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF38_BPCLCD38) & BM_LCD_WF38_BPCLCD38)

/*! @brief Set the BPCLCD38 field to a new value. */
#define BW_LCD_WF38_BPCLCD38(x, v) (BME_BFI8(HW_LCD_WF38_ADDR(x), ((uint8_t)(v) << BP_LCD_WF38_BPCLCD38), BP_LCD_WF38_BPCLCD38, 1))
/*@}*/

/*!
 * @name Register LCD_WF38, field BPDLCD38[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF38_BPDLCD38 (3U)          /*!< Bit position for LCD_WF38_BPDLCD38. */
#define BM_LCD_WF38_BPDLCD38 (0x08U)       /*!< Bit mask for LCD_WF38_BPDLCD38. */
#define BS_LCD_WF38_BPDLCD38 (1U)          /*!< Bit field size in bits for LCD_WF38_BPDLCD38. */

/*! @brief Read current value of the LCD_WF38_BPDLCD38 field. */
#define BR_LCD_WF38_BPDLCD38(x) (BME_UBFX8(HW_LCD_WF38_ADDR(x), BP_LCD_WF38_BPDLCD38, BS_LCD_WF38_BPDLCD38))

/*! @brief Format value for bitfield LCD_WF38_BPDLCD38. */
#define BF_LCD_WF38_BPDLCD38(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF38_BPDLCD38) & BM_LCD_WF38_BPDLCD38)

/*! @brief Set the BPDLCD38 field to a new value. */
#define BW_LCD_WF38_BPDLCD38(x, v) (BME_BFI8(HW_LCD_WF38_ADDR(x), ((uint8_t)(v) << BP_LCD_WF38_BPDLCD38), BP_LCD_WF38_BPDLCD38, 1))
/*@}*/

/*!
 * @name Register LCD_WF38, field BPELCD38[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF38_BPELCD38 (4U)          /*!< Bit position for LCD_WF38_BPELCD38. */
#define BM_LCD_WF38_BPELCD38 (0x10U)       /*!< Bit mask for LCD_WF38_BPELCD38. */
#define BS_LCD_WF38_BPELCD38 (1U)          /*!< Bit field size in bits for LCD_WF38_BPELCD38. */

/*! @brief Read current value of the LCD_WF38_BPELCD38 field. */
#define BR_LCD_WF38_BPELCD38(x) (BME_UBFX8(HW_LCD_WF38_ADDR(x), BP_LCD_WF38_BPELCD38, BS_LCD_WF38_BPELCD38))

/*! @brief Format value for bitfield LCD_WF38_BPELCD38. */
#define BF_LCD_WF38_BPELCD38(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF38_BPELCD38) & BM_LCD_WF38_BPELCD38)

/*! @brief Set the BPELCD38 field to a new value. */
#define BW_LCD_WF38_BPELCD38(x, v) (BME_BFI8(HW_LCD_WF38_ADDR(x), ((uint8_t)(v) << BP_LCD_WF38_BPELCD38), BP_LCD_WF38_BPELCD38, 1))
/*@}*/

/*!
 * @name Register LCD_WF38, field BPFLCD38[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF38_BPFLCD38 (5U)          /*!< Bit position for LCD_WF38_BPFLCD38. */
#define BM_LCD_WF38_BPFLCD38 (0x20U)       /*!< Bit mask for LCD_WF38_BPFLCD38. */
#define BS_LCD_WF38_BPFLCD38 (1U)          /*!< Bit field size in bits for LCD_WF38_BPFLCD38. */

/*! @brief Read current value of the LCD_WF38_BPFLCD38 field. */
#define BR_LCD_WF38_BPFLCD38(x) (BME_UBFX8(HW_LCD_WF38_ADDR(x), BP_LCD_WF38_BPFLCD38, BS_LCD_WF38_BPFLCD38))

/*! @brief Format value for bitfield LCD_WF38_BPFLCD38. */
#define BF_LCD_WF38_BPFLCD38(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF38_BPFLCD38) & BM_LCD_WF38_BPFLCD38)

/*! @brief Set the BPFLCD38 field to a new value. */
#define BW_LCD_WF38_BPFLCD38(x, v) (BME_BFI8(HW_LCD_WF38_ADDR(x), ((uint8_t)(v) << BP_LCD_WF38_BPFLCD38), BP_LCD_WF38_BPFLCD38, 1))
/*@}*/

/*!
 * @name Register LCD_WF38, field BPGLCD38[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF38_BPGLCD38 (6U)          /*!< Bit position for LCD_WF38_BPGLCD38. */
#define BM_LCD_WF38_BPGLCD38 (0x40U)       /*!< Bit mask for LCD_WF38_BPGLCD38. */
#define BS_LCD_WF38_BPGLCD38 (1U)          /*!< Bit field size in bits for LCD_WF38_BPGLCD38. */

/*! @brief Read current value of the LCD_WF38_BPGLCD38 field. */
#define BR_LCD_WF38_BPGLCD38(x) (BME_UBFX8(HW_LCD_WF38_ADDR(x), BP_LCD_WF38_BPGLCD38, BS_LCD_WF38_BPGLCD38))

/*! @brief Format value for bitfield LCD_WF38_BPGLCD38. */
#define BF_LCD_WF38_BPGLCD38(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF38_BPGLCD38) & BM_LCD_WF38_BPGLCD38)

/*! @brief Set the BPGLCD38 field to a new value. */
#define BW_LCD_WF38_BPGLCD38(x, v) (BME_BFI8(HW_LCD_WF38_ADDR(x), ((uint8_t)(v) << BP_LCD_WF38_BPGLCD38), BP_LCD_WF38_BPGLCD38, 1))
/*@}*/

/*!
 * @name Register LCD_WF38, field BPHLCD38[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF38_BPHLCD38 (7U)          /*!< Bit position for LCD_WF38_BPHLCD38. */
#define BM_LCD_WF38_BPHLCD38 (0x80U)       /*!< Bit mask for LCD_WF38_BPHLCD38. */
#define BS_LCD_WF38_BPHLCD38 (1U)          /*!< Bit field size in bits for LCD_WF38_BPHLCD38. */

/*! @brief Read current value of the LCD_WF38_BPHLCD38 field. */
#define BR_LCD_WF38_BPHLCD38(x) (BME_UBFX8(HW_LCD_WF38_ADDR(x), BP_LCD_WF38_BPHLCD38, BS_LCD_WF38_BPHLCD38))

/*! @brief Format value for bitfield LCD_WF38_BPHLCD38. */
#define BF_LCD_WF38_BPHLCD38(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF38_BPHLCD38) & BM_LCD_WF38_BPHLCD38)

/*! @brief Set the BPHLCD38 field to a new value. */
#define BW_LCD_WF38_BPHLCD38(x, v) (BME_BFI8(HW_LCD_WF38_ADDR(x), ((uint8_t)(v) << BP_LCD_WF38_BPHLCD38), BP_LCD_WF38_BPHLCD38, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF39 - LCD Waveform Register 39.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF39 - LCD Waveform Register 39. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf39
{
    uint8_t U;
    struct _hw_lcd_wf39_bitfields
    {
        uint8_t BPALCD39 : 1;          /*!< [0]  */
        uint8_t BPBLCD39 : 1;          /*!< [1]  */
        uint8_t BPCLCD39 : 1;          /*!< [2]  */
        uint8_t BPDLCD39 : 1;          /*!< [3]  */
        uint8_t BPELCD39 : 1;          /*!< [4]  */
        uint8_t BPFLCD39 : 1;          /*!< [5]  */
        uint8_t BPGLCD39 : 1;          /*!< [6]  */
        uint8_t BPHLCD39 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf39_t;

/*!
 * @name Constants and macros for entire LCD_WF39 register
 */
/*@{*/
#define HW_LCD_WF39_ADDR(x)      ((uint32_t)(x) + 0x47U)

#define HW_LCD_WF39(x)           (*(__IO hw_lcd_wf39_t *) HW_LCD_WF39_ADDR(x))
#define HW_LCD_WF39_RD(x)        (HW_LCD_WF39(x).U)
#define HW_LCD_WF39_WR(x, v)     (HW_LCD_WF39(x).U = (v))
#define HW_LCD_WF39_SET(x, v)    (BME_OR8(HW_LCD_WF39_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF39_CLR(x, v)    (BME_AND8(HW_LCD_WF39_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF39_TOG(x, v)    (BME_XOR8(HW_LCD_WF39_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF39 bitfields
 */

/*!
 * @name Register LCD_WF39, field BPALCD39[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF39_BPALCD39 (0U)          /*!< Bit position for LCD_WF39_BPALCD39. */
#define BM_LCD_WF39_BPALCD39 (0x01U)       /*!< Bit mask for LCD_WF39_BPALCD39. */
#define BS_LCD_WF39_BPALCD39 (1U)          /*!< Bit field size in bits for LCD_WF39_BPALCD39. */

/*! @brief Read current value of the LCD_WF39_BPALCD39 field. */
#define BR_LCD_WF39_BPALCD39(x) (BME_UBFX8(HW_LCD_WF39_ADDR(x), BP_LCD_WF39_BPALCD39, BS_LCD_WF39_BPALCD39))

/*! @brief Format value for bitfield LCD_WF39_BPALCD39. */
#define BF_LCD_WF39_BPALCD39(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF39_BPALCD39) & BM_LCD_WF39_BPALCD39)

/*! @brief Set the BPALCD39 field to a new value. */
#define BW_LCD_WF39_BPALCD39(x, v) (BME_BFI8(HW_LCD_WF39_ADDR(x), ((uint8_t)(v) << BP_LCD_WF39_BPALCD39), BP_LCD_WF39_BPALCD39, 1))
/*@}*/

/*!
 * @name Register LCD_WF39, field BPBLCD39[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF39_BPBLCD39 (1U)          /*!< Bit position for LCD_WF39_BPBLCD39. */
#define BM_LCD_WF39_BPBLCD39 (0x02U)       /*!< Bit mask for LCD_WF39_BPBLCD39. */
#define BS_LCD_WF39_BPBLCD39 (1U)          /*!< Bit field size in bits for LCD_WF39_BPBLCD39. */

/*! @brief Read current value of the LCD_WF39_BPBLCD39 field. */
#define BR_LCD_WF39_BPBLCD39(x) (BME_UBFX8(HW_LCD_WF39_ADDR(x), BP_LCD_WF39_BPBLCD39, BS_LCD_WF39_BPBLCD39))

/*! @brief Format value for bitfield LCD_WF39_BPBLCD39. */
#define BF_LCD_WF39_BPBLCD39(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF39_BPBLCD39) & BM_LCD_WF39_BPBLCD39)

/*! @brief Set the BPBLCD39 field to a new value. */
#define BW_LCD_WF39_BPBLCD39(x, v) (BME_BFI8(HW_LCD_WF39_ADDR(x), ((uint8_t)(v) << BP_LCD_WF39_BPBLCD39), BP_LCD_WF39_BPBLCD39, 1))
/*@}*/

/*!
 * @name Register LCD_WF39, field BPCLCD39[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF39_BPCLCD39 (2U)          /*!< Bit position for LCD_WF39_BPCLCD39. */
#define BM_LCD_WF39_BPCLCD39 (0x04U)       /*!< Bit mask for LCD_WF39_BPCLCD39. */
#define BS_LCD_WF39_BPCLCD39 (1U)          /*!< Bit field size in bits for LCD_WF39_BPCLCD39. */

/*! @brief Read current value of the LCD_WF39_BPCLCD39 field. */
#define BR_LCD_WF39_BPCLCD39(x) (BME_UBFX8(HW_LCD_WF39_ADDR(x), BP_LCD_WF39_BPCLCD39, BS_LCD_WF39_BPCLCD39))

/*! @brief Format value for bitfield LCD_WF39_BPCLCD39. */
#define BF_LCD_WF39_BPCLCD39(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF39_BPCLCD39) & BM_LCD_WF39_BPCLCD39)

/*! @brief Set the BPCLCD39 field to a new value. */
#define BW_LCD_WF39_BPCLCD39(x, v) (BME_BFI8(HW_LCD_WF39_ADDR(x), ((uint8_t)(v) << BP_LCD_WF39_BPCLCD39), BP_LCD_WF39_BPCLCD39, 1))
/*@}*/

/*!
 * @name Register LCD_WF39, field BPDLCD39[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF39_BPDLCD39 (3U)          /*!< Bit position for LCD_WF39_BPDLCD39. */
#define BM_LCD_WF39_BPDLCD39 (0x08U)       /*!< Bit mask for LCD_WF39_BPDLCD39. */
#define BS_LCD_WF39_BPDLCD39 (1U)          /*!< Bit field size in bits for LCD_WF39_BPDLCD39. */

/*! @brief Read current value of the LCD_WF39_BPDLCD39 field. */
#define BR_LCD_WF39_BPDLCD39(x) (BME_UBFX8(HW_LCD_WF39_ADDR(x), BP_LCD_WF39_BPDLCD39, BS_LCD_WF39_BPDLCD39))

/*! @brief Format value for bitfield LCD_WF39_BPDLCD39. */
#define BF_LCD_WF39_BPDLCD39(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF39_BPDLCD39) & BM_LCD_WF39_BPDLCD39)

/*! @brief Set the BPDLCD39 field to a new value. */
#define BW_LCD_WF39_BPDLCD39(x, v) (BME_BFI8(HW_LCD_WF39_ADDR(x), ((uint8_t)(v) << BP_LCD_WF39_BPDLCD39), BP_LCD_WF39_BPDLCD39, 1))
/*@}*/

/*!
 * @name Register LCD_WF39, field BPELCD39[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF39_BPELCD39 (4U)          /*!< Bit position for LCD_WF39_BPELCD39. */
#define BM_LCD_WF39_BPELCD39 (0x10U)       /*!< Bit mask for LCD_WF39_BPELCD39. */
#define BS_LCD_WF39_BPELCD39 (1U)          /*!< Bit field size in bits for LCD_WF39_BPELCD39. */

/*! @brief Read current value of the LCD_WF39_BPELCD39 field. */
#define BR_LCD_WF39_BPELCD39(x) (BME_UBFX8(HW_LCD_WF39_ADDR(x), BP_LCD_WF39_BPELCD39, BS_LCD_WF39_BPELCD39))

/*! @brief Format value for bitfield LCD_WF39_BPELCD39. */
#define BF_LCD_WF39_BPELCD39(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF39_BPELCD39) & BM_LCD_WF39_BPELCD39)

/*! @brief Set the BPELCD39 field to a new value. */
#define BW_LCD_WF39_BPELCD39(x, v) (BME_BFI8(HW_LCD_WF39_ADDR(x), ((uint8_t)(v) << BP_LCD_WF39_BPELCD39), BP_LCD_WF39_BPELCD39, 1))
/*@}*/

/*!
 * @name Register LCD_WF39, field BPFLCD39[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF39_BPFLCD39 (5U)          /*!< Bit position for LCD_WF39_BPFLCD39. */
#define BM_LCD_WF39_BPFLCD39 (0x20U)       /*!< Bit mask for LCD_WF39_BPFLCD39. */
#define BS_LCD_WF39_BPFLCD39 (1U)          /*!< Bit field size in bits for LCD_WF39_BPFLCD39. */

/*! @brief Read current value of the LCD_WF39_BPFLCD39 field. */
#define BR_LCD_WF39_BPFLCD39(x) (BME_UBFX8(HW_LCD_WF39_ADDR(x), BP_LCD_WF39_BPFLCD39, BS_LCD_WF39_BPFLCD39))

/*! @brief Format value for bitfield LCD_WF39_BPFLCD39. */
#define BF_LCD_WF39_BPFLCD39(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF39_BPFLCD39) & BM_LCD_WF39_BPFLCD39)

/*! @brief Set the BPFLCD39 field to a new value. */
#define BW_LCD_WF39_BPFLCD39(x, v) (BME_BFI8(HW_LCD_WF39_ADDR(x), ((uint8_t)(v) << BP_LCD_WF39_BPFLCD39), BP_LCD_WF39_BPFLCD39, 1))
/*@}*/

/*!
 * @name Register LCD_WF39, field BPGLCD39[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF39_BPGLCD39 (6U)          /*!< Bit position for LCD_WF39_BPGLCD39. */
#define BM_LCD_WF39_BPGLCD39 (0x40U)       /*!< Bit mask for LCD_WF39_BPGLCD39. */
#define BS_LCD_WF39_BPGLCD39 (1U)          /*!< Bit field size in bits for LCD_WF39_BPGLCD39. */

/*! @brief Read current value of the LCD_WF39_BPGLCD39 field. */
#define BR_LCD_WF39_BPGLCD39(x) (BME_UBFX8(HW_LCD_WF39_ADDR(x), BP_LCD_WF39_BPGLCD39, BS_LCD_WF39_BPGLCD39))

/*! @brief Format value for bitfield LCD_WF39_BPGLCD39. */
#define BF_LCD_WF39_BPGLCD39(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF39_BPGLCD39) & BM_LCD_WF39_BPGLCD39)

/*! @brief Set the BPGLCD39 field to a new value. */
#define BW_LCD_WF39_BPGLCD39(x, v) (BME_BFI8(HW_LCD_WF39_ADDR(x), ((uint8_t)(v) << BP_LCD_WF39_BPGLCD39), BP_LCD_WF39_BPGLCD39, 1))
/*@}*/

/*!
 * @name Register LCD_WF39, field BPHLCD39[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF39_BPHLCD39 (7U)          /*!< Bit position for LCD_WF39_BPHLCD39. */
#define BM_LCD_WF39_BPHLCD39 (0x80U)       /*!< Bit mask for LCD_WF39_BPHLCD39. */
#define BS_LCD_WF39_BPHLCD39 (1U)          /*!< Bit field size in bits for LCD_WF39_BPHLCD39. */

/*! @brief Read current value of the LCD_WF39_BPHLCD39 field. */
#define BR_LCD_WF39_BPHLCD39(x) (BME_UBFX8(HW_LCD_WF39_ADDR(x), BP_LCD_WF39_BPHLCD39, BS_LCD_WF39_BPHLCD39))

/*! @brief Format value for bitfield LCD_WF39_BPHLCD39. */
#define BF_LCD_WF39_BPHLCD39(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF39_BPHLCD39) & BM_LCD_WF39_BPHLCD39)

/*! @brief Set the BPHLCD39 field to a new value. */
#define BW_LCD_WF39_BPHLCD39(x, v) (BME_BFI8(HW_LCD_WF39_ADDR(x), ((uint8_t)(v) << BP_LCD_WF39_BPHLCD39), BP_LCD_WF39_BPHLCD39, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF40 - LCD Waveform Register 40.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF40 - LCD Waveform Register 40. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf40
{
    uint8_t U;
    struct _hw_lcd_wf40_bitfields
    {
        uint8_t BPALCD40 : 1;          /*!< [0]  */
        uint8_t BPBLCD40 : 1;          /*!< [1]  */
        uint8_t BPCLCD40 : 1;          /*!< [2]  */
        uint8_t BPDLCD40 : 1;          /*!< [3]  */
        uint8_t BPELCD40 : 1;          /*!< [4]  */
        uint8_t BPFLCD40 : 1;          /*!< [5]  */
        uint8_t BPGLCD40 : 1;          /*!< [6]  */
        uint8_t BPHLCD40 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf40_t;

/*!
 * @name Constants and macros for entire LCD_WF40 register
 */
/*@{*/
#define HW_LCD_WF40_ADDR(x)      ((uint32_t)(x) + 0x48U)

#define HW_LCD_WF40(x)           (*(__IO hw_lcd_wf40_t *) HW_LCD_WF40_ADDR(x))
#define HW_LCD_WF40_RD(x)        (HW_LCD_WF40(x).U)
#define HW_LCD_WF40_WR(x, v)     (HW_LCD_WF40(x).U = (v))
#define HW_LCD_WF40_SET(x, v)    (BME_OR8(HW_LCD_WF40_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF40_CLR(x, v)    (BME_AND8(HW_LCD_WF40_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF40_TOG(x, v)    (BME_XOR8(HW_LCD_WF40_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF40 bitfields
 */

/*!
 * @name Register LCD_WF40, field BPALCD40[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF40_BPALCD40 (0U)          /*!< Bit position for LCD_WF40_BPALCD40. */
#define BM_LCD_WF40_BPALCD40 (0x01U)       /*!< Bit mask for LCD_WF40_BPALCD40. */
#define BS_LCD_WF40_BPALCD40 (1U)          /*!< Bit field size in bits for LCD_WF40_BPALCD40. */

/*! @brief Read current value of the LCD_WF40_BPALCD40 field. */
#define BR_LCD_WF40_BPALCD40(x) (BME_UBFX8(HW_LCD_WF40_ADDR(x), BP_LCD_WF40_BPALCD40, BS_LCD_WF40_BPALCD40))

/*! @brief Format value for bitfield LCD_WF40_BPALCD40. */
#define BF_LCD_WF40_BPALCD40(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF40_BPALCD40) & BM_LCD_WF40_BPALCD40)

/*! @brief Set the BPALCD40 field to a new value. */
#define BW_LCD_WF40_BPALCD40(x, v) (BME_BFI8(HW_LCD_WF40_ADDR(x), ((uint8_t)(v) << BP_LCD_WF40_BPALCD40), BP_LCD_WF40_BPALCD40, 1))
/*@}*/

/*!
 * @name Register LCD_WF40, field BPBLCD40[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF40_BPBLCD40 (1U)          /*!< Bit position for LCD_WF40_BPBLCD40. */
#define BM_LCD_WF40_BPBLCD40 (0x02U)       /*!< Bit mask for LCD_WF40_BPBLCD40. */
#define BS_LCD_WF40_BPBLCD40 (1U)          /*!< Bit field size in bits for LCD_WF40_BPBLCD40. */

/*! @brief Read current value of the LCD_WF40_BPBLCD40 field. */
#define BR_LCD_WF40_BPBLCD40(x) (BME_UBFX8(HW_LCD_WF40_ADDR(x), BP_LCD_WF40_BPBLCD40, BS_LCD_WF40_BPBLCD40))

/*! @brief Format value for bitfield LCD_WF40_BPBLCD40. */
#define BF_LCD_WF40_BPBLCD40(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF40_BPBLCD40) & BM_LCD_WF40_BPBLCD40)

/*! @brief Set the BPBLCD40 field to a new value. */
#define BW_LCD_WF40_BPBLCD40(x, v) (BME_BFI8(HW_LCD_WF40_ADDR(x), ((uint8_t)(v) << BP_LCD_WF40_BPBLCD40), BP_LCD_WF40_BPBLCD40, 1))
/*@}*/

/*!
 * @name Register LCD_WF40, field BPCLCD40[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF40_BPCLCD40 (2U)          /*!< Bit position for LCD_WF40_BPCLCD40. */
#define BM_LCD_WF40_BPCLCD40 (0x04U)       /*!< Bit mask for LCD_WF40_BPCLCD40. */
#define BS_LCD_WF40_BPCLCD40 (1U)          /*!< Bit field size in bits for LCD_WF40_BPCLCD40. */

/*! @brief Read current value of the LCD_WF40_BPCLCD40 field. */
#define BR_LCD_WF40_BPCLCD40(x) (BME_UBFX8(HW_LCD_WF40_ADDR(x), BP_LCD_WF40_BPCLCD40, BS_LCD_WF40_BPCLCD40))

/*! @brief Format value for bitfield LCD_WF40_BPCLCD40. */
#define BF_LCD_WF40_BPCLCD40(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF40_BPCLCD40) & BM_LCD_WF40_BPCLCD40)

/*! @brief Set the BPCLCD40 field to a new value. */
#define BW_LCD_WF40_BPCLCD40(x, v) (BME_BFI8(HW_LCD_WF40_ADDR(x), ((uint8_t)(v) << BP_LCD_WF40_BPCLCD40), BP_LCD_WF40_BPCLCD40, 1))
/*@}*/

/*!
 * @name Register LCD_WF40, field BPDLCD40[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF40_BPDLCD40 (3U)          /*!< Bit position for LCD_WF40_BPDLCD40. */
#define BM_LCD_WF40_BPDLCD40 (0x08U)       /*!< Bit mask for LCD_WF40_BPDLCD40. */
#define BS_LCD_WF40_BPDLCD40 (1U)          /*!< Bit field size in bits for LCD_WF40_BPDLCD40. */

/*! @brief Read current value of the LCD_WF40_BPDLCD40 field. */
#define BR_LCD_WF40_BPDLCD40(x) (BME_UBFX8(HW_LCD_WF40_ADDR(x), BP_LCD_WF40_BPDLCD40, BS_LCD_WF40_BPDLCD40))

/*! @brief Format value for bitfield LCD_WF40_BPDLCD40. */
#define BF_LCD_WF40_BPDLCD40(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF40_BPDLCD40) & BM_LCD_WF40_BPDLCD40)

/*! @brief Set the BPDLCD40 field to a new value. */
#define BW_LCD_WF40_BPDLCD40(x, v) (BME_BFI8(HW_LCD_WF40_ADDR(x), ((uint8_t)(v) << BP_LCD_WF40_BPDLCD40), BP_LCD_WF40_BPDLCD40, 1))
/*@}*/

/*!
 * @name Register LCD_WF40, field BPELCD40[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF40_BPELCD40 (4U)          /*!< Bit position for LCD_WF40_BPELCD40. */
#define BM_LCD_WF40_BPELCD40 (0x10U)       /*!< Bit mask for LCD_WF40_BPELCD40. */
#define BS_LCD_WF40_BPELCD40 (1U)          /*!< Bit field size in bits for LCD_WF40_BPELCD40. */

/*! @brief Read current value of the LCD_WF40_BPELCD40 field. */
#define BR_LCD_WF40_BPELCD40(x) (BME_UBFX8(HW_LCD_WF40_ADDR(x), BP_LCD_WF40_BPELCD40, BS_LCD_WF40_BPELCD40))

/*! @brief Format value for bitfield LCD_WF40_BPELCD40. */
#define BF_LCD_WF40_BPELCD40(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF40_BPELCD40) & BM_LCD_WF40_BPELCD40)

/*! @brief Set the BPELCD40 field to a new value. */
#define BW_LCD_WF40_BPELCD40(x, v) (BME_BFI8(HW_LCD_WF40_ADDR(x), ((uint8_t)(v) << BP_LCD_WF40_BPELCD40), BP_LCD_WF40_BPELCD40, 1))
/*@}*/

/*!
 * @name Register LCD_WF40, field BPFLCD40[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF40_BPFLCD40 (5U)          /*!< Bit position for LCD_WF40_BPFLCD40. */
#define BM_LCD_WF40_BPFLCD40 (0x20U)       /*!< Bit mask for LCD_WF40_BPFLCD40. */
#define BS_LCD_WF40_BPFLCD40 (1U)          /*!< Bit field size in bits for LCD_WF40_BPFLCD40. */

/*! @brief Read current value of the LCD_WF40_BPFLCD40 field. */
#define BR_LCD_WF40_BPFLCD40(x) (BME_UBFX8(HW_LCD_WF40_ADDR(x), BP_LCD_WF40_BPFLCD40, BS_LCD_WF40_BPFLCD40))

/*! @brief Format value for bitfield LCD_WF40_BPFLCD40. */
#define BF_LCD_WF40_BPFLCD40(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF40_BPFLCD40) & BM_LCD_WF40_BPFLCD40)

/*! @brief Set the BPFLCD40 field to a new value. */
#define BW_LCD_WF40_BPFLCD40(x, v) (BME_BFI8(HW_LCD_WF40_ADDR(x), ((uint8_t)(v) << BP_LCD_WF40_BPFLCD40), BP_LCD_WF40_BPFLCD40, 1))
/*@}*/

/*!
 * @name Register LCD_WF40, field BPGLCD40[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF40_BPGLCD40 (6U)          /*!< Bit position for LCD_WF40_BPGLCD40. */
#define BM_LCD_WF40_BPGLCD40 (0x40U)       /*!< Bit mask for LCD_WF40_BPGLCD40. */
#define BS_LCD_WF40_BPGLCD40 (1U)          /*!< Bit field size in bits for LCD_WF40_BPGLCD40. */

/*! @brief Read current value of the LCD_WF40_BPGLCD40 field. */
#define BR_LCD_WF40_BPGLCD40(x) (BME_UBFX8(HW_LCD_WF40_ADDR(x), BP_LCD_WF40_BPGLCD40, BS_LCD_WF40_BPGLCD40))

/*! @brief Format value for bitfield LCD_WF40_BPGLCD40. */
#define BF_LCD_WF40_BPGLCD40(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF40_BPGLCD40) & BM_LCD_WF40_BPGLCD40)

/*! @brief Set the BPGLCD40 field to a new value. */
#define BW_LCD_WF40_BPGLCD40(x, v) (BME_BFI8(HW_LCD_WF40_ADDR(x), ((uint8_t)(v) << BP_LCD_WF40_BPGLCD40), BP_LCD_WF40_BPGLCD40, 1))
/*@}*/

/*!
 * @name Register LCD_WF40, field BPHLCD40[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF40_BPHLCD40 (7U)          /*!< Bit position for LCD_WF40_BPHLCD40. */
#define BM_LCD_WF40_BPHLCD40 (0x80U)       /*!< Bit mask for LCD_WF40_BPHLCD40. */
#define BS_LCD_WF40_BPHLCD40 (1U)          /*!< Bit field size in bits for LCD_WF40_BPHLCD40. */

/*! @brief Read current value of the LCD_WF40_BPHLCD40 field. */
#define BR_LCD_WF40_BPHLCD40(x) (BME_UBFX8(HW_LCD_WF40_ADDR(x), BP_LCD_WF40_BPHLCD40, BS_LCD_WF40_BPHLCD40))

/*! @brief Format value for bitfield LCD_WF40_BPHLCD40. */
#define BF_LCD_WF40_BPHLCD40(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF40_BPHLCD40) & BM_LCD_WF40_BPHLCD40)

/*! @brief Set the BPHLCD40 field to a new value. */
#define BW_LCD_WF40_BPHLCD40(x, v) (BME_BFI8(HW_LCD_WF40_ADDR(x), ((uint8_t)(v) << BP_LCD_WF40_BPHLCD40), BP_LCD_WF40_BPHLCD40, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF41 - LCD Waveform Register 41.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF41 - LCD Waveform Register 41. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf41
{
    uint8_t U;
    struct _hw_lcd_wf41_bitfields
    {
        uint8_t BPALCD41 : 1;          /*!< [0]  */
        uint8_t BPBLCD41 : 1;          /*!< [1]  */
        uint8_t BPCLCD41 : 1;          /*!< [2]  */
        uint8_t BPDLCD41 : 1;          /*!< [3]  */
        uint8_t BPELCD41 : 1;          /*!< [4]  */
        uint8_t BPFLCD41 : 1;          /*!< [5]  */
        uint8_t BPGLCD41 : 1;          /*!< [6]  */
        uint8_t BPHLCD41 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf41_t;

/*!
 * @name Constants and macros for entire LCD_WF41 register
 */
/*@{*/
#define HW_LCD_WF41_ADDR(x)      ((uint32_t)(x) + 0x49U)

#define HW_LCD_WF41(x)           (*(__IO hw_lcd_wf41_t *) HW_LCD_WF41_ADDR(x))
#define HW_LCD_WF41_RD(x)        (HW_LCD_WF41(x).U)
#define HW_LCD_WF41_WR(x, v)     (HW_LCD_WF41(x).U = (v))
#define HW_LCD_WF41_SET(x, v)    (BME_OR8(HW_LCD_WF41_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF41_CLR(x, v)    (BME_AND8(HW_LCD_WF41_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF41_TOG(x, v)    (BME_XOR8(HW_LCD_WF41_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF41 bitfields
 */

/*!
 * @name Register LCD_WF41, field BPALCD41[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF41_BPALCD41 (0U)          /*!< Bit position for LCD_WF41_BPALCD41. */
#define BM_LCD_WF41_BPALCD41 (0x01U)       /*!< Bit mask for LCD_WF41_BPALCD41. */
#define BS_LCD_WF41_BPALCD41 (1U)          /*!< Bit field size in bits for LCD_WF41_BPALCD41. */

/*! @brief Read current value of the LCD_WF41_BPALCD41 field. */
#define BR_LCD_WF41_BPALCD41(x) (BME_UBFX8(HW_LCD_WF41_ADDR(x), BP_LCD_WF41_BPALCD41, BS_LCD_WF41_BPALCD41))

/*! @brief Format value for bitfield LCD_WF41_BPALCD41. */
#define BF_LCD_WF41_BPALCD41(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF41_BPALCD41) & BM_LCD_WF41_BPALCD41)

/*! @brief Set the BPALCD41 field to a new value. */
#define BW_LCD_WF41_BPALCD41(x, v) (BME_BFI8(HW_LCD_WF41_ADDR(x), ((uint8_t)(v) << BP_LCD_WF41_BPALCD41), BP_LCD_WF41_BPALCD41, 1))
/*@}*/

/*!
 * @name Register LCD_WF41, field BPBLCD41[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF41_BPBLCD41 (1U)          /*!< Bit position for LCD_WF41_BPBLCD41. */
#define BM_LCD_WF41_BPBLCD41 (0x02U)       /*!< Bit mask for LCD_WF41_BPBLCD41. */
#define BS_LCD_WF41_BPBLCD41 (1U)          /*!< Bit field size in bits for LCD_WF41_BPBLCD41. */

/*! @brief Read current value of the LCD_WF41_BPBLCD41 field. */
#define BR_LCD_WF41_BPBLCD41(x) (BME_UBFX8(HW_LCD_WF41_ADDR(x), BP_LCD_WF41_BPBLCD41, BS_LCD_WF41_BPBLCD41))

/*! @brief Format value for bitfield LCD_WF41_BPBLCD41. */
#define BF_LCD_WF41_BPBLCD41(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF41_BPBLCD41) & BM_LCD_WF41_BPBLCD41)

/*! @brief Set the BPBLCD41 field to a new value. */
#define BW_LCD_WF41_BPBLCD41(x, v) (BME_BFI8(HW_LCD_WF41_ADDR(x), ((uint8_t)(v) << BP_LCD_WF41_BPBLCD41), BP_LCD_WF41_BPBLCD41, 1))
/*@}*/

/*!
 * @name Register LCD_WF41, field BPCLCD41[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF41_BPCLCD41 (2U)          /*!< Bit position for LCD_WF41_BPCLCD41. */
#define BM_LCD_WF41_BPCLCD41 (0x04U)       /*!< Bit mask for LCD_WF41_BPCLCD41. */
#define BS_LCD_WF41_BPCLCD41 (1U)          /*!< Bit field size in bits for LCD_WF41_BPCLCD41. */

/*! @brief Read current value of the LCD_WF41_BPCLCD41 field. */
#define BR_LCD_WF41_BPCLCD41(x) (BME_UBFX8(HW_LCD_WF41_ADDR(x), BP_LCD_WF41_BPCLCD41, BS_LCD_WF41_BPCLCD41))

/*! @brief Format value for bitfield LCD_WF41_BPCLCD41. */
#define BF_LCD_WF41_BPCLCD41(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF41_BPCLCD41) & BM_LCD_WF41_BPCLCD41)

/*! @brief Set the BPCLCD41 field to a new value. */
#define BW_LCD_WF41_BPCLCD41(x, v) (BME_BFI8(HW_LCD_WF41_ADDR(x), ((uint8_t)(v) << BP_LCD_WF41_BPCLCD41), BP_LCD_WF41_BPCLCD41, 1))
/*@}*/

/*!
 * @name Register LCD_WF41, field BPDLCD41[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF41_BPDLCD41 (3U)          /*!< Bit position for LCD_WF41_BPDLCD41. */
#define BM_LCD_WF41_BPDLCD41 (0x08U)       /*!< Bit mask for LCD_WF41_BPDLCD41. */
#define BS_LCD_WF41_BPDLCD41 (1U)          /*!< Bit field size in bits for LCD_WF41_BPDLCD41. */

/*! @brief Read current value of the LCD_WF41_BPDLCD41 field. */
#define BR_LCD_WF41_BPDLCD41(x) (BME_UBFX8(HW_LCD_WF41_ADDR(x), BP_LCD_WF41_BPDLCD41, BS_LCD_WF41_BPDLCD41))

/*! @brief Format value for bitfield LCD_WF41_BPDLCD41. */
#define BF_LCD_WF41_BPDLCD41(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF41_BPDLCD41) & BM_LCD_WF41_BPDLCD41)

/*! @brief Set the BPDLCD41 field to a new value. */
#define BW_LCD_WF41_BPDLCD41(x, v) (BME_BFI8(HW_LCD_WF41_ADDR(x), ((uint8_t)(v) << BP_LCD_WF41_BPDLCD41), BP_LCD_WF41_BPDLCD41, 1))
/*@}*/

/*!
 * @name Register LCD_WF41, field BPELCD41[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF41_BPELCD41 (4U)          /*!< Bit position for LCD_WF41_BPELCD41. */
#define BM_LCD_WF41_BPELCD41 (0x10U)       /*!< Bit mask for LCD_WF41_BPELCD41. */
#define BS_LCD_WF41_BPELCD41 (1U)          /*!< Bit field size in bits for LCD_WF41_BPELCD41. */

/*! @brief Read current value of the LCD_WF41_BPELCD41 field. */
#define BR_LCD_WF41_BPELCD41(x) (BME_UBFX8(HW_LCD_WF41_ADDR(x), BP_LCD_WF41_BPELCD41, BS_LCD_WF41_BPELCD41))

/*! @brief Format value for bitfield LCD_WF41_BPELCD41. */
#define BF_LCD_WF41_BPELCD41(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF41_BPELCD41) & BM_LCD_WF41_BPELCD41)

/*! @brief Set the BPELCD41 field to a new value. */
#define BW_LCD_WF41_BPELCD41(x, v) (BME_BFI8(HW_LCD_WF41_ADDR(x), ((uint8_t)(v) << BP_LCD_WF41_BPELCD41), BP_LCD_WF41_BPELCD41, 1))
/*@}*/

/*!
 * @name Register LCD_WF41, field BPFLCD41[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF41_BPFLCD41 (5U)          /*!< Bit position for LCD_WF41_BPFLCD41. */
#define BM_LCD_WF41_BPFLCD41 (0x20U)       /*!< Bit mask for LCD_WF41_BPFLCD41. */
#define BS_LCD_WF41_BPFLCD41 (1U)          /*!< Bit field size in bits for LCD_WF41_BPFLCD41. */

/*! @brief Read current value of the LCD_WF41_BPFLCD41 field. */
#define BR_LCD_WF41_BPFLCD41(x) (BME_UBFX8(HW_LCD_WF41_ADDR(x), BP_LCD_WF41_BPFLCD41, BS_LCD_WF41_BPFLCD41))

/*! @brief Format value for bitfield LCD_WF41_BPFLCD41. */
#define BF_LCD_WF41_BPFLCD41(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF41_BPFLCD41) & BM_LCD_WF41_BPFLCD41)

/*! @brief Set the BPFLCD41 field to a new value. */
#define BW_LCD_WF41_BPFLCD41(x, v) (BME_BFI8(HW_LCD_WF41_ADDR(x), ((uint8_t)(v) << BP_LCD_WF41_BPFLCD41), BP_LCD_WF41_BPFLCD41, 1))
/*@}*/

/*!
 * @name Register LCD_WF41, field BPGLCD41[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF41_BPGLCD41 (6U)          /*!< Bit position for LCD_WF41_BPGLCD41. */
#define BM_LCD_WF41_BPGLCD41 (0x40U)       /*!< Bit mask for LCD_WF41_BPGLCD41. */
#define BS_LCD_WF41_BPGLCD41 (1U)          /*!< Bit field size in bits for LCD_WF41_BPGLCD41. */

/*! @brief Read current value of the LCD_WF41_BPGLCD41 field. */
#define BR_LCD_WF41_BPGLCD41(x) (BME_UBFX8(HW_LCD_WF41_ADDR(x), BP_LCD_WF41_BPGLCD41, BS_LCD_WF41_BPGLCD41))

/*! @brief Format value for bitfield LCD_WF41_BPGLCD41. */
#define BF_LCD_WF41_BPGLCD41(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF41_BPGLCD41) & BM_LCD_WF41_BPGLCD41)

/*! @brief Set the BPGLCD41 field to a new value. */
#define BW_LCD_WF41_BPGLCD41(x, v) (BME_BFI8(HW_LCD_WF41_ADDR(x), ((uint8_t)(v) << BP_LCD_WF41_BPGLCD41), BP_LCD_WF41_BPGLCD41, 1))
/*@}*/

/*!
 * @name Register LCD_WF41, field BPHLCD41[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF41_BPHLCD41 (7U)          /*!< Bit position for LCD_WF41_BPHLCD41. */
#define BM_LCD_WF41_BPHLCD41 (0x80U)       /*!< Bit mask for LCD_WF41_BPHLCD41. */
#define BS_LCD_WF41_BPHLCD41 (1U)          /*!< Bit field size in bits for LCD_WF41_BPHLCD41. */

/*! @brief Read current value of the LCD_WF41_BPHLCD41 field. */
#define BR_LCD_WF41_BPHLCD41(x) (BME_UBFX8(HW_LCD_WF41_ADDR(x), BP_LCD_WF41_BPHLCD41, BS_LCD_WF41_BPHLCD41))

/*! @brief Format value for bitfield LCD_WF41_BPHLCD41. */
#define BF_LCD_WF41_BPHLCD41(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF41_BPHLCD41) & BM_LCD_WF41_BPHLCD41)

/*! @brief Set the BPHLCD41 field to a new value. */
#define BW_LCD_WF41_BPHLCD41(x, v) (BME_BFI8(HW_LCD_WF41_ADDR(x), ((uint8_t)(v) << BP_LCD_WF41_BPHLCD41), BP_LCD_WF41_BPHLCD41, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF42 - LCD Waveform Register 42.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF42 - LCD Waveform Register 42. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf42
{
    uint8_t U;
    struct _hw_lcd_wf42_bitfields
    {
        uint8_t BPALCD42 : 1;          /*!< [0]  */
        uint8_t BPBLCD42 : 1;          /*!< [1]  */
        uint8_t BPCLCD42 : 1;          /*!< [2]  */
        uint8_t BPDLCD42 : 1;          /*!< [3]  */
        uint8_t BPELCD42 : 1;          /*!< [4]  */
        uint8_t BPFLCD42 : 1;          /*!< [5]  */
        uint8_t BPGLCD42 : 1;          /*!< [6]  */
        uint8_t BPHLCD42 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf42_t;

/*!
 * @name Constants and macros for entire LCD_WF42 register
 */
/*@{*/
#define HW_LCD_WF42_ADDR(x)      ((uint32_t)(x) + 0x4AU)

#define HW_LCD_WF42(x)           (*(__IO hw_lcd_wf42_t *) HW_LCD_WF42_ADDR(x))
#define HW_LCD_WF42_RD(x)        (HW_LCD_WF42(x).U)
#define HW_LCD_WF42_WR(x, v)     (HW_LCD_WF42(x).U = (v))
#define HW_LCD_WF42_SET(x, v)    (BME_OR8(HW_LCD_WF42_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF42_CLR(x, v)    (BME_AND8(HW_LCD_WF42_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF42_TOG(x, v)    (BME_XOR8(HW_LCD_WF42_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF42 bitfields
 */

/*!
 * @name Register LCD_WF42, field BPALCD42[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF42_BPALCD42 (0U)          /*!< Bit position for LCD_WF42_BPALCD42. */
#define BM_LCD_WF42_BPALCD42 (0x01U)       /*!< Bit mask for LCD_WF42_BPALCD42. */
#define BS_LCD_WF42_BPALCD42 (1U)          /*!< Bit field size in bits for LCD_WF42_BPALCD42. */

/*! @brief Read current value of the LCD_WF42_BPALCD42 field. */
#define BR_LCD_WF42_BPALCD42(x) (BME_UBFX8(HW_LCD_WF42_ADDR(x), BP_LCD_WF42_BPALCD42, BS_LCD_WF42_BPALCD42))

/*! @brief Format value for bitfield LCD_WF42_BPALCD42. */
#define BF_LCD_WF42_BPALCD42(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF42_BPALCD42) & BM_LCD_WF42_BPALCD42)

/*! @brief Set the BPALCD42 field to a new value. */
#define BW_LCD_WF42_BPALCD42(x, v) (BME_BFI8(HW_LCD_WF42_ADDR(x), ((uint8_t)(v) << BP_LCD_WF42_BPALCD42), BP_LCD_WF42_BPALCD42, 1))
/*@}*/

/*!
 * @name Register LCD_WF42, field BPBLCD42[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF42_BPBLCD42 (1U)          /*!< Bit position for LCD_WF42_BPBLCD42. */
#define BM_LCD_WF42_BPBLCD42 (0x02U)       /*!< Bit mask for LCD_WF42_BPBLCD42. */
#define BS_LCD_WF42_BPBLCD42 (1U)          /*!< Bit field size in bits for LCD_WF42_BPBLCD42. */

/*! @brief Read current value of the LCD_WF42_BPBLCD42 field. */
#define BR_LCD_WF42_BPBLCD42(x) (BME_UBFX8(HW_LCD_WF42_ADDR(x), BP_LCD_WF42_BPBLCD42, BS_LCD_WF42_BPBLCD42))

/*! @brief Format value for bitfield LCD_WF42_BPBLCD42. */
#define BF_LCD_WF42_BPBLCD42(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF42_BPBLCD42) & BM_LCD_WF42_BPBLCD42)

/*! @brief Set the BPBLCD42 field to a new value. */
#define BW_LCD_WF42_BPBLCD42(x, v) (BME_BFI8(HW_LCD_WF42_ADDR(x), ((uint8_t)(v) << BP_LCD_WF42_BPBLCD42), BP_LCD_WF42_BPBLCD42, 1))
/*@}*/

/*!
 * @name Register LCD_WF42, field BPCLCD42[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF42_BPCLCD42 (2U)          /*!< Bit position for LCD_WF42_BPCLCD42. */
#define BM_LCD_WF42_BPCLCD42 (0x04U)       /*!< Bit mask for LCD_WF42_BPCLCD42. */
#define BS_LCD_WF42_BPCLCD42 (1U)          /*!< Bit field size in bits for LCD_WF42_BPCLCD42. */

/*! @brief Read current value of the LCD_WF42_BPCLCD42 field. */
#define BR_LCD_WF42_BPCLCD42(x) (BME_UBFX8(HW_LCD_WF42_ADDR(x), BP_LCD_WF42_BPCLCD42, BS_LCD_WF42_BPCLCD42))

/*! @brief Format value for bitfield LCD_WF42_BPCLCD42. */
#define BF_LCD_WF42_BPCLCD42(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF42_BPCLCD42) & BM_LCD_WF42_BPCLCD42)

/*! @brief Set the BPCLCD42 field to a new value. */
#define BW_LCD_WF42_BPCLCD42(x, v) (BME_BFI8(HW_LCD_WF42_ADDR(x), ((uint8_t)(v) << BP_LCD_WF42_BPCLCD42), BP_LCD_WF42_BPCLCD42, 1))
/*@}*/

/*!
 * @name Register LCD_WF42, field BPDLCD42[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF42_BPDLCD42 (3U)          /*!< Bit position for LCD_WF42_BPDLCD42. */
#define BM_LCD_WF42_BPDLCD42 (0x08U)       /*!< Bit mask for LCD_WF42_BPDLCD42. */
#define BS_LCD_WF42_BPDLCD42 (1U)          /*!< Bit field size in bits for LCD_WF42_BPDLCD42. */

/*! @brief Read current value of the LCD_WF42_BPDLCD42 field. */
#define BR_LCD_WF42_BPDLCD42(x) (BME_UBFX8(HW_LCD_WF42_ADDR(x), BP_LCD_WF42_BPDLCD42, BS_LCD_WF42_BPDLCD42))

/*! @brief Format value for bitfield LCD_WF42_BPDLCD42. */
#define BF_LCD_WF42_BPDLCD42(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF42_BPDLCD42) & BM_LCD_WF42_BPDLCD42)

/*! @brief Set the BPDLCD42 field to a new value. */
#define BW_LCD_WF42_BPDLCD42(x, v) (BME_BFI8(HW_LCD_WF42_ADDR(x), ((uint8_t)(v) << BP_LCD_WF42_BPDLCD42), BP_LCD_WF42_BPDLCD42, 1))
/*@}*/

/*!
 * @name Register LCD_WF42, field BPELCD42[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF42_BPELCD42 (4U)          /*!< Bit position for LCD_WF42_BPELCD42. */
#define BM_LCD_WF42_BPELCD42 (0x10U)       /*!< Bit mask for LCD_WF42_BPELCD42. */
#define BS_LCD_WF42_BPELCD42 (1U)          /*!< Bit field size in bits for LCD_WF42_BPELCD42. */

/*! @brief Read current value of the LCD_WF42_BPELCD42 field. */
#define BR_LCD_WF42_BPELCD42(x) (BME_UBFX8(HW_LCD_WF42_ADDR(x), BP_LCD_WF42_BPELCD42, BS_LCD_WF42_BPELCD42))

/*! @brief Format value for bitfield LCD_WF42_BPELCD42. */
#define BF_LCD_WF42_BPELCD42(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF42_BPELCD42) & BM_LCD_WF42_BPELCD42)

/*! @brief Set the BPELCD42 field to a new value. */
#define BW_LCD_WF42_BPELCD42(x, v) (BME_BFI8(HW_LCD_WF42_ADDR(x), ((uint8_t)(v) << BP_LCD_WF42_BPELCD42), BP_LCD_WF42_BPELCD42, 1))
/*@}*/

/*!
 * @name Register LCD_WF42, field BPFLCD42[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF42_BPFLCD42 (5U)          /*!< Bit position for LCD_WF42_BPFLCD42. */
#define BM_LCD_WF42_BPFLCD42 (0x20U)       /*!< Bit mask for LCD_WF42_BPFLCD42. */
#define BS_LCD_WF42_BPFLCD42 (1U)          /*!< Bit field size in bits for LCD_WF42_BPFLCD42. */

/*! @brief Read current value of the LCD_WF42_BPFLCD42 field. */
#define BR_LCD_WF42_BPFLCD42(x) (BME_UBFX8(HW_LCD_WF42_ADDR(x), BP_LCD_WF42_BPFLCD42, BS_LCD_WF42_BPFLCD42))

/*! @brief Format value for bitfield LCD_WF42_BPFLCD42. */
#define BF_LCD_WF42_BPFLCD42(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF42_BPFLCD42) & BM_LCD_WF42_BPFLCD42)

/*! @brief Set the BPFLCD42 field to a new value. */
#define BW_LCD_WF42_BPFLCD42(x, v) (BME_BFI8(HW_LCD_WF42_ADDR(x), ((uint8_t)(v) << BP_LCD_WF42_BPFLCD42), BP_LCD_WF42_BPFLCD42, 1))
/*@}*/

/*!
 * @name Register LCD_WF42, field BPGLCD42[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF42_BPGLCD42 (6U)          /*!< Bit position for LCD_WF42_BPGLCD42. */
#define BM_LCD_WF42_BPGLCD42 (0x40U)       /*!< Bit mask for LCD_WF42_BPGLCD42. */
#define BS_LCD_WF42_BPGLCD42 (1U)          /*!< Bit field size in bits for LCD_WF42_BPGLCD42. */

/*! @brief Read current value of the LCD_WF42_BPGLCD42 field. */
#define BR_LCD_WF42_BPGLCD42(x) (BME_UBFX8(HW_LCD_WF42_ADDR(x), BP_LCD_WF42_BPGLCD42, BS_LCD_WF42_BPGLCD42))

/*! @brief Format value for bitfield LCD_WF42_BPGLCD42. */
#define BF_LCD_WF42_BPGLCD42(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF42_BPGLCD42) & BM_LCD_WF42_BPGLCD42)

/*! @brief Set the BPGLCD42 field to a new value. */
#define BW_LCD_WF42_BPGLCD42(x, v) (BME_BFI8(HW_LCD_WF42_ADDR(x), ((uint8_t)(v) << BP_LCD_WF42_BPGLCD42), BP_LCD_WF42_BPGLCD42, 1))
/*@}*/

/*!
 * @name Register LCD_WF42, field BPHLCD42[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF42_BPHLCD42 (7U)          /*!< Bit position for LCD_WF42_BPHLCD42. */
#define BM_LCD_WF42_BPHLCD42 (0x80U)       /*!< Bit mask for LCD_WF42_BPHLCD42. */
#define BS_LCD_WF42_BPHLCD42 (1U)          /*!< Bit field size in bits for LCD_WF42_BPHLCD42. */

/*! @brief Read current value of the LCD_WF42_BPHLCD42 field. */
#define BR_LCD_WF42_BPHLCD42(x) (BME_UBFX8(HW_LCD_WF42_ADDR(x), BP_LCD_WF42_BPHLCD42, BS_LCD_WF42_BPHLCD42))

/*! @brief Format value for bitfield LCD_WF42_BPHLCD42. */
#define BF_LCD_WF42_BPHLCD42(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF42_BPHLCD42) & BM_LCD_WF42_BPHLCD42)

/*! @brief Set the BPHLCD42 field to a new value. */
#define BW_LCD_WF42_BPHLCD42(x, v) (BME_BFI8(HW_LCD_WF42_ADDR(x), ((uint8_t)(v) << BP_LCD_WF42_BPHLCD42), BP_LCD_WF42_BPHLCD42, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF43 - LCD Waveform Register 43.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF43 - LCD Waveform Register 43. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf43
{
    uint8_t U;
    struct _hw_lcd_wf43_bitfields
    {
        uint8_t BPALCD43 : 1;          /*!< [0]  */
        uint8_t BPBLCD43 : 1;          /*!< [1]  */
        uint8_t BPCLCD43 : 1;          /*!< [2]  */
        uint8_t BPDLCD43 : 1;          /*!< [3]  */
        uint8_t BPELCD43 : 1;          /*!< [4]  */
        uint8_t BPFLCD43 : 1;          /*!< [5]  */
        uint8_t BPGLCD43 : 1;          /*!< [6]  */
        uint8_t BPHLCD43 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf43_t;

/*!
 * @name Constants and macros for entire LCD_WF43 register
 */
/*@{*/
#define HW_LCD_WF43_ADDR(x)      ((uint32_t)(x) + 0x4BU)

#define HW_LCD_WF43(x)           (*(__IO hw_lcd_wf43_t *) HW_LCD_WF43_ADDR(x))
#define HW_LCD_WF43_RD(x)        (HW_LCD_WF43(x).U)
#define HW_LCD_WF43_WR(x, v)     (HW_LCD_WF43(x).U = (v))
#define HW_LCD_WF43_SET(x, v)    (BME_OR8(HW_LCD_WF43_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF43_CLR(x, v)    (BME_AND8(HW_LCD_WF43_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF43_TOG(x, v)    (BME_XOR8(HW_LCD_WF43_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF43 bitfields
 */

/*!
 * @name Register LCD_WF43, field BPALCD43[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF43_BPALCD43 (0U)          /*!< Bit position for LCD_WF43_BPALCD43. */
#define BM_LCD_WF43_BPALCD43 (0x01U)       /*!< Bit mask for LCD_WF43_BPALCD43. */
#define BS_LCD_WF43_BPALCD43 (1U)          /*!< Bit field size in bits for LCD_WF43_BPALCD43. */

/*! @brief Read current value of the LCD_WF43_BPALCD43 field. */
#define BR_LCD_WF43_BPALCD43(x) (BME_UBFX8(HW_LCD_WF43_ADDR(x), BP_LCD_WF43_BPALCD43, BS_LCD_WF43_BPALCD43))

/*! @brief Format value for bitfield LCD_WF43_BPALCD43. */
#define BF_LCD_WF43_BPALCD43(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF43_BPALCD43) & BM_LCD_WF43_BPALCD43)

/*! @brief Set the BPALCD43 field to a new value. */
#define BW_LCD_WF43_BPALCD43(x, v) (BME_BFI8(HW_LCD_WF43_ADDR(x), ((uint8_t)(v) << BP_LCD_WF43_BPALCD43), BP_LCD_WF43_BPALCD43, 1))
/*@}*/

/*!
 * @name Register LCD_WF43, field BPBLCD43[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF43_BPBLCD43 (1U)          /*!< Bit position for LCD_WF43_BPBLCD43. */
#define BM_LCD_WF43_BPBLCD43 (0x02U)       /*!< Bit mask for LCD_WF43_BPBLCD43. */
#define BS_LCD_WF43_BPBLCD43 (1U)          /*!< Bit field size in bits for LCD_WF43_BPBLCD43. */

/*! @brief Read current value of the LCD_WF43_BPBLCD43 field. */
#define BR_LCD_WF43_BPBLCD43(x) (BME_UBFX8(HW_LCD_WF43_ADDR(x), BP_LCD_WF43_BPBLCD43, BS_LCD_WF43_BPBLCD43))

/*! @brief Format value for bitfield LCD_WF43_BPBLCD43. */
#define BF_LCD_WF43_BPBLCD43(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF43_BPBLCD43) & BM_LCD_WF43_BPBLCD43)

/*! @brief Set the BPBLCD43 field to a new value. */
#define BW_LCD_WF43_BPBLCD43(x, v) (BME_BFI8(HW_LCD_WF43_ADDR(x), ((uint8_t)(v) << BP_LCD_WF43_BPBLCD43), BP_LCD_WF43_BPBLCD43, 1))
/*@}*/

/*!
 * @name Register LCD_WF43, field BPCLCD43[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF43_BPCLCD43 (2U)          /*!< Bit position for LCD_WF43_BPCLCD43. */
#define BM_LCD_WF43_BPCLCD43 (0x04U)       /*!< Bit mask for LCD_WF43_BPCLCD43. */
#define BS_LCD_WF43_BPCLCD43 (1U)          /*!< Bit field size in bits for LCD_WF43_BPCLCD43. */

/*! @brief Read current value of the LCD_WF43_BPCLCD43 field. */
#define BR_LCD_WF43_BPCLCD43(x) (BME_UBFX8(HW_LCD_WF43_ADDR(x), BP_LCD_WF43_BPCLCD43, BS_LCD_WF43_BPCLCD43))

/*! @brief Format value for bitfield LCD_WF43_BPCLCD43. */
#define BF_LCD_WF43_BPCLCD43(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF43_BPCLCD43) & BM_LCD_WF43_BPCLCD43)

/*! @brief Set the BPCLCD43 field to a new value. */
#define BW_LCD_WF43_BPCLCD43(x, v) (BME_BFI8(HW_LCD_WF43_ADDR(x), ((uint8_t)(v) << BP_LCD_WF43_BPCLCD43), BP_LCD_WF43_BPCLCD43, 1))
/*@}*/

/*!
 * @name Register LCD_WF43, field BPDLCD43[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF43_BPDLCD43 (3U)          /*!< Bit position for LCD_WF43_BPDLCD43. */
#define BM_LCD_WF43_BPDLCD43 (0x08U)       /*!< Bit mask for LCD_WF43_BPDLCD43. */
#define BS_LCD_WF43_BPDLCD43 (1U)          /*!< Bit field size in bits for LCD_WF43_BPDLCD43. */

/*! @brief Read current value of the LCD_WF43_BPDLCD43 field. */
#define BR_LCD_WF43_BPDLCD43(x) (BME_UBFX8(HW_LCD_WF43_ADDR(x), BP_LCD_WF43_BPDLCD43, BS_LCD_WF43_BPDLCD43))

/*! @brief Format value for bitfield LCD_WF43_BPDLCD43. */
#define BF_LCD_WF43_BPDLCD43(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF43_BPDLCD43) & BM_LCD_WF43_BPDLCD43)

/*! @brief Set the BPDLCD43 field to a new value. */
#define BW_LCD_WF43_BPDLCD43(x, v) (BME_BFI8(HW_LCD_WF43_ADDR(x), ((uint8_t)(v) << BP_LCD_WF43_BPDLCD43), BP_LCD_WF43_BPDLCD43, 1))
/*@}*/

/*!
 * @name Register LCD_WF43, field BPELCD43[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF43_BPELCD43 (4U)          /*!< Bit position for LCD_WF43_BPELCD43. */
#define BM_LCD_WF43_BPELCD43 (0x10U)       /*!< Bit mask for LCD_WF43_BPELCD43. */
#define BS_LCD_WF43_BPELCD43 (1U)          /*!< Bit field size in bits for LCD_WF43_BPELCD43. */

/*! @brief Read current value of the LCD_WF43_BPELCD43 field. */
#define BR_LCD_WF43_BPELCD43(x) (BME_UBFX8(HW_LCD_WF43_ADDR(x), BP_LCD_WF43_BPELCD43, BS_LCD_WF43_BPELCD43))

/*! @brief Format value for bitfield LCD_WF43_BPELCD43. */
#define BF_LCD_WF43_BPELCD43(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF43_BPELCD43) & BM_LCD_WF43_BPELCD43)

/*! @brief Set the BPELCD43 field to a new value. */
#define BW_LCD_WF43_BPELCD43(x, v) (BME_BFI8(HW_LCD_WF43_ADDR(x), ((uint8_t)(v) << BP_LCD_WF43_BPELCD43), BP_LCD_WF43_BPELCD43, 1))
/*@}*/

/*!
 * @name Register LCD_WF43, field BPFLCD43[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF43_BPFLCD43 (5U)          /*!< Bit position for LCD_WF43_BPFLCD43. */
#define BM_LCD_WF43_BPFLCD43 (0x20U)       /*!< Bit mask for LCD_WF43_BPFLCD43. */
#define BS_LCD_WF43_BPFLCD43 (1U)          /*!< Bit field size in bits for LCD_WF43_BPFLCD43. */

/*! @brief Read current value of the LCD_WF43_BPFLCD43 field. */
#define BR_LCD_WF43_BPFLCD43(x) (BME_UBFX8(HW_LCD_WF43_ADDR(x), BP_LCD_WF43_BPFLCD43, BS_LCD_WF43_BPFLCD43))

/*! @brief Format value for bitfield LCD_WF43_BPFLCD43. */
#define BF_LCD_WF43_BPFLCD43(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF43_BPFLCD43) & BM_LCD_WF43_BPFLCD43)

/*! @brief Set the BPFLCD43 field to a new value. */
#define BW_LCD_WF43_BPFLCD43(x, v) (BME_BFI8(HW_LCD_WF43_ADDR(x), ((uint8_t)(v) << BP_LCD_WF43_BPFLCD43), BP_LCD_WF43_BPFLCD43, 1))
/*@}*/

/*!
 * @name Register LCD_WF43, field BPGLCD43[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF43_BPGLCD43 (6U)          /*!< Bit position for LCD_WF43_BPGLCD43. */
#define BM_LCD_WF43_BPGLCD43 (0x40U)       /*!< Bit mask for LCD_WF43_BPGLCD43. */
#define BS_LCD_WF43_BPGLCD43 (1U)          /*!< Bit field size in bits for LCD_WF43_BPGLCD43. */

/*! @brief Read current value of the LCD_WF43_BPGLCD43 field. */
#define BR_LCD_WF43_BPGLCD43(x) (BME_UBFX8(HW_LCD_WF43_ADDR(x), BP_LCD_WF43_BPGLCD43, BS_LCD_WF43_BPGLCD43))

/*! @brief Format value for bitfield LCD_WF43_BPGLCD43. */
#define BF_LCD_WF43_BPGLCD43(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF43_BPGLCD43) & BM_LCD_WF43_BPGLCD43)

/*! @brief Set the BPGLCD43 field to a new value. */
#define BW_LCD_WF43_BPGLCD43(x, v) (BME_BFI8(HW_LCD_WF43_ADDR(x), ((uint8_t)(v) << BP_LCD_WF43_BPGLCD43), BP_LCD_WF43_BPGLCD43, 1))
/*@}*/

/*!
 * @name Register LCD_WF43, field BPHLCD43[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF43_BPHLCD43 (7U)          /*!< Bit position for LCD_WF43_BPHLCD43. */
#define BM_LCD_WF43_BPHLCD43 (0x80U)       /*!< Bit mask for LCD_WF43_BPHLCD43. */
#define BS_LCD_WF43_BPHLCD43 (1U)          /*!< Bit field size in bits for LCD_WF43_BPHLCD43. */

/*! @brief Read current value of the LCD_WF43_BPHLCD43 field. */
#define BR_LCD_WF43_BPHLCD43(x) (BME_UBFX8(HW_LCD_WF43_ADDR(x), BP_LCD_WF43_BPHLCD43, BS_LCD_WF43_BPHLCD43))

/*! @brief Format value for bitfield LCD_WF43_BPHLCD43. */
#define BF_LCD_WF43_BPHLCD43(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF43_BPHLCD43) & BM_LCD_WF43_BPHLCD43)

/*! @brief Set the BPHLCD43 field to a new value. */
#define BW_LCD_WF43_BPHLCD43(x, v) (BME_BFI8(HW_LCD_WF43_ADDR(x), ((uint8_t)(v) << BP_LCD_WF43_BPHLCD43), BP_LCD_WF43_BPHLCD43, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF44 - LCD Waveform Register 44.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF44 - LCD Waveform Register 44. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf44
{
    uint8_t U;
    struct _hw_lcd_wf44_bitfields
    {
        uint8_t BPALCD44 : 1;          /*!< [0]  */
        uint8_t BPBLCD44 : 1;          /*!< [1]  */
        uint8_t BPCLCD44 : 1;          /*!< [2]  */
        uint8_t BPDLCD44 : 1;          /*!< [3]  */
        uint8_t BPELCD44 : 1;          /*!< [4]  */
        uint8_t BPFLCD44 : 1;          /*!< [5]  */
        uint8_t BPGLCD44 : 1;          /*!< [6]  */
        uint8_t BPHLCD44 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf44_t;

/*!
 * @name Constants and macros for entire LCD_WF44 register
 */
/*@{*/
#define HW_LCD_WF44_ADDR(x)      ((uint32_t)(x) + 0x4CU)

#define HW_LCD_WF44(x)           (*(__IO hw_lcd_wf44_t *) HW_LCD_WF44_ADDR(x))
#define HW_LCD_WF44_RD(x)        (HW_LCD_WF44(x).U)
#define HW_LCD_WF44_WR(x, v)     (HW_LCD_WF44(x).U = (v))
#define HW_LCD_WF44_SET(x, v)    (BME_OR8(HW_LCD_WF44_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF44_CLR(x, v)    (BME_AND8(HW_LCD_WF44_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF44_TOG(x, v)    (BME_XOR8(HW_LCD_WF44_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF44 bitfields
 */

/*!
 * @name Register LCD_WF44, field BPALCD44[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF44_BPALCD44 (0U)          /*!< Bit position for LCD_WF44_BPALCD44. */
#define BM_LCD_WF44_BPALCD44 (0x01U)       /*!< Bit mask for LCD_WF44_BPALCD44. */
#define BS_LCD_WF44_BPALCD44 (1U)          /*!< Bit field size in bits for LCD_WF44_BPALCD44. */

/*! @brief Read current value of the LCD_WF44_BPALCD44 field. */
#define BR_LCD_WF44_BPALCD44(x) (BME_UBFX8(HW_LCD_WF44_ADDR(x), BP_LCD_WF44_BPALCD44, BS_LCD_WF44_BPALCD44))

/*! @brief Format value for bitfield LCD_WF44_BPALCD44. */
#define BF_LCD_WF44_BPALCD44(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF44_BPALCD44) & BM_LCD_WF44_BPALCD44)

/*! @brief Set the BPALCD44 field to a new value. */
#define BW_LCD_WF44_BPALCD44(x, v) (BME_BFI8(HW_LCD_WF44_ADDR(x), ((uint8_t)(v) << BP_LCD_WF44_BPALCD44), BP_LCD_WF44_BPALCD44, 1))
/*@}*/

/*!
 * @name Register LCD_WF44, field BPBLCD44[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF44_BPBLCD44 (1U)          /*!< Bit position for LCD_WF44_BPBLCD44. */
#define BM_LCD_WF44_BPBLCD44 (0x02U)       /*!< Bit mask for LCD_WF44_BPBLCD44. */
#define BS_LCD_WF44_BPBLCD44 (1U)          /*!< Bit field size in bits for LCD_WF44_BPBLCD44. */

/*! @brief Read current value of the LCD_WF44_BPBLCD44 field. */
#define BR_LCD_WF44_BPBLCD44(x) (BME_UBFX8(HW_LCD_WF44_ADDR(x), BP_LCD_WF44_BPBLCD44, BS_LCD_WF44_BPBLCD44))

/*! @brief Format value for bitfield LCD_WF44_BPBLCD44. */
#define BF_LCD_WF44_BPBLCD44(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF44_BPBLCD44) & BM_LCD_WF44_BPBLCD44)

/*! @brief Set the BPBLCD44 field to a new value. */
#define BW_LCD_WF44_BPBLCD44(x, v) (BME_BFI8(HW_LCD_WF44_ADDR(x), ((uint8_t)(v) << BP_LCD_WF44_BPBLCD44), BP_LCD_WF44_BPBLCD44, 1))
/*@}*/

/*!
 * @name Register LCD_WF44, field BPCLCD44[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF44_BPCLCD44 (2U)          /*!< Bit position for LCD_WF44_BPCLCD44. */
#define BM_LCD_WF44_BPCLCD44 (0x04U)       /*!< Bit mask for LCD_WF44_BPCLCD44. */
#define BS_LCD_WF44_BPCLCD44 (1U)          /*!< Bit field size in bits for LCD_WF44_BPCLCD44. */

/*! @brief Read current value of the LCD_WF44_BPCLCD44 field. */
#define BR_LCD_WF44_BPCLCD44(x) (BME_UBFX8(HW_LCD_WF44_ADDR(x), BP_LCD_WF44_BPCLCD44, BS_LCD_WF44_BPCLCD44))

/*! @brief Format value for bitfield LCD_WF44_BPCLCD44. */
#define BF_LCD_WF44_BPCLCD44(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF44_BPCLCD44) & BM_LCD_WF44_BPCLCD44)

/*! @brief Set the BPCLCD44 field to a new value. */
#define BW_LCD_WF44_BPCLCD44(x, v) (BME_BFI8(HW_LCD_WF44_ADDR(x), ((uint8_t)(v) << BP_LCD_WF44_BPCLCD44), BP_LCD_WF44_BPCLCD44, 1))
/*@}*/

/*!
 * @name Register LCD_WF44, field BPDLCD44[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF44_BPDLCD44 (3U)          /*!< Bit position for LCD_WF44_BPDLCD44. */
#define BM_LCD_WF44_BPDLCD44 (0x08U)       /*!< Bit mask for LCD_WF44_BPDLCD44. */
#define BS_LCD_WF44_BPDLCD44 (1U)          /*!< Bit field size in bits for LCD_WF44_BPDLCD44. */

/*! @brief Read current value of the LCD_WF44_BPDLCD44 field. */
#define BR_LCD_WF44_BPDLCD44(x) (BME_UBFX8(HW_LCD_WF44_ADDR(x), BP_LCD_WF44_BPDLCD44, BS_LCD_WF44_BPDLCD44))

/*! @brief Format value for bitfield LCD_WF44_BPDLCD44. */
#define BF_LCD_WF44_BPDLCD44(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF44_BPDLCD44) & BM_LCD_WF44_BPDLCD44)

/*! @brief Set the BPDLCD44 field to a new value. */
#define BW_LCD_WF44_BPDLCD44(x, v) (BME_BFI8(HW_LCD_WF44_ADDR(x), ((uint8_t)(v) << BP_LCD_WF44_BPDLCD44), BP_LCD_WF44_BPDLCD44, 1))
/*@}*/

/*!
 * @name Register LCD_WF44, field BPELCD44[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF44_BPELCD44 (4U)          /*!< Bit position for LCD_WF44_BPELCD44. */
#define BM_LCD_WF44_BPELCD44 (0x10U)       /*!< Bit mask for LCD_WF44_BPELCD44. */
#define BS_LCD_WF44_BPELCD44 (1U)          /*!< Bit field size in bits for LCD_WF44_BPELCD44. */

/*! @brief Read current value of the LCD_WF44_BPELCD44 field. */
#define BR_LCD_WF44_BPELCD44(x) (BME_UBFX8(HW_LCD_WF44_ADDR(x), BP_LCD_WF44_BPELCD44, BS_LCD_WF44_BPELCD44))

/*! @brief Format value for bitfield LCD_WF44_BPELCD44. */
#define BF_LCD_WF44_BPELCD44(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF44_BPELCD44) & BM_LCD_WF44_BPELCD44)

/*! @brief Set the BPELCD44 field to a new value. */
#define BW_LCD_WF44_BPELCD44(x, v) (BME_BFI8(HW_LCD_WF44_ADDR(x), ((uint8_t)(v) << BP_LCD_WF44_BPELCD44), BP_LCD_WF44_BPELCD44, 1))
/*@}*/

/*!
 * @name Register LCD_WF44, field BPFLCD44[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF44_BPFLCD44 (5U)          /*!< Bit position for LCD_WF44_BPFLCD44. */
#define BM_LCD_WF44_BPFLCD44 (0x20U)       /*!< Bit mask for LCD_WF44_BPFLCD44. */
#define BS_LCD_WF44_BPFLCD44 (1U)          /*!< Bit field size in bits for LCD_WF44_BPFLCD44. */

/*! @brief Read current value of the LCD_WF44_BPFLCD44 field. */
#define BR_LCD_WF44_BPFLCD44(x) (BME_UBFX8(HW_LCD_WF44_ADDR(x), BP_LCD_WF44_BPFLCD44, BS_LCD_WF44_BPFLCD44))

/*! @brief Format value for bitfield LCD_WF44_BPFLCD44. */
#define BF_LCD_WF44_BPFLCD44(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF44_BPFLCD44) & BM_LCD_WF44_BPFLCD44)

/*! @brief Set the BPFLCD44 field to a new value. */
#define BW_LCD_WF44_BPFLCD44(x, v) (BME_BFI8(HW_LCD_WF44_ADDR(x), ((uint8_t)(v) << BP_LCD_WF44_BPFLCD44), BP_LCD_WF44_BPFLCD44, 1))
/*@}*/

/*!
 * @name Register LCD_WF44, field BPGLCD44[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF44_BPGLCD44 (6U)          /*!< Bit position for LCD_WF44_BPGLCD44. */
#define BM_LCD_WF44_BPGLCD44 (0x40U)       /*!< Bit mask for LCD_WF44_BPGLCD44. */
#define BS_LCD_WF44_BPGLCD44 (1U)          /*!< Bit field size in bits for LCD_WF44_BPGLCD44. */

/*! @brief Read current value of the LCD_WF44_BPGLCD44 field. */
#define BR_LCD_WF44_BPGLCD44(x) (BME_UBFX8(HW_LCD_WF44_ADDR(x), BP_LCD_WF44_BPGLCD44, BS_LCD_WF44_BPGLCD44))

/*! @brief Format value for bitfield LCD_WF44_BPGLCD44. */
#define BF_LCD_WF44_BPGLCD44(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF44_BPGLCD44) & BM_LCD_WF44_BPGLCD44)

/*! @brief Set the BPGLCD44 field to a new value. */
#define BW_LCD_WF44_BPGLCD44(x, v) (BME_BFI8(HW_LCD_WF44_ADDR(x), ((uint8_t)(v) << BP_LCD_WF44_BPGLCD44), BP_LCD_WF44_BPGLCD44, 1))
/*@}*/

/*!
 * @name Register LCD_WF44, field BPHLCD44[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF44_BPHLCD44 (7U)          /*!< Bit position for LCD_WF44_BPHLCD44. */
#define BM_LCD_WF44_BPHLCD44 (0x80U)       /*!< Bit mask for LCD_WF44_BPHLCD44. */
#define BS_LCD_WF44_BPHLCD44 (1U)          /*!< Bit field size in bits for LCD_WF44_BPHLCD44. */

/*! @brief Read current value of the LCD_WF44_BPHLCD44 field. */
#define BR_LCD_WF44_BPHLCD44(x) (BME_UBFX8(HW_LCD_WF44_ADDR(x), BP_LCD_WF44_BPHLCD44, BS_LCD_WF44_BPHLCD44))

/*! @brief Format value for bitfield LCD_WF44_BPHLCD44. */
#define BF_LCD_WF44_BPHLCD44(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF44_BPHLCD44) & BM_LCD_WF44_BPHLCD44)

/*! @brief Set the BPHLCD44 field to a new value. */
#define BW_LCD_WF44_BPHLCD44(x, v) (BME_BFI8(HW_LCD_WF44_ADDR(x), ((uint8_t)(v) << BP_LCD_WF44_BPHLCD44), BP_LCD_WF44_BPHLCD44, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF45 - LCD Waveform Register 45.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF45 - LCD Waveform Register 45. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf45
{
    uint8_t U;
    struct _hw_lcd_wf45_bitfields
    {
        uint8_t BPALCD45 : 1;          /*!< [0]  */
        uint8_t BPBLCD45 : 1;          /*!< [1]  */
        uint8_t BPCLCD45 : 1;          /*!< [2]  */
        uint8_t BPDLCD45 : 1;          /*!< [3]  */
        uint8_t BPELCD45 : 1;          /*!< [4]  */
        uint8_t BPFLCD45 : 1;          /*!< [5]  */
        uint8_t BPGLCD45 : 1;          /*!< [6]  */
        uint8_t BPHLCD45 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf45_t;

/*!
 * @name Constants and macros for entire LCD_WF45 register
 */
/*@{*/
#define HW_LCD_WF45_ADDR(x)      ((uint32_t)(x) + 0x4DU)

#define HW_LCD_WF45(x)           (*(__IO hw_lcd_wf45_t *) HW_LCD_WF45_ADDR(x))
#define HW_LCD_WF45_RD(x)        (HW_LCD_WF45(x).U)
#define HW_LCD_WF45_WR(x, v)     (HW_LCD_WF45(x).U = (v))
#define HW_LCD_WF45_SET(x, v)    (BME_OR8(HW_LCD_WF45_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF45_CLR(x, v)    (BME_AND8(HW_LCD_WF45_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF45_TOG(x, v)    (BME_XOR8(HW_LCD_WF45_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF45 bitfields
 */

/*!
 * @name Register LCD_WF45, field BPALCD45[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF45_BPALCD45 (0U)          /*!< Bit position for LCD_WF45_BPALCD45. */
#define BM_LCD_WF45_BPALCD45 (0x01U)       /*!< Bit mask for LCD_WF45_BPALCD45. */
#define BS_LCD_WF45_BPALCD45 (1U)          /*!< Bit field size in bits for LCD_WF45_BPALCD45. */

/*! @brief Read current value of the LCD_WF45_BPALCD45 field. */
#define BR_LCD_WF45_BPALCD45(x) (BME_UBFX8(HW_LCD_WF45_ADDR(x), BP_LCD_WF45_BPALCD45, BS_LCD_WF45_BPALCD45))

/*! @brief Format value for bitfield LCD_WF45_BPALCD45. */
#define BF_LCD_WF45_BPALCD45(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF45_BPALCD45) & BM_LCD_WF45_BPALCD45)

/*! @brief Set the BPALCD45 field to a new value. */
#define BW_LCD_WF45_BPALCD45(x, v) (BME_BFI8(HW_LCD_WF45_ADDR(x), ((uint8_t)(v) << BP_LCD_WF45_BPALCD45), BP_LCD_WF45_BPALCD45, 1))
/*@}*/

/*!
 * @name Register LCD_WF45, field BPBLCD45[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF45_BPBLCD45 (1U)          /*!< Bit position for LCD_WF45_BPBLCD45. */
#define BM_LCD_WF45_BPBLCD45 (0x02U)       /*!< Bit mask for LCD_WF45_BPBLCD45. */
#define BS_LCD_WF45_BPBLCD45 (1U)          /*!< Bit field size in bits for LCD_WF45_BPBLCD45. */

/*! @brief Read current value of the LCD_WF45_BPBLCD45 field. */
#define BR_LCD_WF45_BPBLCD45(x) (BME_UBFX8(HW_LCD_WF45_ADDR(x), BP_LCD_WF45_BPBLCD45, BS_LCD_WF45_BPBLCD45))

/*! @brief Format value for bitfield LCD_WF45_BPBLCD45. */
#define BF_LCD_WF45_BPBLCD45(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF45_BPBLCD45) & BM_LCD_WF45_BPBLCD45)

/*! @brief Set the BPBLCD45 field to a new value. */
#define BW_LCD_WF45_BPBLCD45(x, v) (BME_BFI8(HW_LCD_WF45_ADDR(x), ((uint8_t)(v) << BP_LCD_WF45_BPBLCD45), BP_LCD_WF45_BPBLCD45, 1))
/*@}*/

/*!
 * @name Register LCD_WF45, field BPCLCD45[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF45_BPCLCD45 (2U)          /*!< Bit position for LCD_WF45_BPCLCD45. */
#define BM_LCD_WF45_BPCLCD45 (0x04U)       /*!< Bit mask for LCD_WF45_BPCLCD45. */
#define BS_LCD_WF45_BPCLCD45 (1U)          /*!< Bit field size in bits for LCD_WF45_BPCLCD45. */

/*! @brief Read current value of the LCD_WF45_BPCLCD45 field. */
#define BR_LCD_WF45_BPCLCD45(x) (BME_UBFX8(HW_LCD_WF45_ADDR(x), BP_LCD_WF45_BPCLCD45, BS_LCD_WF45_BPCLCD45))

/*! @brief Format value for bitfield LCD_WF45_BPCLCD45. */
#define BF_LCD_WF45_BPCLCD45(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF45_BPCLCD45) & BM_LCD_WF45_BPCLCD45)

/*! @brief Set the BPCLCD45 field to a new value. */
#define BW_LCD_WF45_BPCLCD45(x, v) (BME_BFI8(HW_LCD_WF45_ADDR(x), ((uint8_t)(v) << BP_LCD_WF45_BPCLCD45), BP_LCD_WF45_BPCLCD45, 1))
/*@}*/

/*!
 * @name Register LCD_WF45, field BPDLCD45[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF45_BPDLCD45 (3U)          /*!< Bit position for LCD_WF45_BPDLCD45. */
#define BM_LCD_WF45_BPDLCD45 (0x08U)       /*!< Bit mask for LCD_WF45_BPDLCD45. */
#define BS_LCD_WF45_BPDLCD45 (1U)          /*!< Bit field size in bits for LCD_WF45_BPDLCD45. */

/*! @brief Read current value of the LCD_WF45_BPDLCD45 field. */
#define BR_LCD_WF45_BPDLCD45(x) (BME_UBFX8(HW_LCD_WF45_ADDR(x), BP_LCD_WF45_BPDLCD45, BS_LCD_WF45_BPDLCD45))

/*! @brief Format value for bitfield LCD_WF45_BPDLCD45. */
#define BF_LCD_WF45_BPDLCD45(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF45_BPDLCD45) & BM_LCD_WF45_BPDLCD45)

/*! @brief Set the BPDLCD45 field to a new value. */
#define BW_LCD_WF45_BPDLCD45(x, v) (BME_BFI8(HW_LCD_WF45_ADDR(x), ((uint8_t)(v) << BP_LCD_WF45_BPDLCD45), BP_LCD_WF45_BPDLCD45, 1))
/*@}*/

/*!
 * @name Register LCD_WF45, field BPELCD45[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF45_BPELCD45 (4U)          /*!< Bit position for LCD_WF45_BPELCD45. */
#define BM_LCD_WF45_BPELCD45 (0x10U)       /*!< Bit mask for LCD_WF45_BPELCD45. */
#define BS_LCD_WF45_BPELCD45 (1U)          /*!< Bit field size in bits for LCD_WF45_BPELCD45. */

/*! @brief Read current value of the LCD_WF45_BPELCD45 field. */
#define BR_LCD_WF45_BPELCD45(x) (BME_UBFX8(HW_LCD_WF45_ADDR(x), BP_LCD_WF45_BPELCD45, BS_LCD_WF45_BPELCD45))

/*! @brief Format value for bitfield LCD_WF45_BPELCD45. */
#define BF_LCD_WF45_BPELCD45(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF45_BPELCD45) & BM_LCD_WF45_BPELCD45)

/*! @brief Set the BPELCD45 field to a new value. */
#define BW_LCD_WF45_BPELCD45(x, v) (BME_BFI8(HW_LCD_WF45_ADDR(x), ((uint8_t)(v) << BP_LCD_WF45_BPELCD45), BP_LCD_WF45_BPELCD45, 1))
/*@}*/

/*!
 * @name Register LCD_WF45, field BPFLCD45[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF45_BPFLCD45 (5U)          /*!< Bit position for LCD_WF45_BPFLCD45. */
#define BM_LCD_WF45_BPFLCD45 (0x20U)       /*!< Bit mask for LCD_WF45_BPFLCD45. */
#define BS_LCD_WF45_BPFLCD45 (1U)          /*!< Bit field size in bits for LCD_WF45_BPFLCD45. */

/*! @brief Read current value of the LCD_WF45_BPFLCD45 field. */
#define BR_LCD_WF45_BPFLCD45(x) (BME_UBFX8(HW_LCD_WF45_ADDR(x), BP_LCD_WF45_BPFLCD45, BS_LCD_WF45_BPFLCD45))

/*! @brief Format value for bitfield LCD_WF45_BPFLCD45. */
#define BF_LCD_WF45_BPFLCD45(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF45_BPFLCD45) & BM_LCD_WF45_BPFLCD45)

/*! @brief Set the BPFLCD45 field to a new value. */
#define BW_LCD_WF45_BPFLCD45(x, v) (BME_BFI8(HW_LCD_WF45_ADDR(x), ((uint8_t)(v) << BP_LCD_WF45_BPFLCD45), BP_LCD_WF45_BPFLCD45, 1))
/*@}*/

/*!
 * @name Register LCD_WF45, field BPGLCD45[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF45_BPGLCD45 (6U)          /*!< Bit position for LCD_WF45_BPGLCD45. */
#define BM_LCD_WF45_BPGLCD45 (0x40U)       /*!< Bit mask for LCD_WF45_BPGLCD45. */
#define BS_LCD_WF45_BPGLCD45 (1U)          /*!< Bit field size in bits for LCD_WF45_BPGLCD45. */

/*! @brief Read current value of the LCD_WF45_BPGLCD45 field. */
#define BR_LCD_WF45_BPGLCD45(x) (BME_UBFX8(HW_LCD_WF45_ADDR(x), BP_LCD_WF45_BPGLCD45, BS_LCD_WF45_BPGLCD45))

/*! @brief Format value for bitfield LCD_WF45_BPGLCD45. */
#define BF_LCD_WF45_BPGLCD45(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF45_BPGLCD45) & BM_LCD_WF45_BPGLCD45)

/*! @brief Set the BPGLCD45 field to a new value. */
#define BW_LCD_WF45_BPGLCD45(x, v) (BME_BFI8(HW_LCD_WF45_ADDR(x), ((uint8_t)(v) << BP_LCD_WF45_BPGLCD45), BP_LCD_WF45_BPGLCD45, 1))
/*@}*/

/*!
 * @name Register LCD_WF45, field BPHLCD45[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF45_BPHLCD45 (7U)          /*!< Bit position for LCD_WF45_BPHLCD45. */
#define BM_LCD_WF45_BPHLCD45 (0x80U)       /*!< Bit mask for LCD_WF45_BPHLCD45. */
#define BS_LCD_WF45_BPHLCD45 (1U)          /*!< Bit field size in bits for LCD_WF45_BPHLCD45. */

/*! @brief Read current value of the LCD_WF45_BPHLCD45 field. */
#define BR_LCD_WF45_BPHLCD45(x) (BME_UBFX8(HW_LCD_WF45_ADDR(x), BP_LCD_WF45_BPHLCD45, BS_LCD_WF45_BPHLCD45))

/*! @brief Format value for bitfield LCD_WF45_BPHLCD45. */
#define BF_LCD_WF45_BPHLCD45(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF45_BPHLCD45) & BM_LCD_WF45_BPHLCD45)

/*! @brief Set the BPHLCD45 field to a new value. */
#define BW_LCD_WF45_BPHLCD45(x, v) (BME_BFI8(HW_LCD_WF45_ADDR(x), ((uint8_t)(v) << BP_LCD_WF45_BPHLCD45), BP_LCD_WF45_BPHLCD45, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF46 - LCD Waveform Register 46.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF46 - LCD Waveform Register 46. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf46
{
    uint8_t U;
    struct _hw_lcd_wf46_bitfields
    {
        uint8_t BPALCD46 : 1;          /*!< [0]  */
        uint8_t BPBLCD46 : 1;          /*!< [1]  */
        uint8_t BPCLCD46 : 1;          /*!< [2]  */
        uint8_t BPDLCD46 : 1;          /*!< [3]  */
        uint8_t BPELCD46 : 1;          /*!< [4]  */
        uint8_t BPFLCD46 : 1;          /*!< [5]  */
        uint8_t BPGLCD46 : 1;          /*!< [6]  */
        uint8_t BPHLCD46 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf46_t;

/*!
 * @name Constants and macros for entire LCD_WF46 register
 */
/*@{*/
#define HW_LCD_WF46_ADDR(x)      ((uint32_t)(x) + 0x4EU)

#define HW_LCD_WF46(x)           (*(__IO hw_lcd_wf46_t *) HW_LCD_WF46_ADDR(x))
#define HW_LCD_WF46_RD(x)        (HW_LCD_WF46(x).U)
#define HW_LCD_WF46_WR(x, v)     (HW_LCD_WF46(x).U = (v))
#define HW_LCD_WF46_SET(x, v)    (BME_OR8(HW_LCD_WF46_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF46_CLR(x, v)    (BME_AND8(HW_LCD_WF46_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF46_TOG(x, v)    (BME_XOR8(HW_LCD_WF46_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF46 bitfields
 */

/*!
 * @name Register LCD_WF46, field BPALCD46[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF46_BPALCD46 (0U)          /*!< Bit position for LCD_WF46_BPALCD46. */
#define BM_LCD_WF46_BPALCD46 (0x01U)       /*!< Bit mask for LCD_WF46_BPALCD46. */
#define BS_LCD_WF46_BPALCD46 (1U)          /*!< Bit field size in bits for LCD_WF46_BPALCD46. */

/*! @brief Read current value of the LCD_WF46_BPALCD46 field. */
#define BR_LCD_WF46_BPALCD46(x) (BME_UBFX8(HW_LCD_WF46_ADDR(x), BP_LCD_WF46_BPALCD46, BS_LCD_WF46_BPALCD46))

/*! @brief Format value for bitfield LCD_WF46_BPALCD46. */
#define BF_LCD_WF46_BPALCD46(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF46_BPALCD46) & BM_LCD_WF46_BPALCD46)

/*! @brief Set the BPALCD46 field to a new value. */
#define BW_LCD_WF46_BPALCD46(x, v) (BME_BFI8(HW_LCD_WF46_ADDR(x), ((uint8_t)(v) << BP_LCD_WF46_BPALCD46), BP_LCD_WF46_BPALCD46, 1))
/*@}*/

/*!
 * @name Register LCD_WF46, field BPBLCD46[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF46_BPBLCD46 (1U)          /*!< Bit position for LCD_WF46_BPBLCD46. */
#define BM_LCD_WF46_BPBLCD46 (0x02U)       /*!< Bit mask for LCD_WF46_BPBLCD46. */
#define BS_LCD_WF46_BPBLCD46 (1U)          /*!< Bit field size in bits for LCD_WF46_BPBLCD46. */

/*! @brief Read current value of the LCD_WF46_BPBLCD46 field. */
#define BR_LCD_WF46_BPBLCD46(x) (BME_UBFX8(HW_LCD_WF46_ADDR(x), BP_LCD_WF46_BPBLCD46, BS_LCD_WF46_BPBLCD46))

/*! @brief Format value for bitfield LCD_WF46_BPBLCD46. */
#define BF_LCD_WF46_BPBLCD46(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF46_BPBLCD46) & BM_LCD_WF46_BPBLCD46)

/*! @brief Set the BPBLCD46 field to a new value. */
#define BW_LCD_WF46_BPBLCD46(x, v) (BME_BFI8(HW_LCD_WF46_ADDR(x), ((uint8_t)(v) << BP_LCD_WF46_BPBLCD46), BP_LCD_WF46_BPBLCD46, 1))
/*@}*/

/*!
 * @name Register LCD_WF46, field BPCLCD46[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF46_BPCLCD46 (2U)          /*!< Bit position for LCD_WF46_BPCLCD46. */
#define BM_LCD_WF46_BPCLCD46 (0x04U)       /*!< Bit mask for LCD_WF46_BPCLCD46. */
#define BS_LCD_WF46_BPCLCD46 (1U)          /*!< Bit field size in bits for LCD_WF46_BPCLCD46. */

/*! @brief Read current value of the LCD_WF46_BPCLCD46 field. */
#define BR_LCD_WF46_BPCLCD46(x) (BME_UBFX8(HW_LCD_WF46_ADDR(x), BP_LCD_WF46_BPCLCD46, BS_LCD_WF46_BPCLCD46))

/*! @brief Format value for bitfield LCD_WF46_BPCLCD46. */
#define BF_LCD_WF46_BPCLCD46(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF46_BPCLCD46) & BM_LCD_WF46_BPCLCD46)

/*! @brief Set the BPCLCD46 field to a new value. */
#define BW_LCD_WF46_BPCLCD46(x, v) (BME_BFI8(HW_LCD_WF46_ADDR(x), ((uint8_t)(v) << BP_LCD_WF46_BPCLCD46), BP_LCD_WF46_BPCLCD46, 1))
/*@}*/

/*!
 * @name Register LCD_WF46, field BPDLCD46[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF46_BPDLCD46 (3U)          /*!< Bit position for LCD_WF46_BPDLCD46. */
#define BM_LCD_WF46_BPDLCD46 (0x08U)       /*!< Bit mask for LCD_WF46_BPDLCD46. */
#define BS_LCD_WF46_BPDLCD46 (1U)          /*!< Bit field size in bits for LCD_WF46_BPDLCD46. */

/*! @brief Read current value of the LCD_WF46_BPDLCD46 field. */
#define BR_LCD_WF46_BPDLCD46(x) (BME_UBFX8(HW_LCD_WF46_ADDR(x), BP_LCD_WF46_BPDLCD46, BS_LCD_WF46_BPDLCD46))

/*! @brief Format value for bitfield LCD_WF46_BPDLCD46. */
#define BF_LCD_WF46_BPDLCD46(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF46_BPDLCD46) & BM_LCD_WF46_BPDLCD46)

/*! @brief Set the BPDLCD46 field to a new value. */
#define BW_LCD_WF46_BPDLCD46(x, v) (BME_BFI8(HW_LCD_WF46_ADDR(x), ((uint8_t)(v) << BP_LCD_WF46_BPDLCD46), BP_LCD_WF46_BPDLCD46, 1))
/*@}*/

/*!
 * @name Register LCD_WF46, field BPELCD46[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF46_BPELCD46 (4U)          /*!< Bit position for LCD_WF46_BPELCD46. */
#define BM_LCD_WF46_BPELCD46 (0x10U)       /*!< Bit mask for LCD_WF46_BPELCD46. */
#define BS_LCD_WF46_BPELCD46 (1U)          /*!< Bit field size in bits for LCD_WF46_BPELCD46. */

/*! @brief Read current value of the LCD_WF46_BPELCD46 field. */
#define BR_LCD_WF46_BPELCD46(x) (BME_UBFX8(HW_LCD_WF46_ADDR(x), BP_LCD_WF46_BPELCD46, BS_LCD_WF46_BPELCD46))

/*! @brief Format value for bitfield LCD_WF46_BPELCD46. */
#define BF_LCD_WF46_BPELCD46(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF46_BPELCD46) & BM_LCD_WF46_BPELCD46)

/*! @brief Set the BPELCD46 field to a new value. */
#define BW_LCD_WF46_BPELCD46(x, v) (BME_BFI8(HW_LCD_WF46_ADDR(x), ((uint8_t)(v) << BP_LCD_WF46_BPELCD46), BP_LCD_WF46_BPELCD46, 1))
/*@}*/

/*!
 * @name Register LCD_WF46, field BPFLCD46[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF46_BPFLCD46 (5U)          /*!< Bit position for LCD_WF46_BPFLCD46. */
#define BM_LCD_WF46_BPFLCD46 (0x20U)       /*!< Bit mask for LCD_WF46_BPFLCD46. */
#define BS_LCD_WF46_BPFLCD46 (1U)          /*!< Bit field size in bits for LCD_WF46_BPFLCD46. */

/*! @brief Read current value of the LCD_WF46_BPFLCD46 field. */
#define BR_LCD_WF46_BPFLCD46(x) (BME_UBFX8(HW_LCD_WF46_ADDR(x), BP_LCD_WF46_BPFLCD46, BS_LCD_WF46_BPFLCD46))

/*! @brief Format value for bitfield LCD_WF46_BPFLCD46. */
#define BF_LCD_WF46_BPFLCD46(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF46_BPFLCD46) & BM_LCD_WF46_BPFLCD46)

/*! @brief Set the BPFLCD46 field to a new value. */
#define BW_LCD_WF46_BPFLCD46(x, v) (BME_BFI8(HW_LCD_WF46_ADDR(x), ((uint8_t)(v) << BP_LCD_WF46_BPFLCD46), BP_LCD_WF46_BPFLCD46, 1))
/*@}*/

/*!
 * @name Register LCD_WF46, field BPGLCD46[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF46_BPGLCD46 (6U)          /*!< Bit position for LCD_WF46_BPGLCD46. */
#define BM_LCD_WF46_BPGLCD46 (0x40U)       /*!< Bit mask for LCD_WF46_BPGLCD46. */
#define BS_LCD_WF46_BPGLCD46 (1U)          /*!< Bit field size in bits for LCD_WF46_BPGLCD46. */

/*! @brief Read current value of the LCD_WF46_BPGLCD46 field. */
#define BR_LCD_WF46_BPGLCD46(x) (BME_UBFX8(HW_LCD_WF46_ADDR(x), BP_LCD_WF46_BPGLCD46, BS_LCD_WF46_BPGLCD46))

/*! @brief Format value for bitfield LCD_WF46_BPGLCD46. */
#define BF_LCD_WF46_BPGLCD46(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF46_BPGLCD46) & BM_LCD_WF46_BPGLCD46)

/*! @brief Set the BPGLCD46 field to a new value. */
#define BW_LCD_WF46_BPGLCD46(x, v) (BME_BFI8(HW_LCD_WF46_ADDR(x), ((uint8_t)(v) << BP_LCD_WF46_BPGLCD46), BP_LCD_WF46_BPGLCD46, 1))
/*@}*/

/*!
 * @name Register LCD_WF46, field BPHLCD46[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF46_BPHLCD46 (7U)          /*!< Bit position for LCD_WF46_BPHLCD46. */
#define BM_LCD_WF46_BPHLCD46 (0x80U)       /*!< Bit mask for LCD_WF46_BPHLCD46. */
#define BS_LCD_WF46_BPHLCD46 (1U)          /*!< Bit field size in bits for LCD_WF46_BPHLCD46. */

/*! @brief Read current value of the LCD_WF46_BPHLCD46 field. */
#define BR_LCD_WF46_BPHLCD46(x) (BME_UBFX8(HW_LCD_WF46_ADDR(x), BP_LCD_WF46_BPHLCD46, BS_LCD_WF46_BPHLCD46))

/*! @brief Format value for bitfield LCD_WF46_BPHLCD46. */
#define BF_LCD_WF46_BPHLCD46(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF46_BPHLCD46) & BM_LCD_WF46_BPHLCD46)

/*! @brief Set the BPHLCD46 field to a new value. */
#define BW_LCD_WF46_BPHLCD46(x, v) (BME_BFI8(HW_LCD_WF46_ADDR(x), ((uint8_t)(v) << BP_LCD_WF46_BPHLCD46), BP_LCD_WF46_BPHLCD46, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF47 - LCD Waveform Register 47.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF47 - LCD Waveform Register 47. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf47
{
    uint8_t U;
    struct _hw_lcd_wf47_bitfields
    {
        uint8_t BPALCD47 : 1;          /*!< [0]  */
        uint8_t BPBLCD47 : 1;          /*!< [1]  */
        uint8_t BPCLCD47 : 1;          /*!< [2]  */
        uint8_t BPDLCD47 : 1;          /*!< [3]  */
        uint8_t BPELCD47 : 1;          /*!< [4]  */
        uint8_t BPFLCD47 : 1;          /*!< [5]  */
        uint8_t BPGLCD47 : 1;          /*!< [6]  */
        uint8_t BPHLCD47 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf47_t;

/*!
 * @name Constants and macros for entire LCD_WF47 register
 */
/*@{*/
#define HW_LCD_WF47_ADDR(x)      ((uint32_t)(x) + 0x4FU)

#define HW_LCD_WF47(x)           (*(__IO hw_lcd_wf47_t *) HW_LCD_WF47_ADDR(x))
#define HW_LCD_WF47_RD(x)        (HW_LCD_WF47(x).U)
#define HW_LCD_WF47_WR(x, v)     (HW_LCD_WF47(x).U = (v))
#define HW_LCD_WF47_SET(x, v)    (BME_OR8(HW_LCD_WF47_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF47_CLR(x, v)    (BME_AND8(HW_LCD_WF47_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF47_TOG(x, v)    (BME_XOR8(HW_LCD_WF47_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF47 bitfields
 */

/*!
 * @name Register LCD_WF47, field BPALCD47[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF47_BPALCD47 (0U)          /*!< Bit position for LCD_WF47_BPALCD47. */
#define BM_LCD_WF47_BPALCD47 (0x01U)       /*!< Bit mask for LCD_WF47_BPALCD47. */
#define BS_LCD_WF47_BPALCD47 (1U)          /*!< Bit field size in bits for LCD_WF47_BPALCD47. */

/*! @brief Read current value of the LCD_WF47_BPALCD47 field. */
#define BR_LCD_WF47_BPALCD47(x) (BME_UBFX8(HW_LCD_WF47_ADDR(x), BP_LCD_WF47_BPALCD47, BS_LCD_WF47_BPALCD47))

/*! @brief Format value for bitfield LCD_WF47_BPALCD47. */
#define BF_LCD_WF47_BPALCD47(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF47_BPALCD47) & BM_LCD_WF47_BPALCD47)

/*! @brief Set the BPALCD47 field to a new value. */
#define BW_LCD_WF47_BPALCD47(x, v) (BME_BFI8(HW_LCD_WF47_ADDR(x), ((uint8_t)(v) << BP_LCD_WF47_BPALCD47), BP_LCD_WF47_BPALCD47, 1))
/*@}*/

/*!
 * @name Register LCD_WF47, field BPBLCD47[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF47_BPBLCD47 (1U)          /*!< Bit position for LCD_WF47_BPBLCD47. */
#define BM_LCD_WF47_BPBLCD47 (0x02U)       /*!< Bit mask for LCD_WF47_BPBLCD47. */
#define BS_LCD_WF47_BPBLCD47 (1U)          /*!< Bit field size in bits for LCD_WF47_BPBLCD47. */

/*! @brief Read current value of the LCD_WF47_BPBLCD47 field. */
#define BR_LCD_WF47_BPBLCD47(x) (BME_UBFX8(HW_LCD_WF47_ADDR(x), BP_LCD_WF47_BPBLCD47, BS_LCD_WF47_BPBLCD47))

/*! @brief Format value for bitfield LCD_WF47_BPBLCD47. */
#define BF_LCD_WF47_BPBLCD47(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF47_BPBLCD47) & BM_LCD_WF47_BPBLCD47)

/*! @brief Set the BPBLCD47 field to a new value. */
#define BW_LCD_WF47_BPBLCD47(x, v) (BME_BFI8(HW_LCD_WF47_ADDR(x), ((uint8_t)(v) << BP_LCD_WF47_BPBLCD47), BP_LCD_WF47_BPBLCD47, 1))
/*@}*/

/*!
 * @name Register LCD_WF47, field BPCLCD47[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF47_BPCLCD47 (2U)          /*!< Bit position for LCD_WF47_BPCLCD47. */
#define BM_LCD_WF47_BPCLCD47 (0x04U)       /*!< Bit mask for LCD_WF47_BPCLCD47. */
#define BS_LCD_WF47_BPCLCD47 (1U)          /*!< Bit field size in bits for LCD_WF47_BPCLCD47. */

/*! @brief Read current value of the LCD_WF47_BPCLCD47 field. */
#define BR_LCD_WF47_BPCLCD47(x) (BME_UBFX8(HW_LCD_WF47_ADDR(x), BP_LCD_WF47_BPCLCD47, BS_LCD_WF47_BPCLCD47))

/*! @brief Format value for bitfield LCD_WF47_BPCLCD47. */
#define BF_LCD_WF47_BPCLCD47(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF47_BPCLCD47) & BM_LCD_WF47_BPCLCD47)

/*! @brief Set the BPCLCD47 field to a new value. */
#define BW_LCD_WF47_BPCLCD47(x, v) (BME_BFI8(HW_LCD_WF47_ADDR(x), ((uint8_t)(v) << BP_LCD_WF47_BPCLCD47), BP_LCD_WF47_BPCLCD47, 1))
/*@}*/

/*!
 * @name Register LCD_WF47, field BPDLCD47[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF47_BPDLCD47 (3U)          /*!< Bit position for LCD_WF47_BPDLCD47. */
#define BM_LCD_WF47_BPDLCD47 (0x08U)       /*!< Bit mask for LCD_WF47_BPDLCD47. */
#define BS_LCD_WF47_BPDLCD47 (1U)          /*!< Bit field size in bits for LCD_WF47_BPDLCD47. */

/*! @brief Read current value of the LCD_WF47_BPDLCD47 field. */
#define BR_LCD_WF47_BPDLCD47(x) (BME_UBFX8(HW_LCD_WF47_ADDR(x), BP_LCD_WF47_BPDLCD47, BS_LCD_WF47_BPDLCD47))

/*! @brief Format value for bitfield LCD_WF47_BPDLCD47. */
#define BF_LCD_WF47_BPDLCD47(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF47_BPDLCD47) & BM_LCD_WF47_BPDLCD47)

/*! @brief Set the BPDLCD47 field to a new value. */
#define BW_LCD_WF47_BPDLCD47(x, v) (BME_BFI8(HW_LCD_WF47_ADDR(x), ((uint8_t)(v) << BP_LCD_WF47_BPDLCD47), BP_LCD_WF47_BPDLCD47, 1))
/*@}*/

/*!
 * @name Register LCD_WF47, field BPELCD47[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF47_BPELCD47 (4U)          /*!< Bit position for LCD_WF47_BPELCD47. */
#define BM_LCD_WF47_BPELCD47 (0x10U)       /*!< Bit mask for LCD_WF47_BPELCD47. */
#define BS_LCD_WF47_BPELCD47 (1U)          /*!< Bit field size in bits for LCD_WF47_BPELCD47. */

/*! @brief Read current value of the LCD_WF47_BPELCD47 field. */
#define BR_LCD_WF47_BPELCD47(x) (BME_UBFX8(HW_LCD_WF47_ADDR(x), BP_LCD_WF47_BPELCD47, BS_LCD_WF47_BPELCD47))

/*! @brief Format value for bitfield LCD_WF47_BPELCD47. */
#define BF_LCD_WF47_BPELCD47(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF47_BPELCD47) & BM_LCD_WF47_BPELCD47)

/*! @brief Set the BPELCD47 field to a new value. */
#define BW_LCD_WF47_BPELCD47(x, v) (BME_BFI8(HW_LCD_WF47_ADDR(x), ((uint8_t)(v) << BP_LCD_WF47_BPELCD47), BP_LCD_WF47_BPELCD47, 1))
/*@}*/

/*!
 * @name Register LCD_WF47, field BPFLCD47[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF47_BPFLCD47 (5U)          /*!< Bit position for LCD_WF47_BPFLCD47. */
#define BM_LCD_WF47_BPFLCD47 (0x20U)       /*!< Bit mask for LCD_WF47_BPFLCD47. */
#define BS_LCD_WF47_BPFLCD47 (1U)          /*!< Bit field size in bits for LCD_WF47_BPFLCD47. */

/*! @brief Read current value of the LCD_WF47_BPFLCD47 field. */
#define BR_LCD_WF47_BPFLCD47(x) (BME_UBFX8(HW_LCD_WF47_ADDR(x), BP_LCD_WF47_BPFLCD47, BS_LCD_WF47_BPFLCD47))

/*! @brief Format value for bitfield LCD_WF47_BPFLCD47. */
#define BF_LCD_WF47_BPFLCD47(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF47_BPFLCD47) & BM_LCD_WF47_BPFLCD47)

/*! @brief Set the BPFLCD47 field to a new value. */
#define BW_LCD_WF47_BPFLCD47(x, v) (BME_BFI8(HW_LCD_WF47_ADDR(x), ((uint8_t)(v) << BP_LCD_WF47_BPFLCD47), BP_LCD_WF47_BPFLCD47, 1))
/*@}*/

/*!
 * @name Register LCD_WF47, field BPGLCD47[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF47_BPGLCD47 (6U)          /*!< Bit position for LCD_WF47_BPGLCD47. */
#define BM_LCD_WF47_BPGLCD47 (0x40U)       /*!< Bit mask for LCD_WF47_BPGLCD47. */
#define BS_LCD_WF47_BPGLCD47 (1U)          /*!< Bit field size in bits for LCD_WF47_BPGLCD47. */

/*! @brief Read current value of the LCD_WF47_BPGLCD47 field. */
#define BR_LCD_WF47_BPGLCD47(x) (BME_UBFX8(HW_LCD_WF47_ADDR(x), BP_LCD_WF47_BPGLCD47, BS_LCD_WF47_BPGLCD47))

/*! @brief Format value for bitfield LCD_WF47_BPGLCD47. */
#define BF_LCD_WF47_BPGLCD47(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF47_BPGLCD47) & BM_LCD_WF47_BPGLCD47)

/*! @brief Set the BPGLCD47 field to a new value. */
#define BW_LCD_WF47_BPGLCD47(x, v) (BME_BFI8(HW_LCD_WF47_ADDR(x), ((uint8_t)(v) << BP_LCD_WF47_BPGLCD47), BP_LCD_WF47_BPGLCD47, 1))
/*@}*/

/*!
 * @name Register LCD_WF47, field BPHLCD47[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF47_BPHLCD47 (7U)          /*!< Bit position for LCD_WF47_BPHLCD47. */
#define BM_LCD_WF47_BPHLCD47 (0x80U)       /*!< Bit mask for LCD_WF47_BPHLCD47. */
#define BS_LCD_WF47_BPHLCD47 (1U)          /*!< Bit field size in bits for LCD_WF47_BPHLCD47. */

/*! @brief Read current value of the LCD_WF47_BPHLCD47 field. */
#define BR_LCD_WF47_BPHLCD47(x) (BME_UBFX8(HW_LCD_WF47_ADDR(x), BP_LCD_WF47_BPHLCD47, BS_LCD_WF47_BPHLCD47))

/*! @brief Format value for bitfield LCD_WF47_BPHLCD47. */
#define BF_LCD_WF47_BPHLCD47(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF47_BPHLCD47) & BM_LCD_WF47_BPHLCD47)

/*! @brief Set the BPHLCD47 field to a new value. */
#define BW_LCD_WF47_BPHLCD47(x, v) (BME_BFI8(HW_LCD_WF47_ADDR(x), ((uint8_t)(v) << BP_LCD_WF47_BPHLCD47), BP_LCD_WF47_BPHLCD47, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF48 - LCD Waveform Register 48.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF48 - LCD Waveform Register 48. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf48
{
    uint8_t U;
    struct _hw_lcd_wf48_bitfields
    {
        uint8_t BPALCD48 : 1;          /*!< [0]  */
        uint8_t BPBLCD48 : 1;          /*!< [1]  */
        uint8_t BPCLCD48 : 1;          /*!< [2]  */
        uint8_t BPDLCD48 : 1;          /*!< [3]  */
        uint8_t BPELCD48 : 1;          /*!< [4]  */
        uint8_t BPFLCD48 : 1;          /*!< [5]  */
        uint8_t BPGLCD48 : 1;          /*!< [6]  */
        uint8_t BPHLCD48 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf48_t;

/*!
 * @name Constants and macros for entire LCD_WF48 register
 */
/*@{*/
#define HW_LCD_WF48_ADDR(x)      ((uint32_t)(x) + 0x50U)

#define HW_LCD_WF48(x)           (*(__IO hw_lcd_wf48_t *) HW_LCD_WF48_ADDR(x))
#define HW_LCD_WF48_RD(x)        (HW_LCD_WF48(x).U)
#define HW_LCD_WF48_WR(x, v)     (HW_LCD_WF48(x).U = (v))
#define HW_LCD_WF48_SET(x, v)    (BME_OR8(HW_LCD_WF48_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF48_CLR(x, v)    (BME_AND8(HW_LCD_WF48_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF48_TOG(x, v)    (BME_XOR8(HW_LCD_WF48_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF48 bitfields
 */

/*!
 * @name Register LCD_WF48, field BPALCD48[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF48_BPALCD48 (0U)          /*!< Bit position for LCD_WF48_BPALCD48. */
#define BM_LCD_WF48_BPALCD48 (0x01U)       /*!< Bit mask for LCD_WF48_BPALCD48. */
#define BS_LCD_WF48_BPALCD48 (1U)          /*!< Bit field size in bits for LCD_WF48_BPALCD48. */

/*! @brief Read current value of the LCD_WF48_BPALCD48 field. */
#define BR_LCD_WF48_BPALCD48(x) (BME_UBFX8(HW_LCD_WF48_ADDR(x), BP_LCD_WF48_BPALCD48, BS_LCD_WF48_BPALCD48))

/*! @brief Format value for bitfield LCD_WF48_BPALCD48. */
#define BF_LCD_WF48_BPALCD48(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF48_BPALCD48) & BM_LCD_WF48_BPALCD48)

/*! @brief Set the BPALCD48 field to a new value. */
#define BW_LCD_WF48_BPALCD48(x, v) (BME_BFI8(HW_LCD_WF48_ADDR(x), ((uint8_t)(v) << BP_LCD_WF48_BPALCD48), BP_LCD_WF48_BPALCD48, 1))
/*@}*/

/*!
 * @name Register LCD_WF48, field BPBLCD48[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF48_BPBLCD48 (1U)          /*!< Bit position for LCD_WF48_BPBLCD48. */
#define BM_LCD_WF48_BPBLCD48 (0x02U)       /*!< Bit mask for LCD_WF48_BPBLCD48. */
#define BS_LCD_WF48_BPBLCD48 (1U)          /*!< Bit field size in bits for LCD_WF48_BPBLCD48. */

/*! @brief Read current value of the LCD_WF48_BPBLCD48 field. */
#define BR_LCD_WF48_BPBLCD48(x) (BME_UBFX8(HW_LCD_WF48_ADDR(x), BP_LCD_WF48_BPBLCD48, BS_LCD_WF48_BPBLCD48))

/*! @brief Format value for bitfield LCD_WF48_BPBLCD48. */
#define BF_LCD_WF48_BPBLCD48(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF48_BPBLCD48) & BM_LCD_WF48_BPBLCD48)

/*! @brief Set the BPBLCD48 field to a new value. */
#define BW_LCD_WF48_BPBLCD48(x, v) (BME_BFI8(HW_LCD_WF48_ADDR(x), ((uint8_t)(v) << BP_LCD_WF48_BPBLCD48), BP_LCD_WF48_BPBLCD48, 1))
/*@}*/

/*!
 * @name Register LCD_WF48, field BPCLCD48[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF48_BPCLCD48 (2U)          /*!< Bit position for LCD_WF48_BPCLCD48. */
#define BM_LCD_WF48_BPCLCD48 (0x04U)       /*!< Bit mask for LCD_WF48_BPCLCD48. */
#define BS_LCD_WF48_BPCLCD48 (1U)          /*!< Bit field size in bits for LCD_WF48_BPCLCD48. */

/*! @brief Read current value of the LCD_WF48_BPCLCD48 field. */
#define BR_LCD_WF48_BPCLCD48(x) (BME_UBFX8(HW_LCD_WF48_ADDR(x), BP_LCD_WF48_BPCLCD48, BS_LCD_WF48_BPCLCD48))

/*! @brief Format value for bitfield LCD_WF48_BPCLCD48. */
#define BF_LCD_WF48_BPCLCD48(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF48_BPCLCD48) & BM_LCD_WF48_BPCLCD48)

/*! @brief Set the BPCLCD48 field to a new value. */
#define BW_LCD_WF48_BPCLCD48(x, v) (BME_BFI8(HW_LCD_WF48_ADDR(x), ((uint8_t)(v) << BP_LCD_WF48_BPCLCD48), BP_LCD_WF48_BPCLCD48, 1))
/*@}*/

/*!
 * @name Register LCD_WF48, field BPDLCD48[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF48_BPDLCD48 (3U)          /*!< Bit position for LCD_WF48_BPDLCD48. */
#define BM_LCD_WF48_BPDLCD48 (0x08U)       /*!< Bit mask for LCD_WF48_BPDLCD48. */
#define BS_LCD_WF48_BPDLCD48 (1U)          /*!< Bit field size in bits for LCD_WF48_BPDLCD48. */

/*! @brief Read current value of the LCD_WF48_BPDLCD48 field. */
#define BR_LCD_WF48_BPDLCD48(x) (BME_UBFX8(HW_LCD_WF48_ADDR(x), BP_LCD_WF48_BPDLCD48, BS_LCD_WF48_BPDLCD48))

/*! @brief Format value for bitfield LCD_WF48_BPDLCD48. */
#define BF_LCD_WF48_BPDLCD48(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF48_BPDLCD48) & BM_LCD_WF48_BPDLCD48)

/*! @brief Set the BPDLCD48 field to a new value. */
#define BW_LCD_WF48_BPDLCD48(x, v) (BME_BFI8(HW_LCD_WF48_ADDR(x), ((uint8_t)(v) << BP_LCD_WF48_BPDLCD48), BP_LCD_WF48_BPDLCD48, 1))
/*@}*/

/*!
 * @name Register LCD_WF48, field BPELCD48[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF48_BPELCD48 (4U)          /*!< Bit position for LCD_WF48_BPELCD48. */
#define BM_LCD_WF48_BPELCD48 (0x10U)       /*!< Bit mask for LCD_WF48_BPELCD48. */
#define BS_LCD_WF48_BPELCD48 (1U)          /*!< Bit field size in bits for LCD_WF48_BPELCD48. */

/*! @brief Read current value of the LCD_WF48_BPELCD48 field. */
#define BR_LCD_WF48_BPELCD48(x) (BME_UBFX8(HW_LCD_WF48_ADDR(x), BP_LCD_WF48_BPELCD48, BS_LCD_WF48_BPELCD48))

/*! @brief Format value for bitfield LCD_WF48_BPELCD48. */
#define BF_LCD_WF48_BPELCD48(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF48_BPELCD48) & BM_LCD_WF48_BPELCD48)

/*! @brief Set the BPELCD48 field to a new value. */
#define BW_LCD_WF48_BPELCD48(x, v) (BME_BFI8(HW_LCD_WF48_ADDR(x), ((uint8_t)(v) << BP_LCD_WF48_BPELCD48), BP_LCD_WF48_BPELCD48, 1))
/*@}*/

/*!
 * @name Register LCD_WF48, field BPFLCD48[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF48_BPFLCD48 (5U)          /*!< Bit position for LCD_WF48_BPFLCD48. */
#define BM_LCD_WF48_BPFLCD48 (0x20U)       /*!< Bit mask for LCD_WF48_BPFLCD48. */
#define BS_LCD_WF48_BPFLCD48 (1U)          /*!< Bit field size in bits for LCD_WF48_BPFLCD48. */

/*! @brief Read current value of the LCD_WF48_BPFLCD48 field. */
#define BR_LCD_WF48_BPFLCD48(x) (BME_UBFX8(HW_LCD_WF48_ADDR(x), BP_LCD_WF48_BPFLCD48, BS_LCD_WF48_BPFLCD48))

/*! @brief Format value for bitfield LCD_WF48_BPFLCD48. */
#define BF_LCD_WF48_BPFLCD48(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF48_BPFLCD48) & BM_LCD_WF48_BPFLCD48)

/*! @brief Set the BPFLCD48 field to a new value. */
#define BW_LCD_WF48_BPFLCD48(x, v) (BME_BFI8(HW_LCD_WF48_ADDR(x), ((uint8_t)(v) << BP_LCD_WF48_BPFLCD48), BP_LCD_WF48_BPFLCD48, 1))
/*@}*/

/*!
 * @name Register LCD_WF48, field BPGLCD48[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF48_BPGLCD48 (6U)          /*!< Bit position for LCD_WF48_BPGLCD48. */
#define BM_LCD_WF48_BPGLCD48 (0x40U)       /*!< Bit mask for LCD_WF48_BPGLCD48. */
#define BS_LCD_WF48_BPGLCD48 (1U)          /*!< Bit field size in bits for LCD_WF48_BPGLCD48. */

/*! @brief Read current value of the LCD_WF48_BPGLCD48 field. */
#define BR_LCD_WF48_BPGLCD48(x) (BME_UBFX8(HW_LCD_WF48_ADDR(x), BP_LCD_WF48_BPGLCD48, BS_LCD_WF48_BPGLCD48))

/*! @brief Format value for bitfield LCD_WF48_BPGLCD48. */
#define BF_LCD_WF48_BPGLCD48(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF48_BPGLCD48) & BM_LCD_WF48_BPGLCD48)

/*! @brief Set the BPGLCD48 field to a new value. */
#define BW_LCD_WF48_BPGLCD48(x, v) (BME_BFI8(HW_LCD_WF48_ADDR(x), ((uint8_t)(v) << BP_LCD_WF48_BPGLCD48), BP_LCD_WF48_BPGLCD48, 1))
/*@}*/

/*!
 * @name Register LCD_WF48, field BPHLCD48[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF48_BPHLCD48 (7U)          /*!< Bit position for LCD_WF48_BPHLCD48. */
#define BM_LCD_WF48_BPHLCD48 (0x80U)       /*!< Bit mask for LCD_WF48_BPHLCD48. */
#define BS_LCD_WF48_BPHLCD48 (1U)          /*!< Bit field size in bits for LCD_WF48_BPHLCD48. */

/*! @brief Read current value of the LCD_WF48_BPHLCD48 field. */
#define BR_LCD_WF48_BPHLCD48(x) (BME_UBFX8(HW_LCD_WF48_ADDR(x), BP_LCD_WF48_BPHLCD48, BS_LCD_WF48_BPHLCD48))

/*! @brief Format value for bitfield LCD_WF48_BPHLCD48. */
#define BF_LCD_WF48_BPHLCD48(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF48_BPHLCD48) & BM_LCD_WF48_BPHLCD48)

/*! @brief Set the BPHLCD48 field to a new value. */
#define BW_LCD_WF48_BPHLCD48(x, v) (BME_BFI8(HW_LCD_WF48_ADDR(x), ((uint8_t)(v) << BP_LCD_WF48_BPHLCD48), BP_LCD_WF48_BPHLCD48, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF49 - LCD Waveform Register 49.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF49 - LCD Waveform Register 49. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf49
{
    uint8_t U;
    struct _hw_lcd_wf49_bitfields
    {
        uint8_t BPALCD49 : 1;          /*!< [0]  */
        uint8_t BPBLCD49 : 1;          /*!< [1]  */
        uint8_t BPCLCD49 : 1;          /*!< [2]  */
        uint8_t BPDLCD49 : 1;          /*!< [3]  */
        uint8_t BPELCD49 : 1;          /*!< [4]  */
        uint8_t BPFLCD49 : 1;          /*!< [5]  */
        uint8_t BPGLCD49 : 1;          /*!< [6]  */
        uint8_t BPHLCD49 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf49_t;

/*!
 * @name Constants and macros for entire LCD_WF49 register
 */
/*@{*/
#define HW_LCD_WF49_ADDR(x)      ((uint32_t)(x) + 0x51U)

#define HW_LCD_WF49(x)           (*(__IO hw_lcd_wf49_t *) HW_LCD_WF49_ADDR(x))
#define HW_LCD_WF49_RD(x)        (HW_LCD_WF49(x).U)
#define HW_LCD_WF49_WR(x, v)     (HW_LCD_WF49(x).U = (v))
#define HW_LCD_WF49_SET(x, v)    (BME_OR8(HW_LCD_WF49_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF49_CLR(x, v)    (BME_AND8(HW_LCD_WF49_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF49_TOG(x, v)    (BME_XOR8(HW_LCD_WF49_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF49 bitfields
 */

/*!
 * @name Register LCD_WF49, field BPALCD49[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF49_BPALCD49 (0U)          /*!< Bit position for LCD_WF49_BPALCD49. */
#define BM_LCD_WF49_BPALCD49 (0x01U)       /*!< Bit mask for LCD_WF49_BPALCD49. */
#define BS_LCD_WF49_BPALCD49 (1U)          /*!< Bit field size in bits for LCD_WF49_BPALCD49. */

/*! @brief Read current value of the LCD_WF49_BPALCD49 field. */
#define BR_LCD_WF49_BPALCD49(x) (BME_UBFX8(HW_LCD_WF49_ADDR(x), BP_LCD_WF49_BPALCD49, BS_LCD_WF49_BPALCD49))

/*! @brief Format value for bitfield LCD_WF49_BPALCD49. */
#define BF_LCD_WF49_BPALCD49(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF49_BPALCD49) & BM_LCD_WF49_BPALCD49)

/*! @brief Set the BPALCD49 field to a new value. */
#define BW_LCD_WF49_BPALCD49(x, v) (BME_BFI8(HW_LCD_WF49_ADDR(x), ((uint8_t)(v) << BP_LCD_WF49_BPALCD49), BP_LCD_WF49_BPALCD49, 1))
/*@}*/

/*!
 * @name Register LCD_WF49, field BPBLCD49[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF49_BPBLCD49 (1U)          /*!< Bit position for LCD_WF49_BPBLCD49. */
#define BM_LCD_WF49_BPBLCD49 (0x02U)       /*!< Bit mask for LCD_WF49_BPBLCD49. */
#define BS_LCD_WF49_BPBLCD49 (1U)          /*!< Bit field size in bits for LCD_WF49_BPBLCD49. */

/*! @brief Read current value of the LCD_WF49_BPBLCD49 field. */
#define BR_LCD_WF49_BPBLCD49(x) (BME_UBFX8(HW_LCD_WF49_ADDR(x), BP_LCD_WF49_BPBLCD49, BS_LCD_WF49_BPBLCD49))

/*! @brief Format value for bitfield LCD_WF49_BPBLCD49. */
#define BF_LCD_WF49_BPBLCD49(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF49_BPBLCD49) & BM_LCD_WF49_BPBLCD49)

/*! @brief Set the BPBLCD49 field to a new value. */
#define BW_LCD_WF49_BPBLCD49(x, v) (BME_BFI8(HW_LCD_WF49_ADDR(x), ((uint8_t)(v) << BP_LCD_WF49_BPBLCD49), BP_LCD_WF49_BPBLCD49, 1))
/*@}*/

/*!
 * @name Register LCD_WF49, field BPCLCD49[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF49_BPCLCD49 (2U)          /*!< Bit position for LCD_WF49_BPCLCD49. */
#define BM_LCD_WF49_BPCLCD49 (0x04U)       /*!< Bit mask for LCD_WF49_BPCLCD49. */
#define BS_LCD_WF49_BPCLCD49 (1U)          /*!< Bit field size in bits for LCD_WF49_BPCLCD49. */

/*! @brief Read current value of the LCD_WF49_BPCLCD49 field. */
#define BR_LCD_WF49_BPCLCD49(x) (BME_UBFX8(HW_LCD_WF49_ADDR(x), BP_LCD_WF49_BPCLCD49, BS_LCD_WF49_BPCLCD49))

/*! @brief Format value for bitfield LCD_WF49_BPCLCD49. */
#define BF_LCD_WF49_BPCLCD49(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF49_BPCLCD49) & BM_LCD_WF49_BPCLCD49)

/*! @brief Set the BPCLCD49 field to a new value. */
#define BW_LCD_WF49_BPCLCD49(x, v) (BME_BFI8(HW_LCD_WF49_ADDR(x), ((uint8_t)(v) << BP_LCD_WF49_BPCLCD49), BP_LCD_WF49_BPCLCD49, 1))
/*@}*/

/*!
 * @name Register LCD_WF49, field BPDLCD49[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF49_BPDLCD49 (3U)          /*!< Bit position for LCD_WF49_BPDLCD49. */
#define BM_LCD_WF49_BPDLCD49 (0x08U)       /*!< Bit mask for LCD_WF49_BPDLCD49. */
#define BS_LCD_WF49_BPDLCD49 (1U)          /*!< Bit field size in bits for LCD_WF49_BPDLCD49. */

/*! @brief Read current value of the LCD_WF49_BPDLCD49 field. */
#define BR_LCD_WF49_BPDLCD49(x) (BME_UBFX8(HW_LCD_WF49_ADDR(x), BP_LCD_WF49_BPDLCD49, BS_LCD_WF49_BPDLCD49))

/*! @brief Format value for bitfield LCD_WF49_BPDLCD49. */
#define BF_LCD_WF49_BPDLCD49(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF49_BPDLCD49) & BM_LCD_WF49_BPDLCD49)

/*! @brief Set the BPDLCD49 field to a new value. */
#define BW_LCD_WF49_BPDLCD49(x, v) (BME_BFI8(HW_LCD_WF49_ADDR(x), ((uint8_t)(v) << BP_LCD_WF49_BPDLCD49), BP_LCD_WF49_BPDLCD49, 1))
/*@}*/

/*!
 * @name Register LCD_WF49, field BPELCD49[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF49_BPELCD49 (4U)          /*!< Bit position for LCD_WF49_BPELCD49. */
#define BM_LCD_WF49_BPELCD49 (0x10U)       /*!< Bit mask for LCD_WF49_BPELCD49. */
#define BS_LCD_WF49_BPELCD49 (1U)          /*!< Bit field size in bits for LCD_WF49_BPELCD49. */

/*! @brief Read current value of the LCD_WF49_BPELCD49 field. */
#define BR_LCD_WF49_BPELCD49(x) (BME_UBFX8(HW_LCD_WF49_ADDR(x), BP_LCD_WF49_BPELCD49, BS_LCD_WF49_BPELCD49))

/*! @brief Format value for bitfield LCD_WF49_BPELCD49. */
#define BF_LCD_WF49_BPELCD49(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF49_BPELCD49) & BM_LCD_WF49_BPELCD49)

/*! @brief Set the BPELCD49 field to a new value. */
#define BW_LCD_WF49_BPELCD49(x, v) (BME_BFI8(HW_LCD_WF49_ADDR(x), ((uint8_t)(v) << BP_LCD_WF49_BPELCD49), BP_LCD_WF49_BPELCD49, 1))
/*@}*/

/*!
 * @name Register LCD_WF49, field BPFLCD49[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF49_BPFLCD49 (5U)          /*!< Bit position for LCD_WF49_BPFLCD49. */
#define BM_LCD_WF49_BPFLCD49 (0x20U)       /*!< Bit mask for LCD_WF49_BPFLCD49. */
#define BS_LCD_WF49_BPFLCD49 (1U)          /*!< Bit field size in bits for LCD_WF49_BPFLCD49. */

/*! @brief Read current value of the LCD_WF49_BPFLCD49 field. */
#define BR_LCD_WF49_BPFLCD49(x) (BME_UBFX8(HW_LCD_WF49_ADDR(x), BP_LCD_WF49_BPFLCD49, BS_LCD_WF49_BPFLCD49))

/*! @brief Format value for bitfield LCD_WF49_BPFLCD49. */
#define BF_LCD_WF49_BPFLCD49(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF49_BPFLCD49) & BM_LCD_WF49_BPFLCD49)

/*! @brief Set the BPFLCD49 field to a new value. */
#define BW_LCD_WF49_BPFLCD49(x, v) (BME_BFI8(HW_LCD_WF49_ADDR(x), ((uint8_t)(v) << BP_LCD_WF49_BPFLCD49), BP_LCD_WF49_BPFLCD49, 1))
/*@}*/

/*!
 * @name Register LCD_WF49, field BPGLCD49[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF49_BPGLCD49 (6U)          /*!< Bit position for LCD_WF49_BPGLCD49. */
#define BM_LCD_WF49_BPGLCD49 (0x40U)       /*!< Bit mask for LCD_WF49_BPGLCD49. */
#define BS_LCD_WF49_BPGLCD49 (1U)          /*!< Bit field size in bits for LCD_WF49_BPGLCD49. */

/*! @brief Read current value of the LCD_WF49_BPGLCD49 field. */
#define BR_LCD_WF49_BPGLCD49(x) (BME_UBFX8(HW_LCD_WF49_ADDR(x), BP_LCD_WF49_BPGLCD49, BS_LCD_WF49_BPGLCD49))

/*! @brief Format value for bitfield LCD_WF49_BPGLCD49. */
#define BF_LCD_WF49_BPGLCD49(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF49_BPGLCD49) & BM_LCD_WF49_BPGLCD49)

/*! @brief Set the BPGLCD49 field to a new value. */
#define BW_LCD_WF49_BPGLCD49(x, v) (BME_BFI8(HW_LCD_WF49_ADDR(x), ((uint8_t)(v) << BP_LCD_WF49_BPGLCD49), BP_LCD_WF49_BPGLCD49, 1))
/*@}*/

/*!
 * @name Register LCD_WF49, field BPHLCD49[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF49_BPHLCD49 (7U)          /*!< Bit position for LCD_WF49_BPHLCD49. */
#define BM_LCD_WF49_BPHLCD49 (0x80U)       /*!< Bit mask for LCD_WF49_BPHLCD49. */
#define BS_LCD_WF49_BPHLCD49 (1U)          /*!< Bit field size in bits for LCD_WF49_BPHLCD49. */

/*! @brief Read current value of the LCD_WF49_BPHLCD49 field. */
#define BR_LCD_WF49_BPHLCD49(x) (BME_UBFX8(HW_LCD_WF49_ADDR(x), BP_LCD_WF49_BPHLCD49, BS_LCD_WF49_BPHLCD49))

/*! @brief Format value for bitfield LCD_WF49_BPHLCD49. */
#define BF_LCD_WF49_BPHLCD49(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF49_BPHLCD49) & BM_LCD_WF49_BPHLCD49)

/*! @brief Set the BPHLCD49 field to a new value. */
#define BW_LCD_WF49_BPHLCD49(x, v) (BME_BFI8(HW_LCD_WF49_ADDR(x), ((uint8_t)(v) << BP_LCD_WF49_BPHLCD49), BP_LCD_WF49_BPHLCD49, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF50 - LCD Waveform Register 50.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF50 - LCD Waveform Register 50. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf50
{
    uint8_t U;
    struct _hw_lcd_wf50_bitfields
    {
        uint8_t BPALCD50 : 1;          /*!< [0]  */
        uint8_t BPBLCD50 : 1;          /*!< [1]  */
        uint8_t BPCLCD50 : 1;          /*!< [2]  */
        uint8_t BPDLCD50 : 1;          /*!< [3]  */
        uint8_t BPELCD50 : 1;          /*!< [4]  */
        uint8_t BPFLCD50 : 1;          /*!< [5]  */
        uint8_t BPGLCD50 : 1;          /*!< [6]  */
        uint8_t BPHLCD50 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf50_t;

/*!
 * @name Constants and macros for entire LCD_WF50 register
 */
/*@{*/
#define HW_LCD_WF50_ADDR(x)      ((uint32_t)(x) + 0x52U)

#define HW_LCD_WF50(x)           (*(__IO hw_lcd_wf50_t *) HW_LCD_WF50_ADDR(x))
#define HW_LCD_WF50_RD(x)        (HW_LCD_WF50(x).U)
#define HW_LCD_WF50_WR(x, v)     (HW_LCD_WF50(x).U = (v))
#define HW_LCD_WF50_SET(x, v)    (BME_OR8(HW_LCD_WF50_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF50_CLR(x, v)    (BME_AND8(HW_LCD_WF50_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF50_TOG(x, v)    (BME_XOR8(HW_LCD_WF50_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF50 bitfields
 */

/*!
 * @name Register LCD_WF50, field BPALCD50[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF50_BPALCD50 (0U)          /*!< Bit position for LCD_WF50_BPALCD50. */
#define BM_LCD_WF50_BPALCD50 (0x01U)       /*!< Bit mask for LCD_WF50_BPALCD50. */
#define BS_LCD_WF50_BPALCD50 (1U)          /*!< Bit field size in bits for LCD_WF50_BPALCD50. */

/*! @brief Read current value of the LCD_WF50_BPALCD50 field. */
#define BR_LCD_WF50_BPALCD50(x) (BME_UBFX8(HW_LCD_WF50_ADDR(x), BP_LCD_WF50_BPALCD50, BS_LCD_WF50_BPALCD50))

/*! @brief Format value for bitfield LCD_WF50_BPALCD50. */
#define BF_LCD_WF50_BPALCD50(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF50_BPALCD50) & BM_LCD_WF50_BPALCD50)

/*! @brief Set the BPALCD50 field to a new value. */
#define BW_LCD_WF50_BPALCD50(x, v) (BME_BFI8(HW_LCD_WF50_ADDR(x), ((uint8_t)(v) << BP_LCD_WF50_BPALCD50), BP_LCD_WF50_BPALCD50, 1))
/*@}*/

/*!
 * @name Register LCD_WF50, field BPBLCD50[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF50_BPBLCD50 (1U)          /*!< Bit position for LCD_WF50_BPBLCD50. */
#define BM_LCD_WF50_BPBLCD50 (0x02U)       /*!< Bit mask for LCD_WF50_BPBLCD50. */
#define BS_LCD_WF50_BPBLCD50 (1U)          /*!< Bit field size in bits for LCD_WF50_BPBLCD50. */

/*! @brief Read current value of the LCD_WF50_BPBLCD50 field. */
#define BR_LCD_WF50_BPBLCD50(x) (BME_UBFX8(HW_LCD_WF50_ADDR(x), BP_LCD_WF50_BPBLCD50, BS_LCD_WF50_BPBLCD50))

/*! @brief Format value for bitfield LCD_WF50_BPBLCD50. */
#define BF_LCD_WF50_BPBLCD50(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF50_BPBLCD50) & BM_LCD_WF50_BPBLCD50)

/*! @brief Set the BPBLCD50 field to a new value. */
#define BW_LCD_WF50_BPBLCD50(x, v) (BME_BFI8(HW_LCD_WF50_ADDR(x), ((uint8_t)(v) << BP_LCD_WF50_BPBLCD50), BP_LCD_WF50_BPBLCD50, 1))
/*@}*/

/*!
 * @name Register LCD_WF50, field BPCLCD50[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF50_BPCLCD50 (2U)          /*!< Bit position for LCD_WF50_BPCLCD50. */
#define BM_LCD_WF50_BPCLCD50 (0x04U)       /*!< Bit mask for LCD_WF50_BPCLCD50. */
#define BS_LCD_WF50_BPCLCD50 (1U)          /*!< Bit field size in bits for LCD_WF50_BPCLCD50. */

/*! @brief Read current value of the LCD_WF50_BPCLCD50 field. */
#define BR_LCD_WF50_BPCLCD50(x) (BME_UBFX8(HW_LCD_WF50_ADDR(x), BP_LCD_WF50_BPCLCD50, BS_LCD_WF50_BPCLCD50))

/*! @brief Format value for bitfield LCD_WF50_BPCLCD50. */
#define BF_LCD_WF50_BPCLCD50(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF50_BPCLCD50) & BM_LCD_WF50_BPCLCD50)

/*! @brief Set the BPCLCD50 field to a new value. */
#define BW_LCD_WF50_BPCLCD50(x, v) (BME_BFI8(HW_LCD_WF50_ADDR(x), ((uint8_t)(v) << BP_LCD_WF50_BPCLCD50), BP_LCD_WF50_BPCLCD50, 1))
/*@}*/

/*!
 * @name Register LCD_WF50, field BPDLCD50[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF50_BPDLCD50 (3U)          /*!< Bit position for LCD_WF50_BPDLCD50. */
#define BM_LCD_WF50_BPDLCD50 (0x08U)       /*!< Bit mask for LCD_WF50_BPDLCD50. */
#define BS_LCD_WF50_BPDLCD50 (1U)          /*!< Bit field size in bits for LCD_WF50_BPDLCD50. */

/*! @brief Read current value of the LCD_WF50_BPDLCD50 field. */
#define BR_LCD_WF50_BPDLCD50(x) (BME_UBFX8(HW_LCD_WF50_ADDR(x), BP_LCD_WF50_BPDLCD50, BS_LCD_WF50_BPDLCD50))

/*! @brief Format value for bitfield LCD_WF50_BPDLCD50. */
#define BF_LCD_WF50_BPDLCD50(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF50_BPDLCD50) & BM_LCD_WF50_BPDLCD50)

/*! @brief Set the BPDLCD50 field to a new value. */
#define BW_LCD_WF50_BPDLCD50(x, v) (BME_BFI8(HW_LCD_WF50_ADDR(x), ((uint8_t)(v) << BP_LCD_WF50_BPDLCD50), BP_LCD_WF50_BPDLCD50, 1))
/*@}*/

/*!
 * @name Register LCD_WF50, field BPELCD50[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF50_BPELCD50 (4U)          /*!< Bit position for LCD_WF50_BPELCD50. */
#define BM_LCD_WF50_BPELCD50 (0x10U)       /*!< Bit mask for LCD_WF50_BPELCD50. */
#define BS_LCD_WF50_BPELCD50 (1U)          /*!< Bit field size in bits for LCD_WF50_BPELCD50. */

/*! @brief Read current value of the LCD_WF50_BPELCD50 field. */
#define BR_LCD_WF50_BPELCD50(x) (BME_UBFX8(HW_LCD_WF50_ADDR(x), BP_LCD_WF50_BPELCD50, BS_LCD_WF50_BPELCD50))

/*! @brief Format value for bitfield LCD_WF50_BPELCD50. */
#define BF_LCD_WF50_BPELCD50(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF50_BPELCD50) & BM_LCD_WF50_BPELCD50)

/*! @brief Set the BPELCD50 field to a new value. */
#define BW_LCD_WF50_BPELCD50(x, v) (BME_BFI8(HW_LCD_WF50_ADDR(x), ((uint8_t)(v) << BP_LCD_WF50_BPELCD50), BP_LCD_WF50_BPELCD50, 1))
/*@}*/

/*!
 * @name Register LCD_WF50, field BPFLCD50[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF50_BPFLCD50 (5U)          /*!< Bit position for LCD_WF50_BPFLCD50. */
#define BM_LCD_WF50_BPFLCD50 (0x20U)       /*!< Bit mask for LCD_WF50_BPFLCD50. */
#define BS_LCD_WF50_BPFLCD50 (1U)          /*!< Bit field size in bits for LCD_WF50_BPFLCD50. */

/*! @brief Read current value of the LCD_WF50_BPFLCD50 field. */
#define BR_LCD_WF50_BPFLCD50(x) (BME_UBFX8(HW_LCD_WF50_ADDR(x), BP_LCD_WF50_BPFLCD50, BS_LCD_WF50_BPFLCD50))

/*! @brief Format value for bitfield LCD_WF50_BPFLCD50. */
#define BF_LCD_WF50_BPFLCD50(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF50_BPFLCD50) & BM_LCD_WF50_BPFLCD50)

/*! @brief Set the BPFLCD50 field to a new value. */
#define BW_LCD_WF50_BPFLCD50(x, v) (BME_BFI8(HW_LCD_WF50_ADDR(x), ((uint8_t)(v) << BP_LCD_WF50_BPFLCD50), BP_LCD_WF50_BPFLCD50, 1))
/*@}*/

/*!
 * @name Register LCD_WF50, field BPGLCD50[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF50_BPGLCD50 (6U)          /*!< Bit position for LCD_WF50_BPGLCD50. */
#define BM_LCD_WF50_BPGLCD50 (0x40U)       /*!< Bit mask for LCD_WF50_BPGLCD50. */
#define BS_LCD_WF50_BPGLCD50 (1U)          /*!< Bit field size in bits for LCD_WF50_BPGLCD50. */

/*! @brief Read current value of the LCD_WF50_BPGLCD50 field. */
#define BR_LCD_WF50_BPGLCD50(x) (BME_UBFX8(HW_LCD_WF50_ADDR(x), BP_LCD_WF50_BPGLCD50, BS_LCD_WF50_BPGLCD50))

/*! @brief Format value for bitfield LCD_WF50_BPGLCD50. */
#define BF_LCD_WF50_BPGLCD50(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF50_BPGLCD50) & BM_LCD_WF50_BPGLCD50)

/*! @brief Set the BPGLCD50 field to a new value. */
#define BW_LCD_WF50_BPGLCD50(x, v) (BME_BFI8(HW_LCD_WF50_ADDR(x), ((uint8_t)(v) << BP_LCD_WF50_BPGLCD50), BP_LCD_WF50_BPGLCD50, 1))
/*@}*/

/*!
 * @name Register LCD_WF50, field BPHLCD50[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF50_BPHLCD50 (7U)          /*!< Bit position for LCD_WF50_BPHLCD50. */
#define BM_LCD_WF50_BPHLCD50 (0x80U)       /*!< Bit mask for LCD_WF50_BPHLCD50. */
#define BS_LCD_WF50_BPHLCD50 (1U)          /*!< Bit field size in bits for LCD_WF50_BPHLCD50. */

/*! @brief Read current value of the LCD_WF50_BPHLCD50 field. */
#define BR_LCD_WF50_BPHLCD50(x) (BME_UBFX8(HW_LCD_WF50_ADDR(x), BP_LCD_WF50_BPHLCD50, BS_LCD_WF50_BPHLCD50))

/*! @brief Format value for bitfield LCD_WF50_BPHLCD50. */
#define BF_LCD_WF50_BPHLCD50(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF50_BPHLCD50) & BM_LCD_WF50_BPHLCD50)

/*! @brief Set the BPHLCD50 field to a new value. */
#define BW_LCD_WF50_BPHLCD50(x, v) (BME_BFI8(HW_LCD_WF50_ADDR(x), ((uint8_t)(v) << BP_LCD_WF50_BPHLCD50), BP_LCD_WF50_BPHLCD50, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF51 - LCD Waveform Register 51.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF51 - LCD Waveform Register 51. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf51
{
    uint8_t U;
    struct _hw_lcd_wf51_bitfields
    {
        uint8_t BPALCD51 : 1;          /*!< [0]  */
        uint8_t BPBLCD51 : 1;          /*!< [1]  */
        uint8_t BPCLCD51 : 1;          /*!< [2]  */
        uint8_t BPDLCD51 : 1;          /*!< [3]  */
        uint8_t BPELCD51 : 1;          /*!< [4]  */
        uint8_t BPFLCD51 : 1;          /*!< [5]  */
        uint8_t BPGLCD51 : 1;          /*!< [6]  */
        uint8_t BPHLCD51 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf51_t;

/*!
 * @name Constants and macros for entire LCD_WF51 register
 */
/*@{*/
#define HW_LCD_WF51_ADDR(x)      ((uint32_t)(x) + 0x53U)

#define HW_LCD_WF51(x)           (*(__IO hw_lcd_wf51_t *) HW_LCD_WF51_ADDR(x))
#define HW_LCD_WF51_RD(x)        (HW_LCD_WF51(x).U)
#define HW_LCD_WF51_WR(x, v)     (HW_LCD_WF51(x).U = (v))
#define HW_LCD_WF51_SET(x, v)    (BME_OR8(HW_LCD_WF51_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF51_CLR(x, v)    (BME_AND8(HW_LCD_WF51_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF51_TOG(x, v)    (BME_XOR8(HW_LCD_WF51_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF51 bitfields
 */

/*!
 * @name Register LCD_WF51, field BPALCD51[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF51_BPALCD51 (0U)          /*!< Bit position for LCD_WF51_BPALCD51. */
#define BM_LCD_WF51_BPALCD51 (0x01U)       /*!< Bit mask for LCD_WF51_BPALCD51. */
#define BS_LCD_WF51_BPALCD51 (1U)          /*!< Bit field size in bits for LCD_WF51_BPALCD51. */

/*! @brief Read current value of the LCD_WF51_BPALCD51 field. */
#define BR_LCD_WF51_BPALCD51(x) (BME_UBFX8(HW_LCD_WF51_ADDR(x), BP_LCD_WF51_BPALCD51, BS_LCD_WF51_BPALCD51))

/*! @brief Format value for bitfield LCD_WF51_BPALCD51. */
#define BF_LCD_WF51_BPALCD51(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF51_BPALCD51) & BM_LCD_WF51_BPALCD51)

/*! @brief Set the BPALCD51 field to a new value. */
#define BW_LCD_WF51_BPALCD51(x, v) (BME_BFI8(HW_LCD_WF51_ADDR(x), ((uint8_t)(v) << BP_LCD_WF51_BPALCD51), BP_LCD_WF51_BPALCD51, 1))
/*@}*/

/*!
 * @name Register LCD_WF51, field BPBLCD51[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF51_BPBLCD51 (1U)          /*!< Bit position for LCD_WF51_BPBLCD51. */
#define BM_LCD_WF51_BPBLCD51 (0x02U)       /*!< Bit mask for LCD_WF51_BPBLCD51. */
#define BS_LCD_WF51_BPBLCD51 (1U)          /*!< Bit field size in bits for LCD_WF51_BPBLCD51. */

/*! @brief Read current value of the LCD_WF51_BPBLCD51 field. */
#define BR_LCD_WF51_BPBLCD51(x) (BME_UBFX8(HW_LCD_WF51_ADDR(x), BP_LCD_WF51_BPBLCD51, BS_LCD_WF51_BPBLCD51))

/*! @brief Format value for bitfield LCD_WF51_BPBLCD51. */
#define BF_LCD_WF51_BPBLCD51(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF51_BPBLCD51) & BM_LCD_WF51_BPBLCD51)

/*! @brief Set the BPBLCD51 field to a new value. */
#define BW_LCD_WF51_BPBLCD51(x, v) (BME_BFI8(HW_LCD_WF51_ADDR(x), ((uint8_t)(v) << BP_LCD_WF51_BPBLCD51), BP_LCD_WF51_BPBLCD51, 1))
/*@}*/

/*!
 * @name Register LCD_WF51, field BPCLCD51[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF51_BPCLCD51 (2U)          /*!< Bit position for LCD_WF51_BPCLCD51. */
#define BM_LCD_WF51_BPCLCD51 (0x04U)       /*!< Bit mask for LCD_WF51_BPCLCD51. */
#define BS_LCD_WF51_BPCLCD51 (1U)          /*!< Bit field size in bits for LCD_WF51_BPCLCD51. */

/*! @brief Read current value of the LCD_WF51_BPCLCD51 field. */
#define BR_LCD_WF51_BPCLCD51(x) (BME_UBFX8(HW_LCD_WF51_ADDR(x), BP_LCD_WF51_BPCLCD51, BS_LCD_WF51_BPCLCD51))

/*! @brief Format value for bitfield LCD_WF51_BPCLCD51. */
#define BF_LCD_WF51_BPCLCD51(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF51_BPCLCD51) & BM_LCD_WF51_BPCLCD51)

/*! @brief Set the BPCLCD51 field to a new value. */
#define BW_LCD_WF51_BPCLCD51(x, v) (BME_BFI8(HW_LCD_WF51_ADDR(x), ((uint8_t)(v) << BP_LCD_WF51_BPCLCD51), BP_LCD_WF51_BPCLCD51, 1))
/*@}*/

/*!
 * @name Register LCD_WF51, field BPDLCD51[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF51_BPDLCD51 (3U)          /*!< Bit position for LCD_WF51_BPDLCD51. */
#define BM_LCD_WF51_BPDLCD51 (0x08U)       /*!< Bit mask for LCD_WF51_BPDLCD51. */
#define BS_LCD_WF51_BPDLCD51 (1U)          /*!< Bit field size in bits for LCD_WF51_BPDLCD51. */

/*! @brief Read current value of the LCD_WF51_BPDLCD51 field. */
#define BR_LCD_WF51_BPDLCD51(x) (BME_UBFX8(HW_LCD_WF51_ADDR(x), BP_LCD_WF51_BPDLCD51, BS_LCD_WF51_BPDLCD51))

/*! @brief Format value for bitfield LCD_WF51_BPDLCD51. */
#define BF_LCD_WF51_BPDLCD51(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF51_BPDLCD51) & BM_LCD_WF51_BPDLCD51)

/*! @brief Set the BPDLCD51 field to a new value. */
#define BW_LCD_WF51_BPDLCD51(x, v) (BME_BFI8(HW_LCD_WF51_ADDR(x), ((uint8_t)(v) << BP_LCD_WF51_BPDLCD51), BP_LCD_WF51_BPDLCD51, 1))
/*@}*/

/*!
 * @name Register LCD_WF51, field BPELCD51[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF51_BPELCD51 (4U)          /*!< Bit position for LCD_WF51_BPELCD51. */
#define BM_LCD_WF51_BPELCD51 (0x10U)       /*!< Bit mask for LCD_WF51_BPELCD51. */
#define BS_LCD_WF51_BPELCD51 (1U)          /*!< Bit field size in bits for LCD_WF51_BPELCD51. */

/*! @brief Read current value of the LCD_WF51_BPELCD51 field. */
#define BR_LCD_WF51_BPELCD51(x) (BME_UBFX8(HW_LCD_WF51_ADDR(x), BP_LCD_WF51_BPELCD51, BS_LCD_WF51_BPELCD51))

/*! @brief Format value for bitfield LCD_WF51_BPELCD51. */
#define BF_LCD_WF51_BPELCD51(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF51_BPELCD51) & BM_LCD_WF51_BPELCD51)

/*! @brief Set the BPELCD51 field to a new value. */
#define BW_LCD_WF51_BPELCD51(x, v) (BME_BFI8(HW_LCD_WF51_ADDR(x), ((uint8_t)(v) << BP_LCD_WF51_BPELCD51), BP_LCD_WF51_BPELCD51, 1))
/*@}*/

/*!
 * @name Register LCD_WF51, field BPFLCD51[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF51_BPFLCD51 (5U)          /*!< Bit position for LCD_WF51_BPFLCD51. */
#define BM_LCD_WF51_BPFLCD51 (0x20U)       /*!< Bit mask for LCD_WF51_BPFLCD51. */
#define BS_LCD_WF51_BPFLCD51 (1U)          /*!< Bit field size in bits for LCD_WF51_BPFLCD51. */

/*! @brief Read current value of the LCD_WF51_BPFLCD51 field. */
#define BR_LCD_WF51_BPFLCD51(x) (BME_UBFX8(HW_LCD_WF51_ADDR(x), BP_LCD_WF51_BPFLCD51, BS_LCD_WF51_BPFLCD51))

/*! @brief Format value for bitfield LCD_WF51_BPFLCD51. */
#define BF_LCD_WF51_BPFLCD51(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF51_BPFLCD51) & BM_LCD_WF51_BPFLCD51)

/*! @brief Set the BPFLCD51 field to a new value. */
#define BW_LCD_WF51_BPFLCD51(x, v) (BME_BFI8(HW_LCD_WF51_ADDR(x), ((uint8_t)(v) << BP_LCD_WF51_BPFLCD51), BP_LCD_WF51_BPFLCD51, 1))
/*@}*/

/*!
 * @name Register LCD_WF51, field BPGLCD51[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF51_BPGLCD51 (6U)          /*!< Bit position for LCD_WF51_BPGLCD51. */
#define BM_LCD_WF51_BPGLCD51 (0x40U)       /*!< Bit mask for LCD_WF51_BPGLCD51. */
#define BS_LCD_WF51_BPGLCD51 (1U)          /*!< Bit field size in bits for LCD_WF51_BPGLCD51. */

/*! @brief Read current value of the LCD_WF51_BPGLCD51 field. */
#define BR_LCD_WF51_BPGLCD51(x) (BME_UBFX8(HW_LCD_WF51_ADDR(x), BP_LCD_WF51_BPGLCD51, BS_LCD_WF51_BPGLCD51))

/*! @brief Format value for bitfield LCD_WF51_BPGLCD51. */
#define BF_LCD_WF51_BPGLCD51(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF51_BPGLCD51) & BM_LCD_WF51_BPGLCD51)

/*! @brief Set the BPGLCD51 field to a new value. */
#define BW_LCD_WF51_BPGLCD51(x, v) (BME_BFI8(HW_LCD_WF51_ADDR(x), ((uint8_t)(v) << BP_LCD_WF51_BPGLCD51), BP_LCD_WF51_BPGLCD51, 1))
/*@}*/

/*!
 * @name Register LCD_WF51, field BPHLCD51[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF51_BPHLCD51 (7U)          /*!< Bit position for LCD_WF51_BPHLCD51. */
#define BM_LCD_WF51_BPHLCD51 (0x80U)       /*!< Bit mask for LCD_WF51_BPHLCD51. */
#define BS_LCD_WF51_BPHLCD51 (1U)          /*!< Bit field size in bits for LCD_WF51_BPHLCD51. */

/*! @brief Read current value of the LCD_WF51_BPHLCD51 field. */
#define BR_LCD_WF51_BPHLCD51(x) (BME_UBFX8(HW_LCD_WF51_ADDR(x), BP_LCD_WF51_BPHLCD51, BS_LCD_WF51_BPHLCD51))

/*! @brief Format value for bitfield LCD_WF51_BPHLCD51. */
#define BF_LCD_WF51_BPHLCD51(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF51_BPHLCD51) & BM_LCD_WF51_BPHLCD51)

/*! @brief Set the BPHLCD51 field to a new value. */
#define BW_LCD_WF51_BPHLCD51(x, v) (BME_BFI8(HW_LCD_WF51_ADDR(x), ((uint8_t)(v) << BP_LCD_WF51_BPHLCD51), BP_LCD_WF51_BPHLCD51, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF52 - LCD Waveform Register 52.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF52 - LCD Waveform Register 52. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf52
{
    uint8_t U;
    struct _hw_lcd_wf52_bitfields
    {
        uint8_t BPALCD52 : 1;          /*!< [0]  */
        uint8_t BPBLCD52 : 1;          /*!< [1]  */
        uint8_t BPCLCD52 : 1;          /*!< [2]  */
        uint8_t BPDLCD52 : 1;          /*!< [3]  */
        uint8_t BPELCD52 : 1;          /*!< [4]  */
        uint8_t BPFLCD52 : 1;          /*!< [5]  */
        uint8_t BPGLCD52 : 1;          /*!< [6]  */
        uint8_t BPHLCD52 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf52_t;

/*!
 * @name Constants and macros for entire LCD_WF52 register
 */
/*@{*/
#define HW_LCD_WF52_ADDR(x)      ((uint32_t)(x) + 0x54U)

#define HW_LCD_WF52(x)           (*(__IO hw_lcd_wf52_t *) HW_LCD_WF52_ADDR(x))
#define HW_LCD_WF52_RD(x)        (HW_LCD_WF52(x).U)
#define HW_LCD_WF52_WR(x, v)     (HW_LCD_WF52(x).U = (v))
#define HW_LCD_WF52_SET(x, v)    (BME_OR8(HW_LCD_WF52_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF52_CLR(x, v)    (BME_AND8(HW_LCD_WF52_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF52_TOG(x, v)    (BME_XOR8(HW_LCD_WF52_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF52 bitfields
 */

/*!
 * @name Register LCD_WF52, field BPALCD52[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF52_BPALCD52 (0U)          /*!< Bit position for LCD_WF52_BPALCD52. */
#define BM_LCD_WF52_BPALCD52 (0x01U)       /*!< Bit mask for LCD_WF52_BPALCD52. */
#define BS_LCD_WF52_BPALCD52 (1U)          /*!< Bit field size in bits for LCD_WF52_BPALCD52. */

/*! @brief Read current value of the LCD_WF52_BPALCD52 field. */
#define BR_LCD_WF52_BPALCD52(x) (BME_UBFX8(HW_LCD_WF52_ADDR(x), BP_LCD_WF52_BPALCD52, BS_LCD_WF52_BPALCD52))

/*! @brief Format value for bitfield LCD_WF52_BPALCD52. */
#define BF_LCD_WF52_BPALCD52(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF52_BPALCD52) & BM_LCD_WF52_BPALCD52)

/*! @brief Set the BPALCD52 field to a new value. */
#define BW_LCD_WF52_BPALCD52(x, v) (BME_BFI8(HW_LCD_WF52_ADDR(x), ((uint8_t)(v) << BP_LCD_WF52_BPALCD52), BP_LCD_WF52_BPALCD52, 1))
/*@}*/

/*!
 * @name Register LCD_WF52, field BPBLCD52[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF52_BPBLCD52 (1U)          /*!< Bit position for LCD_WF52_BPBLCD52. */
#define BM_LCD_WF52_BPBLCD52 (0x02U)       /*!< Bit mask for LCD_WF52_BPBLCD52. */
#define BS_LCD_WF52_BPBLCD52 (1U)          /*!< Bit field size in bits for LCD_WF52_BPBLCD52. */

/*! @brief Read current value of the LCD_WF52_BPBLCD52 field. */
#define BR_LCD_WF52_BPBLCD52(x) (BME_UBFX8(HW_LCD_WF52_ADDR(x), BP_LCD_WF52_BPBLCD52, BS_LCD_WF52_BPBLCD52))

/*! @brief Format value for bitfield LCD_WF52_BPBLCD52. */
#define BF_LCD_WF52_BPBLCD52(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF52_BPBLCD52) & BM_LCD_WF52_BPBLCD52)

/*! @brief Set the BPBLCD52 field to a new value. */
#define BW_LCD_WF52_BPBLCD52(x, v) (BME_BFI8(HW_LCD_WF52_ADDR(x), ((uint8_t)(v) << BP_LCD_WF52_BPBLCD52), BP_LCD_WF52_BPBLCD52, 1))
/*@}*/

/*!
 * @name Register LCD_WF52, field BPCLCD52[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF52_BPCLCD52 (2U)          /*!< Bit position for LCD_WF52_BPCLCD52. */
#define BM_LCD_WF52_BPCLCD52 (0x04U)       /*!< Bit mask for LCD_WF52_BPCLCD52. */
#define BS_LCD_WF52_BPCLCD52 (1U)          /*!< Bit field size in bits for LCD_WF52_BPCLCD52. */

/*! @brief Read current value of the LCD_WF52_BPCLCD52 field. */
#define BR_LCD_WF52_BPCLCD52(x) (BME_UBFX8(HW_LCD_WF52_ADDR(x), BP_LCD_WF52_BPCLCD52, BS_LCD_WF52_BPCLCD52))

/*! @brief Format value for bitfield LCD_WF52_BPCLCD52. */
#define BF_LCD_WF52_BPCLCD52(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF52_BPCLCD52) & BM_LCD_WF52_BPCLCD52)

/*! @brief Set the BPCLCD52 field to a new value. */
#define BW_LCD_WF52_BPCLCD52(x, v) (BME_BFI8(HW_LCD_WF52_ADDR(x), ((uint8_t)(v) << BP_LCD_WF52_BPCLCD52), BP_LCD_WF52_BPCLCD52, 1))
/*@}*/

/*!
 * @name Register LCD_WF52, field BPDLCD52[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF52_BPDLCD52 (3U)          /*!< Bit position for LCD_WF52_BPDLCD52. */
#define BM_LCD_WF52_BPDLCD52 (0x08U)       /*!< Bit mask for LCD_WF52_BPDLCD52. */
#define BS_LCD_WF52_BPDLCD52 (1U)          /*!< Bit field size in bits for LCD_WF52_BPDLCD52. */

/*! @brief Read current value of the LCD_WF52_BPDLCD52 field. */
#define BR_LCD_WF52_BPDLCD52(x) (BME_UBFX8(HW_LCD_WF52_ADDR(x), BP_LCD_WF52_BPDLCD52, BS_LCD_WF52_BPDLCD52))

/*! @brief Format value for bitfield LCD_WF52_BPDLCD52. */
#define BF_LCD_WF52_BPDLCD52(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF52_BPDLCD52) & BM_LCD_WF52_BPDLCD52)

/*! @brief Set the BPDLCD52 field to a new value. */
#define BW_LCD_WF52_BPDLCD52(x, v) (BME_BFI8(HW_LCD_WF52_ADDR(x), ((uint8_t)(v) << BP_LCD_WF52_BPDLCD52), BP_LCD_WF52_BPDLCD52, 1))
/*@}*/

/*!
 * @name Register LCD_WF52, field BPELCD52[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF52_BPELCD52 (4U)          /*!< Bit position for LCD_WF52_BPELCD52. */
#define BM_LCD_WF52_BPELCD52 (0x10U)       /*!< Bit mask for LCD_WF52_BPELCD52. */
#define BS_LCD_WF52_BPELCD52 (1U)          /*!< Bit field size in bits for LCD_WF52_BPELCD52. */

/*! @brief Read current value of the LCD_WF52_BPELCD52 field. */
#define BR_LCD_WF52_BPELCD52(x) (BME_UBFX8(HW_LCD_WF52_ADDR(x), BP_LCD_WF52_BPELCD52, BS_LCD_WF52_BPELCD52))

/*! @brief Format value for bitfield LCD_WF52_BPELCD52. */
#define BF_LCD_WF52_BPELCD52(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF52_BPELCD52) & BM_LCD_WF52_BPELCD52)

/*! @brief Set the BPELCD52 field to a new value. */
#define BW_LCD_WF52_BPELCD52(x, v) (BME_BFI8(HW_LCD_WF52_ADDR(x), ((uint8_t)(v) << BP_LCD_WF52_BPELCD52), BP_LCD_WF52_BPELCD52, 1))
/*@}*/

/*!
 * @name Register LCD_WF52, field BPFLCD52[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF52_BPFLCD52 (5U)          /*!< Bit position for LCD_WF52_BPFLCD52. */
#define BM_LCD_WF52_BPFLCD52 (0x20U)       /*!< Bit mask for LCD_WF52_BPFLCD52. */
#define BS_LCD_WF52_BPFLCD52 (1U)          /*!< Bit field size in bits for LCD_WF52_BPFLCD52. */

/*! @brief Read current value of the LCD_WF52_BPFLCD52 field. */
#define BR_LCD_WF52_BPFLCD52(x) (BME_UBFX8(HW_LCD_WF52_ADDR(x), BP_LCD_WF52_BPFLCD52, BS_LCD_WF52_BPFLCD52))

/*! @brief Format value for bitfield LCD_WF52_BPFLCD52. */
#define BF_LCD_WF52_BPFLCD52(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF52_BPFLCD52) & BM_LCD_WF52_BPFLCD52)

/*! @brief Set the BPFLCD52 field to a new value. */
#define BW_LCD_WF52_BPFLCD52(x, v) (BME_BFI8(HW_LCD_WF52_ADDR(x), ((uint8_t)(v) << BP_LCD_WF52_BPFLCD52), BP_LCD_WF52_BPFLCD52, 1))
/*@}*/

/*!
 * @name Register LCD_WF52, field BPGLCD52[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF52_BPGLCD52 (6U)          /*!< Bit position for LCD_WF52_BPGLCD52. */
#define BM_LCD_WF52_BPGLCD52 (0x40U)       /*!< Bit mask for LCD_WF52_BPGLCD52. */
#define BS_LCD_WF52_BPGLCD52 (1U)          /*!< Bit field size in bits for LCD_WF52_BPGLCD52. */

/*! @brief Read current value of the LCD_WF52_BPGLCD52 field. */
#define BR_LCD_WF52_BPGLCD52(x) (BME_UBFX8(HW_LCD_WF52_ADDR(x), BP_LCD_WF52_BPGLCD52, BS_LCD_WF52_BPGLCD52))

/*! @brief Format value for bitfield LCD_WF52_BPGLCD52. */
#define BF_LCD_WF52_BPGLCD52(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF52_BPGLCD52) & BM_LCD_WF52_BPGLCD52)

/*! @brief Set the BPGLCD52 field to a new value. */
#define BW_LCD_WF52_BPGLCD52(x, v) (BME_BFI8(HW_LCD_WF52_ADDR(x), ((uint8_t)(v) << BP_LCD_WF52_BPGLCD52), BP_LCD_WF52_BPGLCD52, 1))
/*@}*/

/*!
 * @name Register LCD_WF52, field BPHLCD52[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF52_BPHLCD52 (7U)          /*!< Bit position for LCD_WF52_BPHLCD52. */
#define BM_LCD_WF52_BPHLCD52 (0x80U)       /*!< Bit mask for LCD_WF52_BPHLCD52. */
#define BS_LCD_WF52_BPHLCD52 (1U)          /*!< Bit field size in bits for LCD_WF52_BPHLCD52. */

/*! @brief Read current value of the LCD_WF52_BPHLCD52 field. */
#define BR_LCD_WF52_BPHLCD52(x) (BME_UBFX8(HW_LCD_WF52_ADDR(x), BP_LCD_WF52_BPHLCD52, BS_LCD_WF52_BPHLCD52))

/*! @brief Format value for bitfield LCD_WF52_BPHLCD52. */
#define BF_LCD_WF52_BPHLCD52(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF52_BPHLCD52) & BM_LCD_WF52_BPHLCD52)

/*! @brief Set the BPHLCD52 field to a new value. */
#define BW_LCD_WF52_BPHLCD52(x, v) (BME_BFI8(HW_LCD_WF52_ADDR(x), ((uint8_t)(v) << BP_LCD_WF52_BPHLCD52), BP_LCD_WF52_BPHLCD52, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF53 - LCD Waveform Register 53.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF53 - LCD Waveform Register 53. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf53
{
    uint8_t U;
    struct _hw_lcd_wf53_bitfields
    {
        uint8_t BPALCD53 : 1;          /*!< [0]  */
        uint8_t BPBLCD53 : 1;          /*!< [1]  */
        uint8_t BPCLCD53 : 1;          /*!< [2]  */
        uint8_t BPDLCD53 : 1;          /*!< [3]  */
        uint8_t BPELCD53 : 1;          /*!< [4]  */
        uint8_t BPFLCD53 : 1;          /*!< [5]  */
        uint8_t BPGLCD53 : 1;          /*!< [6]  */
        uint8_t BPHLCD53 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf53_t;

/*!
 * @name Constants and macros for entire LCD_WF53 register
 */
/*@{*/
#define HW_LCD_WF53_ADDR(x)      ((uint32_t)(x) + 0x55U)

#define HW_LCD_WF53(x)           (*(__IO hw_lcd_wf53_t *) HW_LCD_WF53_ADDR(x))
#define HW_LCD_WF53_RD(x)        (HW_LCD_WF53(x).U)
#define HW_LCD_WF53_WR(x, v)     (HW_LCD_WF53(x).U = (v))
#define HW_LCD_WF53_SET(x, v)    (BME_OR8(HW_LCD_WF53_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF53_CLR(x, v)    (BME_AND8(HW_LCD_WF53_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF53_TOG(x, v)    (BME_XOR8(HW_LCD_WF53_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF53 bitfields
 */

/*!
 * @name Register LCD_WF53, field BPALCD53[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF53_BPALCD53 (0U)          /*!< Bit position for LCD_WF53_BPALCD53. */
#define BM_LCD_WF53_BPALCD53 (0x01U)       /*!< Bit mask for LCD_WF53_BPALCD53. */
#define BS_LCD_WF53_BPALCD53 (1U)          /*!< Bit field size in bits for LCD_WF53_BPALCD53. */

/*! @brief Read current value of the LCD_WF53_BPALCD53 field. */
#define BR_LCD_WF53_BPALCD53(x) (BME_UBFX8(HW_LCD_WF53_ADDR(x), BP_LCD_WF53_BPALCD53, BS_LCD_WF53_BPALCD53))

/*! @brief Format value for bitfield LCD_WF53_BPALCD53. */
#define BF_LCD_WF53_BPALCD53(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF53_BPALCD53) & BM_LCD_WF53_BPALCD53)

/*! @brief Set the BPALCD53 field to a new value. */
#define BW_LCD_WF53_BPALCD53(x, v) (BME_BFI8(HW_LCD_WF53_ADDR(x), ((uint8_t)(v) << BP_LCD_WF53_BPALCD53), BP_LCD_WF53_BPALCD53, 1))
/*@}*/

/*!
 * @name Register LCD_WF53, field BPBLCD53[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF53_BPBLCD53 (1U)          /*!< Bit position for LCD_WF53_BPBLCD53. */
#define BM_LCD_WF53_BPBLCD53 (0x02U)       /*!< Bit mask for LCD_WF53_BPBLCD53. */
#define BS_LCD_WF53_BPBLCD53 (1U)          /*!< Bit field size in bits for LCD_WF53_BPBLCD53. */

/*! @brief Read current value of the LCD_WF53_BPBLCD53 field. */
#define BR_LCD_WF53_BPBLCD53(x) (BME_UBFX8(HW_LCD_WF53_ADDR(x), BP_LCD_WF53_BPBLCD53, BS_LCD_WF53_BPBLCD53))

/*! @brief Format value for bitfield LCD_WF53_BPBLCD53. */
#define BF_LCD_WF53_BPBLCD53(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF53_BPBLCD53) & BM_LCD_WF53_BPBLCD53)

/*! @brief Set the BPBLCD53 field to a new value. */
#define BW_LCD_WF53_BPBLCD53(x, v) (BME_BFI8(HW_LCD_WF53_ADDR(x), ((uint8_t)(v) << BP_LCD_WF53_BPBLCD53), BP_LCD_WF53_BPBLCD53, 1))
/*@}*/

/*!
 * @name Register LCD_WF53, field BPCLCD53[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF53_BPCLCD53 (2U)          /*!< Bit position for LCD_WF53_BPCLCD53. */
#define BM_LCD_WF53_BPCLCD53 (0x04U)       /*!< Bit mask for LCD_WF53_BPCLCD53. */
#define BS_LCD_WF53_BPCLCD53 (1U)          /*!< Bit field size in bits for LCD_WF53_BPCLCD53. */

/*! @brief Read current value of the LCD_WF53_BPCLCD53 field. */
#define BR_LCD_WF53_BPCLCD53(x) (BME_UBFX8(HW_LCD_WF53_ADDR(x), BP_LCD_WF53_BPCLCD53, BS_LCD_WF53_BPCLCD53))

/*! @brief Format value for bitfield LCD_WF53_BPCLCD53. */
#define BF_LCD_WF53_BPCLCD53(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF53_BPCLCD53) & BM_LCD_WF53_BPCLCD53)

/*! @brief Set the BPCLCD53 field to a new value. */
#define BW_LCD_WF53_BPCLCD53(x, v) (BME_BFI8(HW_LCD_WF53_ADDR(x), ((uint8_t)(v) << BP_LCD_WF53_BPCLCD53), BP_LCD_WF53_BPCLCD53, 1))
/*@}*/

/*!
 * @name Register LCD_WF53, field BPDLCD53[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF53_BPDLCD53 (3U)          /*!< Bit position for LCD_WF53_BPDLCD53. */
#define BM_LCD_WF53_BPDLCD53 (0x08U)       /*!< Bit mask for LCD_WF53_BPDLCD53. */
#define BS_LCD_WF53_BPDLCD53 (1U)          /*!< Bit field size in bits for LCD_WF53_BPDLCD53. */

/*! @brief Read current value of the LCD_WF53_BPDLCD53 field. */
#define BR_LCD_WF53_BPDLCD53(x) (BME_UBFX8(HW_LCD_WF53_ADDR(x), BP_LCD_WF53_BPDLCD53, BS_LCD_WF53_BPDLCD53))

/*! @brief Format value for bitfield LCD_WF53_BPDLCD53. */
#define BF_LCD_WF53_BPDLCD53(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF53_BPDLCD53) & BM_LCD_WF53_BPDLCD53)

/*! @brief Set the BPDLCD53 field to a new value. */
#define BW_LCD_WF53_BPDLCD53(x, v) (BME_BFI8(HW_LCD_WF53_ADDR(x), ((uint8_t)(v) << BP_LCD_WF53_BPDLCD53), BP_LCD_WF53_BPDLCD53, 1))
/*@}*/

/*!
 * @name Register LCD_WF53, field BPELCD53[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF53_BPELCD53 (4U)          /*!< Bit position for LCD_WF53_BPELCD53. */
#define BM_LCD_WF53_BPELCD53 (0x10U)       /*!< Bit mask for LCD_WF53_BPELCD53. */
#define BS_LCD_WF53_BPELCD53 (1U)          /*!< Bit field size in bits for LCD_WF53_BPELCD53. */

/*! @brief Read current value of the LCD_WF53_BPELCD53 field. */
#define BR_LCD_WF53_BPELCD53(x) (BME_UBFX8(HW_LCD_WF53_ADDR(x), BP_LCD_WF53_BPELCD53, BS_LCD_WF53_BPELCD53))

/*! @brief Format value for bitfield LCD_WF53_BPELCD53. */
#define BF_LCD_WF53_BPELCD53(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF53_BPELCD53) & BM_LCD_WF53_BPELCD53)

/*! @brief Set the BPELCD53 field to a new value. */
#define BW_LCD_WF53_BPELCD53(x, v) (BME_BFI8(HW_LCD_WF53_ADDR(x), ((uint8_t)(v) << BP_LCD_WF53_BPELCD53), BP_LCD_WF53_BPELCD53, 1))
/*@}*/

/*!
 * @name Register LCD_WF53, field BPFLCD53[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF53_BPFLCD53 (5U)          /*!< Bit position for LCD_WF53_BPFLCD53. */
#define BM_LCD_WF53_BPFLCD53 (0x20U)       /*!< Bit mask for LCD_WF53_BPFLCD53. */
#define BS_LCD_WF53_BPFLCD53 (1U)          /*!< Bit field size in bits for LCD_WF53_BPFLCD53. */

/*! @brief Read current value of the LCD_WF53_BPFLCD53 field. */
#define BR_LCD_WF53_BPFLCD53(x) (BME_UBFX8(HW_LCD_WF53_ADDR(x), BP_LCD_WF53_BPFLCD53, BS_LCD_WF53_BPFLCD53))

/*! @brief Format value for bitfield LCD_WF53_BPFLCD53. */
#define BF_LCD_WF53_BPFLCD53(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF53_BPFLCD53) & BM_LCD_WF53_BPFLCD53)

/*! @brief Set the BPFLCD53 field to a new value. */
#define BW_LCD_WF53_BPFLCD53(x, v) (BME_BFI8(HW_LCD_WF53_ADDR(x), ((uint8_t)(v) << BP_LCD_WF53_BPFLCD53), BP_LCD_WF53_BPFLCD53, 1))
/*@}*/

/*!
 * @name Register LCD_WF53, field BPGLCD53[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF53_BPGLCD53 (6U)          /*!< Bit position for LCD_WF53_BPGLCD53. */
#define BM_LCD_WF53_BPGLCD53 (0x40U)       /*!< Bit mask for LCD_WF53_BPGLCD53. */
#define BS_LCD_WF53_BPGLCD53 (1U)          /*!< Bit field size in bits for LCD_WF53_BPGLCD53. */

/*! @brief Read current value of the LCD_WF53_BPGLCD53 field. */
#define BR_LCD_WF53_BPGLCD53(x) (BME_UBFX8(HW_LCD_WF53_ADDR(x), BP_LCD_WF53_BPGLCD53, BS_LCD_WF53_BPGLCD53))

/*! @brief Format value for bitfield LCD_WF53_BPGLCD53. */
#define BF_LCD_WF53_BPGLCD53(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF53_BPGLCD53) & BM_LCD_WF53_BPGLCD53)

/*! @brief Set the BPGLCD53 field to a new value. */
#define BW_LCD_WF53_BPGLCD53(x, v) (BME_BFI8(HW_LCD_WF53_ADDR(x), ((uint8_t)(v) << BP_LCD_WF53_BPGLCD53), BP_LCD_WF53_BPGLCD53, 1))
/*@}*/

/*!
 * @name Register LCD_WF53, field BPHLCD53[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF53_BPHLCD53 (7U)          /*!< Bit position for LCD_WF53_BPHLCD53. */
#define BM_LCD_WF53_BPHLCD53 (0x80U)       /*!< Bit mask for LCD_WF53_BPHLCD53. */
#define BS_LCD_WF53_BPHLCD53 (1U)          /*!< Bit field size in bits for LCD_WF53_BPHLCD53. */

/*! @brief Read current value of the LCD_WF53_BPHLCD53 field. */
#define BR_LCD_WF53_BPHLCD53(x) (BME_UBFX8(HW_LCD_WF53_ADDR(x), BP_LCD_WF53_BPHLCD53, BS_LCD_WF53_BPHLCD53))

/*! @brief Format value for bitfield LCD_WF53_BPHLCD53. */
#define BF_LCD_WF53_BPHLCD53(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF53_BPHLCD53) & BM_LCD_WF53_BPHLCD53)

/*! @brief Set the BPHLCD53 field to a new value. */
#define BW_LCD_WF53_BPHLCD53(x, v) (BME_BFI8(HW_LCD_WF53_ADDR(x), ((uint8_t)(v) << BP_LCD_WF53_BPHLCD53), BP_LCD_WF53_BPHLCD53, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF54 - LCD Waveform Register 54.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF54 - LCD Waveform Register 54. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf54
{
    uint8_t U;
    struct _hw_lcd_wf54_bitfields
    {
        uint8_t BPALCD54 : 1;          /*!< [0]  */
        uint8_t BPBLCD54 : 1;          /*!< [1]  */
        uint8_t BPCLCD54 : 1;          /*!< [2]  */
        uint8_t BPDLCD54 : 1;          /*!< [3]  */
        uint8_t BPELCD54 : 1;          /*!< [4]  */
        uint8_t BPFLCD54 : 1;          /*!< [5]  */
        uint8_t BPGLCD54 : 1;          /*!< [6]  */
        uint8_t BPHLCD54 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf54_t;

/*!
 * @name Constants and macros for entire LCD_WF54 register
 */
/*@{*/
#define HW_LCD_WF54_ADDR(x)      ((uint32_t)(x) + 0x56U)

#define HW_LCD_WF54(x)           (*(__IO hw_lcd_wf54_t *) HW_LCD_WF54_ADDR(x))
#define HW_LCD_WF54_RD(x)        (HW_LCD_WF54(x).U)
#define HW_LCD_WF54_WR(x, v)     (HW_LCD_WF54(x).U = (v))
#define HW_LCD_WF54_SET(x, v)    (BME_OR8(HW_LCD_WF54_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF54_CLR(x, v)    (BME_AND8(HW_LCD_WF54_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF54_TOG(x, v)    (BME_XOR8(HW_LCD_WF54_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF54 bitfields
 */

/*!
 * @name Register LCD_WF54, field BPALCD54[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF54_BPALCD54 (0U)          /*!< Bit position for LCD_WF54_BPALCD54. */
#define BM_LCD_WF54_BPALCD54 (0x01U)       /*!< Bit mask for LCD_WF54_BPALCD54. */
#define BS_LCD_WF54_BPALCD54 (1U)          /*!< Bit field size in bits for LCD_WF54_BPALCD54. */

/*! @brief Read current value of the LCD_WF54_BPALCD54 field. */
#define BR_LCD_WF54_BPALCD54(x) (BME_UBFX8(HW_LCD_WF54_ADDR(x), BP_LCD_WF54_BPALCD54, BS_LCD_WF54_BPALCD54))

/*! @brief Format value for bitfield LCD_WF54_BPALCD54. */
#define BF_LCD_WF54_BPALCD54(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF54_BPALCD54) & BM_LCD_WF54_BPALCD54)

/*! @brief Set the BPALCD54 field to a new value. */
#define BW_LCD_WF54_BPALCD54(x, v) (BME_BFI8(HW_LCD_WF54_ADDR(x), ((uint8_t)(v) << BP_LCD_WF54_BPALCD54), BP_LCD_WF54_BPALCD54, 1))
/*@}*/

/*!
 * @name Register LCD_WF54, field BPBLCD54[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF54_BPBLCD54 (1U)          /*!< Bit position for LCD_WF54_BPBLCD54. */
#define BM_LCD_WF54_BPBLCD54 (0x02U)       /*!< Bit mask for LCD_WF54_BPBLCD54. */
#define BS_LCD_WF54_BPBLCD54 (1U)          /*!< Bit field size in bits for LCD_WF54_BPBLCD54. */

/*! @brief Read current value of the LCD_WF54_BPBLCD54 field. */
#define BR_LCD_WF54_BPBLCD54(x) (BME_UBFX8(HW_LCD_WF54_ADDR(x), BP_LCD_WF54_BPBLCD54, BS_LCD_WF54_BPBLCD54))

/*! @brief Format value for bitfield LCD_WF54_BPBLCD54. */
#define BF_LCD_WF54_BPBLCD54(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF54_BPBLCD54) & BM_LCD_WF54_BPBLCD54)

/*! @brief Set the BPBLCD54 field to a new value. */
#define BW_LCD_WF54_BPBLCD54(x, v) (BME_BFI8(HW_LCD_WF54_ADDR(x), ((uint8_t)(v) << BP_LCD_WF54_BPBLCD54), BP_LCD_WF54_BPBLCD54, 1))
/*@}*/

/*!
 * @name Register LCD_WF54, field BPCLCD54[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF54_BPCLCD54 (2U)          /*!< Bit position for LCD_WF54_BPCLCD54. */
#define BM_LCD_WF54_BPCLCD54 (0x04U)       /*!< Bit mask for LCD_WF54_BPCLCD54. */
#define BS_LCD_WF54_BPCLCD54 (1U)          /*!< Bit field size in bits for LCD_WF54_BPCLCD54. */

/*! @brief Read current value of the LCD_WF54_BPCLCD54 field. */
#define BR_LCD_WF54_BPCLCD54(x) (BME_UBFX8(HW_LCD_WF54_ADDR(x), BP_LCD_WF54_BPCLCD54, BS_LCD_WF54_BPCLCD54))

/*! @brief Format value for bitfield LCD_WF54_BPCLCD54. */
#define BF_LCD_WF54_BPCLCD54(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF54_BPCLCD54) & BM_LCD_WF54_BPCLCD54)

/*! @brief Set the BPCLCD54 field to a new value. */
#define BW_LCD_WF54_BPCLCD54(x, v) (BME_BFI8(HW_LCD_WF54_ADDR(x), ((uint8_t)(v) << BP_LCD_WF54_BPCLCD54), BP_LCD_WF54_BPCLCD54, 1))
/*@}*/

/*!
 * @name Register LCD_WF54, field BPDLCD54[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF54_BPDLCD54 (3U)          /*!< Bit position for LCD_WF54_BPDLCD54. */
#define BM_LCD_WF54_BPDLCD54 (0x08U)       /*!< Bit mask for LCD_WF54_BPDLCD54. */
#define BS_LCD_WF54_BPDLCD54 (1U)          /*!< Bit field size in bits for LCD_WF54_BPDLCD54. */

/*! @brief Read current value of the LCD_WF54_BPDLCD54 field. */
#define BR_LCD_WF54_BPDLCD54(x) (BME_UBFX8(HW_LCD_WF54_ADDR(x), BP_LCD_WF54_BPDLCD54, BS_LCD_WF54_BPDLCD54))

/*! @brief Format value for bitfield LCD_WF54_BPDLCD54. */
#define BF_LCD_WF54_BPDLCD54(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF54_BPDLCD54) & BM_LCD_WF54_BPDLCD54)

/*! @brief Set the BPDLCD54 field to a new value. */
#define BW_LCD_WF54_BPDLCD54(x, v) (BME_BFI8(HW_LCD_WF54_ADDR(x), ((uint8_t)(v) << BP_LCD_WF54_BPDLCD54), BP_LCD_WF54_BPDLCD54, 1))
/*@}*/

/*!
 * @name Register LCD_WF54, field BPELCD54[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF54_BPELCD54 (4U)          /*!< Bit position for LCD_WF54_BPELCD54. */
#define BM_LCD_WF54_BPELCD54 (0x10U)       /*!< Bit mask for LCD_WF54_BPELCD54. */
#define BS_LCD_WF54_BPELCD54 (1U)          /*!< Bit field size in bits for LCD_WF54_BPELCD54. */

/*! @brief Read current value of the LCD_WF54_BPELCD54 field. */
#define BR_LCD_WF54_BPELCD54(x) (BME_UBFX8(HW_LCD_WF54_ADDR(x), BP_LCD_WF54_BPELCD54, BS_LCD_WF54_BPELCD54))

/*! @brief Format value for bitfield LCD_WF54_BPELCD54. */
#define BF_LCD_WF54_BPELCD54(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF54_BPELCD54) & BM_LCD_WF54_BPELCD54)

/*! @brief Set the BPELCD54 field to a new value. */
#define BW_LCD_WF54_BPELCD54(x, v) (BME_BFI8(HW_LCD_WF54_ADDR(x), ((uint8_t)(v) << BP_LCD_WF54_BPELCD54), BP_LCD_WF54_BPELCD54, 1))
/*@}*/

/*!
 * @name Register LCD_WF54, field BPFLCD54[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF54_BPFLCD54 (5U)          /*!< Bit position for LCD_WF54_BPFLCD54. */
#define BM_LCD_WF54_BPFLCD54 (0x20U)       /*!< Bit mask for LCD_WF54_BPFLCD54. */
#define BS_LCD_WF54_BPFLCD54 (1U)          /*!< Bit field size in bits for LCD_WF54_BPFLCD54. */

/*! @brief Read current value of the LCD_WF54_BPFLCD54 field. */
#define BR_LCD_WF54_BPFLCD54(x) (BME_UBFX8(HW_LCD_WF54_ADDR(x), BP_LCD_WF54_BPFLCD54, BS_LCD_WF54_BPFLCD54))

/*! @brief Format value for bitfield LCD_WF54_BPFLCD54. */
#define BF_LCD_WF54_BPFLCD54(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF54_BPFLCD54) & BM_LCD_WF54_BPFLCD54)

/*! @brief Set the BPFLCD54 field to a new value. */
#define BW_LCD_WF54_BPFLCD54(x, v) (BME_BFI8(HW_LCD_WF54_ADDR(x), ((uint8_t)(v) << BP_LCD_WF54_BPFLCD54), BP_LCD_WF54_BPFLCD54, 1))
/*@}*/

/*!
 * @name Register LCD_WF54, field BPGLCD54[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF54_BPGLCD54 (6U)          /*!< Bit position for LCD_WF54_BPGLCD54. */
#define BM_LCD_WF54_BPGLCD54 (0x40U)       /*!< Bit mask for LCD_WF54_BPGLCD54. */
#define BS_LCD_WF54_BPGLCD54 (1U)          /*!< Bit field size in bits for LCD_WF54_BPGLCD54. */

/*! @brief Read current value of the LCD_WF54_BPGLCD54 field. */
#define BR_LCD_WF54_BPGLCD54(x) (BME_UBFX8(HW_LCD_WF54_ADDR(x), BP_LCD_WF54_BPGLCD54, BS_LCD_WF54_BPGLCD54))

/*! @brief Format value for bitfield LCD_WF54_BPGLCD54. */
#define BF_LCD_WF54_BPGLCD54(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF54_BPGLCD54) & BM_LCD_WF54_BPGLCD54)

/*! @brief Set the BPGLCD54 field to a new value. */
#define BW_LCD_WF54_BPGLCD54(x, v) (BME_BFI8(HW_LCD_WF54_ADDR(x), ((uint8_t)(v) << BP_LCD_WF54_BPGLCD54), BP_LCD_WF54_BPGLCD54, 1))
/*@}*/

/*!
 * @name Register LCD_WF54, field BPHLCD54[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF54_BPHLCD54 (7U)          /*!< Bit position for LCD_WF54_BPHLCD54. */
#define BM_LCD_WF54_BPHLCD54 (0x80U)       /*!< Bit mask for LCD_WF54_BPHLCD54. */
#define BS_LCD_WF54_BPHLCD54 (1U)          /*!< Bit field size in bits for LCD_WF54_BPHLCD54. */

/*! @brief Read current value of the LCD_WF54_BPHLCD54 field. */
#define BR_LCD_WF54_BPHLCD54(x) (BME_UBFX8(HW_LCD_WF54_ADDR(x), BP_LCD_WF54_BPHLCD54, BS_LCD_WF54_BPHLCD54))

/*! @brief Format value for bitfield LCD_WF54_BPHLCD54. */
#define BF_LCD_WF54_BPHLCD54(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF54_BPHLCD54) & BM_LCD_WF54_BPHLCD54)

/*! @brief Set the BPHLCD54 field to a new value. */
#define BW_LCD_WF54_BPHLCD54(x, v) (BME_BFI8(HW_LCD_WF54_ADDR(x), ((uint8_t)(v) << BP_LCD_WF54_BPHLCD54), BP_LCD_WF54_BPHLCD54, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF55 - LCD Waveform Register 55.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF55 - LCD Waveform Register 55. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf55
{
    uint8_t U;
    struct _hw_lcd_wf55_bitfields
    {
        uint8_t BPALCD55 : 1;          /*!< [0]  */
        uint8_t BPBLCD55 : 1;          /*!< [1]  */
        uint8_t BPCLCD55 : 1;          /*!< [2]  */
        uint8_t BPDLCD55 : 1;          /*!< [3]  */
        uint8_t BPELCD55 : 1;          /*!< [4]  */
        uint8_t BPFLCD55 : 1;          /*!< [5]  */
        uint8_t BPGLCD55 : 1;          /*!< [6]  */
        uint8_t BPHLCD55 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf55_t;

/*!
 * @name Constants and macros for entire LCD_WF55 register
 */
/*@{*/
#define HW_LCD_WF55_ADDR(x)      ((uint32_t)(x) + 0x57U)

#define HW_LCD_WF55(x)           (*(__IO hw_lcd_wf55_t *) HW_LCD_WF55_ADDR(x))
#define HW_LCD_WF55_RD(x)        (HW_LCD_WF55(x).U)
#define HW_LCD_WF55_WR(x, v)     (HW_LCD_WF55(x).U = (v))
#define HW_LCD_WF55_SET(x, v)    (BME_OR8(HW_LCD_WF55_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF55_CLR(x, v)    (BME_AND8(HW_LCD_WF55_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF55_TOG(x, v)    (BME_XOR8(HW_LCD_WF55_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF55 bitfields
 */

/*!
 * @name Register LCD_WF55, field BPALCD55[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF55_BPALCD55 (0U)          /*!< Bit position for LCD_WF55_BPALCD55. */
#define BM_LCD_WF55_BPALCD55 (0x01U)       /*!< Bit mask for LCD_WF55_BPALCD55. */
#define BS_LCD_WF55_BPALCD55 (1U)          /*!< Bit field size in bits for LCD_WF55_BPALCD55. */

/*! @brief Read current value of the LCD_WF55_BPALCD55 field. */
#define BR_LCD_WF55_BPALCD55(x) (BME_UBFX8(HW_LCD_WF55_ADDR(x), BP_LCD_WF55_BPALCD55, BS_LCD_WF55_BPALCD55))

/*! @brief Format value for bitfield LCD_WF55_BPALCD55. */
#define BF_LCD_WF55_BPALCD55(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF55_BPALCD55) & BM_LCD_WF55_BPALCD55)

/*! @brief Set the BPALCD55 field to a new value. */
#define BW_LCD_WF55_BPALCD55(x, v) (BME_BFI8(HW_LCD_WF55_ADDR(x), ((uint8_t)(v) << BP_LCD_WF55_BPALCD55), BP_LCD_WF55_BPALCD55, 1))
/*@}*/

/*!
 * @name Register LCD_WF55, field BPBLCD55[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF55_BPBLCD55 (1U)          /*!< Bit position for LCD_WF55_BPBLCD55. */
#define BM_LCD_WF55_BPBLCD55 (0x02U)       /*!< Bit mask for LCD_WF55_BPBLCD55. */
#define BS_LCD_WF55_BPBLCD55 (1U)          /*!< Bit field size in bits for LCD_WF55_BPBLCD55. */

/*! @brief Read current value of the LCD_WF55_BPBLCD55 field. */
#define BR_LCD_WF55_BPBLCD55(x) (BME_UBFX8(HW_LCD_WF55_ADDR(x), BP_LCD_WF55_BPBLCD55, BS_LCD_WF55_BPBLCD55))

/*! @brief Format value for bitfield LCD_WF55_BPBLCD55. */
#define BF_LCD_WF55_BPBLCD55(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF55_BPBLCD55) & BM_LCD_WF55_BPBLCD55)

/*! @brief Set the BPBLCD55 field to a new value. */
#define BW_LCD_WF55_BPBLCD55(x, v) (BME_BFI8(HW_LCD_WF55_ADDR(x), ((uint8_t)(v) << BP_LCD_WF55_BPBLCD55), BP_LCD_WF55_BPBLCD55, 1))
/*@}*/

/*!
 * @name Register LCD_WF55, field BPCLCD55[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF55_BPCLCD55 (2U)          /*!< Bit position for LCD_WF55_BPCLCD55. */
#define BM_LCD_WF55_BPCLCD55 (0x04U)       /*!< Bit mask for LCD_WF55_BPCLCD55. */
#define BS_LCD_WF55_BPCLCD55 (1U)          /*!< Bit field size in bits for LCD_WF55_BPCLCD55. */

/*! @brief Read current value of the LCD_WF55_BPCLCD55 field. */
#define BR_LCD_WF55_BPCLCD55(x) (BME_UBFX8(HW_LCD_WF55_ADDR(x), BP_LCD_WF55_BPCLCD55, BS_LCD_WF55_BPCLCD55))

/*! @brief Format value for bitfield LCD_WF55_BPCLCD55. */
#define BF_LCD_WF55_BPCLCD55(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF55_BPCLCD55) & BM_LCD_WF55_BPCLCD55)

/*! @brief Set the BPCLCD55 field to a new value. */
#define BW_LCD_WF55_BPCLCD55(x, v) (BME_BFI8(HW_LCD_WF55_ADDR(x), ((uint8_t)(v) << BP_LCD_WF55_BPCLCD55), BP_LCD_WF55_BPCLCD55, 1))
/*@}*/

/*!
 * @name Register LCD_WF55, field BPDLCD55[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF55_BPDLCD55 (3U)          /*!< Bit position for LCD_WF55_BPDLCD55. */
#define BM_LCD_WF55_BPDLCD55 (0x08U)       /*!< Bit mask for LCD_WF55_BPDLCD55. */
#define BS_LCD_WF55_BPDLCD55 (1U)          /*!< Bit field size in bits for LCD_WF55_BPDLCD55. */

/*! @brief Read current value of the LCD_WF55_BPDLCD55 field. */
#define BR_LCD_WF55_BPDLCD55(x) (BME_UBFX8(HW_LCD_WF55_ADDR(x), BP_LCD_WF55_BPDLCD55, BS_LCD_WF55_BPDLCD55))

/*! @brief Format value for bitfield LCD_WF55_BPDLCD55. */
#define BF_LCD_WF55_BPDLCD55(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF55_BPDLCD55) & BM_LCD_WF55_BPDLCD55)

/*! @brief Set the BPDLCD55 field to a new value. */
#define BW_LCD_WF55_BPDLCD55(x, v) (BME_BFI8(HW_LCD_WF55_ADDR(x), ((uint8_t)(v) << BP_LCD_WF55_BPDLCD55), BP_LCD_WF55_BPDLCD55, 1))
/*@}*/

/*!
 * @name Register LCD_WF55, field BPELCD55[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF55_BPELCD55 (4U)          /*!< Bit position for LCD_WF55_BPELCD55. */
#define BM_LCD_WF55_BPELCD55 (0x10U)       /*!< Bit mask for LCD_WF55_BPELCD55. */
#define BS_LCD_WF55_BPELCD55 (1U)          /*!< Bit field size in bits for LCD_WF55_BPELCD55. */

/*! @brief Read current value of the LCD_WF55_BPELCD55 field. */
#define BR_LCD_WF55_BPELCD55(x) (BME_UBFX8(HW_LCD_WF55_ADDR(x), BP_LCD_WF55_BPELCD55, BS_LCD_WF55_BPELCD55))

/*! @brief Format value for bitfield LCD_WF55_BPELCD55. */
#define BF_LCD_WF55_BPELCD55(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF55_BPELCD55) & BM_LCD_WF55_BPELCD55)

/*! @brief Set the BPELCD55 field to a new value. */
#define BW_LCD_WF55_BPELCD55(x, v) (BME_BFI8(HW_LCD_WF55_ADDR(x), ((uint8_t)(v) << BP_LCD_WF55_BPELCD55), BP_LCD_WF55_BPELCD55, 1))
/*@}*/

/*!
 * @name Register LCD_WF55, field BPFLCD55[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF55_BPFLCD55 (5U)          /*!< Bit position for LCD_WF55_BPFLCD55. */
#define BM_LCD_WF55_BPFLCD55 (0x20U)       /*!< Bit mask for LCD_WF55_BPFLCD55. */
#define BS_LCD_WF55_BPFLCD55 (1U)          /*!< Bit field size in bits for LCD_WF55_BPFLCD55. */

/*! @brief Read current value of the LCD_WF55_BPFLCD55 field. */
#define BR_LCD_WF55_BPFLCD55(x) (BME_UBFX8(HW_LCD_WF55_ADDR(x), BP_LCD_WF55_BPFLCD55, BS_LCD_WF55_BPFLCD55))

/*! @brief Format value for bitfield LCD_WF55_BPFLCD55. */
#define BF_LCD_WF55_BPFLCD55(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF55_BPFLCD55) & BM_LCD_WF55_BPFLCD55)

/*! @brief Set the BPFLCD55 field to a new value. */
#define BW_LCD_WF55_BPFLCD55(x, v) (BME_BFI8(HW_LCD_WF55_ADDR(x), ((uint8_t)(v) << BP_LCD_WF55_BPFLCD55), BP_LCD_WF55_BPFLCD55, 1))
/*@}*/

/*!
 * @name Register LCD_WF55, field BPGLCD55[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF55_BPGLCD55 (6U)          /*!< Bit position for LCD_WF55_BPGLCD55. */
#define BM_LCD_WF55_BPGLCD55 (0x40U)       /*!< Bit mask for LCD_WF55_BPGLCD55. */
#define BS_LCD_WF55_BPGLCD55 (1U)          /*!< Bit field size in bits for LCD_WF55_BPGLCD55. */

/*! @brief Read current value of the LCD_WF55_BPGLCD55 field. */
#define BR_LCD_WF55_BPGLCD55(x) (BME_UBFX8(HW_LCD_WF55_ADDR(x), BP_LCD_WF55_BPGLCD55, BS_LCD_WF55_BPGLCD55))

/*! @brief Format value for bitfield LCD_WF55_BPGLCD55. */
#define BF_LCD_WF55_BPGLCD55(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF55_BPGLCD55) & BM_LCD_WF55_BPGLCD55)

/*! @brief Set the BPGLCD55 field to a new value. */
#define BW_LCD_WF55_BPGLCD55(x, v) (BME_BFI8(HW_LCD_WF55_ADDR(x), ((uint8_t)(v) << BP_LCD_WF55_BPGLCD55), BP_LCD_WF55_BPGLCD55, 1))
/*@}*/

/*!
 * @name Register LCD_WF55, field BPHLCD55[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF55_BPHLCD55 (7U)          /*!< Bit position for LCD_WF55_BPHLCD55. */
#define BM_LCD_WF55_BPHLCD55 (0x80U)       /*!< Bit mask for LCD_WF55_BPHLCD55. */
#define BS_LCD_WF55_BPHLCD55 (1U)          /*!< Bit field size in bits for LCD_WF55_BPHLCD55. */

/*! @brief Read current value of the LCD_WF55_BPHLCD55 field. */
#define BR_LCD_WF55_BPHLCD55(x) (BME_UBFX8(HW_LCD_WF55_ADDR(x), BP_LCD_WF55_BPHLCD55, BS_LCD_WF55_BPHLCD55))

/*! @brief Format value for bitfield LCD_WF55_BPHLCD55. */
#define BF_LCD_WF55_BPHLCD55(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF55_BPHLCD55) & BM_LCD_WF55_BPHLCD55)

/*! @brief Set the BPHLCD55 field to a new value. */
#define BW_LCD_WF55_BPHLCD55(x, v) (BME_BFI8(HW_LCD_WF55_ADDR(x), ((uint8_t)(v) << BP_LCD_WF55_BPHLCD55), BP_LCD_WF55_BPHLCD55, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF56 - LCD Waveform Register 56.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF56 - LCD Waveform Register 56. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf56
{
    uint8_t U;
    struct _hw_lcd_wf56_bitfields
    {
        uint8_t BPALCD56 : 1;          /*!< [0]  */
        uint8_t BPBLCD56 : 1;          /*!< [1]  */
        uint8_t BPCLCD56 : 1;          /*!< [2]  */
        uint8_t BPDLCD56 : 1;          /*!< [3]  */
        uint8_t BPELCD56 : 1;          /*!< [4]  */
        uint8_t BPFLCD56 : 1;          /*!< [5]  */
        uint8_t BPGLCD56 : 1;          /*!< [6]  */
        uint8_t BPHLCD56 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf56_t;

/*!
 * @name Constants and macros for entire LCD_WF56 register
 */
/*@{*/
#define HW_LCD_WF56_ADDR(x)      ((uint32_t)(x) + 0x58U)

#define HW_LCD_WF56(x)           (*(__IO hw_lcd_wf56_t *) HW_LCD_WF56_ADDR(x))
#define HW_LCD_WF56_RD(x)        (HW_LCD_WF56(x).U)
#define HW_LCD_WF56_WR(x, v)     (HW_LCD_WF56(x).U = (v))
#define HW_LCD_WF56_SET(x, v)    (BME_OR8(HW_LCD_WF56_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF56_CLR(x, v)    (BME_AND8(HW_LCD_WF56_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF56_TOG(x, v)    (BME_XOR8(HW_LCD_WF56_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF56 bitfields
 */

/*!
 * @name Register LCD_WF56, field BPALCD56[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF56_BPALCD56 (0U)          /*!< Bit position for LCD_WF56_BPALCD56. */
#define BM_LCD_WF56_BPALCD56 (0x01U)       /*!< Bit mask for LCD_WF56_BPALCD56. */
#define BS_LCD_WF56_BPALCD56 (1U)          /*!< Bit field size in bits for LCD_WF56_BPALCD56. */

/*! @brief Read current value of the LCD_WF56_BPALCD56 field. */
#define BR_LCD_WF56_BPALCD56(x) (BME_UBFX8(HW_LCD_WF56_ADDR(x), BP_LCD_WF56_BPALCD56, BS_LCD_WF56_BPALCD56))

/*! @brief Format value for bitfield LCD_WF56_BPALCD56. */
#define BF_LCD_WF56_BPALCD56(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF56_BPALCD56) & BM_LCD_WF56_BPALCD56)

/*! @brief Set the BPALCD56 field to a new value. */
#define BW_LCD_WF56_BPALCD56(x, v) (BME_BFI8(HW_LCD_WF56_ADDR(x), ((uint8_t)(v) << BP_LCD_WF56_BPALCD56), BP_LCD_WF56_BPALCD56, 1))
/*@}*/

/*!
 * @name Register LCD_WF56, field BPBLCD56[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF56_BPBLCD56 (1U)          /*!< Bit position for LCD_WF56_BPBLCD56. */
#define BM_LCD_WF56_BPBLCD56 (0x02U)       /*!< Bit mask for LCD_WF56_BPBLCD56. */
#define BS_LCD_WF56_BPBLCD56 (1U)          /*!< Bit field size in bits for LCD_WF56_BPBLCD56. */

/*! @brief Read current value of the LCD_WF56_BPBLCD56 field. */
#define BR_LCD_WF56_BPBLCD56(x) (BME_UBFX8(HW_LCD_WF56_ADDR(x), BP_LCD_WF56_BPBLCD56, BS_LCD_WF56_BPBLCD56))

/*! @brief Format value for bitfield LCD_WF56_BPBLCD56. */
#define BF_LCD_WF56_BPBLCD56(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF56_BPBLCD56) & BM_LCD_WF56_BPBLCD56)

/*! @brief Set the BPBLCD56 field to a new value. */
#define BW_LCD_WF56_BPBLCD56(x, v) (BME_BFI8(HW_LCD_WF56_ADDR(x), ((uint8_t)(v) << BP_LCD_WF56_BPBLCD56), BP_LCD_WF56_BPBLCD56, 1))
/*@}*/

/*!
 * @name Register LCD_WF56, field BPCLCD56[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF56_BPCLCD56 (2U)          /*!< Bit position for LCD_WF56_BPCLCD56. */
#define BM_LCD_WF56_BPCLCD56 (0x04U)       /*!< Bit mask for LCD_WF56_BPCLCD56. */
#define BS_LCD_WF56_BPCLCD56 (1U)          /*!< Bit field size in bits for LCD_WF56_BPCLCD56. */

/*! @brief Read current value of the LCD_WF56_BPCLCD56 field. */
#define BR_LCD_WF56_BPCLCD56(x) (BME_UBFX8(HW_LCD_WF56_ADDR(x), BP_LCD_WF56_BPCLCD56, BS_LCD_WF56_BPCLCD56))

/*! @brief Format value for bitfield LCD_WF56_BPCLCD56. */
#define BF_LCD_WF56_BPCLCD56(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF56_BPCLCD56) & BM_LCD_WF56_BPCLCD56)

/*! @brief Set the BPCLCD56 field to a new value. */
#define BW_LCD_WF56_BPCLCD56(x, v) (BME_BFI8(HW_LCD_WF56_ADDR(x), ((uint8_t)(v) << BP_LCD_WF56_BPCLCD56), BP_LCD_WF56_BPCLCD56, 1))
/*@}*/

/*!
 * @name Register LCD_WF56, field BPDLCD56[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF56_BPDLCD56 (3U)          /*!< Bit position for LCD_WF56_BPDLCD56. */
#define BM_LCD_WF56_BPDLCD56 (0x08U)       /*!< Bit mask for LCD_WF56_BPDLCD56. */
#define BS_LCD_WF56_BPDLCD56 (1U)          /*!< Bit field size in bits for LCD_WF56_BPDLCD56. */

/*! @brief Read current value of the LCD_WF56_BPDLCD56 field. */
#define BR_LCD_WF56_BPDLCD56(x) (BME_UBFX8(HW_LCD_WF56_ADDR(x), BP_LCD_WF56_BPDLCD56, BS_LCD_WF56_BPDLCD56))

/*! @brief Format value for bitfield LCD_WF56_BPDLCD56. */
#define BF_LCD_WF56_BPDLCD56(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF56_BPDLCD56) & BM_LCD_WF56_BPDLCD56)

/*! @brief Set the BPDLCD56 field to a new value. */
#define BW_LCD_WF56_BPDLCD56(x, v) (BME_BFI8(HW_LCD_WF56_ADDR(x), ((uint8_t)(v) << BP_LCD_WF56_BPDLCD56), BP_LCD_WF56_BPDLCD56, 1))
/*@}*/

/*!
 * @name Register LCD_WF56, field BPELCD56[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF56_BPELCD56 (4U)          /*!< Bit position for LCD_WF56_BPELCD56. */
#define BM_LCD_WF56_BPELCD56 (0x10U)       /*!< Bit mask for LCD_WF56_BPELCD56. */
#define BS_LCD_WF56_BPELCD56 (1U)          /*!< Bit field size in bits for LCD_WF56_BPELCD56. */

/*! @brief Read current value of the LCD_WF56_BPELCD56 field. */
#define BR_LCD_WF56_BPELCD56(x) (BME_UBFX8(HW_LCD_WF56_ADDR(x), BP_LCD_WF56_BPELCD56, BS_LCD_WF56_BPELCD56))

/*! @brief Format value for bitfield LCD_WF56_BPELCD56. */
#define BF_LCD_WF56_BPELCD56(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF56_BPELCD56) & BM_LCD_WF56_BPELCD56)

/*! @brief Set the BPELCD56 field to a new value. */
#define BW_LCD_WF56_BPELCD56(x, v) (BME_BFI8(HW_LCD_WF56_ADDR(x), ((uint8_t)(v) << BP_LCD_WF56_BPELCD56), BP_LCD_WF56_BPELCD56, 1))
/*@}*/

/*!
 * @name Register LCD_WF56, field BPFLCD56[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF56_BPFLCD56 (5U)          /*!< Bit position for LCD_WF56_BPFLCD56. */
#define BM_LCD_WF56_BPFLCD56 (0x20U)       /*!< Bit mask for LCD_WF56_BPFLCD56. */
#define BS_LCD_WF56_BPFLCD56 (1U)          /*!< Bit field size in bits for LCD_WF56_BPFLCD56. */

/*! @brief Read current value of the LCD_WF56_BPFLCD56 field. */
#define BR_LCD_WF56_BPFLCD56(x) (BME_UBFX8(HW_LCD_WF56_ADDR(x), BP_LCD_WF56_BPFLCD56, BS_LCD_WF56_BPFLCD56))

/*! @brief Format value for bitfield LCD_WF56_BPFLCD56. */
#define BF_LCD_WF56_BPFLCD56(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF56_BPFLCD56) & BM_LCD_WF56_BPFLCD56)

/*! @brief Set the BPFLCD56 field to a new value. */
#define BW_LCD_WF56_BPFLCD56(x, v) (BME_BFI8(HW_LCD_WF56_ADDR(x), ((uint8_t)(v) << BP_LCD_WF56_BPFLCD56), BP_LCD_WF56_BPFLCD56, 1))
/*@}*/

/*!
 * @name Register LCD_WF56, field BPGLCD56[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF56_BPGLCD56 (6U)          /*!< Bit position for LCD_WF56_BPGLCD56. */
#define BM_LCD_WF56_BPGLCD56 (0x40U)       /*!< Bit mask for LCD_WF56_BPGLCD56. */
#define BS_LCD_WF56_BPGLCD56 (1U)          /*!< Bit field size in bits for LCD_WF56_BPGLCD56. */

/*! @brief Read current value of the LCD_WF56_BPGLCD56 field. */
#define BR_LCD_WF56_BPGLCD56(x) (BME_UBFX8(HW_LCD_WF56_ADDR(x), BP_LCD_WF56_BPGLCD56, BS_LCD_WF56_BPGLCD56))

/*! @brief Format value for bitfield LCD_WF56_BPGLCD56. */
#define BF_LCD_WF56_BPGLCD56(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF56_BPGLCD56) & BM_LCD_WF56_BPGLCD56)

/*! @brief Set the BPGLCD56 field to a new value. */
#define BW_LCD_WF56_BPGLCD56(x, v) (BME_BFI8(HW_LCD_WF56_ADDR(x), ((uint8_t)(v) << BP_LCD_WF56_BPGLCD56), BP_LCD_WF56_BPGLCD56, 1))
/*@}*/

/*!
 * @name Register LCD_WF56, field BPHLCD56[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF56_BPHLCD56 (7U)          /*!< Bit position for LCD_WF56_BPHLCD56. */
#define BM_LCD_WF56_BPHLCD56 (0x80U)       /*!< Bit mask for LCD_WF56_BPHLCD56. */
#define BS_LCD_WF56_BPHLCD56 (1U)          /*!< Bit field size in bits for LCD_WF56_BPHLCD56. */

/*! @brief Read current value of the LCD_WF56_BPHLCD56 field. */
#define BR_LCD_WF56_BPHLCD56(x) (BME_UBFX8(HW_LCD_WF56_ADDR(x), BP_LCD_WF56_BPHLCD56, BS_LCD_WF56_BPHLCD56))

/*! @brief Format value for bitfield LCD_WF56_BPHLCD56. */
#define BF_LCD_WF56_BPHLCD56(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF56_BPHLCD56) & BM_LCD_WF56_BPHLCD56)

/*! @brief Set the BPHLCD56 field to a new value. */
#define BW_LCD_WF56_BPHLCD56(x, v) (BME_BFI8(HW_LCD_WF56_ADDR(x), ((uint8_t)(v) << BP_LCD_WF56_BPHLCD56), BP_LCD_WF56_BPHLCD56, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF57 - LCD Waveform Register 57.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF57 - LCD Waveform Register 57. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf57
{
    uint8_t U;
    struct _hw_lcd_wf57_bitfields
    {
        uint8_t BPALCD57 : 1;          /*!< [0]  */
        uint8_t BPBLCD57 : 1;          /*!< [1]  */
        uint8_t BPCLCD57 : 1;          /*!< [2]  */
        uint8_t BPDLCD57 : 1;          /*!< [3]  */
        uint8_t BPELCD57 : 1;          /*!< [4]  */
        uint8_t BPFLCD57 : 1;          /*!< [5]  */
        uint8_t BPGLCD57 : 1;          /*!< [6]  */
        uint8_t BPHLCD57 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf57_t;

/*!
 * @name Constants and macros for entire LCD_WF57 register
 */
/*@{*/
#define HW_LCD_WF57_ADDR(x)      ((uint32_t)(x) + 0x59U)

#define HW_LCD_WF57(x)           (*(__IO hw_lcd_wf57_t *) HW_LCD_WF57_ADDR(x))
#define HW_LCD_WF57_RD(x)        (HW_LCD_WF57(x).U)
#define HW_LCD_WF57_WR(x, v)     (HW_LCD_WF57(x).U = (v))
#define HW_LCD_WF57_SET(x, v)    (BME_OR8(HW_LCD_WF57_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF57_CLR(x, v)    (BME_AND8(HW_LCD_WF57_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF57_TOG(x, v)    (BME_XOR8(HW_LCD_WF57_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF57 bitfields
 */

/*!
 * @name Register LCD_WF57, field BPALCD57[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF57_BPALCD57 (0U)          /*!< Bit position for LCD_WF57_BPALCD57. */
#define BM_LCD_WF57_BPALCD57 (0x01U)       /*!< Bit mask for LCD_WF57_BPALCD57. */
#define BS_LCD_WF57_BPALCD57 (1U)          /*!< Bit field size in bits for LCD_WF57_BPALCD57. */

/*! @brief Read current value of the LCD_WF57_BPALCD57 field. */
#define BR_LCD_WF57_BPALCD57(x) (BME_UBFX8(HW_LCD_WF57_ADDR(x), BP_LCD_WF57_BPALCD57, BS_LCD_WF57_BPALCD57))

/*! @brief Format value for bitfield LCD_WF57_BPALCD57. */
#define BF_LCD_WF57_BPALCD57(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF57_BPALCD57) & BM_LCD_WF57_BPALCD57)

/*! @brief Set the BPALCD57 field to a new value. */
#define BW_LCD_WF57_BPALCD57(x, v) (BME_BFI8(HW_LCD_WF57_ADDR(x), ((uint8_t)(v) << BP_LCD_WF57_BPALCD57), BP_LCD_WF57_BPALCD57, 1))
/*@}*/

/*!
 * @name Register LCD_WF57, field BPBLCD57[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF57_BPBLCD57 (1U)          /*!< Bit position for LCD_WF57_BPBLCD57. */
#define BM_LCD_WF57_BPBLCD57 (0x02U)       /*!< Bit mask for LCD_WF57_BPBLCD57. */
#define BS_LCD_WF57_BPBLCD57 (1U)          /*!< Bit field size in bits for LCD_WF57_BPBLCD57. */

/*! @brief Read current value of the LCD_WF57_BPBLCD57 field. */
#define BR_LCD_WF57_BPBLCD57(x) (BME_UBFX8(HW_LCD_WF57_ADDR(x), BP_LCD_WF57_BPBLCD57, BS_LCD_WF57_BPBLCD57))

/*! @brief Format value for bitfield LCD_WF57_BPBLCD57. */
#define BF_LCD_WF57_BPBLCD57(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF57_BPBLCD57) & BM_LCD_WF57_BPBLCD57)

/*! @brief Set the BPBLCD57 field to a new value. */
#define BW_LCD_WF57_BPBLCD57(x, v) (BME_BFI8(HW_LCD_WF57_ADDR(x), ((uint8_t)(v) << BP_LCD_WF57_BPBLCD57), BP_LCD_WF57_BPBLCD57, 1))
/*@}*/

/*!
 * @name Register LCD_WF57, field BPCLCD57[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF57_BPCLCD57 (2U)          /*!< Bit position for LCD_WF57_BPCLCD57. */
#define BM_LCD_WF57_BPCLCD57 (0x04U)       /*!< Bit mask for LCD_WF57_BPCLCD57. */
#define BS_LCD_WF57_BPCLCD57 (1U)          /*!< Bit field size in bits for LCD_WF57_BPCLCD57. */

/*! @brief Read current value of the LCD_WF57_BPCLCD57 field. */
#define BR_LCD_WF57_BPCLCD57(x) (BME_UBFX8(HW_LCD_WF57_ADDR(x), BP_LCD_WF57_BPCLCD57, BS_LCD_WF57_BPCLCD57))

/*! @brief Format value for bitfield LCD_WF57_BPCLCD57. */
#define BF_LCD_WF57_BPCLCD57(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF57_BPCLCD57) & BM_LCD_WF57_BPCLCD57)

/*! @brief Set the BPCLCD57 field to a new value. */
#define BW_LCD_WF57_BPCLCD57(x, v) (BME_BFI8(HW_LCD_WF57_ADDR(x), ((uint8_t)(v) << BP_LCD_WF57_BPCLCD57), BP_LCD_WF57_BPCLCD57, 1))
/*@}*/

/*!
 * @name Register LCD_WF57, field BPDLCD57[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF57_BPDLCD57 (3U)          /*!< Bit position for LCD_WF57_BPDLCD57. */
#define BM_LCD_WF57_BPDLCD57 (0x08U)       /*!< Bit mask for LCD_WF57_BPDLCD57. */
#define BS_LCD_WF57_BPDLCD57 (1U)          /*!< Bit field size in bits for LCD_WF57_BPDLCD57. */

/*! @brief Read current value of the LCD_WF57_BPDLCD57 field. */
#define BR_LCD_WF57_BPDLCD57(x) (BME_UBFX8(HW_LCD_WF57_ADDR(x), BP_LCD_WF57_BPDLCD57, BS_LCD_WF57_BPDLCD57))

/*! @brief Format value for bitfield LCD_WF57_BPDLCD57. */
#define BF_LCD_WF57_BPDLCD57(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF57_BPDLCD57) & BM_LCD_WF57_BPDLCD57)

/*! @brief Set the BPDLCD57 field to a new value. */
#define BW_LCD_WF57_BPDLCD57(x, v) (BME_BFI8(HW_LCD_WF57_ADDR(x), ((uint8_t)(v) << BP_LCD_WF57_BPDLCD57), BP_LCD_WF57_BPDLCD57, 1))
/*@}*/

/*!
 * @name Register LCD_WF57, field BPELCD57[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF57_BPELCD57 (4U)          /*!< Bit position for LCD_WF57_BPELCD57. */
#define BM_LCD_WF57_BPELCD57 (0x10U)       /*!< Bit mask for LCD_WF57_BPELCD57. */
#define BS_LCD_WF57_BPELCD57 (1U)          /*!< Bit field size in bits for LCD_WF57_BPELCD57. */

/*! @brief Read current value of the LCD_WF57_BPELCD57 field. */
#define BR_LCD_WF57_BPELCD57(x) (BME_UBFX8(HW_LCD_WF57_ADDR(x), BP_LCD_WF57_BPELCD57, BS_LCD_WF57_BPELCD57))

/*! @brief Format value for bitfield LCD_WF57_BPELCD57. */
#define BF_LCD_WF57_BPELCD57(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF57_BPELCD57) & BM_LCD_WF57_BPELCD57)

/*! @brief Set the BPELCD57 field to a new value. */
#define BW_LCD_WF57_BPELCD57(x, v) (BME_BFI8(HW_LCD_WF57_ADDR(x), ((uint8_t)(v) << BP_LCD_WF57_BPELCD57), BP_LCD_WF57_BPELCD57, 1))
/*@}*/

/*!
 * @name Register LCD_WF57, field BPFLCD57[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF57_BPFLCD57 (5U)          /*!< Bit position for LCD_WF57_BPFLCD57. */
#define BM_LCD_WF57_BPFLCD57 (0x20U)       /*!< Bit mask for LCD_WF57_BPFLCD57. */
#define BS_LCD_WF57_BPFLCD57 (1U)          /*!< Bit field size in bits for LCD_WF57_BPFLCD57. */

/*! @brief Read current value of the LCD_WF57_BPFLCD57 field. */
#define BR_LCD_WF57_BPFLCD57(x) (BME_UBFX8(HW_LCD_WF57_ADDR(x), BP_LCD_WF57_BPFLCD57, BS_LCD_WF57_BPFLCD57))

/*! @brief Format value for bitfield LCD_WF57_BPFLCD57. */
#define BF_LCD_WF57_BPFLCD57(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF57_BPFLCD57) & BM_LCD_WF57_BPFLCD57)

/*! @brief Set the BPFLCD57 field to a new value. */
#define BW_LCD_WF57_BPFLCD57(x, v) (BME_BFI8(HW_LCD_WF57_ADDR(x), ((uint8_t)(v) << BP_LCD_WF57_BPFLCD57), BP_LCD_WF57_BPFLCD57, 1))
/*@}*/

/*!
 * @name Register LCD_WF57, field BPGLCD57[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF57_BPGLCD57 (6U)          /*!< Bit position for LCD_WF57_BPGLCD57. */
#define BM_LCD_WF57_BPGLCD57 (0x40U)       /*!< Bit mask for LCD_WF57_BPGLCD57. */
#define BS_LCD_WF57_BPGLCD57 (1U)          /*!< Bit field size in bits for LCD_WF57_BPGLCD57. */

/*! @brief Read current value of the LCD_WF57_BPGLCD57 field. */
#define BR_LCD_WF57_BPGLCD57(x) (BME_UBFX8(HW_LCD_WF57_ADDR(x), BP_LCD_WF57_BPGLCD57, BS_LCD_WF57_BPGLCD57))

/*! @brief Format value for bitfield LCD_WF57_BPGLCD57. */
#define BF_LCD_WF57_BPGLCD57(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF57_BPGLCD57) & BM_LCD_WF57_BPGLCD57)

/*! @brief Set the BPGLCD57 field to a new value. */
#define BW_LCD_WF57_BPGLCD57(x, v) (BME_BFI8(HW_LCD_WF57_ADDR(x), ((uint8_t)(v) << BP_LCD_WF57_BPGLCD57), BP_LCD_WF57_BPGLCD57, 1))
/*@}*/

/*!
 * @name Register LCD_WF57, field BPHLCD57[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF57_BPHLCD57 (7U)          /*!< Bit position for LCD_WF57_BPHLCD57. */
#define BM_LCD_WF57_BPHLCD57 (0x80U)       /*!< Bit mask for LCD_WF57_BPHLCD57. */
#define BS_LCD_WF57_BPHLCD57 (1U)          /*!< Bit field size in bits for LCD_WF57_BPHLCD57. */

/*! @brief Read current value of the LCD_WF57_BPHLCD57 field. */
#define BR_LCD_WF57_BPHLCD57(x) (BME_UBFX8(HW_LCD_WF57_ADDR(x), BP_LCD_WF57_BPHLCD57, BS_LCD_WF57_BPHLCD57))

/*! @brief Format value for bitfield LCD_WF57_BPHLCD57. */
#define BF_LCD_WF57_BPHLCD57(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF57_BPHLCD57) & BM_LCD_WF57_BPHLCD57)

/*! @brief Set the BPHLCD57 field to a new value. */
#define BW_LCD_WF57_BPHLCD57(x, v) (BME_BFI8(HW_LCD_WF57_ADDR(x), ((uint8_t)(v) << BP_LCD_WF57_BPHLCD57), BP_LCD_WF57_BPHLCD57, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF58 - LCD Waveform Register 58.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF58 - LCD Waveform Register 58. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf58
{
    uint8_t U;
    struct _hw_lcd_wf58_bitfields
    {
        uint8_t BPALCD58 : 1;          /*!< [0]  */
        uint8_t BPBLCD58 : 1;          /*!< [1]  */
        uint8_t BPCLCD58 : 1;          /*!< [2]  */
        uint8_t BPDLCD58 : 1;          /*!< [3]  */
        uint8_t BPELCD58 : 1;          /*!< [4]  */
        uint8_t BPFLCD58 : 1;          /*!< [5]  */
        uint8_t BPGLCD58 : 1;          /*!< [6]  */
        uint8_t BPHLCD58 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf58_t;

/*!
 * @name Constants and macros for entire LCD_WF58 register
 */
/*@{*/
#define HW_LCD_WF58_ADDR(x)      ((uint32_t)(x) + 0x5AU)

#define HW_LCD_WF58(x)           (*(__IO hw_lcd_wf58_t *) HW_LCD_WF58_ADDR(x))
#define HW_LCD_WF58_RD(x)        (HW_LCD_WF58(x).U)
#define HW_LCD_WF58_WR(x, v)     (HW_LCD_WF58(x).U = (v))
#define HW_LCD_WF58_SET(x, v)    (BME_OR8(HW_LCD_WF58_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF58_CLR(x, v)    (BME_AND8(HW_LCD_WF58_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF58_TOG(x, v)    (BME_XOR8(HW_LCD_WF58_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF58 bitfields
 */

/*!
 * @name Register LCD_WF58, field BPALCD58[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF58_BPALCD58 (0U)          /*!< Bit position for LCD_WF58_BPALCD58. */
#define BM_LCD_WF58_BPALCD58 (0x01U)       /*!< Bit mask for LCD_WF58_BPALCD58. */
#define BS_LCD_WF58_BPALCD58 (1U)          /*!< Bit field size in bits for LCD_WF58_BPALCD58. */

/*! @brief Read current value of the LCD_WF58_BPALCD58 field. */
#define BR_LCD_WF58_BPALCD58(x) (BME_UBFX8(HW_LCD_WF58_ADDR(x), BP_LCD_WF58_BPALCD58, BS_LCD_WF58_BPALCD58))

/*! @brief Format value for bitfield LCD_WF58_BPALCD58. */
#define BF_LCD_WF58_BPALCD58(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF58_BPALCD58) & BM_LCD_WF58_BPALCD58)

/*! @brief Set the BPALCD58 field to a new value. */
#define BW_LCD_WF58_BPALCD58(x, v) (BME_BFI8(HW_LCD_WF58_ADDR(x), ((uint8_t)(v) << BP_LCD_WF58_BPALCD58), BP_LCD_WF58_BPALCD58, 1))
/*@}*/

/*!
 * @name Register LCD_WF58, field BPBLCD58[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF58_BPBLCD58 (1U)          /*!< Bit position for LCD_WF58_BPBLCD58. */
#define BM_LCD_WF58_BPBLCD58 (0x02U)       /*!< Bit mask for LCD_WF58_BPBLCD58. */
#define BS_LCD_WF58_BPBLCD58 (1U)          /*!< Bit field size in bits for LCD_WF58_BPBLCD58. */

/*! @brief Read current value of the LCD_WF58_BPBLCD58 field. */
#define BR_LCD_WF58_BPBLCD58(x) (BME_UBFX8(HW_LCD_WF58_ADDR(x), BP_LCD_WF58_BPBLCD58, BS_LCD_WF58_BPBLCD58))

/*! @brief Format value for bitfield LCD_WF58_BPBLCD58. */
#define BF_LCD_WF58_BPBLCD58(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF58_BPBLCD58) & BM_LCD_WF58_BPBLCD58)

/*! @brief Set the BPBLCD58 field to a new value. */
#define BW_LCD_WF58_BPBLCD58(x, v) (BME_BFI8(HW_LCD_WF58_ADDR(x), ((uint8_t)(v) << BP_LCD_WF58_BPBLCD58), BP_LCD_WF58_BPBLCD58, 1))
/*@}*/

/*!
 * @name Register LCD_WF58, field BPCLCD58[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF58_BPCLCD58 (2U)          /*!< Bit position for LCD_WF58_BPCLCD58. */
#define BM_LCD_WF58_BPCLCD58 (0x04U)       /*!< Bit mask for LCD_WF58_BPCLCD58. */
#define BS_LCD_WF58_BPCLCD58 (1U)          /*!< Bit field size in bits for LCD_WF58_BPCLCD58. */

/*! @brief Read current value of the LCD_WF58_BPCLCD58 field. */
#define BR_LCD_WF58_BPCLCD58(x) (BME_UBFX8(HW_LCD_WF58_ADDR(x), BP_LCD_WF58_BPCLCD58, BS_LCD_WF58_BPCLCD58))

/*! @brief Format value for bitfield LCD_WF58_BPCLCD58. */
#define BF_LCD_WF58_BPCLCD58(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF58_BPCLCD58) & BM_LCD_WF58_BPCLCD58)

/*! @brief Set the BPCLCD58 field to a new value. */
#define BW_LCD_WF58_BPCLCD58(x, v) (BME_BFI8(HW_LCD_WF58_ADDR(x), ((uint8_t)(v) << BP_LCD_WF58_BPCLCD58), BP_LCD_WF58_BPCLCD58, 1))
/*@}*/

/*!
 * @name Register LCD_WF58, field BPDLCD58[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF58_BPDLCD58 (3U)          /*!< Bit position for LCD_WF58_BPDLCD58. */
#define BM_LCD_WF58_BPDLCD58 (0x08U)       /*!< Bit mask for LCD_WF58_BPDLCD58. */
#define BS_LCD_WF58_BPDLCD58 (1U)          /*!< Bit field size in bits for LCD_WF58_BPDLCD58. */

/*! @brief Read current value of the LCD_WF58_BPDLCD58 field. */
#define BR_LCD_WF58_BPDLCD58(x) (BME_UBFX8(HW_LCD_WF58_ADDR(x), BP_LCD_WF58_BPDLCD58, BS_LCD_WF58_BPDLCD58))

/*! @brief Format value for bitfield LCD_WF58_BPDLCD58. */
#define BF_LCD_WF58_BPDLCD58(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF58_BPDLCD58) & BM_LCD_WF58_BPDLCD58)

/*! @brief Set the BPDLCD58 field to a new value. */
#define BW_LCD_WF58_BPDLCD58(x, v) (BME_BFI8(HW_LCD_WF58_ADDR(x), ((uint8_t)(v) << BP_LCD_WF58_BPDLCD58), BP_LCD_WF58_BPDLCD58, 1))
/*@}*/

/*!
 * @name Register LCD_WF58, field BPELCD58[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF58_BPELCD58 (4U)          /*!< Bit position for LCD_WF58_BPELCD58. */
#define BM_LCD_WF58_BPELCD58 (0x10U)       /*!< Bit mask for LCD_WF58_BPELCD58. */
#define BS_LCD_WF58_BPELCD58 (1U)          /*!< Bit field size in bits for LCD_WF58_BPELCD58. */

/*! @brief Read current value of the LCD_WF58_BPELCD58 field. */
#define BR_LCD_WF58_BPELCD58(x) (BME_UBFX8(HW_LCD_WF58_ADDR(x), BP_LCD_WF58_BPELCD58, BS_LCD_WF58_BPELCD58))

/*! @brief Format value for bitfield LCD_WF58_BPELCD58. */
#define BF_LCD_WF58_BPELCD58(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF58_BPELCD58) & BM_LCD_WF58_BPELCD58)

/*! @brief Set the BPELCD58 field to a new value. */
#define BW_LCD_WF58_BPELCD58(x, v) (BME_BFI8(HW_LCD_WF58_ADDR(x), ((uint8_t)(v) << BP_LCD_WF58_BPELCD58), BP_LCD_WF58_BPELCD58, 1))
/*@}*/

/*!
 * @name Register LCD_WF58, field BPFLCD58[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF58_BPFLCD58 (5U)          /*!< Bit position for LCD_WF58_BPFLCD58. */
#define BM_LCD_WF58_BPFLCD58 (0x20U)       /*!< Bit mask for LCD_WF58_BPFLCD58. */
#define BS_LCD_WF58_BPFLCD58 (1U)          /*!< Bit field size in bits for LCD_WF58_BPFLCD58. */

/*! @brief Read current value of the LCD_WF58_BPFLCD58 field. */
#define BR_LCD_WF58_BPFLCD58(x) (BME_UBFX8(HW_LCD_WF58_ADDR(x), BP_LCD_WF58_BPFLCD58, BS_LCD_WF58_BPFLCD58))

/*! @brief Format value for bitfield LCD_WF58_BPFLCD58. */
#define BF_LCD_WF58_BPFLCD58(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF58_BPFLCD58) & BM_LCD_WF58_BPFLCD58)

/*! @brief Set the BPFLCD58 field to a new value. */
#define BW_LCD_WF58_BPFLCD58(x, v) (BME_BFI8(HW_LCD_WF58_ADDR(x), ((uint8_t)(v) << BP_LCD_WF58_BPFLCD58), BP_LCD_WF58_BPFLCD58, 1))
/*@}*/

/*!
 * @name Register LCD_WF58, field BPGLCD58[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF58_BPGLCD58 (6U)          /*!< Bit position for LCD_WF58_BPGLCD58. */
#define BM_LCD_WF58_BPGLCD58 (0x40U)       /*!< Bit mask for LCD_WF58_BPGLCD58. */
#define BS_LCD_WF58_BPGLCD58 (1U)          /*!< Bit field size in bits for LCD_WF58_BPGLCD58. */

/*! @brief Read current value of the LCD_WF58_BPGLCD58 field. */
#define BR_LCD_WF58_BPGLCD58(x) (BME_UBFX8(HW_LCD_WF58_ADDR(x), BP_LCD_WF58_BPGLCD58, BS_LCD_WF58_BPGLCD58))

/*! @brief Format value for bitfield LCD_WF58_BPGLCD58. */
#define BF_LCD_WF58_BPGLCD58(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF58_BPGLCD58) & BM_LCD_WF58_BPGLCD58)

/*! @brief Set the BPGLCD58 field to a new value. */
#define BW_LCD_WF58_BPGLCD58(x, v) (BME_BFI8(HW_LCD_WF58_ADDR(x), ((uint8_t)(v) << BP_LCD_WF58_BPGLCD58), BP_LCD_WF58_BPGLCD58, 1))
/*@}*/

/*!
 * @name Register LCD_WF58, field BPHLCD58[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF58_BPHLCD58 (7U)          /*!< Bit position for LCD_WF58_BPHLCD58. */
#define BM_LCD_WF58_BPHLCD58 (0x80U)       /*!< Bit mask for LCD_WF58_BPHLCD58. */
#define BS_LCD_WF58_BPHLCD58 (1U)          /*!< Bit field size in bits for LCD_WF58_BPHLCD58. */

/*! @brief Read current value of the LCD_WF58_BPHLCD58 field. */
#define BR_LCD_WF58_BPHLCD58(x) (BME_UBFX8(HW_LCD_WF58_ADDR(x), BP_LCD_WF58_BPHLCD58, BS_LCD_WF58_BPHLCD58))

/*! @brief Format value for bitfield LCD_WF58_BPHLCD58. */
#define BF_LCD_WF58_BPHLCD58(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF58_BPHLCD58) & BM_LCD_WF58_BPHLCD58)

/*! @brief Set the BPHLCD58 field to a new value. */
#define BW_LCD_WF58_BPHLCD58(x, v) (BME_BFI8(HW_LCD_WF58_ADDR(x), ((uint8_t)(v) << BP_LCD_WF58_BPHLCD58), BP_LCD_WF58_BPHLCD58, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF59 - LCD Waveform Register 59.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF59 - LCD Waveform Register 59. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf59
{
    uint8_t U;
    struct _hw_lcd_wf59_bitfields
    {
        uint8_t BPALCD59 : 1;          /*!< [0]  */
        uint8_t BPBLCD59 : 1;          /*!< [1]  */
        uint8_t BPCLCD59 : 1;          /*!< [2]  */
        uint8_t BPDLCD59 : 1;          /*!< [3]  */
        uint8_t BPELCD59 : 1;          /*!< [4]  */
        uint8_t BPFLCD59 : 1;          /*!< [5]  */
        uint8_t BPGLCD59 : 1;          /*!< [6]  */
        uint8_t BPHLCD59 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf59_t;

/*!
 * @name Constants and macros for entire LCD_WF59 register
 */
/*@{*/
#define HW_LCD_WF59_ADDR(x)      ((uint32_t)(x) + 0x5BU)

#define HW_LCD_WF59(x)           (*(__IO hw_lcd_wf59_t *) HW_LCD_WF59_ADDR(x))
#define HW_LCD_WF59_RD(x)        (HW_LCD_WF59(x).U)
#define HW_LCD_WF59_WR(x, v)     (HW_LCD_WF59(x).U = (v))
#define HW_LCD_WF59_SET(x, v)    (BME_OR8(HW_LCD_WF59_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF59_CLR(x, v)    (BME_AND8(HW_LCD_WF59_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF59_TOG(x, v)    (BME_XOR8(HW_LCD_WF59_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF59 bitfields
 */

/*!
 * @name Register LCD_WF59, field BPALCD59[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF59_BPALCD59 (0U)          /*!< Bit position for LCD_WF59_BPALCD59. */
#define BM_LCD_WF59_BPALCD59 (0x01U)       /*!< Bit mask for LCD_WF59_BPALCD59. */
#define BS_LCD_WF59_BPALCD59 (1U)          /*!< Bit field size in bits for LCD_WF59_BPALCD59. */

/*! @brief Read current value of the LCD_WF59_BPALCD59 field. */
#define BR_LCD_WF59_BPALCD59(x) (BME_UBFX8(HW_LCD_WF59_ADDR(x), BP_LCD_WF59_BPALCD59, BS_LCD_WF59_BPALCD59))

/*! @brief Format value for bitfield LCD_WF59_BPALCD59. */
#define BF_LCD_WF59_BPALCD59(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF59_BPALCD59) & BM_LCD_WF59_BPALCD59)

/*! @brief Set the BPALCD59 field to a new value. */
#define BW_LCD_WF59_BPALCD59(x, v) (BME_BFI8(HW_LCD_WF59_ADDR(x), ((uint8_t)(v) << BP_LCD_WF59_BPALCD59), BP_LCD_WF59_BPALCD59, 1))
/*@}*/

/*!
 * @name Register LCD_WF59, field BPBLCD59[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF59_BPBLCD59 (1U)          /*!< Bit position for LCD_WF59_BPBLCD59. */
#define BM_LCD_WF59_BPBLCD59 (0x02U)       /*!< Bit mask for LCD_WF59_BPBLCD59. */
#define BS_LCD_WF59_BPBLCD59 (1U)          /*!< Bit field size in bits for LCD_WF59_BPBLCD59. */

/*! @brief Read current value of the LCD_WF59_BPBLCD59 field. */
#define BR_LCD_WF59_BPBLCD59(x) (BME_UBFX8(HW_LCD_WF59_ADDR(x), BP_LCD_WF59_BPBLCD59, BS_LCD_WF59_BPBLCD59))

/*! @brief Format value for bitfield LCD_WF59_BPBLCD59. */
#define BF_LCD_WF59_BPBLCD59(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF59_BPBLCD59) & BM_LCD_WF59_BPBLCD59)

/*! @brief Set the BPBLCD59 field to a new value. */
#define BW_LCD_WF59_BPBLCD59(x, v) (BME_BFI8(HW_LCD_WF59_ADDR(x), ((uint8_t)(v) << BP_LCD_WF59_BPBLCD59), BP_LCD_WF59_BPBLCD59, 1))
/*@}*/

/*!
 * @name Register LCD_WF59, field BPCLCD59[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF59_BPCLCD59 (2U)          /*!< Bit position for LCD_WF59_BPCLCD59. */
#define BM_LCD_WF59_BPCLCD59 (0x04U)       /*!< Bit mask for LCD_WF59_BPCLCD59. */
#define BS_LCD_WF59_BPCLCD59 (1U)          /*!< Bit field size in bits for LCD_WF59_BPCLCD59. */

/*! @brief Read current value of the LCD_WF59_BPCLCD59 field. */
#define BR_LCD_WF59_BPCLCD59(x) (BME_UBFX8(HW_LCD_WF59_ADDR(x), BP_LCD_WF59_BPCLCD59, BS_LCD_WF59_BPCLCD59))

/*! @brief Format value for bitfield LCD_WF59_BPCLCD59. */
#define BF_LCD_WF59_BPCLCD59(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF59_BPCLCD59) & BM_LCD_WF59_BPCLCD59)

/*! @brief Set the BPCLCD59 field to a new value. */
#define BW_LCD_WF59_BPCLCD59(x, v) (BME_BFI8(HW_LCD_WF59_ADDR(x), ((uint8_t)(v) << BP_LCD_WF59_BPCLCD59), BP_LCD_WF59_BPCLCD59, 1))
/*@}*/

/*!
 * @name Register LCD_WF59, field BPDLCD59[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF59_BPDLCD59 (3U)          /*!< Bit position for LCD_WF59_BPDLCD59. */
#define BM_LCD_WF59_BPDLCD59 (0x08U)       /*!< Bit mask for LCD_WF59_BPDLCD59. */
#define BS_LCD_WF59_BPDLCD59 (1U)          /*!< Bit field size in bits for LCD_WF59_BPDLCD59. */

/*! @brief Read current value of the LCD_WF59_BPDLCD59 field. */
#define BR_LCD_WF59_BPDLCD59(x) (BME_UBFX8(HW_LCD_WF59_ADDR(x), BP_LCD_WF59_BPDLCD59, BS_LCD_WF59_BPDLCD59))

/*! @brief Format value for bitfield LCD_WF59_BPDLCD59. */
#define BF_LCD_WF59_BPDLCD59(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF59_BPDLCD59) & BM_LCD_WF59_BPDLCD59)

/*! @brief Set the BPDLCD59 field to a new value. */
#define BW_LCD_WF59_BPDLCD59(x, v) (BME_BFI8(HW_LCD_WF59_ADDR(x), ((uint8_t)(v) << BP_LCD_WF59_BPDLCD59), BP_LCD_WF59_BPDLCD59, 1))
/*@}*/

/*!
 * @name Register LCD_WF59, field BPELCD59[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF59_BPELCD59 (4U)          /*!< Bit position for LCD_WF59_BPELCD59. */
#define BM_LCD_WF59_BPELCD59 (0x10U)       /*!< Bit mask for LCD_WF59_BPELCD59. */
#define BS_LCD_WF59_BPELCD59 (1U)          /*!< Bit field size in bits for LCD_WF59_BPELCD59. */

/*! @brief Read current value of the LCD_WF59_BPELCD59 field. */
#define BR_LCD_WF59_BPELCD59(x) (BME_UBFX8(HW_LCD_WF59_ADDR(x), BP_LCD_WF59_BPELCD59, BS_LCD_WF59_BPELCD59))

/*! @brief Format value for bitfield LCD_WF59_BPELCD59. */
#define BF_LCD_WF59_BPELCD59(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF59_BPELCD59) & BM_LCD_WF59_BPELCD59)

/*! @brief Set the BPELCD59 field to a new value. */
#define BW_LCD_WF59_BPELCD59(x, v) (BME_BFI8(HW_LCD_WF59_ADDR(x), ((uint8_t)(v) << BP_LCD_WF59_BPELCD59), BP_LCD_WF59_BPELCD59, 1))
/*@}*/

/*!
 * @name Register LCD_WF59, field BPFLCD59[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF59_BPFLCD59 (5U)          /*!< Bit position for LCD_WF59_BPFLCD59. */
#define BM_LCD_WF59_BPFLCD59 (0x20U)       /*!< Bit mask for LCD_WF59_BPFLCD59. */
#define BS_LCD_WF59_BPFLCD59 (1U)          /*!< Bit field size in bits for LCD_WF59_BPFLCD59. */

/*! @brief Read current value of the LCD_WF59_BPFLCD59 field. */
#define BR_LCD_WF59_BPFLCD59(x) (BME_UBFX8(HW_LCD_WF59_ADDR(x), BP_LCD_WF59_BPFLCD59, BS_LCD_WF59_BPFLCD59))

/*! @brief Format value for bitfield LCD_WF59_BPFLCD59. */
#define BF_LCD_WF59_BPFLCD59(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF59_BPFLCD59) & BM_LCD_WF59_BPFLCD59)

/*! @brief Set the BPFLCD59 field to a new value. */
#define BW_LCD_WF59_BPFLCD59(x, v) (BME_BFI8(HW_LCD_WF59_ADDR(x), ((uint8_t)(v) << BP_LCD_WF59_BPFLCD59), BP_LCD_WF59_BPFLCD59, 1))
/*@}*/

/*!
 * @name Register LCD_WF59, field BPGLCD59[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF59_BPGLCD59 (6U)          /*!< Bit position for LCD_WF59_BPGLCD59. */
#define BM_LCD_WF59_BPGLCD59 (0x40U)       /*!< Bit mask for LCD_WF59_BPGLCD59. */
#define BS_LCD_WF59_BPGLCD59 (1U)          /*!< Bit field size in bits for LCD_WF59_BPGLCD59. */

/*! @brief Read current value of the LCD_WF59_BPGLCD59 field. */
#define BR_LCD_WF59_BPGLCD59(x) (BME_UBFX8(HW_LCD_WF59_ADDR(x), BP_LCD_WF59_BPGLCD59, BS_LCD_WF59_BPGLCD59))

/*! @brief Format value for bitfield LCD_WF59_BPGLCD59. */
#define BF_LCD_WF59_BPGLCD59(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF59_BPGLCD59) & BM_LCD_WF59_BPGLCD59)

/*! @brief Set the BPGLCD59 field to a new value. */
#define BW_LCD_WF59_BPGLCD59(x, v) (BME_BFI8(HW_LCD_WF59_ADDR(x), ((uint8_t)(v) << BP_LCD_WF59_BPGLCD59), BP_LCD_WF59_BPGLCD59, 1))
/*@}*/

/*!
 * @name Register LCD_WF59, field BPHLCD59[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF59_BPHLCD59 (7U)          /*!< Bit position for LCD_WF59_BPHLCD59. */
#define BM_LCD_WF59_BPHLCD59 (0x80U)       /*!< Bit mask for LCD_WF59_BPHLCD59. */
#define BS_LCD_WF59_BPHLCD59 (1U)          /*!< Bit field size in bits for LCD_WF59_BPHLCD59. */

/*! @brief Read current value of the LCD_WF59_BPHLCD59 field. */
#define BR_LCD_WF59_BPHLCD59(x) (BME_UBFX8(HW_LCD_WF59_ADDR(x), BP_LCD_WF59_BPHLCD59, BS_LCD_WF59_BPHLCD59))

/*! @brief Format value for bitfield LCD_WF59_BPHLCD59. */
#define BF_LCD_WF59_BPHLCD59(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF59_BPHLCD59) & BM_LCD_WF59_BPHLCD59)

/*! @brief Set the BPHLCD59 field to a new value. */
#define BW_LCD_WF59_BPHLCD59(x, v) (BME_BFI8(HW_LCD_WF59_ADDR(x), ((uint8_t)(v) << BP_LCD_WF59_BPHLCD59), BP_LCD_WF59_BPHLCD59, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF60 - LCD Waveform Register 60.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF60 - LCD Waveform Register 60. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf60
{
    uint8_t U;
    struct _hw_lcd_wf60_bitfields
    {
        uint8_t BPALCD60 : 1;          /*!< [0]  */
        uint8_t BPBLCD60 : 1;          /*!< [1]  */
        uint8_t BPCLCD60 : 1;          /*!< [2]  */
        uint8_t BPDLCD60 : 1;          /*!< [3]  */
        uint8_t BPELCD60 : 1;          /*!< [4]  */
        uint8_t BPFLCD60 : 1;          /*!< [5]  */
        uint8_t BPGLCD60 : 1;          /*!< [6]  */
        uint8_t BPHLCD60 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf60_t;

/*!
 * @name Constants and macros for entire LCD_WF60 register
 */
/*@{*/
#define HW_LCD_WF60_ADDR(x)      ((uint32_t)(x) + 0x5CU)

#define HW_LCD_WF60(x)           (*(__IO hw_lcd_wf60_t *) HW_LCD_WF60_ADDR(x))
#define HW_LCD_WF60_RD(x)        (HW_LCD_WF60(x).U)
#define HW_LCD_WF60_WR(x, v)     (HW_LCD_WF60(x).U = (v))
#define HW_LCD_WF60_SET(x, v)    (BME_OR8(HW_LCD_WF60_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF60_CLR(x, v)    (BME_AND8(HW_LCD_WF60_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF60_TOG(x, v)    (BME_XOR8(HW_LCD_WF60_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF60 bitfields
 */

/*!
 * @name Register LCD_WF60, field BPALCD60[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF60_BPALCD60 (0U)          /*!< Bit position for LCD_WF60_BPALCD60. */
#define BM_LCD_WF60_BPALCD60 (0x01U)       /*!< Bit mask for LCD_WF60_BPALCD60. */
#define BS_LCD_WF60_BPALCD60 (1U)          /*!< Bit field size in bits for LCD_WF60_BPALCD60. */

/*! @brief Read current value of the LCD_WF60_BPALCD60 field. */
#define BR_LCD_WF60_BPALCD60(x) (BME_UBFX8(HW_LCD_WF60_ADDR(x), BP_LCD_WF60_BPALCD60, BS_LCD_WF60_BPALCD60))

/*! @brief Format value for bitfield LCD_WF60_BPALCD60. */
#define BF_LCD_WF60_BPALCD60(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF60_BPALCD60) & BM_LCD_WF60_BPALCD60)

/*! @brief Set the BPALCD60 field to a new value. */
#define BW_LCD_WF60_BPALCD60(x, v) (BME_BFI8(HW_LCD_WF60_ADDR(x), ((uint8_t)(v) << BP_LCD_WF60_BPALCD60), BP_LCD_WF60_BPALCD60, 1))
/*@}*/

/*!
 * @name Register LCD_WF60, field BPBLCD60[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF60_BPBLCD60 (1U)          /*!< Bit position for LCD_WF60_BPBLCD60. */
#define BM_LCD_WF60_BPBLCD60 (0x02U)       /*!< Bit mask for LCD_WF60_BPBLCD60. */
#define BS_LCD_WF60_BPBLCD60 (1U)          /*!< Bit field size in bits for LCD_WF60_BPBLCD60. */

/*! @brief Read current value of the LCD_WF60_BPBLCD60 field. */
#define BR_LCD_WF60_BPBLCD60(x) (BME_UBFX8(HW_LCD_WF60_ADDR(x), BP_LCD_WF60_BPBLCD60, BS_LCD_WF60_BPBLCD60))

/*! @brief Format value for bitfield LCD_WF60_BPBLCD60. */
#define BF_LCD_WF60_BPBLCD60(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF60_BPBLCD60) & BM_LCD_WF60_BPBLCD60)

/*! @brief Set the BPBLCD60 field to a new value. */
#define BW_LCD_WF60_BPBLCD60(x, v) (BME_BFI8(HW_LCD_WF60_ADDR(x), ((uint8_t)(v) << BP_LCD_WF60_BPBLCD60), BP_LCD_WF60_BPBLCD60, 1))
/*@}*/

/*!
 * @name Register LCD_WF60, field BPCLCD60[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF60_BPCLCD60 (2U)          /*!< Bit position for LCD_WF60_BPCLCD60. */
#define BM_LCD_WF60_BPCLCD60 (0x04U)       /*!< Bit mask for LCD_WF60_BPCLCD60. */
#define BS_LCD_WF60_BPCLCD60 (1U)          /*!< Bit field size in bits for LCD_WF60_BPCLCD60. */

/*! @brief Read current value of the LCD_WF60_BPCLCD60 field. */
#define BR_LCD_WF60_BPCLCD60(x) (BME_UBFX8(HW_LCD_WF60_ADDR(x), BP_LCD_WF60_BPCLCD60, BS_LCD_WF60_BPCLCD60))

/*! @brief Format value for bitfield LCD_WF60_BPCLCD60. */
#define BF_LCD_WF60_BPCLCD60(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF60_BPCLCD60) & BM_LCD_WF60_BPCLCD60)

/*! @brief Set the BPCLCD60 field to a new value. */
#define BW_LCD_WF60_BPCLCD60(x, v) (BME_BFI8(HW_LCD_WF60_ADDR(x), ((uint8_t)(v) << BP_LCD_WF60_BPCLCD60), BP_LCD_WF60_BPCLCD60, 1))
/*@}*/

/*!
 * @name Register LCD_WF60, field BPDLCD60[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF60_BPDLCD60 (3U)          /*!< Bit position for LCD_WF60_BPDLCD60. */
#define BM_LCD_WF60_BPDLCD60 (0x08U)       /*!< Bit mask for LCD_WF60_BPDLCD60. */
#define BS_LCD_WF60_BPDLCD60 (1U)          /*!< Bit field size in bits for LCD_WF60_BPDLCD60. */

/*! @brief Read current value of the LCD_WF60_BPDLCD60 field. */
#define BR_LCD_WF60_BPDLCD60(x) (BME_UBFX8(HW_LCD_WF60_ADDR(x), BP_LCD_WF60_BPDLCD60, BS_LCD_WF60_BPDLCD60))

/*! @brief Format value for bitfield LCD_WF60_BPDLCD60. */
#define BF_LCD_WF60_BPDLCD60(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF60_BPDLCD60) & BM_LCD_WF60_BPDLCD60)

/*! @brief Set the BPDLCD60 field to a new value. */
#define BW_LCD_WF60_BPDLCD60(x, v) (BME_BFI8(HW_LCD_WF60_ADDR(x), ((uint8_t)(v) << BP_LCD_WF60_BPDLCD60), BP_LCD_WF60_BPDLCD60, 1))
/*@}*/

/*!
 * @name Register LCD_WF60, field BPELCD60[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF60_BPELCD60 (4U)          /*!< Bit position for LCD_WF60_BPELCD60. */
#define BM_LCD_WF60_BPELCD60 (0x10U)       /*!< Bit mask for LCD_WF60_BPELCD60. */
#define BS_LCD_WF60_BPELCD60 (1U)          /*!< Bit field size in bits for LCD_WF60_BPELCD60. */

/*! @brief Read current value of the LCD_WF60_BPELCD60 field. */
#define BR_LCD_WF60_BPELCD60(x) (BME_UBFX8(HW_LCD_WF60_ADDR(x), BP_LCD_WF60_BPELCD60, BS_LCD_WF60_BPELCD60))

/*! @brief Format value for bitfield LCD_WF60_BPELCD60. */
#define BF_LCD_WF60_BPELCD60(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF60_BPELCD60) & BM_LCD_WF60_BPELCD60)

/*! @brief Set the BPELCD60 field to a new value. */
#define BW_LCD_WF60_BPELCD60(x, v) (BME_BFI8(HW_LCD_WF60_ADDR(x), ((uint8_t)(v) << BP_LCD_WF60_BPELCD60), BP_LCD_WF60_BPELCD60, 1))
/*@}*/

/*!
 * @name Register LCD_WF60, field BPFLCD60[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF60_BPFLCD60 (5U)          /*!< Bit position for LCD_WF60_BPFLCD60. */
#define BM_LCD_WF60_BPFLCD60 (0x20U)       /*!< Bit mask for LCD_WF60_BPFLCD60. */
#define BS_LCD_WF60_BPFLCD60 (1U)          /*!< Bit field size in bits for LCD_WF60_BPFLCD60. */

/*! @brief Read current value of the LCD_WF60_BPFLCD60 field. */
#define BR_LCD_WF60_BPFLCD60(x) (BME_UBFX8(HW_LCD_WF60_ADDR(x), BP_LCD_WF60_BPFLCD60, BS_LCD_WF60_BPFLCD60))

/*! @brief Format value for bitfield LCD_WF60_BPFLCD60. */
#define BF_LCD_WF60_BPFLCD60(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF60_BPFLCD60) & BM_LCD_WF60_BPFLCD60)

/*! @brief Set the BPFLCD60 field to a new value. */
#define BW_LCD_WF60_BPFLCD60(x, v) (BME_BFI8(HW_LCD_WF60_ADDR(x), ((uint8_t)(v) << BP_LCD_WF60_BPFLCD60), BP_LCD_WF60_BPFLCD60, 1))
/*@}*/

/*!
 * @name Register LCD_WF60, field BPGLCD60[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF60_BPGLCD60 (6U)          /*!< Bit position for LCD_WF60_BPGLCD60. */
#define BM_LCD_WF60_BPGLCD60 (0x40U)       /*!< Bit mask for LCD_WF60_BPGLCD60. */
#define BS_LCD_WF60_BPGLCD60 (1U)          /*!< Bit field size in bits for LCD_WF60_BPGLCD60. */

/*! @brief Read current value of the LCD_WF60_BPGLCD60 field. */
#define BR_LCD_WF60_BPGLCD60(x) (BME_UBFX8(HW_LCD_WF60_ADDR(x), BP_LCD_WF60_BPGLCD60, BS_LCD_WF60_BPGLCD60))

/*! @brief Format value for bitfield LCD_WF60_BPGLCD60. */
#define BF_LCD_WF60_BPGLCD60(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF60_BPGLCD60) & BM_LCD_WF60_BPGLCD60)

/*! @brief Set the BPGLCD60 field to a new value. */
#define BW_LCD_WF60_BPGLCD60(x, v) (BME_BFI8(HW_LCD_WF60_ADDR(x), ((uint8_t)(v) << BP_LCD_WF60_BPGLCD60), BP_LCD_WF60_BPGLCD60, 1))
/*@}*/

/*!
 * @name Register LCD_WF60, field BPHLCD60[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF60_BPHLCD60 (7U)          /*!< Bit position for LCD_WF60_BPHLCD60. */
#define BM_LCD_WF60_BPHLCD60 (0x80U)       /*!< Bit mask for LCD_WF60_BPHLCD60. */
#define BS_LCD_WF60_BPHLCD60 (1U)          /*!< Bit field size in bits for LCD_WF60_BPHLCD60. */

/*! @brief Read current value of the LCD_WF60_BPHLCD60 field. */
#define BR_LCD_WF60_BPHLCD60(x) (BME_UBFX8(HW_LCD_WF60_ADDR(x), BP_LCD_WF60_BPHLCD60, BS_LCD_WF60_BPHLCD60))

/*! @brief Format value for bitfield LCD_WF60_BPHLCD60. */
#define BF_LCD_WF60_BPHLCD60(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF60_BPHLCD60) & BM_LCD_WF60_BPHLCD60)

/*! @brief Set the BPHLCD60 field to a new value. */
#define BW_LCD_WF60_BPHLCD60(x, v) (BME_BFI8(HW_LCD_WF60_ADDR(x), ((uint8_t)(v) << BP_LCD_WF60_BPHLCD60), BP_LCD_WF60_BPHLCD60, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF61 - LCD Waveform Register 61.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF61 - LCD Waveform Register 61. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf61
{
    uint8_t U;
    struct _hw_lcd_wf61_bitfields
    {
        uint8_t BPALCD61 : 1;          /*!< [0]  */
        uint8_t BPBLCD61 : 1;          /*!< [1]  */
        uint8_t BPCLCD61 : 1;          /*!< [2]  */
        uint8_t BPDLCD61 : 1;          /*!< [3]  */
        uint8_t BPELCD61 : 1;          /*!< [4]  */
        uint8_t BPFLCD61 : 1;          /*!< [5]  */
        uint8_t BPGLCD61 : 1;          /*!< [6]  */
        uint8_t BPHLCD61 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf61_t;

/*!
 * @name Constants and macros for entire LCD_WF61 register
 */
/*@{*/
#define HW_LCD_WF61_ADDR(x)      ((uint32_t)(x) + 0x5DU)

#define HW_LCD_WF61(x)           (*(__IO hw_lcd_wf61_t *) HW_LCD_WF61_ADDR(x))
#define HW_LCD_WF61_RD(x)        (HW_LCD_WF61(x).U)
#define HW_LCD_WF61_WR(x, v)     (HW_LCD_WF61(x).U = (v))
#define HW_LCD_WF61_SET(x, v)    (BME_OR8(HW_LCD_WF61_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF61_CLR(x, v)    (BME_AND8(HW_LCD_WF61_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF61_TOG(x, v)    (BME_XOR8(HW_LCD_WF61_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF61 bitfields
 */

/*!
 * @name Register LCD_WF61, field BPALCD61[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF61_BPALCD61 (0U)          /*!< Bit position for LCD_WF61_BPALCD61. */
#define BM_LCD_WF61_BPALCD61 (0x01U)       /*!< Bit mask for LCD_WF61_BPALCD61. */
#define BS_LCD_WF61_BPALCD61 (1U)          /*!< Bit field size in bits for LCD_WF61_BPALCD61. */

/*! @brief Read current value of the LCD_WF61_BPALCD61 field. */
#define BR_LCD_WF61_BPALCD61(x) (BME_UBFX8(HW_LCD_WF61_ADDR(x), BP_LCD_WF61_BPALCD61, BS_LCD_WF61_BPALCD61))

/*! @brief Format value for bitfield LCD_WF61_BPALCD61. */
#define BF_LCD_WF61_BPALCD61(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF61_BPALCD61) & BM_LCD_WF61_BPALCD61)

/*! @brief Set the BPALCD61 field to a new value. */
#define BW_LCD_WF61_BPALCD61(x, v) (BME_BFI8(HW_LCD_WF61_ADDR(x), ((uint8_t)(v) << BP_LCD_WF61_BPALCD61), BP_LCD_WF61_BPALCD61, 1))
/*@}*/

/*!
 * @name Register LCD_WF61, field BPBLCD61[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF61_BPBLCD61 (1U)          /*!< Bit position for LCD_WF61_BPBLCD61. */
#define BM_LCD_WF61_BPBLCD61 (0x02U)       /*!< Bit mask for LCD_WF61_BPBLCD61. */
#define BS_LCD_WF61_BPBLCD61 (1U)          /*!< Bit field size in bits for LCD_WF61_BPBLCD61. */

/*! @brief Read current value of the LCD_WF61_BPBLCD61 field. */
#define BR_LCD_WF61_BPBLCD61(x) (BME_UBFX8(HW_LCD_WF61_ADDR(x), BP_LCD_WF61_BPBLCD61, BS_LCD_WF61_BPBLCD61))

/*! @brief Format value for bitfield LCD_WF61_BPBLCD61. */
#define BF_LCD_WF61_BPBLCD61(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF61_BPBLCD61) & BM_LCD_WF61_BPBLCD61)

/*! @brief Set the BPBLCD61 field to a new value. */
#define BW_LCD_WF61_BPBLCD61(x, v) (BME_BFI8(HW_LCD_WF61_ADDR(x), ((uint8_t)(v) << BP_LCD_WF61_BPBLCD61), BP_LCD_WF61_BPBLCD61, 1))
/*@}*/

/*!
 * @name Register LCD_WF61, field BPCLCD61[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF61_BPCLCD61 (2U)          /*!< Bit position for LCD_WF61_BPCLCD61. */
#define BM_LCD_WF61_BPCLCD61 (0x04U)       /*!< Bit mask for LCD_WF61_BPCLCD61. */
#define BS_LCD_WF61_BPCLCD61 (1U)          /*!< Bit field size in bits for LCD_WF61_BPCLCD61. */

/*! @brief Read current value of the LCD_WF61_BPCLCD61 field. */
#define BR_LCD_WF61_BPCLCD61(x) (BME_UBFX8(HW_LCD_WF61_ADDR(x), BP_LCD_WF61_BPCLCD61, BS_LCD_WF61_BPCLCD61))

/*! @brief Format value for bitfield LCD_WF61_BPCLCD61. */
#define BF_LCD_WF61_BPCLCD61(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF61_BPCLCD61) & BM_LCD_WF61_BPCLCD61)

/*! @brief Set the BPCLCD61 field to a new value. */
#define BW_LCD_WF61_BPCLCD61(x, v) (BME_BFI8(HW_LCD_WF61_ADDR(x), ((uint8_t)(v) << BP_LCD_WF61_BPCLCD61), BP_LCD_WF61_BPCLCD61, 1))
/*@}*/

/*!
 * @name Register LCD_WF61, field BPDLCD61[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF61_BPDLCD61 (3U)          /*!< Bit position for LCD_WF61_BPDLCD61. */
#define BM_LCD_WF61_BPDLCD61 (0x08U)       /*!< Bit mask for LCD_WF61_BPDLCD61. */
#define BS_LCD_WF61_BPDLCD61 (1U)          /*!< Bit field size in bits for LCD_WF61_BPDLCD61. */

/*! @brief Read current value of the LCD_WF61_BPDLCD61 field. */
#define BR_LCD_WF61_BPDLCD61(x) (BME_UBFX8(HW_LCD_WF61_ADDR(x), BP_LCD_WF61_BPDLCD61, BS_LCD_WF61_BPDLCD61))

/*! @brief Format value for bitfield LCD_WF61_BPDLCD61. */
#define BF_LCD_WF61_BPDLCD61(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF61_BPDLCD61) & BM_LCD_WF61_BPDLCD61)

/*! @brief Set the BPDLCD61 field to a new value. */
#define BW_LCD_WF61_BPDLCD61(x, v) (BME_BFI8(HW_LCD_WF61_ADDR(x), ((uint8_t)(v) << BP_LCD_WF61_BPDLCD61), BP_LCD_WF61_BPDLCD61, 1))
/*@}*/

/*!
 * @name Register LCD_WF61, field BPELCD61[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF61_BPELCD61 (4U)          /*!< Bit position for LCD_WF61_BPELCD61. */
#define BM_LCD_WF61_BPELCD61 (0x10U)       /*!< Bit mask for LCD_WF61_BPELCD61. */
#define BS_LCD_WF61_BPELCD61 (1U)          /*!< Bit field size in bits for LCD_WF61_BPELCD61. */

/*! @brief Read current value of the LCD_WF61_BPELCD61 field. */
#define BR_LCD_WF61_BPELCD61(x) (BME_UBFX8(HW_LCD_WF61_ADDR(x), BP_LCD_WF61_BPELCD61, BS_LCD_WF61_BPELCD61))

/*! @brief Format value for bitfield LCD_WF61_BPELCD61. */
#define BF_LCD_WF61_BPELCD61(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF61_BPELCD61) & BM_LCD_WF61_BPELCD61)

/*! @brief Set the BPELCD61 field to a new value. */
#define BW_LCD_WF61_BPELCD61(x, v) (BME_BFI8(HW_LCD_WF61_ADDR(x), ((uint8_t)(v) << BP_LCD_WF61_BPELCD61), BP_LCD_WF61_BPELCD61, 1))
/*@}*/

/*!
 * @name Register LCD_WF61, field BPFLCD61[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF61_BPFLCD61 (5U)          /*!< Bit position for LCD_WF61_BPFLCD61. */
#define BM_LCD_WF61_BPFLCD61 (0x20U)       /*!< Bit mask for LCD_WF61_BPFLCD61. */
#define BS_LCD_WF61_BPFLCD61 (1U)          /*!< Bit field size in bits for LCD_WF61_BPFLCD61. */

/*! @brief Read current value of the LCD_WF61_BPFLCD61 field. */
#define BR_LCD_WF61_BPFLCD61(x) (BME_UBFX8(HW_LCD_WF61_ADDR(x), BP_LCD_WF61_BPFLCD61, BS_LCD_WF61_BPFLCD61))

/*! @brief Format value for bitfield LCD_WF61_BPFLCD61. */
#define BF_LCD_WF61_BPFLCD61(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF61_BPFLCD61) & BM_LCD_WF61_BPFLCD61)

/*! @brief Set the BPFLCD61 field to a new value. */
#define BW_LCD_WF61_BPFLCD61(x, v) (BME_BFI8(HW_LCD_WF61_ADDR(x), ((uint8_t)(v) << BP_LCD_WF61_BPFLCD61), BP_LCD_WF61_BPFLCD61, 1))
/*@}*/

/*!
 * @name Register LCD_WF61, field BPGLCD61[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF61_BPGLCD61 (6U)          /*!< Bit position for LCD_WF61_BPGLCD61. */
#define BM_LCD_WF61_BPGLCD61 (0x40U)       /*!< Bit mask for LCD_WF61_BPGLCD61. */
#define BS_LCD_WF61_BPGLCD61 (1U)          /*!< Bit field size in bits for LCD_WF61_BPGLCD61. */

/*! @brief Read current value of the LCD_WF61_BPGLCD61 field. */
#define BR_LCD_WF61_BPGLCD61(x) (BME_UBFX8(HW_LCD_WF61_ADDR(x), BP_LCD_WF61_BPGLCD61, BS_LCD_WF61_BPGLCD61))

/*! @brief Format value for bitfield LCD_WF61_BPGLCD61. */
#define BF_LCD_WF61_BPGLCD61(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF61_BPGLCD61) & BM_LCD_WF61_BPGLCD61)

/*! @brief Set the BPGLCD61 field to a new value. */
#define BW_LCD_WF61_BPGLCD61(x, v) (BME_BFI8(HW_LCD_WF61_ADDR(x), ((uint8_t)(v) << BP_LCD_WF61_BPGLCD61), BP_LCD_WF61_BPGLCD61, 1))
/*@}*/

/*!
 * @name Register LCD_WF61, field BPHLCD61[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF61_BPHLCD61 (7U)          /*!< Bit position for LCD_WF61_BPHLCD61. */
#define BM_LCD_WF61_BPHLCD61 (0x80U)       /*!< Bit mask for LCD_WF61_BPHLCD61. */
#define BS_LCD_WF61_BPHLCD61 (1U)          /*!< Bit field size in bits for LCD_WF61_BPHLCD61. */

/*! @brief Read current value of the LCD_WF61_BPHLCD61 field. */
#define BR_LCD_WF61_BPHLCD61(x) (BME_UBFX8(HW_LCD_WF61_ADDR(x), BP_LCD_WF61_BPHLCD61, BS_LCD_WF61_BPHLCD61))

/*! @brief Format value for bitfield LCD_WF61_BPHLCD61. */
#define BF_LCD_WF61_BPHLCD61(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF61_BPHLCD61) & BM_LCD_WF61_BPHLCD61)

/*! @brief Set the BPHLCD61 field to a new value. */
#define BW_LCD_WF61_BPHLCD61(x, v) (BME_BFI8(HW_LCD_WF61_ADDR(x), ((uint8_t)(v) << BP_LCD_WF61_BPHLCD61), BP_LCD_WF61_BPHLCD61, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF62 - LCD Waveform Register 62.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF62 - LCD Waveform Register 62. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf62
{
    uint8_t U;
    struct _hw_lcd_wf62_bitfields
    {
        uint8_t BPALCD62 : 1;          /*!< [0]  */
        uint8_t BPBLCD62 : 1;          /*!< [1]  */
        uint8_t BPCLCD62 : 1;          /*!< [2]  */
        uint8_t BPDLCD62 : 1;          /*!< [3]  */
        uint8_t BPELCD62 : 1;          /*!< [4]  */
        uint8_t BPFLCD62 : 1;          /*!< [5]  */
        uint8_t BPGLCD62 : 1;          /*!< [6]  */
        uint8_t BPHLCD62 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf62_t;

/*!
 * @name Constants and macros for entire LCD_WF62 register
 */
/*@{*/
#define HW_LCD_WF62_ADDR(x)      ((uint32_t)(x) + 0x5EU)

#define HW_LCD_WF62(x)           (*(__IO hw_lcd_wf62_t *) HW_LCD_WF62_ADDR(x))
#define HW_LCD_WF62_RD(x)        (HW_LCD_WF62(x).U)
#define HW_LCD_WF62_WR(x, v)     (HW_LCD_WF62(x).U = (v))
#define HW_LCD_WF62_SET(x, v)    (BME_OR8(HW_LCD_WF62_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF62_CLR(x, v)    (BME_AND8(HW_LCD_WF62_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF62_TOG(x, v)    (BME_XOR8(HW_LCD_WF62_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF62 bitfields
 */

/*!
 * @name Register LCD_WF62, field BPALCD62[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF62_BPALCD62 (0U)          /*!< Bit position for LCD_WF62_BPALCD62. */
#define BM_LCD_WF62_BPALCD62 (0x01U)       /*!< Bit mask for LCD_WF62_BPALCD62. */
#define BS_LCD_WF62_BPALCD62 (1U)          /*!< Bit field size in bits for LCD_WF62_BPALCD62. */

/*! @brief Read current value of the LCD_WF62_BPALCD62 field. */
#define BR_LCD_WF62_BPALCD62(x) (BME_UBFX8(HW_LCD_WF62_ADDR(x), BP_LCD_WF62_BPALCD62, BS_LCD_WF62_BPALCD62))

/*! @brief Format value for bitfield LCD_WF62_BPALCD62. */
#define BF_LCD_WF62_BPALCD62(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF62_BPALCD62) & BM_LCD_WF62_BPALCD62)

/*! @brief Set the BPALCD62 field to a new value. */
#define BW_LCD_WF62_BPALCD62(x, v) (BME_BFI8(HW_LCD_WF62_ADDR(x), ((uint8_t)(v) << BP_LCD_WF62_BPALCD62), BP_LCD_WF62_BPALCD62, 1))
/*@}*/

/*!
 * @name Register LCD_WF62, field BPBLCD62[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF62_BPBLCD62 (1U)          /*!< Bit position for LCD_WF62_BPBLCD62. */
#define BM_LCD_WF62_BPBLCD62 (0x02U)       /*!< Bit mask for LCD_WF62_BPBLCD62. */
#define BS_LCD_WF62_BPBLCD62 (1U)          /*!< Bit field size in bits for LCD_WF62_BPBLCD62. */

/*! @brief Read current value of the LCD_WF62_BPBLCD62 field. */
#define BR_LCD_WF62_BPBLCD62(x) (BME_UBFX8(HW_LCD_WF62_ADDR(x), BP_LCD_WF62_BPBLCD62, BS_LCD_WF62_BPBLCD62))

/*! @brief Format value for bitfield LCD_WF62_BPBLCD62. */
#define BF_LCD_WF62_BPBLCD62(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF62_BPBLCD62) & BM_LCD_WF62_BPBLCD62)

/*! @brief Set the BPBLCD62 field to a new value. */
#define BW_LCD_WF62_BPBLCD62(x, v) (BME_BFI8(HW_LCD_WF62_ADDR(x), ((uint8_t)(v) << BP_LCD_WF62_BPBLCD62), BP_LCD_WF62_BPBLCD62, 1))
/*@}*/

/*!
 * @name Register LCD_WF62, field BPCLCD62[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF62_BPCLCD62 (2U)          /*!< Bit position for LCD_WF62_BPCLCD62. */
#define BM_LCD_WF62_BPCLCD62 (0x04U)       /*!< Bit mask for LCD_WF62_BPCLCD62. */
#define BS_LCD_WF62_BPCLCD62 (1U)          /*!< Bit field size in bits for LCD_WF62_BPCLCD62. */

/*! @brief Read current value of the LCD_WF62_BPCLCD62 field. */
#define BR_LCD_WF62_BPCLCD62(x) (BME_UBFX8(HW_LCD_WF62_ADDR(x), BP_LCD_WF62_BPCLCD62, BS_LCD_WF62_BPCLCD62))

/*! @brief Format value for bitfield LCD_WF62_BPCLCD62. */
#define BF_LCD_WF62_BPCLCD62(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF62_BPCLCD62) & BM_LCD_WF62_BPCLCD62)

/*! @brief Set the BPCLCD62 field to a new value. */
#define BW_LCD_WF62_BPCLCD62(x, v) (BME_BFI8(HW_LCD_WF62_ADDR(x), ((uint8_t)(v) << BP_LCD_WF62_BPCLCD62), BP_LCD_WF62_BPCLCD62, 1))
/*@}*/

/*!
 * @name Register LCD_WF62, field BPDLCD62[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF62_BPDLCD62 (3U)          /*!< Bit position for LCD_WF62_BPDLCD62. */
#define BM_LCD_WF62_BPDLCD62 (0x08U)       /*!< Bit mask for LCD_WF62_BPDLCD62. */
#define BS_LCD_WF62_BPDLCD62 (1U)          /*!< Bit field size in bits for LCD_WF62_BPDLCD62. */

/*! @brief Read current value of the LCD_WF62_BPDLCD62 field. */
#define BR_LCD_WF62_BPDLCD62(x) (BME_UBFX8(HW_LCD_WF62_ADDR(x), BP_LCD_WF62_BPDLCD62, BS_LCD_WF62_BPDLCD62))

/*! @brief Format value for bitfield LCD_WF62_BPDLCD62. */
#define BF_LCD_WF62_BPDLCD62(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF62_BPDLCD62) & BM_LCD_WF62_BPDLCD62)

/*! @brief Set the BPDLCD62 field to a new value. */
#define BW_LCD_WF62_BPDLCD62(x, v) (BME_BFI8(HW_LCD_WF62_ADDR(x), ((uint8_t)(v) << BP_LCD_WF62_BPDLCD62), BP_LCD_WF62_BPDLCD62, 1))
/*@}*/

/*!
 * @name Register LCD_WF62, field BPELCD62[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF62_BPELCD62 (4U)          /*!< Bit position for LCD_WF62_BPELCD62. */
#define BM_LCD_WF62_BPELCD62 (0x10U)       /*!< Bit mask for LCD_WF62_BPELCD62. */
#define BS_LCD_WF62_BPELCD62 (1U)          /*!< Bit field size in bits for LCD_WF62_BPELCD62. */

/*! @brief Read current value of the LCD_WF62_BPELCD62 field. */
#define BR_LCD_WF62_BPELCD62(x) (BME_UBFX8(HW_LCD_WF62_ADDR(x), BP_LCD_WF62_BPELCD62, BS_LCD_WF62_BPELCD62))

/*! @brief Format value for bitfield LCD_WF62_BPELCD62. */
#define BF_LCD_WF62_BPELCD62(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF62_BPELCD62) & BM_LCD_WF62_BPELCD62)

/*! @brief Set the BPELCD62 field to a new value. */
#define BW_LCD_WF62_BPELCD62(x, v) (BME_BFI8(HW_LCD_WF62_ADDR(x), ((uint8_t)(v) << BP_LCD_WF62_BPELCD62), BP_LCD_WF62_BPELCD62, 1))
/*@}*/

/*!
 * @name Register LCD_WF62, field BPFLCD62[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF62_BPFLCD62 (5U)          /*!< Bit position for LCD_WF62_BPFLCD62. */
#define BM_LCD_WF62_BPFLCD62 (0x20U)       /*!< Bit mask for LCD_WF62_BPFLCD62. */
#define BS_LCD_WF62_BPFLCD62 (1U)          /*!< Bit field size in bits for LCD_WF62_BPFLCD62. */

/*! @brief Read current value of the LCD_WF62_BPFLCD62 field. */
#define BR_LCD_WF62_BPFLCD62(x) (BME_UBFX8(HW_LCD_WF62_ADDR(x), BP_LCD_WF62_BPFLCD62, BS_LCD_WF62_BPFLCD62))

/*! @brief Format value for bitfield LCD_WF62_BPFLCD62. */
#define BF_LCD_WF62_BPFLCD62(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF62_BPFLCD62) & BM_LCD_WF62_BPFLCD62)

/*! @brief Set the BPFLCD62 field to a new value. */
#define BW_LCD_WF62_BPFLCD62(x, v) (BME_BFI8(HW_LCD_WF62_ADDR(x), ((uint8_t)(v) << BP_LCD_WF62_BPFLCD62), BP_LCD_WF62_BPFLCD62, 1))
/*@}*/

/*!
 * @name Register LCD_WF62, field BPGLCD62[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF62_BPGLCD62 (6U)          /*!< Bit position for LCD_WF62_BPGLCD62. */
#define BM_LCD_WF62_BPGLCD62 (0x40U)       /*!< Bit mask for LCD_WF62_BPGLCD62. */
#define BS_LCD_WF62_BPGLCD62 (1U)          /*!< Bit field size in bits for LCD_WF62_BPGLCD62. */

/*! @brief Read current value of the LCD_WF62_BPGLCD62 field. */
#define BR_LCD_WF62_BPGLCD62(x) (BME_UBFX8(HW_LCD_WF62_ADDR(x), BP_LCD_WF62_BPGLCD62, BS_LCD_WF62_BPGLCD62))

/*! @brief Format value for bitfield LCD_WF62_BPGLCD62. */
#define BF_LCD_WF62_BPGLCD62(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF62_BPGLCD62) & BM_LCD_WF62_BPGLCD62)

/*! @brief Set the BPGLCD62 field to a new value. */
#define BW_LCD_WF62_BPGLCD62(x, v) (BME_BFI8(HW_LCD_WF62_ADDR(x), ((uint8_t)(v) << BP_LCD_WF62_BPGLCD62), BP_LCD_WF62_BPGLCD62, 1))
/*@}*/

/*!
 * @name Register LCD_WF62, field BPHLCD62[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF62_BPHLCD62 (7U)          /*!< Bit position for LCD_WF62_BPHLCD62. */
#define BM_LCD_WF62_BPHLCD62 (0x80U)       /*!< Bit mask for LCD_WF62_BPHLCD62. */
#define BS_LCD_WF62_BPHLCD62 (1U)          /*!< Bit field size in bits for LCD_WF62_BPHLCD62. */

/*! @brief Read current value of the LCD_WF62_BPHLCD62 field. */
#define BR_LCD_WF62_BPHLCD62(x) (BME_UBFX8(HW_LCD_WF62_ADDR(x), BP_LCD_WF62_BPHLCD62, BS_LCD_WF62_BPHLCD62))

/*! @brief Format value for bitfield LCD_WF62_BPHLCD62. */
#define BF_LCD_WF62_BPHLCD62(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF62_BPHLCD62) & BM_LCD_WF62_BPHLCD62)

/*! @brief Set the BPHLCD62 field to a new value. */
#define BW_LCD_WF62_BPHLCD62(x, v) (BME_BFI8(HW_LCD_WF62_ADDR(x), ((uint8_t)(v) << BP_LCD_WF62_BPHLCD62), BP_LCD_WF62_BPHLCD62, 1))
/*@}*/
/*******************************************************************************
 * HW_LCD_WF63 - LCD Waveform Register 63.
 ******************************************************************************/

/*!
 * @brief HW_LCD_WF63 - LCD Waveform Register 63. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_lcd_wf63
{
    uint8_t U;
    struct _hw_lcd_wf63_bitfields
    {
        uint8_t BPALCD63 : 1;          /*!< [0]  */
        uint8_t BPBLCD63 : 1;          /*!< [1]  */
        uint8_t BPCLCD63 : 1;          /*!< [2]  */
        uint8_t BPDLCD63 : 1;          /*!< [3]  */
        uint8_t BPELCD63 : 1;          /*!< [4]  */
        uint8_t BPFLCD63 : 1;          /*!< [5]  */
        uint8_t BPGLCD63 : 1;          /*!< [6]  */
        uint8_t BPHLCD63 : 1;          /*!< [7]  */
    } B;
} hw_lcd_wf63_t;

/*!
 * @name Constants and macros for entire LCD_WF63 register
 */
/*@{*/
#define HW_LCD_WF63_ADDR(x)      ((uint32_t)(x) + 0x5FU)

#define HW_LCD_WF63(x)           (*(__IO hw_lcd_wf63_t *) HW_LCD_WF63_ADDR(x))
#define HW_LCD_WF63_RD(x)        (HW_LCD_WF63(x).U)
#define HW_LCD_WF63_WR(x, v)     (HW_LCD_WF63(x).U = (v))
#define HW_LCD_WF63_SET(x, v)    (BME_OR8(HW_LCD_WF63_ADDR(x), (uint8_t)(v)))
#define HW_LCD_WF63_CLR(x, v)    (BME_AND8(HW_LCD_WF63_ADDR(x), (uint8_t)(~(v))))
#define HW_LCD_WF63_TOG(x, v)    (BME_XOR8(HW_LCD_WF63_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF63 bitfields
 */

/*!
 * @name Register LCD_WF63, field BPALCD63[0] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase A
 * - 1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
#define BP_LCD_WF63_BPALCD63 (0U)          /*!< Bit position for LCD_WF63_BPALCD63. */
#define BM_LCD_WF63_BPALCD63 (0x01U)       /*!< Bit mask for LCD_WF63_BPALCD63. */
#define BS_LCD_WF63_BPALCD63 (1U)          /*!< Bit field size in bits for LCD_WF63_BPALCD63. */

/*! @brief Read current value of the LCD_WF63_BPALCD63 field. */
#define BR_LCD_WF63_BPALCD63(x) (BME_UBFX8(HW_LCD_WF63_ADDR(x), BP_LCD_WF63_BPALCD63, BS_LCD_WF63_BPALCD63))

/*! @brief Format value for bitfield LCD_WF63_BPALCD63. */
#define BF_LCD_WF63_BPALCD63(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF63_BPALCD63) & BM_LCD_WF63_BPALCD63)

/*! @brief Set the BPALCD63 field to a new value. */
#define BW_LCD_WF63_BPALCD63(x, v) (BME_BFI8(HW_LCD_WF63_ADDR(x), ((uint8_t)(v) << BP_LCD_WF63_BPALCD63), BP_LCD_WF63_BPALCD63, 1))
/*@}*/

/*!
 * @name Register LCD_WF63, field BPBLCD63[1] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase B
 * - 1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
#define BP_LCD_WF63_BPBLCD63 (1U)          /*!< Bit position for LCD_WF63_BPBLCD63. */
#define BM_LCD_WF63_BPBLCD63 (0x02U)       /*!< Bit mask for LCD_WF63_BPBLCD63. */
#define BS_LCD_WF63_BPBLCD63 (1U)          /*!< Bit field size in bits for LCD_WF63_BPBLCD63. */

/*! @brief Read current value of the LCD_WF63_BPBLCD63 field. */
#define BR_LCD_WF63_BPBLCD63(x) (BME_UBFX8(HW_LCD_WF63_ADDR(x), BP_LCD_WF63_BPBLCD63, BS_LCD_WF63_BPBLCD63))

/*! @brief Format value for bitfield LCD_WF63_BPBLCD63. */
#define BF_LCD_WF63_BPBLCD63(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF63_BPBLCD63) & BM_LCD_WF63_BPBLCD63)

/*! @brief Set the BPBLCD63 field to a new value. */
#define BW_LCD_WF63_BPBLCD63(x, v) (BME_BFI8(HW_LCD_WF63_ADDR(x), ((uint8_t)(v) << BP_LCD_WF63_BPBLCD63), BP_LCD_WF63_BPBLCD63, 1))
/*@}*/

/*!
 * @name Register LCD_WF63, field BPCLCD63[2] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase C
 * - 1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
#define BP_LCD_WF63_BPCLCD63 (2U)          /*!< Bit position for LCD_WF63_BPCLCD63. */
#define BM_LCD_WF63_BPCLCD63 (0x04U)       /*!< Bit mask for LCD_WF63_BPCLCD63. */
#define BS_LCD_WF63_BPCLCD63 (1U)          /*!< Bit field size in bits for LCD_WF63_BPCLCD63. */

/*! @brief Read current value of the LCD_WF63_BPCLCD63 field. */
#define BR_LCD_WF63_BPCLCD63(x) (BME_UBFX8(HW_LCD_WF63_ADDR(x), BP_LCD_WF63_BPCLCD63, BS_LCD_WF63_BPCLCD63))

/*! @brief Format value for bitfield LCD_WF63_BPCLCD63. */
#define BF_LCD_WF63_BPCLCD63(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF63_BPCLCD63) & BM_LCD_WF63_BPCLCD63)

/*! @brief Set the BPCLCD63 field to a new value. */
#define BW_LCD_WF63_BPCLCD63(x, v) (BME_BFI8(HW_LCD_WF63_ADDR(x), ((uint8_t)(v) << BP_LCD_WF63_BPCLCD63), BP_LCD_WF63_BPCLCD63, 1))
/*@}*/

/*!
 * @name Register LCD_WF63, field BPDLCD63[3] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase D
 * - 1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
#define BP_LCD_WF63_BPDLCD63 (3U)          /*!< Bit position for LCD_WF63_BPDLCD63. */
#define BM_LCD_WF63_BPDLCD63 (0x08U)       /*!< Bit mask for LCD_WF63_BPDLCD63. */
#define BS_LCD_WF63_BPDLCD63 (1U)          /*!< Bit field size in bits for LCD_WF63_BPDLCD63. */

/*! @brief Read current value of the LCD_WF63_BPDLCD63 field. */
#define BR_LCD_WF63_BPDLCD63(x) (BME_UBFX8(HW_LCD_WF63_ADDR(x), BP_LCD_WF63_BPDLCD63, BS_LCD_WF63_BPDLCD63))

/*! @brief Format value for bitfield LCD_WF63_BPDLCD63. */
#define BF_LCD_WF63_BPDLCD63(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF63_BPDLCD63) & BM_LCD_WF63_BPDLCD63)

/*! @brief Set the BPDLCD63 field to a new value. */
#define BW_LCD_WF63_BPDLCD63(x, v) (BME_BFI8(HW_LCD_WF63_ADDR(x), ((uint8_t)(v) << BP_LCD_WF63_BPDLCD63), BP_LCD_WF63_BPDLCD63, 1))
/*@}*/

/*!
 * @name Register LCD_WF63, field BPELCD63[4] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase E
 * - 1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
#define BP_LCD_WF63_BPELCD63 (4U)          /*!< Bit position for LCD_WF63_BPELCD63. */
#define BM_LCD_WF63_BPELCD63 (0x10U)       /*!< Bit mask for LCD_WF63_BPELCD63. */
#define BS_LCD_WF63_BPELCD63 (1U)          /*!< Bit field size in bits for LCD_WF63_BPELCD63. */

/*! @brief Read current value of the LCD_WF63_BPELCD63 field. */
#define BR_LCD_WF63_BPELCD63(x) (BME_UBFX8(HW_LCD_WF63_ADDR(x), BP_LCD_WF63_BPELCD63, BS_LCD_WF63_BPELCD63))

/*! @brief Format value for bitfield LCD_WF63_BPELCD63. */
#define BF_LCD_WF63_BPELCD63(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF63_BPELCD63) & BM_LCD_WF63_BPELCD63)

/*! @brief Set the BPELCD63 field to a new value. */
#define BW_LCD_WF63_BPELCD63(x, v) (BME_BFI8(HW_LCD_WF63_ADDR(x), ((uint8_t)(v) << BP_LCD_WF63_BPELCD63), BP_LCD_WF63_BPELCD63, 1))
/*@}*/

/*!
 * @name Register LCD_WF63, field BPFLCD63[5] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase F
 * - 1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
#define BP_LCD_WF63_BPFLCD63 (5U)          /*!< Bit position for LCD_WF63_BPFLCD63. */
#define BM_LCD_WF63_BPFLCD63 (0x20U)       /*!< Bit mask for LCD_WF63_BPFLCD63. */
#define BS_LCD_WF63_BPFLCD63 (1U)          /*!< Bit field size in bits for LCD_WF63_BPFLCD63. */

/*! @brief Read current value of the LCD_WF63_BPFLCD63 field. */
#define BR_LCD_WF63_BPFLCD63(x) (BME_UBFX8(HW_LCD_WF63_ADDR(x), BP_LCD_WF63_BPFLCD63, BS_LCD_WF63_BPFLCD63))

/*! @brief Format value for bitfield LCD_WF63_BPFLCD63. */
#define BF_LCD_WF63_BPFLCD63(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF63_BPFLCD63) & BM_LCD_WF63_BPFLCD63)

/*! @brief Set the BPFLCD63 field to a new value. */
#define BW_LCD_WF63_BPFLCD63(x, v) (BME_BFI8(HW_LCD_WF63_ADDR(x), ((uint8_t)(v) << BP_LCD_WF63_BPFLCD63), BP_LCD_WF63_BPFLCD63, 1))
/*@}*/

/*!
 * @name Register LCD_WF63, field BPGLCD63[6] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase G
 * - 1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
#define BP_LCD_WF63_BPGLCD63 (6U)          /*!< Bit position for LCD_WF63_BPGLCD63. */
#define BM_LCD_WF63_BPGLCD63 (0x40U)       /*!< Bit mask for LCD_WF63_BPGLCD63. */
#define BS_LCD_WF63_BPGLCD63 (1U)          /*!< Bit field size in bits for LCD_WF63_BPGLCD63. */

/*! @brief Read current value of the LCD_WF63_BPGLCD63 field. */
#define BR_LCD_WF63_BPGLCD63(x) (BME_UBFX8(HW_LCD_WF63_ADDR(x), BP_LCD_WF63_BPGLCD63, BS_LCD_WF63_BPGLCD63))

/*! @brief Format value for bitfield LCD_WF63_BPGLCD63. */
#define BF_LCD_WF63_BPGLCD63(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF63_BPGLCD63) & BM_LCD_WF63_BPGLCD63)

/*! @brief Set the BPGLCD63 field to a new value. */
#define BW_LCD_WF63_BPGLCD63(x, v) (BME_BFI8(HW_LCD_WF63_ADDR(x), ((uint8_t)(v) << BP_LCD_WF63_BPGLCD63), BP_LCD_WF63_BPGLCD63, 1))
/*@}*/

/*!
 * @name Register LCD_WF63, field BPHLCD63[7] (RW)
 *
 * Values:
 * - 0 - LCD segment off or LCD backplane inactive for phase H
 * - 1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
#define BP_LCD_WF63_BPHLCD63 (7U)          /*!< Bit position for LCD_WF63_BPHLCD63. */
#define BM_LCD_WF63_BPHLCD63 (0x80U)       /*!< Bit mask for LCD_WF63_BPHLCD63. */
#define BS_LCD_WF63_BPHLCD63 (1U)          /*!< Bit field size in bits for LCD_WF63_BPHLCD63. */

/*! @brief Read current value of the LCD_WF63_BPHLCD63 field. */
#define BR_LCD_WF63_BPHLCD63(x) (BME_UBFX8(HW_LCD_WF63_ADDR(x), BP_LCD_WF63_BPHLCD63, BS_LCD_WF63_BPHLCD63))

/*! @brief Format value for bitfield LCD_WF63_BPHLCD63. */
#define BF_LCD_WF63_BPHLCD63(v) ((uint8_t)((uint8_t)(v) << BP_LCD_WF63_BPHLCD63) & BM_LCD_WF63_BPHLCD63)

/*! @brief Set the BPHLCD63 field to a new value. */
#define BW_LCD_WF63_BPHLCD63(x, v) (BME_BFI8(HW_LCD_WF63_ADDR(x), ((uint8_t)(v) << BP_LCD_WF63_BPHLCD63), BP_LCD_WF63_BPHLCD63, 1))
/*@}*/

/*
** Start of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma push
  #pragma anon_unions
#elif defined(__CWCC__)
  #pragma push
  #pragma cpp_extensions on
#elif defined(__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=extended
#else
  #error Not supported compiler type
#endif

/*******************************************************************************
 * hw_lcd_t - module struct
 ******************************************************************************/
/*!
 * @brief All LCD module registers.
 */
#pragma pack(1)
typedef struct _hw_lcd
{
    __IO hw_lcd_gcr_t GCR;                 /*!< [0x0] LCD General Control Register */
    __IO hw_lcd_ar_t AR;                   /*!< [0x4] LCD Auxiliary Register */
    __IO hw_lcd_fdcr_t FDCR;               /*!< [0x8] LCD Fault Detect Control Register */
    __IO hw_lcd_fdsr_t FDSR;               /*!< [0xC] LCD Fault Detect Status Register */
    __IO hw_lcd_penl_t PENL;               /*!< [0x10] LCD Pin Enable register */
    __IO hw_lcd_penh_t PENH;               /*!< [0x14] LCD Pin Enable register */
    __IO hw_lcd_bpenl_t BPENL;             /*!< [0x18] LCD Back Plane Enable register */
    __IO hw_lcd_bpenh_t BPENH;             /*!< [0x1C] LCD Back Plane Enable register */
    union {
        struct {
            __IO hw_lcd_wf3to0_t WF3TO0;   /*!< [0x20] LCD Waveform register */
            __IO hw_lcd_wf7to4_t WF7TO4;   /*!< [0x24] LCD Waveform register */
            __IO hw_lcd_wf11to8_t WF11TO8; /*!< [0x28] LCD Waveform register */
            __IO hw_lcd_wf15to12_t WF15TO12; /*!< [0x2C] LCD Waveform register */
            __IO hw_lcd_wf19to16_t WF19TO16; /*!< [0x30] LCD Waveform register */
            __IO hw_lcd_wf23to20_t WF23TO20; /*!< [0x34] LCD Waveform register */
            __IO hw_lcd_wf27to24_t WF27TO24; /*!< [0x38] LCD Waveform register */
            __IO hw_lcd_wf31to28_t WF31TO28; /*!< [0x3C] LCD Waveform register */
            __IO hw_lcd_wf35to32_t WF35TO32; /*!< [0x40] LCD Waveform register */
            __IO hw_lcd_wf39to36_t WF39TO36; /*!< [0x44] LCD Waveform register */
            __IO hw_lcd_wf43to40_t WF43TO40; /*!< [0x48] LCD Waveform register */
            __IO hw_lcd_wf47to44_t WF47TO44; /*!< [0x4C] LCD Waveform register */
            __IO hw_lcd_wf51to48_t WF51TO48; /*!< [0x50] LCD Waveform register */
            __IO hw_lcd_wf55to52_t WF55TO52; /*!< [0x54] LCD Waveform register */
            __IO hw_lcd_wf59to56_t WF59TO56; /*!< [0x58] LCD Waveform register */
            __IO hw_lcd_wf63to60_t WF63TO60; /*!< [0x5C] LCD Waveform register */
        } WFACCESS32BIT;
        struct {
            __IO hw_lcd_wf0_t WF0;         /*!< [0x20] LCD Waveform Register 0. */
            __IO hw_lcd_wf1_t WF1;         /*!< [0x21] LCD Waveform Register 1. */
            __IO hw_lcd_wf2_t WF2;         /*!< [0x22] LCD Waveform Register 2. */
            __IO hw_lcd_wf3_t WF3;         /*!< [0x23] LCD Waveform Register 3. */
            __IO hw_lcd_wf4_t WF4;         /*!< [0x24] LCD Waveform Register 4. */
            __IO hw_lcd_wf5_t WF5;         /*!< [0x25] LCD Waveform Register 5. */
            __IO hw_lcd_wf6_t WF6;         /*!< [0x26] LCD Waveform Register 6. */
            __IO hw_lcd_wf7_t WF7;         /*!< [0x27] LCD Waveform Register 7. */
            __IO hw_lcd_wf8_t WF8;         /*!< [0x28] LCD Waveform Register 8. */
            __IO hw_lcd_wf9_t WF9;         /*!< [0x29] LCD Waveform Register 9. */
            __IO hw_lcd_wf10_t WF10;       /*!< [0x2A] LCD Waveform Register 10. */
            __IO hw_lcd_wf11_t WF11;       /*!< [0x2B] LCD Waveform Register 11. */
            __IO hw_lcd_wf12_t WF12;       /*!< [0x2C] LCD Waveform Register 12. */
            __IO hw_lcd_wf13_t WF13;       /*!< [0x2D] LCD Waveform Register 13. */
            __IO hw_lcd_wf14_t WF14;       /*!< [0x2E] LCD Waveform Register 14. */
            __IO hw_lcd_wf15_t WF15;       /*!< [0x2F] LCD Waveform Register 15. */
            __IO hw_lcd_wf16_t WF16;       /*!< [0x30] LCD Waveform Register 16. */
            __IO hw_lcd_wf17_t WF17;       /*!< [0x31] LCD Waveform Register 17. */
            __IO hw_lcd_wf18_t WF18;       /*!< [0x32] LCD Waveform Register 18. */
            __IO hw_lcd_wf19_t WF19;       /*!< [0x33] LCD Waveform Register 19. */
            __IO hw_lcd_wf20_t WF20;       /*!< [0x34] LCD Waveform Register 20. */
            __IO hw_lcd_wf21_t WF21;       /*!< [0x35] LCD Waveform Register 21. */
            __IO hw_lcd_wf22_t WF22;       /*!< [0x36] LCD Waveform Register 22. */
            __IO hw_lcd_wf23_t WF23;       /*!< [0x37] LCD Waveform Register 23. */
            __IO hw_lcd_wf24_t WF24;       /*!< [0x38] LCD Waveform Register 24. */
            __IO hw_lcd_wf25_t WF25;       /*!< [0x39] LCD Waveform Register 25. */
            __IO hw_lcd_wf26_t WF26;       /*!< [0x3A] LCD Waveform Register 26. */
            __IO hw_lcd_wf27_t WF27;       /*!< [0x3B] LCD Waveform Register 27. */
            __IO hw_lcd_wf28_t WF28;       /*!< [0x3C] LCD Waveform Register 28. */
            __IO hw_lcd_wf29_t WF29;       /*!< [0x3D] LCD Waveform Register 29. */
            __IO hw_lcd_wf30_t WF30;       /*!< [0x3E] LCD Waveform Register 30. */
            __IO hw_lcd_wf31_t WF31;       /*!< [0x3F] LCD Waveform Register 31. */
            __IO hw_lcd_wf32_t WF32;       /*!< [0x40] LCD Waveform Register 32. */
            __IO hw_lcd_wf33_t WF33;       /*!< [0x41] LCD Waveform Register 33. */
            __IO hw_lcd_wf34_t WF34;       /*!< [0x42] LCD Waveform Register 34. */
            __IO hw_lcd_wf35_t WF35;       /*!< [0x43] LCD Waveform Register 35. */
            __IO hw_lcd_wf36_t WF36;       /*!< [0x44] LCD Waveform Register 36. */
            __IO hw_lcd_wf37_t WF37;       /*!< [0x45] LCD Waveform Register 37. */
            __IO hw_lcd_wf38_t WF38;       /*!< [0x46] LCD Waveform Register 38. */
            __IO hw_lcd_wf39_t WF39;       /*!< [0x47] LCD Waveform Register 39. */
            __IO hw_lcd_wf40_t WF40;       /*!< [0x48] LCD Waveform Register 40. */
            __IO hw_lcd_wf41_t WF41;       /*!< [0x49] LCD Waveform Register 41. */
            __IO hw_lcd_wf42_t WF42;       /*!< [0x4A] LCD Waveform Register 42. */
            __IO hw_lcd_wf43_t WF43;       /*!< [0x4B] LCD Waveform Register 43. */
            __IO hw_lcd_wf44_t WF44;       /*!< [0x4C] LCD Waveform Register 44. */
            __IO hw_lcd_wf45_t WF45;       /*!< [0x4D] LCD Waveform Register 45. */
            __IO hw_lcd_wf46_t WF46;       /*!< [0x4E] LCD Waveform Register 46. */
            __IO hw_lcd_wf47_t WF47;       /*!< [0x4F] LCD Waveform Register 47. */
            __IO hw_lcd_wf48_t WF48;       /*!< [0x50] LCD Waveform Register 48. */
            __IO hw_lcd_wf49_t WF49;       /*!< [0x51] LCD Waveform Register 49. */
            __IO hw_lcd_wf50_t WF50;       /*!< [0x52] LCD Waveform Register 50. */
            __IO hw_lcd_wf51_t WF51;       /*!< [0x53] LCD Waveform Register 51. */
            __IO hw_lcd_wf52_t WF52;       /*!< [0x54] LCD Waveform Register 52. */
            __IO hw_lcd_wf53_t WF53;       /*!< [0x55] LCD Waveform Register 53. */
            __IO hw_lcd_wf54_t WF54;       /*!< [0x56] LCD Waveform Register 54. */
            __IO hw_lcd_wf55_t WF55;       /*!< [0x57] LCD Waveform Register 55. */
            __IO hw_lcd_wf56_t WF56;       /*!< [0x58] LCD Waveform Register 56. */
            __IO hw_lcd_wf57_t WF57;       /*!< [0x59] LCD Waveform Register 57. */
            __IO hw_lcd_wf58_t WF58;       /*!< [0x5A] LCD Waveform Register 58. */
            __IO hw_lcd_wf59_t WF59;       /*!< [0x5B] LCD Waveform Register 59. */
            __IO hw_lcd_wf60_t WF60;       /*!< [0x5C] LCD Waveform Register 60. */
            __IO hw_lcd_wf61_t WF61;       /*!< [0x5D] LCD Waveform Register 61. */
            __IO hw_lcd_wf62_t WF62;       /*!< [0x5E] LCD Waveform Register 62. */
            __IO hw_lcd_wf63_t WF63;       /*!< [0x5F] LCD Waveform Register 63. */
        } WFACCESS8BIT;
    };
} hw_lcd_t;
#pragma pack()

/*! @brief Macro to access all LCD registers. */
/*! @param x LCD module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_LCD_REGS(LCD_BASE)</code>. */
#define HW_LCD_REGS(x) (*(hw_lcd_t *)(x))

/*
** End of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma pop
#elif defined(__CWCC__)
  #pragma pop
#elif defined(__GNUC__)
  /* leave anonymous unions enabled */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=default
#else
  #error Not supported compiler type
#endif

/*
 * MKL43Z4 LLWU
 *
 * Low leakage wakeup unit
 *
 * Registers defined in this header file:
 * - HW_LLWU_PE1 - LLWU Pin Enable 1 register
 * - HW_LLWU_PE2 - LLWU Pin Enable 2 register
 * - HW_LLWU_PE3 - LLWU Pin Enable 3 register
 * - HW_LLWU_PE4 - LLWU Pin Enable 4 register
 * - HW_LLWU_ME - LLWU Module Enable register
 * - HW_LLWU_F1 - LLWU Flag 1 register
 * - HW_LLWU_F2 - LLWU Flag 2 register
 * - HW_LLWU_F3 - LLWU Flag 3 register
 * - HW_LLWU_FILT1 - LLWU Pin Filter 1 register
 * - HW_LLWU_FILT2 - LLWU Pin Filter 2 register
 *
 * - hw_llwu_t - Struct containing all module registers.
 */

#define HW_LLWU_INSTANCE_COUNT (1U) /*!< Number of instances of the LLWU module. */
#define HW_LLWU (0U) /*!< Instance number for LLWU. */

/*******************************************************************************
 * HW_LLWU_PE1 - LLWU Pin Enable 1 register
 ******************************************************************************/

/*!
 * @brief HW_LLWU_PE1 - LLWU Pin Enable 1 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE1 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P3-LLWU_P0. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
typedef union _hw_llwu_pe1
{
    uint8_t U;
    struct _hw_llwu_pe1_bitfields
    {
        uint8_t WUPE0 : 2;             /*!< [1:0] Wakeup Pin Enable For LLWU_P0 */
        uint8_t WUPE1 : 2;             /*!< [3:2] Wakeup Pin Enable For LLWU_P1 */
        uint8_t WUPE2 : 2;             /*!< [5:4] Wakeup Pin Enable For LLWU_P2 */
        uint8_t WUPE3 : 2;             /*!< [7:6] Wakeup Pin Enable For LLWU_P3 */
    } B;
} hw_llwu_pe1_t;

/*!
 * @name Constants and macros for entire LLWU_PE1 register
 */
/*@{*/
#define HW_LLWU_PE1_ADDR(x)      ((uint32_t)(x) + 0x0U)

#define HW_LLWU_PE1(x)           (*(__IO hw_llwu_pe1_t *) HW_LLWU_PE1_ADDR(x))
#define HW_LLWU_PE1_RD(x)        (HW_LLWU_PE1(x).U)
#define HW_LLWU_PE1_WR(x, v)     (HW_LLWU_PE1(x).U = (v))
#define HW_LLWU_PE1_SET(x, v)    (BME_OR8(HW_LLWU_PE1_ADDR(x), (uint8_t)(v)))
#define HW_LLWU_PE1_CLR(x, v)    (BME_AND8(HW_LLWU_PE1_ADDR(x), (uint8_t)(~(v))))
#define HW_LLWU_PE1_TOG(x, v)    (BME_XOR8(HW_LLWU_PE1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE1 bitfields
 */

/*!
 * @name Register LLWU_PE1, field WUPE0[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE1_WUPE0    (0U)          /*!< Bit position for LLWU_PE1_WUPE0. */
#define BM_LLWU_PE1_WUPE0    (0x03U)       /*!< Bit mask for LLWU_PE1_WUPE0. */
#define BS_LLWU_PE1_WUPE0    (2U)          /*!< Bit field size in bits for LLWU_PE1_WUPE0. */

/*! @brief Read current value of the LLWU_PE1_WUPE0 field. */
#define BR_LLWU_PE1_WUPE0(x) (BME_UBFX8(HW_LLWU_PE1_ADDR(x), BP_LLWU_PE1_WUPE0, BS_LLWU_PE1_WUPE0))

/*! @brief Format value for bitfield LLWU_PE1_WUPE0. */
#define BF_LLWU_PE1_WUPE0(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE1_WUPE0) & BM_LLWU_PE1_WUPE0)

/*! @brief Set the WUPE0 field to a new value. */
#define BW_LLWU_PE1_WUPE0(x, v) (BME_BFI8(HW_LLWU_PE1_ADDR(x), ((uint8_t)(v) << BP_LLWU_PE1_WUPE0), BP_LLWU_PE1_WUPE0, 2))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE1[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE1_WUPE1    (2U)          /*!< Bit position for LLWU_PE1_WUPE1. */
#define BM_LLWU_PE1_WUPE1    (0x0CU)       /*!< Bit mask for LLWU_PE1_WUPE1. */
#define BS_LLWU_PE1_WUPE1    (2U)          /*!< Bit field size in bits for LLWU_PE1_WUPE1. */

/*! @brief Read current value of the LLWU_PE1_WUPE1 field. */
#define BR_LLWU_PE1_WUPE1(x) (BME_UBFX8(HW_LLWU_PE1_ADDR(x), BP_LLWU_PE1_WUPE1, BS_LLWU_PE1_WUPE1))

/*! @brief Format value for bitfield LLWU_PE1_WUPE1. */
#define BF_LLWU_PE1_WUPE1(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE1_WUPE1) & BM_LLWU_PE1_WUPE1)

/*! @brief Set the WUPE1 field to a new value. */
#define BW_LLWU_PE1_WUPE1(x, v) (BME_BFI8(HW_LLWU_PE1_ADDR(x), ((uint8_t)(v) << BP_LLWU_PE1_WUPE1), BP_LLWU_PE1_WUPE1, 2))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE2[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE1_WUPE2    (4U)          /*!< Bit position for LLWU_PE1_WUPE2. */
#define BM_LLWU_PE1_WUPE2    (0x30U)       /*!< Bit mask for LLWU_PE1_WUPE2. */
#define BS_LLWU_PE1_WUPE2    (2U)          /*!< Bit field size in bits for LLWU_PE1_WUPE2. */

/*! @brief Read current value of the LLWU_PE1_WUPE2 field. */
#define BR_LLWU_PE1_WUPE2(x) (BME_UBFX8(HW_LLWU_PE1_ADDR(x), BP_LLWU_PE1_WUPE2, BS_LLWU_PE1_WUPE2))

/*! @brief Format value for bitfield LLWU_PE1_WUPE2. */
#define BF_LLWU_PE1_WUPE2(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE1_WUPE2) & BM_LLWU_PE1_WUPE2)

/*! @brief Set the WUPE2 field to a new value. */
#define BW_LLWU_PE1_WUPE2(x, v) (BME_BFI8(HW_LLWU_PE1_ADDR(x), ((uint8_t)(v) << BP_LLWU_PE1_WUPE2), BP_LLWU_PE1_WUPE2, 2))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE3[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE1_WUPE3    (6U)          /*!< Bit position for LLWU_PE1_WUPE3. */
#define BM_LLWU_PE1_WUPE3    (0xC0U)       /*!< Bit mask for LLWU_PE1_WUPE3. */
#define BS_LLWU_PE1_WUPE3    (2U)          /*!< Bit field size in bits for LLWU_PE1_WUPE3. */

/*! @brief Read current value of the LLWU_PE1_WUPE3 field. */
#define BR_LLWU_PE1_WUPE3(x) (BME_UBFX8(HW_LLWU_PE1_ADDR(x), BP_LLWU_PE1_WUPE3, BS_LLWU_PE1_WUPE3))

/*! @brief Format value for bitfield LLWU_PE1_WUPE3. */
#define BF_LLWU_PE1_WUPE3(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE1_WUPE3) & BM_LLWU_PE1_WUPE3)

/*! @brief Set the WUPE3 field to a new value. */
#define BW_LLWU_PE1_WUPE3(x, v) (BME_BFI8(HW_LLWU_PE1_ADDR(x), ((uint8_t)(v) << BP_LLWU_PE1_WUPE3), BP_LLWU_PE1_WUPE3, 2))
/*@}*/

/*******************************************************************************
 * HW_LLWU_PE2 - LLWU Pin Enable 2 register
 ******************************************************************************/

/*!
 * @brief HW_LLWU_PE2 - LLWU Pin Enable 2 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE2 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P7-LLWU_P4. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
typedef union _hw_llwu_pe2
{
    uint8_t U;
    struct _hw_llwu_pe2_bitfields
    {
        uint8_t WUPE4 : 2;             /*!< [1:0] Wakeup Pin Enable For LLWU_P4 */
        uint8_t WUPE5 : 2;             /*!< [3:2] Wakeup Pin Enable For LLWU_P5 */
        uint8_t WUPE6 : 2;             /*!< [5:4] Wakeup Pin Enable For LLWU_P6 */
        uint8_t WUPE7 : 2;             /*!< [7:6] Wakeup Pin Enable For LLWU_P7 */
    } B;
} hw_llwu_pe2_t;

/*!
 * @name Constants and macros for entire LLWU_PE2 register
 */
/*@{*/
#define HW_LLWU_PE2_ADDR(x)      ((uint32_t)(x) + 0x1U)

#define HW_LLWU_PE2(x)           (*(__IO hw_llwu_pe2_t *) HW_LLWU_PE2_ADDR(x))
#define HW_LLWU_PE2_RD(x)        (HW_LLWU_PE2(x).U)
#define HW_LLWU_PE2_WR(x, v)     (HW_LLWU_PE2(x).U = (v))
#define HW_LLWU_PE2_SET(x, v)    (BME_OR8(HW_LLWU_PE2_ADDR(x), (uint8_t)(v)))
#define HW_LLWU_PE2_CLR(x, v)    (BME_AND8(HW_LLWU_PE2_ADDR(x), (uint8_t)(~(v))))
#define HW_LLWU_PE2_TOG(x, v)    (BME_XOR8(HW_LLWU_PE2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE2 bitfields
 */

/*!
 * @name Register LLWU_PE2, field WUPE4[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE2_WUPE4    (0U)          /*!< Bit position for LLWU_PE2_WUPE4. */
#define BM_LLWU_PE2_WUPE4    (0x03U)       /*!< Bit mask for LLWU_PE2_WUPE4. */
#define BS_LLWU_PE2_WUPE4    (2U)          /*!< Bit field size in bits for LLWU_PE2_WUPE4. */

/*! @brief Read current value of the LLWU_PE2_WUPE4 field. */
#define BR_LLWU_PE2_WUPE4(x) (BME_UBFX8(HW_LLWU_PE2_ADDR(x), BP_LLWU_PE2_WUPE4, BS_LLWU_PE2_WUPE4))

/*! @brief Format value for bitfield LLWU_PE2_WUPE4. */
#define BF_LLWU_PE2_WUPE4(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE2_WUPE4) & BM_LLWU_PE2_WUPE4)

/*! @brief Set the WUPE4 field to a new value. */
#define BW_LLWU_PE2_WUPE4(x, v) (BME_BFI8(HW_LLWU_PE2_ADDR(x), ((uint8_t)(v) << BP_LLWU_PE2_WUPE4), BP_LLWU_PE2_WUPE4, 2))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE5[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE2_WUPE5    (2U)          /*!< Bit position for LLWU_PE2_WUPE5. */
#define BM_LLWU_PE2_WUPE5    (0x0CU)       /*!< Bit mask for LLWU_PE2_WUPE5. */
#define BS_LLWU_PE2_WUPE5    (2U)          /*!< Bit field size in bits for LLWU_PE2_WUPE5. */

/*! @brief Read current value of the LLWU_PE2_WUPE5 field. */
#define BR_LLWU_PE2_WUPE5(x) (BME_UBFX8(HW_LLWU_PE2_ADDR(x), BP_LLWU_PE2_WUPE5, BS_LLWU_PE2_WUPE5))

/*! @brief Format value for bitfield LLWU_PE2_WUPE5. */
#define BF_LLWU_PE2_WUPE5(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE2_WUPE5) & BM_LLWU_PE2_WUPE5)

/*! @brief Set the WUPE5 field to a new value. */
#define BW_LLWU_PE2_WUPE5(x, v) (BME_BFI8(HW_LLWU_PE2_ADDR(x), ((uint8_t)(v) << BP_LLWU_PE2_WUPE5), BP_LLWU_PE2_WUPE5, 2))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE6[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE2_WUPE6    (4U)          /*!< Bit position for LLWU_PE2_WUPE6. */
#define BM_LLWU_PE2_WUPE6    (0x30U)       /*!< Bit mask for LLWU_PE2_WUPE6. */
#define BS_LLWU_PE2_WUPE6    (2U)          /*!< Bit field size in bits for LLWU_PE2_WUPE6. */

/*! @brief Read current value of the LLWU_PE2_WUPE6 field. */
#define BR_LLWU_PE2_WUPE6(x) (BME_UBFX8(HW_LLWU_PE2_ADDR(x), BP_LLWU_PE2_WUPE6, BS_LLWU_PE2_WUPE6))

/*! @brief Format value for bitfield LLWU_PE2_WUPE6. */
#define BF_LLWU_PE2_WUPE6(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE2_WUPE6) & BM_LLWU_PE2_WUPE6)

/*! @brief Set the WUPE6 field to a new value. */
#define BW_LLWU_PE2_WUPE6(x, v) (BME_BFI8(HW_LLWU_PE2_ADDR(x), ((uint8_t)(v) << BP_LLWU_PE2_WUPE6), BP_LLWU_PE2_WUPE6, 2))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE7[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE2_WUPE7    (6U)          /*!< Bit position for LLWU_PE2_WUPE7. */
#define BM_LLWU_PE2_WUPE7    (0xC0U)       /*!< Bit mask for LLWU_PE2_WUPE7. */
#define BS_LLWU_PE2_WUPE7    (2U)          /*!< Bit field size in bits for LLWU_PE2_WUPE7. */

/*! @brief Read current value of the LLWU_PE2_WUPE7 field. */
#define BR_LLWU_PE2_WUPE7(x) (BME_UBFX8(HW_LLWU_PE2_ADDR(x), BP_LLWU_PE2_WUPE7, BS_LLWU_PE2_WUPE7))

/*! @brief Format value for bitfield LLWU_PE2_WUPE7. */
#define BF_LLWU_PE2_WUPE7(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE2_WUPE7) & BM_LLWU_PE2_WUPE7)

/*! @brief Set the WUPE7 field to a new value. */
#define BW_LLWU_PE2_WUPE7(x, v) (BME_BFI8(HW_LLWU_PE2_ADDR(x), ((uint8_t)(v) << BP_LLWU_PE2_WUPE7), BP_LLWU_PE2_WUPE7, 2))
/*@}*/

/*******************************************************************************
 * HW_LLWU_PE3 - LLWU Pin Enable 3 register
 ******************************************************************************/

/*!
 * @brief HW_LLWU_PE3 - LLWU Pin Enable 3 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE3 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P11-LLWU_P8. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
typedef union _hw_llwu_pe3
{
    uint8_t U;
    struct _hw_llwu_pe3_bitfields
    {
        uint8_t WUPE8 : 2;             /*!< [1:0] Wakeup Pin Enable For LLWU_P8 */
        uint8_t WUPE9 : 2;             /*!< [3:2] Wakeup Pin Enable For LLWU_P9 */
        uint8_t WUPE10 : 2;            /*!< [5:4] Wakeup Pin Enable For LLWU_P10 */
        uint8_t WUPE11 : 2;            /*!< [7:6] Wakeup Pin Enable For LLWU_P11 */
    } B;
} hw_llwu_pe3_t;

/*!
 * @name Constants and macros for entire LLWU_PE3 register
 */
/*@{*/
#define HW_LLWU_PE3_ADDR(x)      ((uint32_t)(x) + 0x2U)

#define HW_LLWU_PE3(x)           (*(__IO hw_llwu_pe3_t *) HW_LLWU_PE3_ADDR(x))
#define HW_LLWU_PE3_RD(x)        (HW_LLWU_PE3(x).U)
#define HW_LLWU_PE3_WR(x, v)     (HW_LLWU_PE3(x).U = (v))
#define HW_LLWU_PE3_SET(x, v)    (BME_OR8(HW_LLWU_PE3_ADDR(x), (uint8_t)(v)))
#define HW_LLWU_PE3_CLR(x, v)    (BME_AND8(HW_LLWU_PE3_ADDR(x), (uint8_t)(~(v))))
#define HW_LLWU_PE3_TOG(x, v)    (BME_XOR8(HW_LLWU_PE3_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE3 bitfields
 */

/*!
 * @name Register LLWU_PE3, field WUPE8[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE3_WUPE8    (0U)          /*!< Bit position for LLWU_PE3_WUPE8. */
#define BM_LLWU_PE3_WUPE8    (0x03U)       /*!< Bit mask for LLWU_PE3_WUPE8. */
#define BS_LLWU_PE3_WUPE8    (2U)          /*!< Bit field size in bits for LLWU_PE3_WUPE8. */

/*! @brief Read current value of the LLWU_PE3_WUPE8 field. */
#define BR_LLWU_PE3_WUPE8(x) (BME_UBFX8(HW_LLWU_PE3_ADDR(x), BP_LLWU_PE3_WUPE8, BS_LLWU_PE3_WUPE8))

/*! @brief Format value for bitfield LLWU_PE3_WUPE8. */
#define BF_LLWU_PE3_WUPE8(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE3_WUPE8) & BM_LLWU_PE3_WUPE8)

/*! @brief Set the WUPE8 field to a new value. */
#define BW_LLWU_PE3_WUPE8(x, v) (BME_BFI8(HW_LLWU_PE3_ADDR(x), ((uint8_t)(v) << BP_LLWU_PE3_WUPE8), BP_LLWU_PE3_WUPE8, 2))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE9[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE3_WUPE9    (2U)          /*!< Bit position for LLWU_PE3_WUPE9. */
#define BM_LLWU_PE3_WUPE9    (0x0CU)       /*!< Bit mask for LLWU_PE3_WUPE9. */
#define BS_LLWU_PE3_WUPE9    (2U)          /*!< Bit field size in bits for LLWU_PE3_WUPE9. */

/*! @brief Read current value of the LLWU_PE3_WUPE9 field. */
#define BR_LLWU_PE3_WUPE9(x) (BME_UBFX8(HW_LLWU_PE3_ADDR(x), BP_LLWU_PE3_WUPE9, BS_LLWU_PE3_WUPE9))

/*! @brief Format value for bitfield LLWU_PE3_WUPE9. */
#define BF_LLWU_PE3_WUPE9(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE3_WUPE9) & BM_LLWU_PE3_WUPE9)

/*! @brief Set the WUPE9 field to a new value. */
#define BW_LLWU_PE3_WUPE9(x, v) (BME_BFI8(HW_LLWU_PE3_ADDR(x), ((uint8_t)(v) << BP_LLWU_PE3_WUPE9), BP_LLWU_PE3_WUPE9, 2))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE10[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE3_WUPE10   (4U)          /*!< Bit position for LLWU_PE3_WUPE10. */
#define BM_LLWU_PE3_WUPE10   (0x30U)       /*!< Bit mask for LLWU_PE3_WUPE10. */
#define BS_LLWU_PE3_WUPE10   (2U)          /*!< Bit field size in bits for LLWU_PE3_WUPE10. */

/*! @brief Read current value of the LLWU_PE3_WUPE10 field. */
#define BR_LLWU_PE3_WUPE10(x) (BME_UBFX8(HW_LLWU_PE3_ADDR(x), BP_LLWU_PE3_WUPE10, BS_LLWU_PE3_WUPE10))

/*! @brief Format value for bitfield LLWU_PE3_WUPE10. */
#define BF_LLWU_PE3_WUPE10(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE3_WUPE10) & BM_LLWU_PE3_WUPE10)

/*! @brief Set the WUPE10 field to a new value. */
#define BW_LLWU_PE3_WUPE10(x, v) (BME_BFI8(HW_LLWU_PE3_ADDR(x), ((uint8_t)(v) << BP_LLWU_PE3_WUPE10), BP_LLWU_PE3_WUPE10, 2))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE11[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE3_WUPE11   (6U)          /*!< Bit position for LLWU_PE3_WUPE11. */
#define BM_LLWU_PE3_WUPE11   (0xC0U)       /*!< Bit mask for LLWU_PE3_WUPE11. */
#define BS_LLWU_PE3_WUPE11   (2U)          /*!< Bit field size in bits for LLWU_PE3_WUPE11. */

/*! @brief Read current value of the LLWU_PE3_WUPE11 field. */
#define BR_LLWU_PE3_WUPE11(x) (BME_UBFX8(HW_LLWU_PE3_ADDR(x), BP_LLWU_PE3_WUPE11, BS_LLWU_PE3_WUPE11))

/*! @brief Format value for bitfield LLWU_PE3_WUPE11. */
#define BF_LLWU_PE3_WUPE11(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE3_WUPE11) & BM_LLWU_PE3_WUPE11)

/*! @brief Set the WUPE11 field to a new value. */
#define BW_LLWU_PE3_WUPE11(x, v) (BME_BFI8(HW_LLWU_PE3_ADDR(x), ((uint8_t)(v) << BP_LLWU_PE3_WUPE11), BP_LLWU_PE3_WUPE11, 2))
/*@}*/

/*******************************************************************************
 * HW_LLWU_PE4 - LLWU Pin Enable 4 register
 ******************************************************************************/

/*!
 * @brief HW_LLWU_PE4 - LLWU Pin Enable 4 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE4 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P15-LLWU_P12. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
typedef union _hw_llwu_pe4
{
    uint8_t U;
    struct _hw_llwu_pe4_bitfields
    {
        uint8_t WUPE12 : 2;            /*!< [1:0] Wakeup Pin Enable For LLWU_P12 */
        uint8_t WUPE13 : 2;            /*!< [3:2] Wakeup Pin Enable For LLWU_P13 */
        uint8_t WUPE14 : 2;            /*!< [5:4] Wakeup Pin Enable For LLWU_P14 */
        uint8_t WUPE15 : 2;            /*!< [7:6] Wakeup Pin Enable For LLWU_P15 */
    } B;
} hw_llwu_pe4_t;

/*!
 * @name Constants and macros for entire LLWU_PE4 register
 */
/*@{*/
#define HW_LLWU_PE4_ADDR(x)      ((uint32_t)(x) + 0x3U)

#define HW_LLWU_PE4(x)           (*(__IO hw_llwu_pe4_t *) HW_LLWU_PE4_ADDR(x))
#define HW_LLWU_PE4_RD(x)        (HW_LLWU_PE4(x).U)
#define HW_LLWU_PE4_WR(x, v)     (HW_LLWU_PE4(x).U = (v))
#define HW_LLWU_PE4_SET(x, v)    (BME_OR8(HW_LLWU_PE4_ADDR(x), (uint8_t)(v)))
#define HW_LLWU_PE4_CLR(x, v)    (BME_AND8(HW_LLWU_PE4_ADDR(x), (uint8_t)(~(v))))
#define HW_LLWU_PE4_TOG(x, v)    (BME_XOR8(HW_LLWU_PE4_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE4 bitfields
 */

/*!
 * @name Register LLWU_PE4, field WUPE12[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE4_WUPE12   (0U)          /*!< Bit position for LLWU_PE4_WUPE12. */
#define BM_LLWU_PE4_WUPE12   (0x03U)       /*!< Bit mask for LLWU_PE4_WUPE12. */
#define BS_LLWU_PE4_WUPE12   (2U)          /*!< Bit field size in bits for LLWU_PE4_WUPE12. */

/*! @brief Read current value of the LLWU_PE4_WUPE12 field. */
#define BR_LLWU_PE4_WUPE12(x) (BME_UBFX8(HW_LLWU_PE4_ADDR(x), BP_LLWU_PE4_WUPE12, BS_LLWU_PE4_WUPE12))

/*! @brief Format value for bitfield LLWU_PE4_WUPE12. */
#define BF_LLWU_PE4_WUPE12(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE4_WUPE12) & BM_LLWU_PE4_WUPE12)

/*! @brief Set the WUPE12 field to a new value. */
#define BW_LLWU_PE4_WUPE12(x, v) (BME_BFI8(HW_LLWU_PE4_ADDR(x), ((uint8_t)(v) << BP_LLWU_PE4_WUPE12), BP_LLWU_PE4_WUPE12, 2))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE13[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE4_WUPE13   (2U)          /*!< Bit position for LLWU_PE4_WUPE13. */
#define BM_LLWU_PE4_WUPE13   (0x0CU)       /*!< Bit mask for LLWU_PE4_WUPE13. */
#define BS_LLWU_PE4_WUPE13   (2U)          /*!< Bit field size in bits for LLWU_PE4_WUPE13. */

/*! @brief Read current value of the LLWU_PE4_WUPE13 field. */
#define BR_LLWU_PE4_WUPE13(x) (BME_UBFX8(HW_LLWU_PE4_ADDR(x), BP_LLWU_PE4_WUPE13, BS_LLWU_PE4_WUPE13))

/*! @brief Format value for bitfield LLWU_PE4_WUPE13. */
#define BF_LLWU_PE4_WUPE13(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE4_WUPE13) & BM_LLWU_PE4_WUPE13)

/*! @brief Set the WUPE13 field to a new value. */
#define BW_LLWU_PE4_WUPE13(x, v) (BME_BFI8(HW_LLWU_PE4_ADDR(x), ((uint8_t)(v) << BP_LLWU_PE4_WUPE13), BP_LLWU_PE4_WUPE13, 2))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE14[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE4_WUPE14   (4U)          /*!< Bit position for LLWU_PE4_WUPE14. */
#define BM_LLWU_PE4_WUPE14   (0x30U)       /*!< Bit mask for LLWU_PE4_WUPE14. */
#define BS_LLWU_PE4_WUPE14   (2U)          /*!< Bit field size in bits for LLWU_PE4_WUPE14. */

/*! @brief Read current value of the LLWU_PE4_WUPE14 field. */
#define BR_LLWU_PE4_WUPE14(x) (BME_UBFX8(HW_LLWU_PE4_ADDR(x), BP_LLWU_PE4_WUPE14, BS_LLWU_PE4_WUPE14))

/*! @brief Format value for bitfield LLWU_PE4_WUPE14. */
#define BF_LLWU_PE4_WUPE14(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE4_WUPE14) & BM_LLWU_PE4_WUPE14)

/*! @brief Set the WUPE14 field to a new value. */
#define BW_LLWU_PE4_WUPE14(x, v) (BME_BFI8(HW_LLWU_PE4_ADDR(x), ((uint8_t)(v) << BP_LLWU_PE4_WUPE14), BP_LLWU_PE4_WUPE14, 2))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE15[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE4_WUPE15   (6U)          /*!< Bit position for LLWU_PE4_WUPE15. */
#define BM_LLWU_PE4_WUPE15   (0xC0U)       /*!< Bit mask for LLWU_PE4_WUPE15. */
#define BS_LLWU_PE4_WUPE15   (2U)          /*!< Bit field size in bits for LLWU_PE4_WUPE15. */

/*! @brief Read current value of the LLWU_PE4_WUPE15 field. */
#define BR_LLWU_PE4_WUPE15(x) (BME_UBFX8(HW_LLWU_PE4_ADDR(x), BP_LLWU_PE4_WUPE15, BS_LLWU_PE4_WUPE15))

/*! @brief Format value for bitfield LLWU_PE4_WUPE15. */
#define BF_LLWU_PE4_WUPE15(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE4_WUPE15) & BM_LLWU_PE4_WUPE15)

/*! @brief Set the WUPE15 field to a new value. */
#define BW_LLWU_PE4_WUPE15(x, v) (BME_BFI8(HW_LLWU_PE4_ADDR(x), ((uint8_t)(v) << BP_LLWU_PE4_WUPE15), BP_LLWU_PE4_WUPE15, 2))
/*@}*/

/*******************************************************************************
 * HW_LLWU_ME - LLWU Module Enable register
 ******************************************************************************/

/*!
 * @brief HW_LLWU_ME - LLWU Module Enable register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_ME contains the bits to enable the internal module flag as a wakeup
 * input source for inputs MWUF7-MWUF0. This register is reset on Chip Reset not VLLS
 * and by reset types that trigger Chip Reset not VLLS. It is unaffected by
 * reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module (RCM). The
 * RCM implements many of the reset functions for the chip. See the chip's reset
 * chapter for more information. details for more information.
 */
typedef union _hw_llwu_me
{
    uint8_t U;
    struct _hw_llwu_me_bitfields
    {
        uint8_t WUME0 : 1;             /*!< [0] Wakeup Module Enable For Module 0 */
        uint8_t WUME1 : 1;             /*!< [1] Wakeup Module Enable for Module 1 */
        uint8_t WUME2 : 1;             /*!< [2] Wakeup Module Enable For Module 2 */
        uint8_t WUME3 : 1;             /*!< [3] Wakeup Module Enable For Module 3 */
        uint8_t WUME4 : 1;             /*!< [4] Wakeup Module Enable For Module 4 */
        uint8_t WUME5 : 1;             /*!< [5] Wakeup Module Enable For Module 5 */
        uint8_t WUME6 : 1;             /*!< [6] Wakeup Module Enable For Module 6 */
        uint8_t WUME7 : 1;             /*!< [7] Wakeup Module Enable For Module 7 */
    } B;
} hw_llwu_me_t;

/*!
 * @name Constants and macros for entire LLWU_ME register
 */
/*@{*/
#define HW_LLWU_ME_ADDR(x)       ((uint32_t)(x) + 0x4U)

#define HW_LLWU_ME(x)            (*(__IO hw_llwu_me_t *) HW_LLWU_ME_ADDR(x))
#define HW_LLWU_ME_RD(x)         (HW_LLWU_ME(x).U)
#define HW_LLWU_ME_WR(x, v)      (HW_LLWU_ME(x).U = (v))
#define HW_LLWU_ME_SET(x, v)     (BME_OR8(HW_LLWU_ME_ADDR(x), (uint8_t)(v)))
#define HW_LLWU_ME_CLR(x, v)     (BME_AND8(HW_LLWU_ME_ADDR(x), (uint8_t)(~(v))))
#define HW_LLWU_ME_TOG(x, v)     (BME_XOR8(HW_LLWU_ME_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LLWU_ME bitfields
 */

/*!
 * @name Register LLWU_ME, field WUME0[0] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
#define BP_LLWU_ME_WUME0     (0U)          /*!< Bit position for LLWU_ME_WUME0. */
#define BM_LLWU_ME_WUME0     (0x01U)       /*!< Bit mask for LLWU_ME_WUME0. */
#define BS_LLWU_ME_WUME0     (1U)          /*!< Bit field size in bits for LLWU_ME_WUME0. */

/*! @brief Read current value of the LLWU_ME_WUME0 field. */
#define BR_LLWU_ME_WUME0(x)  (BME_UBFX8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME0, BS_LLWU_ME_WUME0))

/*! @brief Format value for bitfield LLWU_ME_WUME0. */
#define BF_LLWU_ME_WUME0(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_ME_WUME0) & BM_LLWU_ME_WUME0)

/*! @brief Set the WUME0 field to a new value. */
#define BW_LLWU_ME_WUME0(x, v) (BME_BFI8(HW_LLWU_ME_ADDR(x), ((uint8_t)(v) << BP_LLWU_ME_WUME0), BP_LLWU_ME_WUME0, 1))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME1[1] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
#define BP_LLWU_ME_WUME1     (1U)          /*!< Bit position for LLWU_ME_WUME1. */
#define BM_LLWU_ME_WUME1     (0x02U)       /*!< Bit mask for LLWU_ME_WUME1. */
#define BS_LLWU_ME_WUME1     (1U)          /*!< Bit field size in bits for LLWU_ME_WUME1. */

/*! @brief Read current value of the LLWU_ME_WUME1 field. */
#define BR_LLWU_ME_WUME1(x)  (BME_UBFX8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME1, BS_LLWU_ME_WUME1))

/*! @brief Format value for bitfield LLWU_ME_WUME1. */
#define BF_LLWU_ME_WUME1(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_ME_WUME1) & BM_LLWU_ME_WUME1)

/*! @brief Set the WUME1 field to a new value. */
#define BW_LLWU_ME_WUME1(x, v) (BME_BFI8(HW_LLWU_ME_ADDR(x), ((uint8_t)(v) << BP_LLWU_ME_WUME1), BP_LLWU_ME_WUME1, 1))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME2[2] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
#define BP_LLWU_ME_WUME2     (2U)          /*!< Bit position for LLWU_ME_WUME2. */
#define BM_LLWU_ME_WUME2     (0x04U)       /*!< Bit mask for LLWU_ME_WUME2. */
#define BS_LLWU_ME_WUME2     (1U)          /*!< Bit field size in bits for LLWU_ME_WUME2. */

/*! @brief Read current value of the LLWU_ME_WUME2 field. */
#define BR_LLWU_ME_WUME2(x)  (BME_UBFX8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME2, BS_LLWU_ME_WUME2))

/*! @brief Format value for bitfield LLWU_ME_WUME2. */
#define BF_LLWU_ME_WUME2(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_ME_WUME2) & BM_LLWU_ME_WUME2)

/*! @brief Set the WUME2 field to a new value. */
#define BW_LLWU_ME_WUME2(x, v) (BME_BFI8(HW_LLWU_ME_ADDR(x), ((uint8_t)(v) << BP_LLWU_ME_WUME2), BP_LLWU_ME_WUME2, 1))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME3[3] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
#define BP_LLWU_ME_WUME3     (3U)          /*!< Bit position for LLWU_ME_WUME3. */
#define BM_LLWU_ME_WUME3     (0x08U)       /*!< Bit mask for LLWU_ME_WUME3. */
#define BS_LLWU_ME_WUME3     (1U)          /*!< Bit field size in bits for LLWU_ME_WUME3. */

/*! @brief Read current value of the LLWU_ME_WUME3 field. */
#define BR_LLWU_ME_WUME3(x)  (BME_UBFX8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME3, BS_LLWU_ME_WUME3))

/*! @brief Format value for bitfield LLWU_ME_WUME3. */
#define BF_LLWU_ME_WUME3(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_ME_WUME3) & BM_LLWU_ME_WUME3)

/*! @brief Set the WUME3 field to a new value. */
#define BW_LLWU_ME_WUME3(x, v) (BME_BFI8(HW_LLWU_ME_ADDR(x), ((uint8_t)(v) << BP_LLWU_ME_WUME3), BP_LLWU_ME_WUME3, 1))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME4[4] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
#define BP_LLWU_ME_WUME4     (4U)          /*!< Bit position for LLWU_ME_WUME4. */
#define BM_LLWU_ME_WUME4     (0x10U)       /*!< Bit mask for LLWU_ME_WUME4. */
#define BS_LLWU_ME_WUME4     (1U)          /*!< Bit field size in bits for LLWU_ME_WUME4. */

/*! @brief Read current value of the LLWU_ME_WUME4 field. */
#define BR_LLWU_ME_WUME4(x)  (BME_UBFX8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME4, BS_LLWU_ME_WUME4))

/*! @brief Format value for bitfield LLWU_ME_WUME4. */
#define BF_LLWU_ME_WUME4(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_ME_WUME4) & BM_LLWU_ME_WUME4)

/*! @brief Set the WUME4 field to a new value. */
#define BW_LLWU_ME_WUME4(x, v) (BME_BFI8(HW_LLWU_ME_ADDR(x), ((uint8_t)(v) << BP_LLWU_ME_WUME4), BP_LLWU_ME_WUME4, 1))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME5[5] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
#define BP_LLWU_ME_WUME5     (5U)          /*!< Bit position for LLWU_ME_WUME5. */
#define BM_LLWU_ME_WUME5     (0x20U)       /*!< Bit mask for LLWU_ME_WUME5. */
#define BS_LLWU_ME_WUME5     (1U)          /*!< Bit field size in bits for LLWU_ME_WUME5. */

/*! @brief Read current value of the LLWU_ME_WUME5 field. */
#define BR_LLWU_ME_WUME5(x)  (BME_UBFX8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME5, BS_LLWU_ME_WUME5))

/*! @brief Format value for bitfield LLWU_ME_WUME5. */
#define BF_LLWU_ME_WUME5(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_ME_WUME5) & BM_LLWU_ME_WUME5)

/*! @brief Set the WUME5 field to a new value. */
#define BW_LLWU_ME_WUME5(x, v) (BME_BFI8(HW_LLWU_ME_ADDR(x), ((uint8_t)(v) << BP_LLWU_ME_WUME5), BP_LLWU_ME_WUME5, 1))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME6[6] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
#define BP_LLWU_ME_WUME6     (6U)          /*!< Bit position for LLWU_ME_WUME6. */
#define BM_LLWU_ME_WUME6     (0x40U)       /*!< Bit mask for LLWU_ME_WUME6. */
#define BS_LLWU_ME_WUME6     (1U)          /*!< Bit field size in bits for LLWU_ME_WUME6. */

/*! @brief Read current value of the LLWU_ME_WUME6 field. */
#define BR_LLWU_ME_WUME6(x)  (BME_UBFX8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME6, BS_LLWU_ME_WUME6))

/*! @brief Format value for bitfield LLWU_ME_WUME6. */
#define BF_LLWU_ME_WUME6(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_ME_WUME6) & BM_LLWU_ME_WUME6)

/*! @brief Set the WUME6 field to a new value. */
#define BW_LLWU_ME_WUME6(x, v) (BME_BFI8(HW_LLWU_ME_ADDR(x), ((uint8_t)(v) << BP_LLWU_ME_WUME6), BP_LLWU_ME_WUME6, 1))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME7[7] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
#define BP_LLWU_ME_WUME7     (7U)          /*!< Bit position for LLWU_ME_WUME7. */
#define BM_LLWU_ME_WUME7     (0x80U)       /*!< Bit mask for LLWU_ME_WUME7. */
#define BS_LLWU_ME_WUME7     (1U)          /*!< Bit field size in bits for LLWU_ME_WUME7. */

/*! @brief Read current value of the LLWU_ME_WUME7 field. */
#define BR_LLWU_ME_WUME7(x)  (BME_UBFX8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME7, BS_LLWU_ME_WUME7))

/*! @brief Format value for bitfield LLWU_ME_WUME7. */
#define BF_LLWU_ME_WUME7(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_ME_WUME7) & BM_LLWU_ME_WUME7)

/*! @brief Set the WUME7 field to a new value. */
#define BW_LLWU_ME_WUME7(x, v) (BME_BFI8(HW_LLWU_ME_ADDR(x), ((uint8_t)(v) << BP_LLWU_ME_WUME7), BP_LLWU_ME_WUME7, 1))
/*@}*/

/*******************************************************************************
 * HW_LLWU_F1 - LLWU Flag 1 register
 ******************************************************************************/

/*!
 * @brief HW_LLWU_F1 - LLWU Flag 1 register (W1C)
 *
 * Reset value: 0x00U
 *
 * LLWU_F1 contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit LLS or VLLS mode. For LLS, this is the source causing the CPU
 * interrupt flow. For VLLS, this is the source causing the MCU reset flow. The
 * external wakeup flags are read-only and clearing a flag is accomplished by a write
 * of a 1 to the corresponding WUFx bit. The wakeup flag (WUFx), if set, will
 * remain set if the associated WUPEx bit is cleared. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
typedef union _hw_llwu_f1
{
    uint8_t U;
    struct _hw_llwu_f1_bitfields
    {
        uint8_t WUF0 : 1;              /*!< [0] Wakeup Flag For LLWU_P0 */
        uint8_t WUF1 : 1;              /*!< [1] Wakeup Flag For LLWU_P1 */
        uint8_t WUF2 : 1;              /*!< [2] Wakeup Flag For LLWU_P2 */
        uint8_t WUF3 : 1;              /*!< [3] Wakeup Flag For LLWU_P3 */
        uint8_t WUF4 : 1;              /*!< [4] Wakeup Flag For LLWU_P4 */
        uint8_t WUF5 : 1;              /*!< [5] Wakeup Flag For LLWU_P5 */
        uint8_t WUF6 : 1;              /*!< [6] Wakeup Flag For LLWU_P6 */
        uint8_t WUF7 : 1;              /*!< [7] Wakeup Flag For LLWU_P7 */
    } B;
} hw_llwu_f1_t;

/*!
 * @name Constants and macros for entire LLWU_F1 register
 */
/*@{*/
#define HW_LLWU_F1_ADDR(x)       ((uint32_t)(x) + 0x5U)

#define HW_LLWU_F1(x)            (*(__IO hw_llwu_f1_t *) HW_LLWU_F1_ADDR(x))
#define HW_LLWU_F1_RD(x)         (HW_LLWU_F1(x).U)
#define HW_LLWU_F1_WR(x, v)      (HW_LLWU_F1(x).U = (v))
#define HW_LLWU_F1_SET(x, v)     (BME_OR8(HW_LLWU_F1_ADDR(x), (uint8_t)(v)))
#define HW_LLWU_F1_CLR(x, v)     (BME_AND8(HW_LLWU_F1_ADDR(x), (uint8_t)(~(v))))
#define HW_LLWU_F1_TOG(x, v)     (BME_XOR8(HW_LLWU_F1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LLWU_F1 bitfields
 */

/*!
 * @name Register LLWU_F1, field WUF0[0] (W1C)
 *
 * Indicates that an enabled external wake-up pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF0.
 *
 * Values:
 * - 0 - LLWU_P0 input was not a wakeup source
 * - 1 - LLWU_P0 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F1_WUF0      (0U)          /*!< Bit position for LLWU_F1_WUF0. */
#define BM_LLWU_F1_WUF0      (0x01U)       /*!< Bit mask for LLWU_F1_WUF0. */
#define BS_LLWU_F1_WUF0      (1U)          /*!< Bit field size in bits for LLWU_F1_WUF0. */

/*! @brief Read current value of the LLWU_F1_WUF0 field. */
#define BR_LLWU_F1_WUF0(x)   (BME_UBFX8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF0, BS_LLWU_F1_WUF0))

/*! @brief Format value for bitfield LLWU_F1_WUF0. */
#define BF_LLWU_F1_WUF0(v)   ((uint8_t)((uint8_t)(v) << BP_LLWU_F1_WUF0) & BM_LLWU_F1_WUF0)

/*! @brief Set the WUF0 field to a new value. */
#define BW_LLWU_F1_WUF0(x, v) (BME_BFI8(HW_LLWU_F1_ADDR(x), ((uint8_t)(v) << BP_LLWU_F1_WUF0), BP_LLWU_F1_WUF0, 1))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF1[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF1.
 *
 * Values:
 * - 0 - LLWU_P1 input was not a wakeup source
 * - 1 - LLWU_P1 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F1_WUF1      (1U)          /*!< Bit position for LLWU_F1_WUF1. */
#define BM_LLWU_F1_WUF1      (0x02U)       /*!< Bit mask for LLWU_F1_WUF1. */
#define BS_LLWU_F1_WUF1      (1U)          /*!< Bit field size in bits for LLWU_F1_WUF1. */

/*! @brief Read current value of the LLWU_F1_WUF1 field. */
#define BR_LLWU_F1_WUF1(x)   (BME_UBFX8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF1, BS_LLWU_F1_WUF1))

/*! @brief Format value for bitfield LLWU_F1_WUF1. */
#define BF_LLWU_F1_WUF1(v)   ((uint8_t)((uint8_t)(v) << BP_LLWU_F1_WUF1) & BM_LLWU_F1_WUF1)

/*! @brief Set the WUF1 field to a new value. */
#define BW_LLWU_F1_WUF1(x, v) (BME_BFI8(HW_LLWU_F1_ADDR(x), ((uint8_t)(v) << BP_LLWU_F1_WUF1), BP_LLWU_F1_WUF1, 1))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF2[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF2.
 *
 * Values:
 * - 0 - LLWU_P2 input was not a wakeup source
 * - 1 - LLWU_P2 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F1_WUF2      (2U)          /*!< Bit position for LLWU_F1_WUF2. */
#define BM_LLWU_F1_WUF2      (0x04U)       /*!< Bit mask for LLWU_F1_WUF2. */
#define BS_LLWU_F1_WUF2      (1U)          /*!< Bit field size in bits for LLWU_F1_WUF2. */

/*! @brief Read current value of the LLWU_F1_WUF2 field. */
#define BR_LLWU_F1_WUF2(x)   (BME_UBFX8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF2, BS_LLWU_F1_WUF2))

/*! @brief Format value for bitfield LLWU_F1_WUF2. */
#define BF_LLWU_F1_WUF2(v)   ((uint8_t)((uint8_t)(v) << BP_LLWU_F1_WUF2) & BM_LLWU_F1_WUF2)

/*! @brief Set the WUF2 field to a new value. */
#define BW_LLWU_F1_WUF2(x, v) (BME_BFI8(HW_LLWU_F1_ADDR(x), ((uint8_t)(v) << BP_LLWU_F1_WUF2), BP_LLWU_F1_WUF2, 1))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF3[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF3.
 *
 * Values:
 * - 0 - LLWU_P3 input was not a wake-up source
 * - 1 - LLWU_P3 input was a wake-up source
 */
/*@{*/
#define BP_LLWU_F1_WUF3      (3U)          /*!< Bit position for LLWU_F1_WUF3. */
#define BM_LLWU_F1_WUF3      (0x08U)       /*!< Bit mask for LLWU_F1_WUF3. */
#define BS_LLWU_F1_WUF3      (1U)          /*!< Bit field size in bits for LLWU_F1_WUF3. */

/*! @brief Read current value of the LLWU_F1_WUF3 field. */
#define BR_LLWU_F1_WUF3(x)   (BME_UBFX8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF3, BS_LLWU_F1_WUF3))

/*! @brief Format value for bitfield LLWU_F1_WUF3. */
#define BF_LLWU_F1_WUF3(v)   ((uint8_t)((uint8_t)(v) << BP_LLWU_F1_WUF3) & BM_LLWU_F1_WUF3)

/*! @brief Set the WUF3 field to a new value. */
#define BW_LLWU_F1_WUF3(x, v) (BME_BFI8(HW_LLWU_F1_ADDR(x), ((uint8_t)(v) << BP_LLWU_F1_WUF3), BP_LLWU_F1_WUF3, 1))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF4[4] (W1C)
 *
 * Indicates that an enabled external wake-up pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF4.
 *
 * Values:
 * - 0 - LLWU_P4 input was not a wakeup source
 * - 1 - LLWU_P4 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F1_WUF4      (4U)          /*!< Bit position for LLWU_F1_WUF4. */
#define BM_LLWU_F1_WUF4      (0x10U)       /*!< Bit mask for LLWU_F1_WUF4. */
#define BS_LLWU_F1_WUF4      (1U)          /*!< Bit field size in bits for LLWU_F1_WUF4. */

/*! @brief Read current value of the LLWU_F1_WUF4 field. */
#define BR_LLWU_F1_WUF4(x)   (BME_UBFX8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF4, BS_LLWU_F1_WUF4))

/*! @brief Format value for bitfield LLWU_F1_WUF4. */
#define BF_LLWU_F1_WUF4(v)   ((uint8_t)((uint8_t)(v) << BP_LLWU_F1_WUF4) & BM_LLWU_F1_WUF4)

/*! @brief Set the WUF4 field to a new value. */
#define BW_LLWU_F1_WUF4(x, v) (BME_BFI8(HW_LLWU_F1_ADDR(x), ((uint8_t)(v) << BP_LLWU_F1_WUF4), BP_LLWU_F1_WUF4, 1))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF5[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF5.
 *
 * Values:
 * - 0 - LLWU_P5 input was not a wakeup source
 * - 1 - LLWU_P5 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F1_WUF5      (5U)          /*!< Bit position for LLWU_F1_WUF5. */
#define BM_LLWU_F1_WUF5      (0x20U)       /*!< Bit mask for LLWU_F1_WUF5. */
#define BS_LLWU_F1_WUF5      (1U)          /*!< Bit field size in bits for LLWU_F1_WUF5. */

/*! @brief Read current value of the LLWU_F1_WUF5 field. */
#define BR_LLWU_F1_WUF5(x)   (BME_UBFX8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF5, BS_LLWU_F1_WUF5))

/*! @brief Format value for bitfield LLWU_F1_WUF5. */
#define BF_LLWU_F1_WUF5(v)   ((uint8_t)((uint8_t)(v) << BP_LLWU_F1_WUF5) & BM_LLWU_F1_WUF5)

/*! @brief Set the WUF5 field to a new value. */
#define BW_LLWU_F1_WUF5(x, v) (BME_BFI8(HW_LLWU_F1_ADDR(x), ((uint8_t)(v) << BP_LLWU_F1_WUF5), BP_LLWU_F1_WUF5, 1))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF6[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF6.
 *
 * Values:
 * - 0 - LLWU_P6 input was not a wakeup source
 * - 1 - LLWU_P6 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F1_WUF6      (6U)          /*!< Bit position for LLWU_F1_WUF6. */
#define BM_LLWU_F1_WUF6      (0x40U)       /*!< Bit mask for LLWU_F1_WUF6. */
#define BS_LLWU_F1_WUF6      (1U)          /*!< Bit field size in bits for LLWU_F1_WUF6. */

/*! @brief Read current value of the LLWU_F1_WUF6 field. */
#define BR_LLWU_F1_WUF6(x)   (BME_UBFX8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF6, BS_LLWU_F1_WUF6))

/*! @brief Format value for bitfield LLWU_F1_WUF6. */
#define BF_LLWU_F1_WUF6(v)   ((uint8_t)((uint8_t)(v) << BP_LLWU_F1_WUF6) & BM_LLWU_F1_WUF6)

/*! @brief Set the WUF6 field to a new value. */
#define BW_LLWU_F1_WUF6(x, v) (BME_BFI8(HW_LLWU_F1_ADDR(x), ((uint8_t)(v) << BP_LLWU_F1_WUF6), BP_LLWU_F1_WUF6, 1))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF7[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF7.
 *
 * Values:
 * - 0 - LLWU_P7 input was not a wakeup source
 * - 1 - LLWU_P7 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F1_WUF7      (7U)          /*!< Bit position for LLWU_F1_WUF7. */
#define BM_LLWU_F1_WUF7      (0x80U)       /*!< Bit mask for LLWU_F1_WUF7. */
#define BS_LLWU_F1_WUF7      (1U)          /*!< Bit field size in bits for LLWU_F1_WUF7. */

/*! @brief Read current value of the LLWU_F1_WUF7 field. */
#define BR_LLWU_F1_WUF7(x)   (BME_UBFX8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF7, BS_LLWU_F1_WUF7))

/*! @brief Format value for bitfield LLWU_F1_WUF7. */
#define BF_LLWU_F1_WUF7(v)   ((uint8_t)((uint8_t)(v) << BP_LLWU_F1_WUF7) & BM_LLWU_F1_WUF7)

/*! @brief Set the WUF7 field to a new value. */
#define BW_LLWU_F1_WUF7(x, v) (BME_BFI8(HW_LLWU_F1_ADDR(x), ((uint8_t)(v) << BP_LLWU_F1_WUF7), BP_LLWU_F1_WUF7, 1))
/*@}*/

/*******************************************************************************
 * HW_LLWU_F2 - LLWU Flag 2 register
 ******************************************************************************/

/*!
 * @brief HW_LLWU_F2 - LLWU Flag 2 register (W1C)
 *
 * Reset value: 0x00U
 *
 * LLWU_F2 contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit LLS or VLLS mode. For LLS, this is the source causing the CPU
 * interrupt flow. For VLLS, this is the source causing the MCU reset flow. The
 * external wakeup flags are read-only and clearing a flag is accomplished by a write
 * of a 1 to the corresponding WUFx bit. The wakeup flag (WUFx), if set, will
 * remain set if the associated WUPEx bit is cleared. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
typedef union _hw_llwu_f2
{
    uint8_t U;
    struct _hw_llwu_f2_bitfields
    {
        uint8_t WUF8 : 1;              /*!< [0] Wakeup Flag For LLWU_P8 */
        uint8_t WUF9 : 1;              /*!< [1] Wakeup Flag For LLWU_P9 */
        uint8_t WUF10 : 1;             /*!< [2] Wakeup Flag For LLWU_P10 */
        uint8_t WUF11 : 1;             /*!< [3] Wakeup Flag For LLWU_P11 */
        uint8_t WUF12 : 1;             /*!< [4] Wakeup Flag For LLWU_P12 */
        uint8_t WUF13 : 1;             /*!< [5] Wakeup Flag For LLWU_P13 */
        uint8_t WUF14 : 1;             /*!< [6] Wakeup Flag For LLWU_P14 */
        uint8_t WUF15 : 1;             /*!< [7] Wakeup Flag For LLWU_P15 */
    } B;
} hw_llwu_f2_t;

/*!
 * @name Constants and macros for entire LLWU_F2 register
 */
/*@{*/
#define HW_LLWU_F2_ADDR(x)       ((uint32_t)(x) + 0x6U)

#define HW_LLWU_F2(x)            (*(__IO hw_llwu_f2_t *) HW_LLWU_F2_ADDR(x))
#define HW_LLWU_F2_RD(x)         (HW_LLWU_F2(x).U)
#define HW_LLWU_F2_WR(x, v)      (HW_LLWU_F2(x).U = (v))
#define HW_LLWU_F2_SET(x, v)     (BME_OR8(HW_LLWU_F2_ADDR(x), (uint8_t)(v)))
#define HW_LLWU_F2_CLR(x, v)     (BME_AND8(HW_LLWU_F2_ADDR(x), (uint8_t)(~(v))))
#define HW_LLWU_F2_TOG(x, v)     (BME_XOR8(HW_LLWU_F2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LLWU_F2 bitfields
 */

/*!
 * @name Register LLWU_F2, field WUF8[0] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF8.
 *
 * Values:
 * - 0 - LLWU_P8 input was not a wakeup source
 * - 1 - LLWU_P8 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F2_WUF8      (0U)          /*!< Bit position for LLWU_F2_WUF8. */
#define BM_LLWU_F2_WUF8      (0x01U)       /*!< Bit mask for LLWU_F2_WUF8. */
#define BS_LLWU_F2_WUF8      (1U)          /*!< Bit field size in bits for LLWU_F2_WUF8. */

/*! @brief Read current value of the LLWU_F2_WUF8 field. */
#define BR_LLWU_F2_WUF8(x)   (BME_UBFX8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF8, BS_LLWU_F2_WUF8))

/*! @brief Format value for bitfield LLWU_F2_WUF8. */
#define BF_LLWU_F2_WUF8(v)   ((uint8_t)((uint8_t)(v) << BP_LLWU_F2_WUF8) & BM_LLWU_F2_WUF8)

/*! @brief Set the WUF8 field to a new value. */
#define BW_LLWU_F2_WUF8(x, v) (BME_BFI8(HW_LLWU_F2_ADDR(x), ((uint8_t)(v) << BP_LLWU_F2_WUF8), BP_LLWU_F2_WUF8, 1))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF9[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF9.
 *
 * Values:
 * - 0 - LLWU_P9 input was not a wakeup source
 * - 1 - LLWU_P9 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F2_WUF9      (1U)          /*!< Bit position for LLWU_F2_WUF9. */
#define BM_LLWU_F2_WUF9      (0x02U)       /*!< Bit mask for LLWU_F2_WUF9. */
#define BS_LLWU_F2_WUF9      (1U)          /*!< Bit field size in bits for LLWU_F2_WUF9. */

/*! @brief Read current value of the LLWU_F2_WUF9 field. */
#define BR_LLWU_F2_WUF9(x)   (BME_UBFX8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF9, BS_LLWU_F2_WUF9))

/*! @brief Format value for bitfield LLWU_F2_WUF9. */
#define BF_LLWU_F2_WUF9(v)   ((uint8_t)((uint8_t)(v) << BP_LLWU_F2_WUF9) & BM_LLWU_F2_WUF9)

/*! @brief Set the WUF9 field to a new value. */
#define BW_LLWU_F2_WUF9(x, v) (BME_BFI8(HW_LLWU_F2_ADDR(x), ((uint8_t)(v) << BP_LLWU_F2_WUF9), BP_LLWU_F2_WUF9, 1))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF10[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF10.
 *
 * Values:
 * - 0 - LLWU_P10 input was not a wakeup source
 * - 1 - LLWU_P10 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F2_WUF10     (2U)          /*!< Bit position for LLWU_F2_WUF10. */
#define BM_LLWU_F2_WUF10     (0x04U)       /*!< Bit mask for LLWU_F2_WUF10. */
#define BS_LLWU_F2_WUF10     (1U)          /*!< Bit field size in bits for LLWU_F2_WUF10. */

/*! @brief Read current value of the LLWU_F2_WUF10 field. */
#define BR_LLWU_F2_WUF10(x)  (BME_UBFX8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF10, BS_LLWU_F2_WUF10))

/*! @brief Format value for bitfield LLWU_F2_WUF10. */
#define BF_LLWU_F2_WUF10(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_F2_WUF10) & BM_LLWU_F2_WUF10)

/*! @brief Set the WUF10 field to a new value. */
#define BW_LLWU_F2_WUF10(x, v) (BME_BFI8(HW_LLWU_F2_ADDR(x), ((uint8_t)(v) << BP_LLWU_F2_WUF10), BP_LLWU_F2_WUF10, 1))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF11[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF11.
 *
 * Values:
 * - 0 - LLWU_P11 input was not a wakeup source
 * - 1 - LLWU_P11 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F2_WUF11     (3U)          /*!< Bit position for LLWU_F2_WUF11. */
#define BM_LLWU_F2_WUF11     (0x08U)       /*!< Bit mask for LLWU_F2_WUF11. */
#define BS_LLWU_F2_WUF11     (1U)          /*!< Bit field size in bits for LLWU_F2_WUF11. */

/*! @brief Read current value of the LLWU_F2_WUF11 field. */
#define BR_LLWU_F2_WUF11(x)  (BME_UBFX8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF11, BS_LLWU_F2_WUF11))

/*! @brief Format value for bitfield LLWU_F2_WUF11. */
#define BF_LLWU_F2_WUF11(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_F2_WUF11) & BM_LLWU_F2_WUF11)

/*! @brief Set the WUF11 field to a new value. */
#define BW_LLWU_F2_WUF11(x, v) (BME_BFI8(HW_LLWU_F2_ADDR(x), ((uint8_t)(v) << BP_LLWU_F2_WUF11), BP_LLWU_F2_WUF11, 1))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF12[4] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF12.
 *
 * Values:
 * - 0 - LLWU_P12 input was not a wakeup source
 * - 1 - LLWU_P12 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F2_WUF12     (4U)          /*!< Bit position for LLWU_F2_WUF12. */
#define BM_LLWU_F2_WUF12     (0x10U)       /*!< Bit mask for LLWU_F2_WUF12. */
#define BS_LLWU_F2_WUF12     (1U)          /*!< Bit field size in bits for LLWU_F2_WUF12. */

/*! @brief Read current value of the LLWU_F2_WUF12 field. */
#define BR_LLWU_F2_WUF12(x)  (BME_UBFX8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF12, BS_LLWU_F2_WUF12))

/*! @brief Format value for bitfield LLWU_F2_WUF12. */
#define BF_LLWU_F2_WUF12(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_F2_WUF12) & BM_LLWU_F2_WUF12)

/*! @brief Set the WUF12 field to a new value. */
#define BW_LLWU_F2_WUF12(x, v) (BME_BFI8(HW_LLWU_F2_ADDR(x), ((uint8_t)(v) << BP_LLWU_F2_WUF12), BP_LLWU_F2_WUF12, 1))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF13[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF13.
 *
 * Values:
 * - 0 - LLWU_P13 input was not a wakeup source
 * - 1 - LLWU_P13 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F2_WUF13     (5U)          /*!< Bit position for LLWU_F2_WUF13. */
#define BM_LLWU_F2_WUF13     (0x20U)       /*!< Bit mask for LLWU_F2_WUF13. */
#define BS_LLWU_F2_WUF13     (1U)          /*!< Bit field size in bits for LLWU_F2_WUF13. */

/*! @brief Read current value of the LLWU_F2_WUF13 field. */
#define BR_LLWU_F2_WUF13(x)  (BME_UBFX8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF13, BS_LLWU_F2_WUF13))

/*! @brief Format value for bitfield LLWU_F2_WUF13. */
#define BF_LLWU_F2_WUF13(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_F2_WUF13) & BM_LLWU_F2_WUF13)

/*! @brief Set the WUF13 field to a new value. */
#define BW_LLWU_F2_WUF13(x, v) (BME_BFI8(HW_LLWU_F2_ADDR(x), ((uint8_t)(v) << BP_LLWU_F2_WUF13), BP_LLWU_F2_WUF13, 1))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF14[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF14.
 *
 * Values:
 * - 0 - LLWU_P14 input was not a wakeup source
 * - 1 - LLWU_P14 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F2_WUF14     (6U)          /*!< Bit position for LLWU_F2_WUF14. */
#define BM_LLWU_F2_WUF14     (0x40U)       /*!< Bit mask for LLWU_F2_WUF14. */
#define BS_LLWU_F2_WUF14     (1U)          /*!< Bit field size in bits for LLWU_F2_WUF14. */

/*! @brief Read current value of the LLWU_F2_WUF14 field. */
#define BR_LLWU_F2_WUF14(x)  (BME_UBFX8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF14, BS_LLWU_F2_WUF14))

/*! @brief Format value for bitfield LLWU_F2_WUF14. */
#define BF_LLWU_F2_WUF14(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_F2_WUF14) & BM_LLWU_F2_WUF14)

/*! @brief Set the WUF14 field to a new value. */
#define BW_LLWU_F2_WUF14(x, v) (BME_BFI8(HW_LLWU_F2_ADDR(x), ((uint8_t)(v) << BP_LLWU_F2_WUF14), BP_LLWU_F2_WUF14, 1))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF15[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF15.
 *
 * Values:
 * - 0 - LLWU_P15 input was not a wakeup source
 * - 1 - LLWU_P15 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F2_WUF15     (7U)          /*!< Bit position for LLWU_F2_WUF15. */
#define BM_LLWU_F2_WUF15     (0x80U)       /*!< Bit mask for LLWU_F2_WUF15. */
#define BS_LLWU_F2_WUF15     (1U)          /*!< Bit field size in bits for LLWU_F2_WUF15. */

/*! @brief Read current value of the LLWU_F2_WUF15 field. */
#define BR_LLWU_F2_WUF15(x)  (BME_UBFX8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF15, BS_LLWU_F2_WUF15))

/*! @brief Format value for bitfield LLWU_F2_WUF15. */
#define BF_LLWU_F2_WUF15(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_F2_WUF15) & BM_LLWU_F2_WUF15)

/*! @brief Set the WUF15 field to a new value. */
#define BW_LLWU_F2_WUF15(x, v) (BME_BFI8(HW_LLWU_F2_ADDR(x), ((uint8_t)(v) << BP_LLWU_F2_WUF15), BP_LLWU_F2_WUF15, 1))
/*@}*/

/*******************************************************************************
 * HW_LLWU_F3 - LLWU Flag 3 register
 ******************************************************************************/

/*!
 * @brief HW_LLWU_F3 - LLWU Flag 3 register (RO)
 *
 * Reset value: 0x00U
 *
 * LLWU_F3 contains the wakeup flags indicating which internal wakeup source
 * caused the MCU to exit LLS or VLLS mode. For LLS, this is the source causing the
 * CPU interrupt flow. For VLLS, this is the source causing the MCU reset flow.
 * For internal peripherals that are capable of running in a low-leakage power
 * mode, such as a real time clock module or CMP module, the flag from the
 * associated peripheral is accessible as the MWUFx bit. The flag will need to be cleared
 * in the peripheral instead of writing a 1 to the MWUFx bit. This register is
 * reset on Chip Reset not VLLS and by reset types that trigger Chip Reset not
 * VLLS. It is unaffected by reset types that do not trigger Chip Reset not VLLS. See
 * the IntroductionInformation found here describes the registers of the Reset
 * Control Module (RCM). The RCM implements many of the reset functions for the
 * chip. See the chip's reset chapter for more information. details for more
 * information.
 */
typedef union _hw_llwu_f3
{
    uint8_t U;
    struct _hw_llwu_f3_bitfields
    {
        uint8_t MWUF0 : 1;             /*!< [0] Wakeup flag For module 0 */
        uint8_t MWUF1 : 1;             /*!< [1] Wakeup flag For module 1 */
        uint8_t MWUF2 : 1;             /*!< [2] Wakeup flag For module 2 */
        uint8_t MWUF3 : 1;             /*!< [3] Wakeup flag For module 3 */
        uint8_t MWUF4 : 1;             /*!< [4] Wakeup flag For module 4 */
        uint8_t MWUF5 : 1;             /*!< [5] Wakeup flag For module 5 */
        uint8_t MWUF6 : 1;             /*!< [6] Wakeup flag For module 6 */
        uint8_t MWUF7 : 1;             /*!< [7] Wakeup flag For module 7 */
    } B;
} hw_llwu_f3_t;

/*!
 * @name Constants and macros for entire LLWU_F3 register
 */
/*@{*/
#define HW_LLWU_F3_ADDR(x)       ((uint32_t)(x) + 0x7U)

#define HW_LLWU_F3(x)            (*(__I hw_llwu_f3_t *) HW_LLWU_F3_ADDR(x))
#define HW_LLWU_F3_RD(x)         (HW_LLWU_F3(x).U)
/*@}*/

/*
 * Constants & macros for individual LLWU_F3 bitfields
 */

/*!
 * @name Register LLWU_F3, field MWUF0[0] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 0 input was not a wakeup source
 * - 1 - Module 0 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F3_MWUF0     (0U)          /*!< Bit position for LLWU_F3_MWUF0. */
#define BM_LLWU_F3_MWUF0     (0x01U)       /*!< Bit mask for LLWU_F3_MWUF0. */
#define BS_LLWU_F3_MWUF0     (1U)          /*!< Bit field size in bits for LLWU_F3_MWUF0. */

/*! @brief Read current value of the LLWU_F3_MWUF0 field. */
#define BR_LLWU_F3_MWUF0(x)  (BME_UBFX8(HW_LLWU_F3_ADDR(x), BP_LLWU_F3_MWUF0, BS_LLWU_F3_MWUF0))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF1[1] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 1 input was not a wakeup source
 * - 1 - Module 1 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F3_MWUF1     (1U)          /*!< Bit position for LLWU_F3_MWUF1. */
#define BM_LLWU_F3_MWUF1     (0x02U)       /*!< Bit mask for LLWU_F3_MWUF1. */
#define BS_LLWU_F3_MWUF1     (1U)          /*!< Bit field size in bits for LLWU_F3_MWUF1. */

/*! @brief Read current value of the LLWU_F3_MWUF1 field. */
#define BR_LLWU_F3_MWUF1(x)  (BME_UBFX8(HW_LLWU_F3_ADDR(x), BP_LLWU_F3_MWUF1, BS_LLWU_F3_MWUF1))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF2[2] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 2 input was not a wakeup source
 * - 1 - Module 2 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F3_MWUF2     (2U)          /*!< Bit position for LLWU_F3_MWUF2. */
#define BM_LLWU_F3_MWUF2     (0x04U)       /*!< Bit mask for LLWU_F3_MWUF2. */
#define BS_LLWU_F3_MWUF2     (1U)          /*!< Bit field size in bits for LLWU_F3_MWUF2. */

/*! @brief Read current value of the LLWU_F3_MWUF2 field. */
#define BR_LLWU_F3_MWUF2(x)  (BME_UBFX8(HW_LLWU_F3_ADDR(x), BP_LLWU_F3_MWUF2, BS_LLWU_F3_MWUF2))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF3[3] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 3 input was not a wakeup source
 * - 1 - Module 3 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F3_MWUF3     (3U)          /*!< Bit position for LLWU_F3_MWUF3. */
#define BM_LLWU_F3_MWUF3     (0x08U)       /*!< Bit mask for LLWU_F3_MWUF3. */
#define BS_LLWU_F3_MWUF3     (1U)          /*!< Bit field size in bits for LLWU_F3_MWUF3. */

/*! @brief Read current value of the LLWU_F3_MWUF3 field. */
#define BR_LLWU_F3_MWUF3(x)  (BME_UBFX8(HW_LLWU_F3_ADDR(x), BP_LLWU_F3_MWUF3, BS_LLWU_F3_MWUF3))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF4[4] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 4 input was not a wakeup source
 * - 1 - Module 4 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F3_MWUF4     (4U)          /*!< Bit position for LLWU_F3_MWUF4. */
#define BM_LLWU_F3_MWUF4     (0x10U)       /*!< Bit mask for LLWU_F3_MWUF4. */
#define BS_LLWU_F3_MWUF4     (1U)          /*!< Bit field size in bits for LLWU_F3_MWUF4. */

/*! @brief Read current value of the LLWU_F3_MWUF4 field. */
#define BR_LLWU_F3_MWUF4(x)  (BME_UBFX8(HW_LLWU_F3_ADDR(x), BP_LLWU_F3_MWUF4, BS_LLWU_F3_MWUF4))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF5[5] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 5 input was not a wakeup source
 * - 1 - Module 5 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F3_MWUF5     (5U)          /*!< Bit position for LLWU_F3_MWUF5. */
#define BM_LLWU_F3_MWUF5     (0x20U)       /*!< Bit mask for LLWU_F3_MWUF5. */
#define BS_LLWU_F3_MWUF5     (1U)          /*!< Bit field size in bits for LLWU_F3_MWUF5. */

/*! @brief Read current value of the LLWU_F3_MWUF5 field. */
#define BR_LLWU_F3_MWUF5(x)  (BME_UBFX8(HW_LLWU_F3_ADDR(x), BP_LLWU_F3_MWUF5, BS_LLWU_F3_MWUF5))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF6[6] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 6 input was not a wakeup source
 * - 1 - Module 6 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F3_MWUF6     (6U)          /*!< Bit position for LLWU_F3_MWUF6. */
#define BM_LLWU_F3_MWUF6     (0x40U)       /*!< Bit mask for LLWU_F3_MWUF6. */
#define BS_LLWU_F3_MWUF6     (1U)          /*!< Bit field size in bits for LLWU_F3_MWUF6. */

/*! @brief Read current value of the LLWU_F3_MWUF6 field. */
#define BR_LLWU_F3_MWUF6(x)  (BME_UBFX8(HW_LLWU_F3_ADDR(x), BP_LLWU_F3_MWUF6, BS_LLWU_F3_MWUF6))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF7[7] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 7 input was not a wakeup source
 * - 1 - Module 7 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F3_MWUF7     (7U)          /*!< Bit position for LLWU_F3_MWUF7. */
#define BM_LLWU_F3_MWUF7     (0x80U)       /*!< Bit mask for LLWU_F3_MWUF7. */
#define BS_LLWU_F3_MWUF7     (1U)          /*!< Bit field size in bits for LLWU_F3_MWUF7. */

/*! @brief Read current value of the LLWU_F3_MWUF7 field. */
#define BR_LLWU_F3_MWUF7(x)  (BME_UBFX8(HW_LLWU_F3_ADDR(x), BP_LLWU_F3_MWUF7, BS_LLWU_F3_MWUF7))
/*@}*/

/*******************************************************************************
 * HW_LLWU_FILT1 - LLWU Pin Filter 1 register
 ******************************************************************************/

/*!
 * @brief HW_LLWU_FILT1 - LLWU Pin Filter 1 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_FILT1 is a control and status register that is used to enable/disable
 * the digital filter 1 features for an external pin. This register is reset on
 * Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See
 * the chip's reset chapter for more information. details for more information.
 */
typedef union _hw_llwu_filt1
{
    uint8_t U;
    struct _hw_llwu_filt1_bitfields
    {
        uint8_t FILTSEL : 4;           /*!< [3:0] Filter Pin Select */
        uint8_t RESERVED0 : 1;         /*!< [4]  */
        uint8_t FILTE : 2;             /*!< [6:5] Digital Filter On External Pin */
        uint8_t FILTF : 1;             /*!< [7] Filter Detect Flag */
    } B;
} hw_llwu_filt1_t;

/*!
 * @name Constants and macros for entire LLWU_FILT1 register
 */
/*@{*/
#define HW_LLWU_FILT1_ADDR(x)    ((uint32_t)(x) + 0x8U)

#define HW_LLWU_FILT1(x)         (*(__IO hw_llwu_filt1_t *) HW_LLWU_FILT1_ADDR(x))
#define HW_LLWU_FILT1_RD(x)      (HW_LLWU_FILT1(x).U)
#define HW_LLWU_FILT1_WR(x, v)   (HW_LLWU_FILT1(x).U = (v))
#define HW_LLWU_FILT1_SET(x, v)  (BME_OR8(HW_LLWU_FILT1_ADDR(x), (uint8_t)(v)))
#define HW_LLWU_FILT1_CLR(x, v)  (BME_AND8(HW_LLWU_FILT1_ADDR(x), (uint8_t)(~(v))))
#define HW_LLWU_FILT1_TOG(x, v)  (BME_XOR8(HW_LLWU_FILT1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LLWU_FILT1 bitfields
 */

/*!
 * @name Register LLWU_FILT1, field FILTSEL[3:0] (RW)
 *
 * Selects 1 out of the 16 wakeup pins to be muxed into the filter.
 *
 * Values:
 * - 0000 - Select LLWU_P0 for filter
 * - 1111 - Select LLWU_P15 for filter
 */
/*@{*/
#define BP_LLWU_FILT1_FILTSEL (0U)         /*!< Bit position for LLWU_FILT1_FILTSEL. */
#define BM_LLWU_FILT1_FILTSEL (0x0FU)      /*!< Bit mask for LLWU_FILT1_FILTSEL. */
#define BS_LLWU_FILT1_FILTSEL (4U)         /*!< Bit field size in bits for LLWU_FILT1_FILTSEL. */

/*! @brief Read current value of the LLWU_FILT1_FILTSEL field. */
#define BR_LLWU_FILT1_FILTSEL(x) (BME_UBFX8(HW_LLWU_FILT1_ADDR(x), BP_LLWU_FILT1_FILTSEL, BS_LLWU_FILT1_FILTSEL))

/*! @brief Format value for bitfield LLWU_FILT1_FILTSEL. */
#define BF_LLWU_FILT1_FILTSEL(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_FILT1_FILTSEL) & BM_LLWU_FILT1_FILTSEL)

/*! @brief Set the FILTSEL field to a new value. */
#define BW_LLWU_FILT1_FILTSEL(x, v) (BME_BFI8(HW_LLWU_FILT1_ADDR(x), ((uint8_t)(v) << BP_LLWU_FILT1_FILTSEL), BP_LLWU_FILT1_FILTSEL, 4))
/*@}*/

/*!
 * @name Register LLWU_FILT1, field FILTE[6:5] (RW)
 *
 * Controls the digital filter options for the external pin detect.
 *
 * Values:
 * - 00 - Filter disabled
 * - 01 - Filter posedge detect enabled
 * - 10 - Filter negedge detect enabled
 * - 11 - Filter any edge detect enabled
 */
/*@{*/
#define BP_LLWU_FILT1_FILTE  (5U)          /*!< Bit position for LLWU_FILT1_FILTE. */
#define BM_LLWU_FILT1_FILTE  (0x60U)       /*!< Bit mask for LLWU_FILT1_FILTE. */
#define BS_LLWU_FILT1_FILTE  (2U)          /*!< Bit field size in bits for LLWU_FILT1_FILTE. */

/*! @brief Read current value of the LLWU_FILT1_FILTE field. */
#define BR_LLWU_FILT1_FILTE(x) (BME_UBFX8(HW_LLWU_FILT1_ADDR(x), BP_LLWU_FILT1_FILTE, BS_LLWU_FILT1_FILTE))

/*! @brief Format value for bitfield LLWU_FILT1_FILTE. */
#define BF_LLWU_FILT1_FILTE(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_FILT1_FILTE) & BM_LLWU_FILT1_FILTE)

/*! @brief Set the FILTE field to a new value. */
#define BW_LLWU_FILT1_FILTE(x, v) (BME_BFI8(HW_LLWU_FILT1_ADDR(x), ((uint8_t)(v) << BP_LLWU_FILT1_FILTE), BP_LLWU_FILT1_FILTE, 2))
/*@}*/

/*!
 * @name Register LLWU_FILT1, field FILTF[7] (W1C)
 *
 * Indicates that the filtered external wakeup pin, selected by FILTSEL, was a
 * source of exiting a low-leakage power mode. To clear the flag write a one to
 * FILTF.
 *
 * Values:
 * - 0 - Pin Filter 1 was not a wakeup source
 * - 1 - Pin Filter 1 was a wakeup source
 */
/*@{*/
#define BP_LLWU_FILT1_FILTF  (7U)          /*!< Bit position for LLWU_FILT1_FILTF. */
#define BM_LLWU_FILT1_FILTF  (0x80U)       /*!< Bit mask for LLWU_FILT1_FILTF. */
#define BS_LLWU_FILT1_FILTF  (1U)          /*!< Bit field size in bits for LLWU_FILT1_FILTF. */

/*! @brief Read current value of the LLWU_FILT1_FILTF field. */
#define BR_LLWU_FILT1_FILTF(x) (BME_UBFX8(HW_LLWU_FILT1_ADDR(x), BP_LLWU_FILT1_FILTF, BS_LLWU_FILT1_FILTF))

/*! @brief Format value for bitfield LLWU_FILT1_FILTF. */
#define BF_LLWU_FILT1_FILTF(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_FILT1_FILTF) & BM_LLWU_FILT1_FILTF)

/*! @brief Set the FILTF field to a new value. */
#define BW_LLWU_FILT1_FILTF(x, v) (BME_BFI8(HW_LLWU_FILT1_ADDR(x), ((uint8_t)(v) << BP_LLWU_FILT1_FILTF), BP_LLWU_FILT1_FILTF, 1))
/*@}*/

/*******************************************************************************
 * HW_LLWU_FILT2 - LLWU Pin Filter 2 register
 ******************************************************************************/

/*!
 * @brief HW_LLWU_FILT2 - LLWU Pin Filter 2 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_FILT2 is a control and status register that is used to enable/disable
 * the digital filter 2 features for an external pin. This register is reset on
 * Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See
 * the chip's reset chapter for more information. details for more information.
 */
typedef union _hw_llwu_filt2
{
    uint8_t U;
    struct _hw_llwu_filt2_bitfields
    {
        uint8_t FILTSEL : 4;           /*!< [3:0] Filter Pin Select */
        uint8_t RESERVED0 : 1;         /*!< [4]  */
        uint8_t FILTE : 2;             /*!< [6:5] Digital Filter On External Pin */
        uint8_t FILTF : 1;             /*!< [7] Filter Detect Flag */
    } B;
} hw_llwu_filt2_t;

/*!
 * @name Constants and macros for entire LLWU_FILT2 register
 */
/*@{*/
#define HW_LLWU_FILT2_ADDR(x)    ((uint32_t)(x) + 0x9U)

#define HW_LLWU_FILT2(x)         (*(__IO hw_llwu_filt2_t *) HW_LLWU_FILT2_ADDR(x))
#define HW_LLWU_FILT2_RD(x)      (HW_LLWU_FILT2(x).U)
#define HW_LLWU_FILT2_WR(x, v)   (HW_LLWU_FILT2(x).U = (v))
#define HW_LLWU_FILT2_SET(x, v)  (BME_OR8(HW_LLWU_FILT2_ADDR(x), (uint8_t)(v)))
#define HW_LLWU_FILT2_CLR(x, v)  (BME_AND8(HW_LLWU_FILT2_ADDR(x), (uint8_t)(~(v))))
#define HW_LLWU_FILT2_TOG(x, v)  (BME_XOR8(HW_LLWU_FILT2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LLWU_FILT2 bitfields
 */

/*!
 * @name Register LLWU_FILT2, field FILTSEL[3:0] (RW)
 *
 * Selects 1 out of the 16 wakeup pins to be muxed into the filter.
 *
 * Values:
 * - 0000 - Select LLWU_P0 for filter
 * - 1111 - Select LLWU_P15 for filter
 */
/*@{*/
#define BP_LLWU_FILT2_FILTSEL (0U)         /*!< Bit position for LLWU_FILT2_FILTSEL. */
#define BM_LLWU_FILT2_FILTSEL (0x0FU)      /*!< Bit mask for LLWU_FILT2_FILTSEL. */
#define BS_LLWU_FILT2_FILTSEL (4U)         /*!< Bit field size in bits for LLWU_FILT2_FILTSEL. */

/*! @brief Read current value of the LLWU_FILT2_FILTSEL field. */
#define BR_LLWU_FILT2_FILTSEL(x) (BME_UBFX8(HW_LLWU_FILT2_ADDR(x), BP_LLWU_FILT2_FILTSEL, BS_LLWU_FILT2_FILTSEL))

/*! @brief Format value for bitfield LLWU_FILT2_FILTSEL. */
#define BF_LLWU_FILT2_FILTSEL(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_FILT2_FILTSEL) & BM_LLWU_FILT2_FILTSEL)

/*! @brief Set the FILTSEL field to a new value. */
#define BW_LLWU_FILT2_FILTSEL(x, v) (BME_BFI8(HW_LLWU_FILT2_ADDR(x), ((uint8_t)(v) << BP_LLWU_FILT2_FILTSEL), BP_LLWU_FILT2_FILTSEL, 4))
/*@}*/

/*!
 * @name Register LLWU_FILT2, field FILTE[6:5] (RW)
 *
 * Controls the digital filter options for the external pin detect.
 *
 * Values:
 * - 00 - Filter disabled
 * - 01 - Filter posedge detect enabled
 * - 10 - Filter negedge detect enabled
 * - 11 - Filter any edge detect enabled
 */
/*@{*/
#define BP_LLWU_FILT2_FILTE  (5U)          /*!< Bit position for LLWU_FILT2_FILTE. */
#define BM_LLWU_FILT2_FILTE  (0x60U)       /*!< Bit mask for LLWU_FILT2_FILTE. */
#define BS_LLWU_FILT2_FILTE  (2U)          /*!< Bit field size in bits for LLWU_FILT2_FILTE. */

/*! @brief Read current value of the LLWU_FILT2_FILTE field. */
#define BR_LLWU_FILT2_FILTE(x) (BME_UBFX8(HW_LLWU_FILT2_ADDR(x), BP_LLWU_FILT2_FILTE, BS_LLWU_FILT2_FILTE))

/*! @brief Format value for bitfield LLWU_FILT2_FILTE. */
#define BF_LLWU_FILT2_FILTE(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_FILT2_FILTE) & BM_LLWU_FILT2_FILTE)

/*! @brief Set the FILTE field to a new value. */
#define BW_LLWU_FILT2_FILTE(x, v) (BME_BFI8(HW_LLWU_FILT2_ADDR(x), ((uint8_t)(v) << BP_LLWU_FILT2_FILTE), BP_LLWU_FILT2_FILTE, 2))
/*@}*/

/*!
 * @name Register LLWU_FILT2, field FILTF[7] (W1C)
 *
 * Indicates that the filtered external wakeup pin, selected by FILTSEL, was a
 * source of exiting a low-leakage power mode. To clear the flag write a one to
 * FILTF.
 *
 * Values:
 * - 0 - Pin Filter 2 was not a wakeup source
 * - 1 - Pin Filter 2 was a wakeup source
 */
/*@{*/
#define BP_LLWU_FILT2_FILTF  (7U)          /*!< Bit position for LLWU_FILT2_FILTF. */
#define BM_LLWU_FILT2_FILTF  (0x80U)       /*!< Bit mask for LLWU_FILT2_FILTF. */
#define BS_LLWU_FILT2_FILTF  (1U)          /*!< Bit field size in bits for LLWU_FILT2_FILTF. */

/*! @brief Read current value of the LLWU_FILT2_FILTF field. */
#define BR_LLWU_FILT2_FILTF(x) (BME_UBFX8(HW_LLWU_FILT2_ADDR(x), BP_LLWU_FILT2_FILTF, BS_LLWU_FILT2_FILTF))

/*! @brief Format value for bitfield LLWU_FILT2_FILTF. */
#define BF_LLWU_FILT2_FILTF(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_FILT2_FILTF) & BM_LLWU_FILT2_FILTF)

/*! @brief Set the FILTF field to a new value. */
#define BW_LLWU_FILT2_FILTF(x, v) (BME_BFI8(HW_LLWU_FILT2_ADDR(x), ((uint8_t)(v) << BP_LLWU_FILT2_FILTF), BP_LLWU_FILT2_FILTF, 1))
/*@}*/

/*******************************************************************************
 * hw_llwu_t - module struct
 ******************************************************************************/
/*!
 * @brief All LLWU module registers.
 */
#pragma pack(1)
typedef struct _hw_llwu
{
    __IO hw_llwu_pe1_t PE1;                /*!< [0x0] LLWU Pin Enable 1 register */
    __IO hw_llwu_pe2_t PE2;                /*!< [0x1] LLWU Pin Enable 2 register */
    __IO hw_llwu_pe3_t PE3;                /*!< [0x2] LLWU Pin Enable 3 register */
    __IO hw_llwu_pe4_t PE4;                /*!< [0x3] LLWU Pin Enable 4 register */
    __IO hw_llwu_me_t ME;                  /*!< [0x4] LLWU Module Enable register */
    __IO hw_llwu_f1_t F1;                  /*!< [0x5] LLWU Flag 1 register */
    __IO hw_llwu_f2_t F2;                  /*!< [0x6] LLWU Flag 2 register */
    __I hw_llwu_f3_t F3;                   /*!< [0x7] LLWU Flag 3 register */
    __IO hw_llwu_filt1_t FILT1;            /*!< [0x8] LLWU Pin Filter 1 register */
    __IO hw_llwu_filt2_t FILT2;            /*!< [0x9] LLWU Pin Filter 2 register */
} hw_llwu_t;
#pragma pack()

/*! @brief Macro to access all LLWU registers. */
/*! @param x LLWU module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_LLWU_REGS(LLWU_BASE)</code>. */
#define HW_LLWU_REGS(x) (*(hw_llwu_t *)(x))

/*
 * MKL43Z4 LPTMR
 *
 * Low Power Timer
 *
 * Registers defined in this header file:
 * - HW_LPTMR_CSR - Low Power Timer Control Status Register
 * - HW_LPTMR_PSR - Low Power Timer Prescale Register
 * - HW_LPTMR_CMR - Low Power Timer Compare Register
 * - HW_LPTMR_CNR - Low Power Timer Counter Register
 *
 * - hw_lptmr_t - Struct containing all module registers.
 */

#define HW_LPTMR_INSTANCE_COUNT (1U) /*!< Number of instances of the LPTMR module. */
#define HW_LPTMR0 (0U) /*!< Instance number for LPTMR0. */

/*******************************************************************************
 * HW_LPTMR_CSR - Low Power Timer Control Status Register
 ******************************************************************************/

/*!
 * @brief HW_LPTMR_CSR - Low Power Timer Control Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_lptmr_csr
{
    uint32_t U;
    struct _hw_lptmr_csr_bitfields
    {
        uint32_t TEN : 1;              /*!< [0] Timer Enable */
        uint32_t TMS : 1;              /*!< [1] Timer Mode Select */
        uint32_t TFC : 1;              /*!< [2] Timer Free-Running Counter */
        uint32_t TPP : 1;              /*!< [3] Timer Pin Polarity */
        uint32_t TPS : 2;              /*!< [5:4] Timer Pin Select */
        uint32_t TIE : 1;              /*!< [6] Timer Interrupt Enable */
        uint32_t TCF : 1;              /*!< [7] Timer Compare Flag */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_lptmr_csr_t;

/*!
 * @name Constants and macros for entire LPTMR_CSR register
 */
/*@{*/
#define HW_LPTMR_CSR_ADDR(x)     ((uint32_t)(x) + 0x0U)

#define HW_LPTMR_CSR(x)          (*(__IO hw_lptmr_csr_t *) HW_LPTMR_CSR_ADDR(x))
#define HW_LPTMR_CSR_RD(x)       (HW_LPTMR_CSR(x).U)
#define HW_LPTMR_CSR_WR(x, v)    (HW_LPTMR_CSR(x).U = (v))
#define HW_LPTMR_CSR_SET(x, v)   (BME_OR32(HW_LPTMR_CSR_ADDR(x), (uint32_t)(v)))
#define HW_LPTMR_CSR_CLR(x, v)   (BME_AND32(HW_LPTMR_CSR_ADDR(x), (uint32_t)(~(v))))
#define HW_LPTMR_CSR_TOG(x, v)   (BME_XOR32(HW_LPTMR_CSR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CSR bitfields
 */

/*!
 * @name Register LPTMR_CSR, field TEN[0] (RW)
 *
 * When TEN is clear, it resets the LPTMR internal logic, including the CNR and
 * TCF. When TEN is set, the LPTMR is enabled. While writing 1 to this field,
 * CSR[5:1] must not be altered.
 *
 * Values:
 * - 0 - LPTMR is disabled and internal logic is reset.
 * - 1 - LPTMR is enabled.
 */
/*@{*/
#define BP_LPTMR_CSR_TEN     (0U)          /*!< Bit position for LPTMR_CSR_TEN. */
#define BM_LPTMR_CSR_TEN     (0x00000001U) /*!< Bit mask for LPTMR_CSR_TEN. */
#define BS_LPTMR_CSR_TEN     (1U)          /*!< Bit field size in bits for LPTMR_CSR_TEN. */

/*! @brief Read current value of the LPTMR_CSR_TEN field. */
#define BR_LPTMR_CSR_TEN(x)  (BME_UBFX32(HW_LPTMR_CSR_ADDR(x), BP_LPTMR_CSR_TEN, BS_LPTMR_CSR_TEN))

/*! @brief Format value for bitfield LPTMR_CSR_TEN. */
#define BF_LPTMR_CSR_TEN(v)  ((uint32_t)((uint32_t)(v) << BP_LPTMR_CSR_TEN) & BM_LPTMR_CSR_TEN)

/*! @brief Set the TEN field to a new value. */
#define BW_LPTMR_CSR_TEN(x, v) (BME_BFI32(HW_LPTMR_CSR_ADDR(x), ((uint32_t)(v) << BP_LPTMR_CSR_TEN), BP_LPTMR_CSR_TEN, 1))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TMS[1] (RW)
 *
 * Configures the mode of the LPTMR. TMS must be altered only when the LPTMR is
 * disabled.
 *
 * Values:
 * - 0 - Time Counter mode.
 * - 1 - Pulse Counter mode.
 */
/*@{*/
#define BP_LPTMR_CSR_TMS     (1U)          /*!< Bit position for LPTMR_CSR_TMS. */
#define BM_LPTMR_CSR_TMS     (0x00000002U) /*!< Bit mask for LPTMR_CSR_TMS. */
#define BS_LPTMR_CSR_TMS     (1U)          /*!< Bit field size in bits for LPTMR_CSR_TMS. */

/*! @brief Read current value of the LPTMR_CSR_TMS field. */
#define BR_LPTMR_CSR_TMS(x)  (BME_UBFX32(HW_LPTMR_CSR_ADDR(x), BP_LPTMR_CSR_TMS, BS_LPTMR_CSR_TMS))

/*! @brief Format value for bitfield LPTMR_CSR_TMS. */
#define BF_LPTMR_CSR_TMS(v)  ((uint32_t)((uint32_t)(v) << BP_LPTMR_CSR_TMS) & BM_LPTMR_CSR_TMS)

/*! @brief Set the TMS field to a new value. */
#define BW_LPTMR_CSR_TMS(x, v) (BME_BFI32(HW_LPTMR_CSR_ADDR(x), ((uint32_t)(v) << BP_LPTMR_CSR_TMS), BP_LPTMR_CSR_TMS, 1))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TFC[2] (RW)
 *
 * When clear, TFC configures the CNR to reset whenever TCF is set. When set,
 * TFC configures the CNR to reset on overflow. TFC must be altered only when the
 * LPTMR is disabled.
 *
 * Values:
 * - 0 - CNR is reset whenever TCF is set.
 * - 1 - CNR is reset on overflow.
 */
/*@{*/
#define BP_LPTMR_CSR_TFC     (2U)          /*!< Bit position for LPTMR_CSR_TFC. */
#define BM_LPTMR_CSR_TFC     (0x00000004U) /*!< Bit mask for LPTMR_CSR_TFC. */
#define BS_LPTMR_CSR_TFC     (1U)          /*!< Bit field size in bits for LPTMR_CSR_TFC. */

/*! @brief Read current value of the LPTMR_CSR_TFC field. */
#define BR_LPTMR_CSR_TFC(x)  (BME_UBFX32(HW_LPTMR_CSR_ADDR(x), BP_LPTMR_CSR_TFC, BS_LPTMR_CSR_TFC))

/*! @brief Format value for bitfield LPTMR_CSR_TFC. */
#define BF_LPTMR_CSR_TFC(v)  ((uint32_t)((uint32_t)(v) << BP_LPTMR_CSR_TFC) & BM_LPTMR_CSR_TFC)

/*! @brief Set the TFC field to a new value. */
#define BW_LPTMR_CSR_TFC(x, v) (BME_BFI32(HW_LPTMR_CSR_ADDR(x), ((uint32_t)(v) << BP_LPTMR_CSR_TFC), BP_LPTMR_CSR_TFC, 1))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TPP[3] (RW)
 *
 * Configures the polarity of the input source in Pulse Counter mode. TPP must
 * be changed only when the LPTMR is disabled.
 *
 * Values:
 * - 0 - Pulse Counter input source is active-high, and the CNR will increment
 *     on the rising-edge.
 * - 1 - Pulse Counter input source is active-low, and the CNR will increment on
 *     the falling-edge.
 */
/*@{*/
#define BP_LPTMR_CSR_TPP     (3U)          /*!< Bit position for LPTMR_CSR_TPP. */
#define BM_LPTMR_CSR_TPP     (0x00000008U) /*!< Bit mask for LPTMR_CSR_TPP. */
#define BS_LPTMR_CSR_TPP     (1U)          /*!< Bit field size in bits for LPTMR_CSR_TPP. */

/*! @brief Read current value of the LPTMR_CSR_TPP field. */
#define BR_LPTMR_CSR_TPP(x)  (BME_UBFX32(HW_LPTMR_CSR_ADDR(x), BP_LPTMR_CSR_TPP, BS_LPTMR_CSR_TPP))

/*! @brief Format value for bitfield LPTMR_CSR_TPP. */
#define BF_LPTMR_CSR_TPP(v)  ((uint32_t)((uint32_t)(v) << BP_LPTMR_CSR_TPP) & BM_LPTMR_CSR_TPP)

/*! @brief Set the TPP field to a new value. */
#define BW_LPTMR_CSR_TPP(x, v) (BME_BFI32(HW_LPTMR_CSR_ADDR(x), ((uint32_t)(v) << BP_LPTMR_CSR_TPP), BP_LPTMR_CSR_TPP, 1))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TPS[5:4] (RW)
 *
 * Configures the input source to be used in Pulse Counter mode. TPS must be
 * altered only when the LPTMR is disabled. The input connections vary by device.
 * See the for information on the connections to these inputs.
 *
 * Values:
 * - 00 - Pulse counter input 0 is selected.
 * - 01 - Pulse counter input 1 is selected.
 * - 10 - Pulse counter input 2 is selected.
 * - 11 - Pulse counter input 3 is selected.
 */
/*@{*/
#define BP_LPTMR_CSR_TPS     (4U)          /*!< Bit position for LPTMR_CSR_TPS. */
#define BM_LPTMR_CSR_TPS     (0x00000030U) /*!< Bit mask for LPTMR_CSR_TPS. */
#define BS_LPTMR_CSR_TPS     (2U)          /*!< Bit field size in bits for LPTMR_CSR_TPS. */

/*! @brief Read current value of the LPTMR_CSR_TPS field. */
#define BR_LPTMR_CSR_TPS(x)  (BME_UBFX32(HW_LPTMR_CSR_ADDR(x), BP_LPTMR_CSR_TPS, BS_LPTMR_CSR_TPS))

/*! @brief Format value for bitfield LPTMR_CSR_TPS. */
#define BF_LPTMR_CSR_TPS(v)  ((uint32_t)((uint32_t)(v) << BP_LPTMR_CSR_TPS) & BM_LPTMR_CSR_TPS)

/*! @brief Set the TPS field to a new value. */
#define BW_LPTMR_CSR_TPS(x, v) (BME_BFI32(HW_LPTMR_CSR_ADDR(x), ((uint32_t)(v) << BP_LPTMR_CSR_TPS), BP_LPTMR_CSR_TPS, 2))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TIE[6] (RW)
 *
 * When TIE is set, the LPTMR Interrupt is generated whenever TCF is also set.
 *
 * Values:
 * - 0 - Timer interrupt disabled.
 * - 1 - Timer interrupt enabled.
 */
/*@{*/
#define BP_LPTMR_CSR_TIE     (6U)          /*!< Bit position for LPTMR_CSR_TIE. */
#define BM_LPTMR_CSR_TIE     (0x00000040U) /*!< Bit mask for LPTMR_CSR_TIE. */
#define BS_LPTMR_CSR_TIE     (1U)          /*!< Bit field size in bits for LPTMR_CSR_TIE. */

/*! @brief Read current value of the LPTMR_CSR_TIE field. */
#define BR_LPTMR_CSR_TIE(x)  (BME_UBFX32(HW_LPTMR_CSR_ADDR(x), BP_LPTMR_CSR_TIE, BS_LPTMR_CSR_TIE))

/*! @brief Format value for bitfield LPTMR_CSR_TIE. */
#define BF_LPTMR_CSR_TIE(v)  ((uint32_t)((uint32_t)(v) << BP_LPTMR_CSR_TIE) & BM_LPTMR_CSR_TIE)

/*! @brief Set the TIE field to a new value. */
#define BW_LPTMR_CSR_TIE(x, v) (BME_BFI32(HW_LPTMR_CSR_ADDR(x), ((uint32_t)(v) << BP_LPTMR_CSR_TIE), BP_LPTMR_CSR_TIE, 1))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TCF[7] (W1C)
 *
 * TCF is set when the LPTMR is enabled and the CNR equals the CMR and
 * increments. TCF is cleared when the LPTMR is disabled or a logic 1 is written to it.
 *
 * Values:
 * - 0 - The value of CNR is not equal to CMR and increments.
 * - 1 - The value of CNR is equal to CMR and increments.
 */
/*@{*/
#define BP_LPTMR_CSR_TCF     (7U)          /*!< Bit position for LPTMR_CSR_TCF. */
#define BM_LPTMR_CSR_TCF     (0x00000080U) /*!< Bit mask for LPTMR_CSR_TCF. */
#define BS_LPTMR_CSR_TCF     (1U)          /*!< Bit field size in bits for LPTMR_CSR_TCF. */

/*! @brief Read current value of the LPTMR_CSR_TCF field. */
#define BR_LPTMR_CSR_TCF(x)  (BME_UBFX32(HW_LPTMR_CSR_ADDR(x), BP_LPTMR_CSR_TCF, BS_LPTMR_CSR_TCF))

/*! @brief Format value for bitfield LPTMR_CSR_TCF. */
#define BF_LPTMR_CSR_TCF(v)  ((uint32_t)((uint32_t)(v) << BP_LPTMR_CSR_TCF) & BM_LPTMR_CSR_TCF)

/*! @brief Set the TCF field to a new value. */
#define BW_LPTMR_CSR_TCF(x, v) (BME_BFI32(HW_LPTMR_CSR_ADDR(x), ((uint32_t)(v) << BP_LPTMR_CSR_TCF), BP_LPTMR_CSR_TCF, 1))
/*@}*/

/*******************************************************************************
 * HW_LPTMR_PSR - Low Power Timer Prescale Register
 ******************************************************************************/

/*!
 * @brief HW_LPTMR_PSR - Low Power Timer Prescale Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_lptmr_psr
{
    uint32_t U;
    struct _hw_lptmr_psr_bitfields
    {
        uint32_t PCS : 2;              /*!< [1:0] Prescaler Clock Select */
        uint32_t PBYP : 1;             /*!< [2] Prescaler Bypass */
        uint32_t PRESCALE : 4;         /*!< [6:3] Prescale Value */
        uint32_t RESERVED0 : 25;       /*!< [31:7]  */
    } B;
} hw_lptmr_psr_t;

/*!
 * @name Constants and macros for entire LPTMR_PSR register
 */
/*@{*/
#define HW_LPTMR_PSR_ADDR(x)     ((uint32_t)(x) + 0x4U)

#define HW_LPTMR_PSR(x)          (*(__IO hw_lptmr_psr_t *) HW_LPTMR_PSR_ADDR(x))
#define HW_LPTMR_PSR_RD(x)       (HW_LPTMR_PSR(x).U)
#define HW_LPTMR_PSR_WR(x, v)    (HW_LPTMR_PSR(x).U = (v))
#define HW_LPTMR_PSR_SET(x, v)   (BME_OR32(HW_LPTMR_PSR_ADDR(x), (uint32_t)(v)))
#define HW_LPTMR_PSR_CLR(x, v)   (BME_AND32(HW_LPTMR_PSR_ADDR(x), (uint32_t)(~(v))))
#define HW_LPTMR_PSR_TOG(x, v)   (BME_XOR32(HW_LPTMR_PSR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_PSR bitfields
 */

/*!
 * @name Register LPTMR_PSR, field PCS[1:0] (RW)
 *
 * Selects the clock to be used by the LPTMR prescaler/glitch filter. PCS must
 * be altered only when the LPTMR is disabled. The clock connections vary by
 * device. See the chip configuration details for information on the connections to
 * these inputs.
 *
 * Values:
 * - 00 - Prescaler/glitch filter clock 0 selected.
 * - 01 - Prescaler/glitch filter clock 1 selected.
 * - 10 - Prescaler/glitch filter clock 2 selected.
 * - 11 - Prescaler/glitch filter clock 3 selected.
 */
/*@{*/
#define BP_LPTMR_PSR_PCS     (0U)          /*!< Bit position for LPTMR_PSR_PCS. */
#define BM_LPTMR_PSR_PCS     (0x00000003U) /*!< Bit mask for LPTMR_PSR_PCS. */
#define BS_LPTMR_PSR_PCS     (2U)          /*!< Bit field size in bits for LPTMR_PSR_PCS. */

/*! @brief Read current value of the LPTMR_PSR_PCS field. */
#define BR_LPTMR_PSR_PCS(x)  (BME_UBFX32(HW_LPTMR_PSR_ADDR(x), BP_LPTMR_PSR_PCS, BS_LPTMR_PSR_PCS))

/*! @brief Format value for bitfield LPTMR_PSR_PCS. */
#define BF_LPTMR_PSR_PCS(v)  ((uint32_t)((uint32_t)(v) << BP_LPTMR_PSR_PCS) & BM_LPTMR_PSR_PCS)

/*! @brief Set the PCS field to a new value. */
#define BW_LPTMR_PSR_PCS(x, v) (BME_BFI32(HW_LPTMR_PSR_ADDR(x), ((uint32_t)(v) << BP_LPTMR_PSR_PCS), BP_LPTMR_PSR_PCS, 2))
/*@}*/

/*!
 * @name Register LPTMR_PSR, field PBYP[2] (RW)
 *
 * When PBYP is set, the selected prescaler clock in Time Counter mode or
 * selected input source in Pulse Counter mode directly clocks the CNR. When PBYP is
 * clear, the CNR is clocked by the output of the prescaler/glitch filter. PBYP
 * must be altered only when the LPTMR is disabled.
 *
 * Values:
 * - 0 - Prescaler/glitch filter is enabled.
 * - 1 - Prescaler/glitch filter is bypassed.
 */
/*@{*/
#define BP_LPTMR_PSR_PBYP    (2U)          /*!< Bit position for LPTMR_PSR_PBYP. */
#define BM_LPTMR_PSR_PBYP    (0x00000004U) /*!< Bit mask for LPTMR_PSR_PBYP. */
#define BS_LPTMR_PSR_PBYP    (1U)          /*!< Bit field size in bits for LPTMR_PSR_PBYP. */

/*! @brief Read current value of the LPTMR_PSR_PBYP field. */
#define BR_LPTMR_PSR_PBYP(x) (BME_UBFX32(HW_LPTMR_PSR_ADDR(x), BP_LPTMR_PSR_PBYP, BS_LPTMR_PSR_PBYP))

/*! @brief Format value for bitfield LPTMR_PSR_PBYP. */
#define BF_LPTMR_PSR_PBYP(v) ((uint32_t)((uint32_t)(v) << BP_LPTMR_PSR_PBYP) & BM_LPTMR_PSR_PBYP)

/*! @brief Set the PBYP field to a new value. */
#define BW_LPTMR_PSR_PBYP(x, v) (BME_BFI32(HW_LPTMR_PSR_ADDR(x), ((uint32_t)(v) << BP_LPTMR_PSR_PBYP), BP_LPTMR_PSR_PBYP, 1))
/*@}*/

/*!
 * @name Register LPTMR_PSR, field PRESCALE[6:3] (RW)
 *
 * Configures the size of the Prescaler in Time Counter mode or width of the
 * glitch filter in Pulse Counter mode. PRESCALE must be altered only when the LPTMR
 * is disabled.
 *
 * Values:
 * - 0000 - Prescaler divides the prescaler clock by 2; glitch filter does not
 *     support this configuration.
 * - 0001 - Prescaler divides the prescaler clock by 4; glitch filter recognizes
 *     change on input pin after 2 rising clock edges.
 * - 0010 - Prescaler divides the prescaler clock by 8; glitch filter recognizes
 *     change on input pin after 4 rising clock edges.
 * - 0011 - Prescaler divides the prescaler clock by 16; glitch filter
 *     recognizes change on input pin after 8 rising clock edges.
 * - 0100 - Prescaler divides the prescaler clock by 32; glitch filter
 *     recognizes change on input pin after 16 rising clock edges.
 * - 0101 - Prescaler divides the prescaler clock by 64; glitch filter
 *     recognizes change on input pin after 32 rising clock edges.
 * - 0110 - Prescaler divides the prescaler clock by 128; glitch filter
 *     recognizes change on input pin after 64 rising clock edges.
 * - 0111 - Prescaler divides the prescaler clock by 256; glitch filter
 *     recognizes change on input pin after 128 rising clock edges.
 * - 1000 - Prescaler divides the prescaler clock by 512; glitch filter
 *     recognizes change on input pin after 256 rising clock edges.
 * - 1001 - Prescaler divides the prescaler clock by 1024; glitch filter
 *     recognizes change on input pin after 512 rising clock edges.
 * - 1010 - Prescaler divides the prescaler clock by 2048; glitch filter
 *     recognizes change on input pin after 1024 rising clock edges.
 * - 1011 - Prescaler divides the prescaler clock by 4096; glitch filter
 *     recognizes change on input pin after 2048 rising clock edges.
 * - 1100 - Prescaler divides the prescaler clock by 8192; glitch filter
 *     recognizes change on input pin after 4096 rising clock edges.
 * - 1101 - Prescaler divides the prescaler clock by 16,384; glitch filter
 *     recognizes change on input pin after 8192 rising clock edges.
 * - 1110 - Prescaler divides the prescaler clock by 32,768; glitch filter
 *     recognizes change on input pin after 16,384 rising clock edges.
 * - 1111 - Prescaler divides the prescaler clock by 65,536; glitch filter
 *     recognizes change on input pin after 32,768 rising clock edges.
 */
/*@{*/
#define BP_LPTMR_PSR_PRESCALE (3U)         /*!< Bit position for LPTMR_PSR_PRESCALE. */
#define BM_LPTMR_PSR_PRESCALE (0x00000078U) /*!< Bit mask for LPTMR_PSR_PRESCALE. */
#define BS_LPTMR_PSR_PRESCALE (4U)         /*!< Bit field size in bits for LPTMR_PSR_PRESCALE. */

/*! @brief Read current value of the LPTMR_PSR_PRESCALE field. */
#define BR_LPTMR_PSR_PRESCALE(x) (BME_UBFX32(HW_LPTMR_PSR_ADDR(x), BP_LPTMR_PSR_PRESCALE, BS_LPTMR_PSR_PRESCALE))

/*! @brief Format value for bitfield LPTMR_PSR_PRESCALE. */
#define BF_LPTMR_PSR_PRESCALE(v) ((uint32_t)((uint32_t)(v) << BP_LPTMR_PSR_PRESCALE) & BM_LPTMR_PSR_PRESCALE)

/*! @brief Set the PRESCALE field to a new value. */
#define BW_LPTMR_PSR_PRESCALE(x, v) (BME_BFI32(HW_LPTMR_PSR_ADDR(x), ((uint32_t)(v) << BP_LPTMR_PSR_PRESCALE), BP_LPTMR_PSR_PRESCALE, 4))
/*@}*/

/*******************************************************************************
 * HW_LPTMR_CMR - Low Power Timer Compare Register
 ******************************************************************************/

/*!
 * @brief HW_LPTMR_CMR - Low Power Timer Compare Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_lptmr_cmr
{
    uint32_t U;
    struct _hw_lptmr_cmr_bitfields
    {
        uint32_t COMPARE : 16;         /*!< [15:0] Compare Value */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_lptmr_cmr_t;

/*!
 * @name Constants and macros for entire LPTMR_CMR register
 */
/*@{*/
#define HW_LPTMR_CMR_ADDR(x)     ((uint32_t)(x) + 0x8U)

#define HW_LPTMR_CMR(x)          (*(__IO hw_lptmr_cmr_t *) HW_LPTMR_CMR_ADDR(x))
#define HW_LPTMR_CMR_RD(x)       (HW_LPTMR_CMR(x).U)
#define HW_LPTMR_CMR_WR(x, v)    (HW_LPTMR_CMR(x).U = (v))
#define HW_LPTMR_CMR_SET(x, v)   (BME_OR32(HW_LPTMR_CMR_ADDR(x), (uint32_t)(v)))
#define HW_LPTMR_CMR_CLR(x, v)   (BME_AND32(HW_LPTMR_CMR_ADDR(x), (uint32_t)(~(v))))
#define HW_LPTMR_CMR_TOG(x, v)   (BME_XOR32(HW_LPTMR_CMR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CMR bitfields
 */

/*!
 * @name Register LPTMR_CMR, field COMPARE[15:0] (RW)
 *
 * When the LPTMR is enabled and the CNR equals the value in the CMR and
 * increments, TCF is set and the hardware trigger asserts until the next time the CNR
 * increments. If the CMR is 0, the hardware trigger will remain asserted until
 * the LPTMR is disabled. If the LPTMR is enabled, the CMR must be altered only
 * when TCF is set.
 */
/*@{*/
#define BP_LPTMR_CMR_COMPARE (0U)          /*!< Bit position for LPTMR_CMR_COMPARE. */
#define BM_LPTMR_CMR_COMPARE (0x0000FFFFU) /*!< Bit mask for LPTMR_CMR_COMPARE. */
#define BS_LPTMR_CMR_COMPARE (16U)         /*!< Bit field size in bits for LPTMR_CMR_COMPARE. */

/*! @brief Read current value of the LPTMR_CMR_COMPARE field. */
#define BR_LPTMR_CMR_COMPARE(x) (BME_UBFX32(HW_LPTMR_CMR_ADDR(x), BP_LPTMR_CMR_COMPARE, BS_LPTMR_CMR_COMPARE))

/*! @brief Format value for bitfield LPTMR_CMR_COMPARE. */
#define BF_LPTMR_CMR_COMPARE(v) ((uint32_t)((uint32_t)(v) << BP_LPTMR_CMR_COMPARE) & BM_LPTMR_CMR_COMPARE)

/*! @brief Set the COMPARE field to a new value. */
#define BW_LPTMR_CMR_COMPARE(x, v) (BME_BFI32(HW_LPTMR_CMR_ADDR(x), ((uint32_t)(v) << BP_LPTMR_CMR_COMPARE), BP_LPTMR_CMR_COMPARE, 16))
/*@}*/

/*******************************************************************************
 * HW_LPTMR_CNR - Low Power Timer Counter Register
 ******************************************************************************/

/*!
 * @brief HW_LPTMR_CNR - Low Power Timer Counter Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_lptmr_cnr
{
    uint32_t U;
    struct _hw_lptmr_cnr_bitfields
    {
        uint32_t COUNTER : 16;         /*!< [15:0] Counter Value */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_lptmr_cnr_t;

/*!
 * @name Constants and macros for entire LPTMR_CNR register
 */
/*@{*/
#define HW_LPTMR_CNR_ADDR(x)     ((uint32_t)(x) + 0xCU)

#define HW_LPTMR_CNR(x)          (*(__IO hw_lptmr_cnr_t *) HW_LPTMR_CNR_ADDR(x))
#define HW_LPTMR_CNR_RD(x)       (HW_LPTMR_CNR(x).U)
#define HW_LPTMR_CNR_WR(x, v)    (HW_LPTMR_CNR(x).U = (v))
#define HW_LPTMR_CNR_SET(x, v)   (BME_OR32(HW_LPTMR_CNR_ADDR(x), (uint32_t)(v)))
#define HW_LPTMR_CNR_CLR(x, v)   (BME_AND32(HW_LPTMR_CNR_ADDR(x), (uint32_t)(~(v))))
#define HW_LPTMR_CNR_TOG(x, v)   (BME_XOR32(HW_LPTMR_CNR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CNR bitfields
 */

/*!
 * @name Register LPTMR_CNR, field COUNTER[15:0] (RW)
 */
/*@{*/
#define BP_LPTMR_CNR_COUNTER (0U)          /*!< Bit position for LPTMR_CNR_COUNTER. */
#define BM_LPTMR_CNR_COUNTER (0x0000FFFFU) /*!< Bit mask for LPTMR_CNR_COUNTER. */
#define BS_LPTMR_CNR_COUNTER (16U)         /*!< Bit field size in bits for LPTMR_CNR_COUNTER. */

/*! @brief Read current value of the LPTMR_CNR_COUNTER field. */
#define BR_LPTMR_CNR_COUNTER(x) (BME_UBFX32(HW_LPTMR_CNR_ADDR(x), BP_LPTMR_CNR_COUNTER, BS_LPTMR_CNR_COUNTER))

/*! @brief Format value for bitfield LPTMR_CNR_COUNTER. */
#define BF_LPTMR_CNR_COUNTER(v) ((uint32_t)((uint32_t)(v) << BP_LPTMR_CNR_COUNTER) & BM_LPTMR_CNR_COUNTER)

/*! @brief Set the COUNTER field to a new value. */
#define BW_LPTMR_CNR_COUNTER(x, v) (BME_BFI32(HW_LPTMR_CNR_ADDR(x), ((uint32_t)(v) << BP_LPTMR_CNR_COUNTER), BP_LPTMR_CNR_COUNTER, 16))
/*@}*/

/*******************************************************************************
 * hw_lptmr_t - module struct
 ******************************************************************************/
/*!
 * @brief All LPTMR module registers.
 */
#pragma pack(1)
typedef struct _hw_lptmr
{
    __IO hw_lptmr_csr_t CSR;               /*!< [0x0] Low Power Timer Control Status Register */
    __IO hw_lptmr_psr_t PSR;               /*!< [0x4] Low Power Timer Prescale Register */
    __IO hw_lptmr_cmr_t CMR;               /*!< [0x8] Low Power Timer Compare Register */
    __IO hw_lptmr_cnr_t CNR;               /*!< [0xC] Low Power Timer Counter Register */
} hw_lptmr_t;
#pragma pack()

/*! @brief Macro to access all LPTMR registers. */
/*! @param x LPTMR module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_LPTMR_REGS(LPTMR0_BASE)</code>. */
#define HW_LPTMR_REGS(x) (*(hw_lptmr_t *)(x))

/*
 * MKL43Z4 LPUART
 *
 * Universal Asynchronous Receiver/Transmitter
 *
 * Registers defined in this header file:
 * - HW_LPUART_BAUD - LPUART Baud Rate Register
 * - HW_LPUART_STAT - LPUART Status Register
 * - HW_LPUART_CTRL - LPUART Control Register
 * - HW_LPUART_DATA - LPUART Data Register
 * - HW_LPUART_MATCH - LPUART Match Address Register
 *
 * - hw_lpuart_t - Struct containing all module registers.
 */

#define HW_LPUART_INSTANCE_COUNT (2U) /*!< Number of instances of the LPUART module. */
#define HW_LPUART0 (0U) /*!< Instance number for LPUART0. */
#define HW_LPUART1 (1U) /*!< Instance number for LPUART1. */

/*******************************************************************************
 * HW_LPUART_BAUD - LPUART Baud Rate Register
 ******************************************************************************/

/*!
 * @brief HW_LPUART_BAUD - LPUART Baud Rate Register (RW)
 *
 * Reset value: 0x0F000004U
 */
typedef union _hw_lpuart_baud
{
    uint32_t U;
    struct _hw_lpuart_baud_bitfields
    {
        uint32_t SBR : 13;             /*!< [12:0] Baud Rate Modulo Divisor. */
        uint32_t SBNS : 1;             /*!< [13] Stop Bit Number Select */
        uint32_t RXEDGIE : 1;          /*!< [14] RX Input Active Edge Interrupt Enable
                                        * */
        uint32_t LBKDIE : 1;           /*!< [15] LIN Break Detect Interrupt Enable */
        uint32_t RESYNCDIS : 1;        /*!< [16] Resynchronization Disable */
        uint32_t BOTHEDGE : 1;         /*!< [17] Both Edge Sampling */
        uint32_t MATCFG : 2;           /*!< [19:18] Match Configuration */
        uint32_t RESERVED0 : 1;        /*!< [20]  */
        uint32_t RDMAE : 1;            /*!< [21] Receiver Full DMA Enable */
        uint32_t RESERVED1 : 1;        /*!< [22]  */
        uint32_t TDMAE : 1;            /*!< [23] Transmitter DMA Enable */
        uint32_t OSR : 5;              /*!< [28:24] Over Sampling Ratio */
        uint32_t M10 : 1;              /*!< [29] 10-bit Mode select */
        uint32_t MAEN2 : 1;            /*!< [30] Match Address Mode Enable 2 */
        uint32_t MAEN1 : 1;            /*!< [31] Match Address Mode Enable 1 */
    } B;
} hw_lpuart_baud_t;

/*!
 * @name Constants and macros for entire LPUART_BAUD register
 */
/*@{*/
#define HW_LPUART_BAUD_ADDR(x)   ((uint32_t)(x) + 0x0U)

#define HW_LPUART_BAUD(x)        (*(__IO hw_lpuart_baud_t *) HW_LPUART_BAUD_ADDR(x))
#define HW_LPUART_BAUD_RD(x)     (HW_LPUART_BAUD(x).U)
#define HW_LPUART_BAUD_WR(x, v)  (HW_LPUART_BAUD(x).U = (v))
#define HW_LPUART_BAUD_SET(x, v) (BME_OR32(HW_LPUART_BAUD_ADDR(x), (uint32_t)(v)))
#define HW_LPUART_BAUD_CLR(x, v) (BME_AND32(HW_LPUART_BAUD_ADDR(x), (uint32_t)(~(v))))
#define HW_LPUART_BAUD_TOG(x, v) (BME_XOR32(HW_LPUART_BAUD_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LPUART_BAUD bitfields
 */

/*!
 * @name Register LPUART_BAUD, field SBR[12:0] (RW)
 *
 * The 13 bits in SBR[12:0] set the modulo divide rate for the baud rate
 * generator. When SBR is 1 - 8191, the baud rate equals "baud clock / ((OSR+1) * SBR)".
 * The 13-bit baud rate setting [SBR12:SBR0] must only be updated when the
 * transmitter and receiver are both disabled (LPUART_CTRL[RE] and LPUART_CTRL[TE] are
 * both 0).
 */
/*@{*/
#define BP_LPUART_BAUD_SBR   (0U)          /*!< Bit position for LPUART_BAUD_SBR. */
#define BM_LPUART_BAUD_SBR   (0x00001FFFU) /*!< Bit mask for LPUART_BAUD_SBR. */
#define BS_LPUART_BAUD_SBR   (13U)         /*!< Bit field size in bits for LPUART_BAUD_SBR. */

/*! @brief Read current value of the LPUART_BAUD_SBR field. */
#define BR_LPUART_BAUD_SBR(x) (BME_UBFX32(HW_LPUART_BAUD_ADDR(x), BP_LPUART_BAUD_SBR, BS_LPUART_BAUD_SBR))

/*! @brief Format value for bitfield LPUART_BAUD_SBR. */
#define BF_LPUART_BAUD_SBR(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_BAUD_SBR) & BM_LPUART_BAUD_SBR)

/*! @brief Set the SBR field to a new value. */
#define BW_LPUART_BAUD_SBR(x, v) (BME_BFI32(HW_LPUART_BAUD_ADDR(x), ((uint32_t)(v) << BP_LPUART_BAUD_SBR), BP_LPUART_BAUD_SBR, 13))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field SBNS[13] (RW)
 *
 * SBNS determines whether data characters are one or two stop bits. This bit
 * should only be changed when the transmitter and receiver are both disabled.
 *
 * Values:
 * - 0 - One stop bit.
 * - 1 - Two stop bits.
 */
/*@{*/
#define BP_LPUART_BAUD_SBNS  (13U)         /*!< Bit position for LPUART_BAUD_SBNS. */
#define BM_LPUART_BAUD_SBNS  (0x00002000U) /*!< Bit mask for LPUART_BAUD_SBNS. */
#define BS_LPUART_BAUD_SBNS  (1U)          /*!< Bit field size in bits for LPUART_BAUD_SBNS. */

/*! @brief Read current value of the LPUART_BAUD_SBNS field. */
#define BR_LPUART_BAUD_SBNS(x) (BME_UBFX32(HW_LPUART_BAUD_ADDR(x), BP_LPUART_BAUD_SBNS, BS_LPUART_BAUD_SBNS))

/*! @brief Format value for bitfield LPUART_BAUD_SBNS. */
#define BF_LPUART_BAUD_SBNS(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_BAUD_SBNS) & BM_LPUART_BAUD_SBNS)

/*! @brief Set the SBNS field to a new value. */
#define BW_LPUART_BAUD_SBNS(x, v) (BME_BFI32(HW_LPUART_BAUD_ADDR(x), ((uint32_t)(v) << BP_LPUART_BAUD_SBNS), BP_LPUART_BAUD_SBNS, 1))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field RXEDGIE[14] (RW)
 *
 * Enables the receive input active edge, RXEDGIF, to generate interrupt
 * requests. Changing CTRL[LOOP] or CTRL[RSRC] when RXEDGIE is set can cause the RXEDGIF
 * to set.
 *
 * Values:
 * - 0 - Hardware interrupts from LPUART_STAT[RXEDGIF] disabled (use polling).
 * - 1 - Hardware interrupt requested when LPUART_STAT[RXEDGIF] flag is 1.
 */
/*@{*/
#define BP_LPUART_BAUD_RXEDGIE (14U)       /*!< Bit position for LPUART_BAUD_RXEDGIE. */
#define BM_LPUART_BAUD_RXEDGIE (0x00004000U) /*!< Bit mask for LPUART_BAUD_RXEDGIE. */
#define BS_LPUART_BAUD_RXEDGIE (1U)        /*!< Bit field size in bits for LPUART_BAUD_RXEDGIE. */

/*! @brief Read current value of the LPUART_BAUD_RXEDGIE field. */
#define BR_LPUART_BAUD_RXEDGIE(x) (BME_UBFX32(HW_LPUART_BAUD_ADDR(x), BP_LPUART_BAUD_RXEDGIE, BS_LPUART_BAUD_RXEDGIE))

/*! @brief Format value for bitfield LPUART_BAUD_RXEDGIE. */
#define BF_LPUART_BAUD_RXEDGIE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_BAUD_RXEDGIE) & BM_LPUART_BAUD_RXEDGIE)

/*! @brief Set the RXEDGIE field to a new value. */
#define BW_LPUART_BAUD_RXEDGIE(x, v) (BME_BFI32(HW_LPUART_BAUD_ADDR(x), ((uint32_t)(v) << BP_LPUART_BAUD_RXEDGIE), BP_LPUART_BAUD_RXEDGIE, 1))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field LBKDIE[15] (RW)
 *
 * LBKDIE enables the LIN break detect flag, LBKDIF, to generate interrupt
 * requests.
 *
 * Values:
 * - 0 - Hardware interrupts from LPUART_STAT[LBKDIF] disabled (use polling).
 * - 1 - Hardware interrupt requested when LPUART_STAT[LBKDIF] flag is 1.
 */
/*@{*/
#define BP_LPUART_BAUD_LBKDIE (15U)        /*!< Bit position for LPUART_BAUD_LBKDIE. */
#define BM_LPUART_BAUD_LBKDIE (0x00008000U) /*!< Bit mask for LPUART_BAUD_LBKDIE. */
#define BS_LPUART_BAUD_LBKDIE (1U)         /*!< Bit field size in bits for LPUART_BAUD_LBKDIE. */

/*! @brief Read current value of the LPUART_BAUD_LBKDIE field. */
#define BR_LPUART_BAUD_LBKDIE(x) (BME_UBFX32(HW_LPUART_BAUD_ADDR(x), BP_LPUART_BAUD_LBKDIE, BS_LPUART_BAUD_LBKDIE))

/*! @brief Format value for bitfield LPUART_BAUD_LBKDIE. */
#define BF_LPUART_BAUD_LBKDIE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_BAUD_LBKDIE) & BM_LPUART_BAUD_LBKDIE)

/*! @brief Set the LBKDIE field to a new value. */
#define BW_LPUART_BAUD_LBKDIE(x, v) (BME_BFI32(HW_LPUART_BAUD_ADDR(x), ((uint32_t)(v) << BP_LPUART_BAUD_LBKDIE), BP_LPUART_BAUD_LBKDIE, 1))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field RESYNCDIS[16] (RW)
 *
 * When set, disables the resynchronization of the received data word when a
 * data one followed by data zero transition is detected. This bit should only be
 * changed when the receiver is disabled.
 *
 * Values:
 * - 0 - Resynchronization during received data word is supported
 * - 1 - Resynchronization during received data word is disabled
 */
/*@{*/
#define BP_LPUART_BAUD_RESYNCDIS (16U)     /*!< Bit position for LPUART_BAUD_RESYNCDIS. */
#define BM_LPUART_BAUD_RESYNCDIS (0x00010000U) /*!< Bit mask for LPUART_BAUD_RESYNCDIS. */
#define BS_LPUART_BAUD_RESYNCDIS (1U)      /*!< Bit field size in bits for LPUART_BAUD_RESYNCDIS. */

/*! @brief Read current value of the LPUART_BAUD_RESYNCDIS field. */
#define BR_LPUART_BAUD_RESYNCDIS(x) (BME_UBFX32(HW_LPUART_BAUD_ADDR(x), BP_LPUART_BAUD_RESYNCDIS, BS_LPUART_BAUD_RESYNCDIS))

/*! @brief Format value for bitfield LPUART_BAUD_RESYNCDIS. */
#define BF_LPUART_BAUD_RESYNCDIS(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_BAUD_RESYNCDIS) & BM_LPUART_BAUD_RESYNCDIS)

/*! @brief Set the RESYNCDIS field to a new value. */
#define BW_LPUART_BAUD_RESYNCDIS(x, v) (BME_BFI32(HW_LPUART_BAUD_ADDR(x), ((uint32_t)(v) << BP_LPUART_BAUD_RESYNCDIS), BP_LPUART_BAUD_RESYNCDIS, 1))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field BOTHEDGE[17] (RW)
 *
 * Enables sampling of the received data on both edges of the baud rate clock,
 * effectively doubling the number of times the receiver samples the input data
 * for a given oversampling ratio. This bit must be set for oversampling ratios
 * between x4 and x7 and is optional for higher oversampling ratios. This bit should
 * only be changed when the receiver is disabled.
 *
 * Values:
 * - 0 - Receiver samples input data using the rising edge of the baud rate
 *     clock.
 * - 1 - Receiver samples input data using the rising and falling edge of the
 *     baud rate clock.
 */
/*@{*/
#define BP_LPUART_BAUD_BOTHEDGE (17U)      /*!< Bit position for LPUART_BAUD_BOTHEDGE. */
#define BM_LPUART_BAUD_BOTHEDGE (0x00020000U) /*!< Bit mask for LPUART_BAUD_BOTHEDGE. */
#define BS_LPUART_BAUD_BOTHEDGE (1U)       /*!< Bit field size in bits for LPUART_BAUD_BOTHEDGE. */

/*! @brief Read current value of the LPUART_BAUD_BOTHEDGE field. */
#define BR_LPUART_BAUD_BOTHEDGE(x) (BME_UBFX32(HW_LPUART_BAUD_ADDR(x), BP_LPUART_BAUD_BOTHEDGE, BS_LPUART_BAUD_BOTHEDGE))

/*! @brief Format value for bitfield LPUART_BAUD_BOTHEDGE. */
#define BF_LPUART_BAUD_BOTHEDGE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_BAUD_BOTHEDGE) & BM_LPUART_BAUD_BOTHEDGE)

/*! @brief Set the BOTHEDGE field to a new value. */
#define BW_LPUART_BAUD_BOTHEDGE(x, v) (BME_BFI32(HW_LPUART_BAUD_ADDR(x), ((uint32_t)(v) << BP_LPUART_BAUD_BOTHEDGE), BP_LPUART_BAUD_BOTHEDGE, 1))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field MATCFG[19:18] (RW)
 *
 * Configures the match addressing mode used.
 *
 * Values:
 * - 00 - Address Match Wakeup
 * - 01 - Idle Match Wakeup
 * - 10 - Match On and Match Off
 * - 11 - Enables RWU on Data Match and Match On/Off for transmitter CTS input
 */
/*@{*/
#define BP_LPUART_BAUD_MATCFG (18U)        /*!< Bit position for LPUART_BAUD_MATCFG. */
#define BM_LPUART_BAUD_MATCFG (0x000C0000U) /*!< Bit mask for LPUART_BAUD_MATCFG. */
#define BS_LPUART_BAUD_MATCFG (2U)         /*!< Bit field size in bits for LPUART_BAUD_MATCFG. */

/*! @brief Read current value of the LPUART_BAUD_MATCFG field. */
#define BR_LPUART_BAUD_MATCFG(x) (BME_UBFX32(HW_LPUART_BAUD_ADDR(x), BP_LPUART_BAUD_MATCFG, BS_LPUART_BAUD_MATCFG))

/*! @brief Format value for bitfield LPUART_BAUD_MATCFG. */
#define BF_LPUART_BAUD_MATCFG(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_BAUD_MATCFG) & BM_LPUART_BAUD_MATCFG)

/*! @brief Set the MATCFG field to a new value. */
#define BW_LPUART_BAUD_MATCFG(x, v) (BME_BFI32(HW_LPUART_BAUD_ADDR(x), ((uint32_t)(v) << BP_LPUART_BAUD_MATCFG), BP_LPUART_BAUD_MATCFG, 2))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field RDMAE[21] (RW)
 *
 * RDMAE configures the receiver data register full flag, LPUART_STAT[RDRF], to
 * generate a DMA request.
 *
 * Values:
 * - 0 - DMA request disabled.
 * - 1 - DMA request enabled.
 */
/*@{*/
#define BP_LPUART_BAUD_RDMAE (21U)         /*!< Bit position for LPUART_BAUD_RDMAE. */
#define BM_LPUART_BAUD_RDMAE (0x00200000U) /*!< Bit mask for LPUART_BAUD_RDMAE. */
#define BS_LPUART_BAUD_RDMAE (1U)          /*!< Bit field size in bits for LPUART_BAUD_RDMAE. */

/*! @brief Read current value of the LPUART_BAUD_RDMAE field. */
#define BR_LPUART_BAUD_RDMAE(x) (BME_UBFX32(HW_LPUART_BAUD_ADDR(x), BP_LPUART_BAUD_RDMAE, BS_LPUART_BAUD_RDMAE))

/*! @brief Format value for bitfield LPUART_BAUD_RDMAE. */
#define BF_LPUART_BAUD_RDMAE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_BAUD_RDMAE) & BM_LPUART_BAUD_RDMAE)

/*! @brief Set the RDMAE field to a new value. */
#define BW_LPUART_BAUD_RDMAE(x, v) (BME_BFI32(HW_LPUART_BAUD_ADDR(x), ((uint32_t)(v) << BP_LPUART_BAUD_RDMAE), BP_LPUART_BAUD_RDMAE, 1))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field TDMAE[23] (RW)
 *
 * TDMAE configures the transmit data register empty flag, LPUART_STAT[TDRE], to
 * generate a DMA request.
 *
 * Values:
 * - 0 - DMA request disabled.
 * - 1 - DMA request enabled.
 */
/*@{*/
#define BP_LPUART_BAUD_TDMAE (23U)         /*!< Bit position for LPUART_BAUD_TDMAE. */
#define BM_LPUART_BAUD_TDMAE (0x00800000U) /*!< Bit mask for LPUART_BAUD_TDMAE. */
#define BS_LPUART_BAUD_TDMAE (1U)          /*!< Bit field size in bits for LPUART_BAUD_TDMAE. */

/*! @brief Read current value of the LPUART_BAUD_TDMAE field. */
#define BR_LPUART_BAUD_TDMAE(x) (BME_UBFX32(HW_LPUART_BAUD_ADDR(x), BP_LPUART_BAUD_TDMAE, BS_LPUART_BAUD_TDMAE))

/*! @brief Format value for bitfield LPUART_BAUD_TDMAE. */
#define BF_LPUART_BAUD_TDMAE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_BAUD_TDMAE) & BM_LPUART_BAUD_TDMAE)

/*! @brief Set the TDMAE field to a new value. */
#define BW_LPUART_BAUD_TDMAE(x, v) (BME_BFI32(HW_LPUART_BAUD_ADDR(x), ((uint32_t)(v) << BP_LPUART_BAUD_TDMAE), BP_LPUART_BAUD_TDMAE, 1))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field OSR[28:24] (RW)
 *
 * This field configures the oversampling ratio for the receiver between 4x
 * (00011) and 32x (11111). Writing an invalid oversampling ratio will default to an
 * oversampling ratio of 16 (01111). This field should only be changed when the
 * transmitter and receiver are both disabled.
 */
/*@{*/
#define BP_LPUART_BAUD_OSR   (24U)         /*!< Bit position for LPUART_BAUD_OSR. */
#define BM_LPUART_BAUD_OSR   (0x1F000000U) /*!< Bit mask for LPUART_BAUD_OSR. */
#define BS_LPUART_BAUD_OSR   (5U)          /*!< Bit field size in bits for LPUART_BAUD_OSR. */

/*! @brief Read current value of the LPUART_BAUD_OSR field. */
#define BR_LPUART_BAUD_OSR(x) (BME_UBFX32(HW_LPUART_BAUD_ADDR(x), BP_LPUART_BAUD_OSR, BS_LPUART_BAUD_OSR))

/*! @brief Format value for bitfield LPUART_BAUD_OSR. */
#define BF_LPUART_BAUD_OSR(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_BAUD_OSR) & BM_LPUART_BAUD_OSR)

/*! @brief Set the OSR field to a new value. */
#define BW_LPUART_BAUD_OSR(x, v) (BME_BFI32(HW_LPUART_BAUD_ADDR(x), ((uint32_t)(v) << BP_LPUART_BAUD_OSR), BP_LPUART_BAUD_OSR, 5))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field M10[29] (RW)
 *
 * The M10 bit causes a tenth bit to be part of the serial transmission. This
 * bit should only be changed when the transmitter and receiver are both disabled.
 *
 * Values:
 * - 0 - Receiver and transmitter use 8-bit or 9-bit data characters.
 * - 1 - Receiver and transmitter use 10-bit data characters.
 */
/*@{*/
#define BP_LPUART_BAUD_M10   (29U)         /*!< Bit position for LPUART_BAUD_M10. */
#define BM_LPUART_BAUD_M10   (0x20000000U) /*!< Bit mask for LPUART_BAUD_M10. */
#define BS_LPUART_BAUD_M10   (1U)          /*!< Bit field size in bits for LPUART_BAUD_M10. */

/*! @brief Read current value of the LPUART_BAUD_M10 field. */
#define BR_LPUART_BAUD_M10(x) (BME_UBFX32(HW_LPUART_BAUD_ADDR(x), BP_LPUART_BAUD_M10, BS_LPUART_BAUD_M10))

/*! @brief Format value for bitfield LPUART_BAUD_M10. */
#define BF_LPUART_BAUD_M10(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_BAUD_M10) & BM_LPUART_BAUD_M10)

/*! @brief Set the M10 field to a new value. */
#define BW_LPUART_BAUD_M10(x, v) (BME_BFI32(HW_LPUART_BAUD_ADDR(x), ((uint32_t)(v) << BP_LPUART_BAUD_M10), BP_LPUART_BAUD_M10, 1))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field MAEN2[30] (RW)
 *
 * Values:
 * - 0 - Normal operation.
 * - 1 - Enables automatic address matching or data matching mode for MATCH[MA2].
 */
/*@{*/
#define BP_LPUART_BAUD_MAEN2 (30U)         /*!< Bit position for LPUART_BAUD_MAEN2. */
#define BM_LPUART_BAUD_MAEN2 (0x40000000U) /*!< Bit mask for LPUART_BAUD_MAEN2. */
#define BS_LPUART_BAUD_MAEN2 (1U)          /*!< Bit field size in bits for LPUART_BAUD_MAEN2. */

/*! @brief Read current value of the LPUART_BAUD_MAEN2 field. */
#define BR_LPUART_BAUD_MAEN2(x) (BME_UBFX32(HW_LPUART_BAUD_ADDR(x), BP_LPUART_BAUD_MAEN2, BS_LPUART_BAUD_MAEN2))

/*! @brief Format value for bitfield LPUART_BAUD_MAEN2. */
#define BF_LPUART_BAUD_MAEN2(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_BAUD_MAEN2) & BM_LPUART_BAUD_MAEN2)

/*! @brief Set the MAEN2 field to a new value. */
#define BW_LPUART_BAUD_MAEN2(x, v) (BME_BFI32(HW_LPUART_BAUD_ADDR(x), ((uint32_t)(v) << BP_LPUART_BAUD_MAEN2), BP_LPUART_BAUD_MAEN2, 1))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field MAEN1[31] (RW)
 *
 * Values:
 * - 0 - Normal operation.
 * - 1 - Enables automatic address matching or data matching mode for MATCH[MA1].
 */
/*@{*/
#define BP_LPUART_BAUD_MAEN1 (31U)         /*!< Bit position for LPUART_BAUD_MAEN1. */
#define BM_LPUART_BAUD_MAEN1 (0x80000000U) /*!< Bit mask for LPUART_BAUD_MAEN1. */
#define BS_LPUART_BAUD_MAEN1 (1U)          /*!< Bit field size in bits for LPUART_BAUD_MAEN1. */

/*! @brief Read current value of the LPUART_BAUD_MAEN1 field. */
#define BR_LPUART_BAUD_MAEN1(x) (BME_UBFX32(HW_LPUART_BAUD_ADDR(x), BP_LPUART_BAUD_MAEN1, BS_LPUART_BAUD_MAEN1))

/*! @brief Format value for bitfield LPUART_BAUD_MAEN1. */
#define BF_LPUART_BAUD_MAEN1(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_BAUD_MAEN1) & BM_LPUART_BAUD_MAEN1)

/*! @brief Set the MAEN1 field to a new value. */
#define BW_LPUART_BAUD_MAEN1(x, v) (BME_BFI32(HW_LPUART_BAUD_ADDR(x), ((uint32_t)(v) << BP_LPUART_BAUD_MAEN1), BP_LPUART_BAUD_MAEN1, 1))
/*@}*/

/*******************************************************************************
 * HW_LPUART_STAT - LPUART Status Register
 ******************************************************************************/

/*!
 * @brief HW_LPUART_STAT - LPUART Status Register (RW)
 *
 * Reset value: 0x00C00000U
 */
typedef union _hw_lpuart_stat
{
    uint32_t U;
    struct _hw_lpuart_stat_bitfields
    {
        uint32_t RESERVED0 : 14;       /*!< [13:0]  */
        uint32_t MA2F : 1;             /*!< [14] Match 2 Flag */
        uint32_t MA1F : 1;             /*!< [15] Match 1 Flag */
        uint32_t PF : 1;               /*!< [16] Parity Error Flag */
        uint32_t FE : 1;               /*!< [17] Framing Error Flag */
        uint32_t NF : 1;               /*!< [18] Noise Flag */
        uint32_t OR : 1;               /*!< [19] Receiver Overrun Flag */
        uint32_t IDLE : 1;             /*!< [20] Idle Line Flag */
        uint32_t RDRF : 1;             /*!< [21] Receive Data Register Full Flag */
        uint32_t TC : 1;               /*!< [22] Transmission Complete Flag */
        uint32_t TDRE : 1;             /*!< [23] Transmit Data Register Empty Flag */
        uint32_t RAF : 1;              /*!< [24] Receiver Active Flag */
        uint32_t LBKDE : 1;            /*!< [25] LIN Break Detection Enable */
        uint32_t BRK13 : 1;            /*!< [26] Break Character Generation Length */
        uint32_t RWUID : 1;            /*!< [27] Receive Wake Up Idle Detect */
        uint32_t RXINV : 1;            /*!< [28] Receive Data Inversion */
        uint32_t MSBF : 1;             /*!< [29] MSB First */
        uint32_t RXEDGIF : 1;          /*!< [30] LPUART_RX Pin Active Edge Interrupt
                                        * Flag */
        uint32_t LBKDIF : 1;           /*!< [31] LIN Break Detect Interrupt Flag */
    } B;
} hw_lpuart_stat_t;

/*!
 * @name Constants and macros for entire LPUART_STAT register
 */
/*@{*/
#define HW_LPUART_STAT_ADDR(x)   ((uint32_t)(x) + 0x4U)

#define HW_LPUART_STAT(x)        (*(__IO hw_lpuart_stat_t *) HW_LPUART_STAT_ADDR(x))
#define HW_LPUART_STAT_RD(x)     (HW_LPUART_STAT(x).U)
#define HW_LPUART_STAT_WR(x, v)  (HW_LPUART_STAT(x).U = (v))
#define HW_LPUART_STAT_SET(x, v) (BME_OR32(HW_LPUART_STAT_ADDR(x), (uint32_t)(v)))
#define HW_LPUART_STAT_CLR(x, v) (BME_AND32(HW_LPUART_STAT_ADDR(x), (uint32_t)(~(v))))
#define HW_LPUART_STAT_TOG(x, v) (BME_XOR32(HW_LPUART_STAT_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LPUART_STAT bitfields
 */

/*!
 * @name Register LPUART_STAT, field MA2F[14] (W1C)
 *
 * MA2F is set whenever the next character to be read from LPUART_DATA matches
 * MA2. To clear MA2F, write a logic one to the MA2F.
 *
 * Values:
 * - 0 - Received data is not equal to MA2
 * - 1 - Received data is equal to MA2
 */
/*@{*/
#define BP_LPUART_STAT_MA2F  (14U)         /*!< Bit position for LPUART_STAT_MA2F. */
#define BM_LPUART_STAT_MA2F  (0x00004000U) /*!< Bit mask for LPUART_STAT_MA2F. */
#define BS_LPUART_STAT_MA2F  (1U)          /*!< Bit field size in bits for LPUART_STAT_MA2F. */

/*! @brief Read current value of the LPUART_STAT_MA2F field. */
#define BR_LPUART_STAT_MA2F(x) (BME_UBFX32(HW_LPUART_STAT_ADDR(x), BP_LPUART_STAT_MA2F, BS_LPUART_STAT_MA2F))

/*! @brief Format value for bitfield LPUART_STAT_MA2F. */
#define BF_LPUART_STAT_MA2F(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_STAT_MA2F) & BM_LPUART_STAT_MA2F)

/*! @brief Set the MA2F field to a new value. */
#define BW_LPUART_STAT_MA2F(x, v) (BME_BFI32(HW_LPUART_STAT_ADDR(x), ((uint32_t)(v) << BP_LPUART_STAT_MA2F), BP_LPUART_STAT_MA2F, 1))
/*@}*/

/*!
 * @name Register LPUART_STAT, field MA1F[15] (W1C)
 *
 * MA1F is set whenever the next character to be read from LPUART_DATA matches
 * MA1. To clear MA1F, write a logic one to the MA1F.
 *
 * Values:
 * - 0 - Received data is not equal to MA1
 * - 1 - Received data is equal to MA1
 */
/*@{*/
#define BP_LPUART_STAT_MA1F  (15U)         /*!< Bit position for LPUART_STAT_MA1F. */
#define BM_LPUART_STAT_MA1F  (0x00008000U) /*!< Bit mask for LPUART_STAT_MA1F. */
#define BS_LPUART_STAT_MA1F  (1U)          /*!< Bit field size in bits for LPUART_STAT_MA1F. */

/*! @brief Read current value of the LPUART_STAT_MA1F field. */
#define BR_LPUART_STAT_MA1F(x) (BME_UBFX32(HW_LPUART_STAT_ADDR(x), BP_LPUART_STAT_MA1F, BS_LPUART_STAT_MA1F))

/*! @brief Format value for bitfield LPUART_STAT_MA1F. */
#define BF_LPUART_STAT_MA1F(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_STAT_MA1F) & BM_LPUART_STAT_MA1F)

/*! @brief Set the MA1F field to a new value. */
#define BW_LPUART_STAT_MA1F(x, v) (BME_BFI32(HW_LPUART_STAT_ADDR(x), ((uint32_t)(v) << BP_LPUART_STAT_MA1F), BP_LPUART_STAT_MA1F, 1))
/*@}*/

/*!
 * @name Register LPUART_STAT, field PF[16] (W1C)
 *
 * PF is set whenever the next character to be read from LPUART_DATA was
 * received when parity is enabled (PE = 1) and the parity bit in the received character
 * does not agree with the expected parity value. To clear PF, write a logic one
 * to the PF.
 *
 * Values:
 * - 0 - No parity error.
 * - 1 - Parity error.
 */
/*@{*/
#define BP_LPUART_STAT_PF    (16U)         /*!< Bit position for LPUART_STAT_PF. */
#define BM_LPUART_STAT_PF    (0x00010000U) /*!< Bit mask for LPUART_STAT_PF. */
#define BS_LPUART_STAT_PF    (1U)          /*!< Bit field size in bits for LPUART_STAT_PF. */

/*! @brief Read current value of the LPUART_STAT_PF field. */
#define BR_LPUART_STAT_PF(x) (BME_UBFX32(HW_LPUART_STAT_ADDR(x), BP_LPUART_STAT_PF, BS_LPUART_STAT_PF))

/*! @brief Format value for bitfield LPUART_STAT_PF. */
#define BF_LPUART_STAT_PF(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_STAT_PF) & BM_LPUART_STAT_PF)

/*! @brief Set the PF field to a new value. */
#define BW_LPUART_STAT_PF(x, v) (BME_BFI32(HW_LPUART_STAT_ADDR(x), ((uint32_t)(v) << BP_LPUART_STAT_PF), BP_LPUART_STAT_PF, 1))
/*@}*/

/*!
 * @name Register LPUART_STAT, field FE[17] (W1C)
 *
 * FE is set whenever the next character to be read from LPUART_DATA was
 * received with logic 0 detected where a stop bit was expected. To clear NF, write
 * logic one to the NF.
 *
 * Values:
 * - 0 - No framing error detected. This does not guarantee the framing is
 *     correct.
 * - 1 - Framing error.
 */
/*@{*/
#define BP_LPUART_STAT_FE    (17U)         /*!< Bit position for LPUART_STAT_FE. */
#define BM_LPUART_STAT_FE    (0x00020000U) /*!< Bit mask for LPUART_STAT_FE. */
#define BS_LPUART_STAT_FE    (1U)          /*!< Bit field size in bits for LPUART_STAT_FE. */

/*! @brief Read current value of the LPUART_STAT_FE field. */
#define BR_LPUART_STAT_FE(x) (BME_UBFX32(HW_LPUART_STAT_ADDR(x), BP_LPUART_STAT_FE, BS_LPUART_STAT_FE))

/*! @brief Format value for bitfield LPUART_STAT_FE. */
#define BF_LPUART_STAT_FE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_STAT_FE) & BM_LPUART_STAT_FE)

/*! @brief Set the FE field to a new value. */
#define BW_LPUART_STAT_FE(x, v) (BME_BFI32(HW_LPUART_STAT_ADDR(x), ((uint32_t)(v) << BP_LPUART_STAT_FE), BP_LPUART_STAT_FE, 1))
/*@}*/

/*!
 * @name Register LPUART_STAT, field NF[18] (W1C)
 *
 * The advanced sampling technique used in the receiver takes three samples in
 * each of the received bits. If any of these samples disagrees with the rest of
 * the samples within any bit time in the frame then noise is detected for that
 * character. NF is set whenever the next character to be read from LPUART_DATA was
 * received with noise detected within the character. To clear NF, write logic
 * one to the NF.
 *
 * Values:
 * - 0 - No noise detected.
 * - 1 - Noise detected in the received character in LPUART_DATA.
 */
/*@{*/
#define BP_LPUART_STAT_NF    (18U)         /*!< Bit position for LPUART_STAT_NF. */
#define BM_LPUART_STAT_NF    (0x00040000U) /*!< Bit mask for LPUART_STAT_NF. */
#define BS_LPUART_STAT_NF    (1U)          /*!< Bit field size in bits for LPUART_STAT_NF. */

/*! @brief Read current value of the LPUART_STAT_NF field. */
#define BR_LPUART_STAT_NF(x) (BME_UBFX32(HW_LPUART_STAT_ADDR(x), BP_LPUART_STAT_NF, BS_LPUART_STAT_NF))

/*! @brief Format value for bitfield LPUART_STAT_NF. */
#define BF_LPUART_STAT_NF(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_STAT_NF) & BM_LPUART_STAT_NF)

/*! @brief Set the NF field to a new value. */
#define BW_LPUART_STAT_NF(x, v) (BME_BFI32(HW_LPUART_STAT_ADDR(x), ((uint32_t)(v) << BP_LPUART_STAT_NF), BP_LPUART_STAT_NF, 1))
/*@}*/

/*!
 * @name Register LPUART_STAT, field OR[19] (W1C)
 *
 * OR is set when software fails to prevent the receive data register from
 * overflowing with data. The OR bit is set immediately after the stop bit has been
 * completely received for the dataword that overflows the buffer and all the other
 * error flags (FE, NF, and PF) are prevented from setting. The data in the
 * shift register is lost, but the data already in the LPUART data registers is not
 * affected. If LBKDE is enabled and a LIN Break is detected, the OR field asserts
 * if LBKDIF is not cleared before the next data character is received. While
 * the OR flag is set, no additional data is stored in the data buffer even if
 * sufficient room exists. To clear OR, write logic 1 to the OR flag.
 *
 * Values:
 * - 0 - No overrun.
 * - 1 - Receive overrun (new LPUART data lost).
 */
/*@{*/
#define BP_LPUART_STAT_OR    (19U)         /*!< Bit position for LPUART_STAT_OR. */
#define BM_LPUART_STAT_OR    (0x00080000U) /*!< Bit mask for LPUART_STAT_OR. */
#define BS_LPUART_STAT_OR    (1U)          /*!< Bit field size in bits for LPUART_STAT_OR. */

/*! @brief Read current value of the LPUART_STAT_OR field. */
#define BR_LPUART_STAT_OR(x) (BME_UBFX32(HW_LPUART_STAT_ADDR(x), BP_LPUART_STAT_OR, BS_LPUART_STAT_OR))

/*! @brief Format value for bitfield LPUART_STAT_OR. */
#define BF_LPUART_STAT_OR(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_STAT_OR) & BM_LPUART_STAT_OR)

/*! @brief Set the OR field to a new value. */
#define BW_LPUART_STAT_OR(x, v) (BME_BFI32(HW_LPUART_STAT_ADDR(x), ((uint32_t)(v) << BP_LPUART_STAT_OR), BP_LPUART_STAT_OR, 1))
/*@}*/

/*!
 * @name Register LPUART_STAT, field IDLE[20] (W1C)
 *
 * IDLE is set when the LPUART receive line becomes idle for a full character
 * time after a period of activity. When ILT is cleared, the receiver starts
 * counting idle bit times after the start bit. If the receive character is all 1s,
 * these bit times and the stop bits time count toward the full character time of
 * logic high, 10 to 13 bit times, needed for the receiver to detect an idle line.
 * When ILT is set, the receiver doesn't start counting idle bit times until
 * after the stop bits. The stop bits and any logic high bit times at the end of the
 * previous character do not count toward the full character time of logic high
 * needed for the receiver to detect an idle line. To clear IDLE, write logic 1 to
 * the IDLE flag. After IDLE has been cleared, it cannot become set again until
 * after a new character has been stored in the receive buffer or a LIN break
 * character has set the LBKDIF flag . IDLE is set only once even if the receive
 * line remains idle for an extended period.
 *
 * Values:
 * - 0 - No idle line detected.
 * - 1 - Idle line was detected.
 */
/*@{*/
#define BP_LPUART_STAT_IDLE  (20U)         /*!< Bit position for LPUART_STAT_IDLE. */
#define BM_LPUART_STAT_IDLE  (0x00100000U) /*!< Bit mask for LPUART_STAT_IDLE. */
#define BS_LPUART_STAT_IDLE  (1U)          /*!< Bit field size in bits for LPUART_STAT_IDLE. */

/*! @brief Read current value of the LPUART_STAT_IDLE field. */
#define BR_LPUART_STAT_IDLE(x) (BME_UBFX32(HW_LPUART_STAT_ADDR(x), BP_LPUART_STAT_IDLE, BS_LPUART_STAT_IDLE))

/*! @brief Format value for bitfield LPUART_STAT_IDLE. */
#define BF_LPUART_STAT_IDLE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_STAT_IDLE) & BM_LPUART_STAT_IDLE)

/*! @brief Set the IDLE field to a new value. */
#define BW_LPUART_STAT_IDLE(x, v) (BME_BFI32(HW_LPUART_STAT_ADDR(x), ((uint32_t)(v) << BP_LPUART_STAT_IDLE), BP_LPUART_STAT_IDLE, 1))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RDRF[21] (RO)
 *
 * RDRF is set when the receive buffer (LPUART_DATA) is full. To clear RDRF,
 * read the LPUART_DATA register. A character that is in the process of being
 * received does not cause a change in RDRF until the entire character is received.
 * Even if RDRF is set, the character will continue to be received until an overrun
 * condition occurs once the entire character is received.
 *
 * Values:
 * - 0 - Receive data buffer empty.
 * - 1 - Receive data buffer full.
 */
/*@{*/
#define BP_LPUART_STAT_RDRF  (21U)         /*!< Bit position for LPUART_STAT_RDRF. */
#define BM_LPUART_STAT_RDRF  (0x00200000U) /*!< Bit mask for LPUART_STAT_RDRF. */
#define BS_LPUART_STAT_RDRF  (1U)          /*!< Bit field size in bits for LPUART_STAT_RDRF. */

/*! @brief Read current value of the LPUART_STAT_RDRF field. */
#define BR_LPUART_STAT_RDRF(x) (BME_UBFX32(HW_LPUART_STAT_ADDR(x), BP_LPUART_STAT_RDRF, BS_LPUART_STAT_RDRF))
/*@}*/

/*!
 * @name Register LPUART_STAT, field TC[22] (RO)
 *
 * TC is cleared when there is a transmission in progress or when a preamble or
 * break character is loaded. TC is set when the transmit buffer is empty and no
 * data, preamble, or break character is being transmitted. When TC is set, the
 * transmit data output signal becomes idle (logic 1). TC is cleared by writing to
 * LPUART_DATA to transmit new data, queuing a preamble by clearing and then
 * setting LPUART_CTRL[TE], queuing a break character by writing 1 to
 * LPUART_CTRL[SBK].
 *
 * Values:
 * - 0 - Transmitter active (sending data, a preamble, or a break).
 * - 1 - Transmitter idle (transmission activity complete).
 */
/*@{*/
#define BP_LPUART_STAT_TC    (22U)         /*!< Bit position for LPUART_STAT_TC. */
#define BM_LPUART_STAT_TC    (0x00400000U) /*!< Bit mask for LPUART_STAT_TC. */
#define BS_LPUART_STAT_TC    (1U)          /*!< Bit field size in bits for LPUART_STAT_TC. */

/*! @brief Read current value of the LPUART_STAT_TC field. */
#define BR_LPUART_STAT_TC(x) (BME_UBFX32(HW_LPUART_STAT_ADDR(x), BP_LPUART_STAT_TC, BS_LPUART_STAT_TC))
/*@}*/

/*!
 * @name Register LPUART_STAT, field TDRE[23] (RO)
 *
 * TDRE will set when the transmit data register (LPUART_DATA) is empty. To
 * clear TDRE, write to the LPUART data register (LPUART_DATA). TDRE is not affected
 * by a character that is in the process of being transmitted, it is updated at
 * the start of each transmitted character.
 *
 * Values:
 * - 0 - Transmit data buffer full.
 * - 1 - Transmit data buffer empty.
 */
/*@{*/
#define BP_LPUART_STAT_TDRE  (23U)         /*!< Bit position for LPUART_STAT_TDRE. */
#define BM_LPUART_STAT_TDRE  (0x00800000U) /*!< Bit mask for LPUART_STAT_TDRE. */
#define BS_LPUART_STAT_TDRE  (1U)          /*!< Bit field size in bits for LPUART_STAT_TDRE. */

/*! @brief Read current value of the LPUART_STAT_TDRE field. */
#define BR_LPUART_STAT_TDRE(x) (BME_UBFX32(HW_LPUART_STAT_ADDR(x), BP_LPUART_STAT_TDRE, BS_LPUART_STAT_TDRE))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RAF[24] (RO)
 *
 * RAF is set when the receiver detects the beginning of a valid start bit, and
 * RAF is cleared automatically when the receiver detects an idle line.
 *
 * Values:
 * - 0 - LPUART receiver idle waiting for a start bit.
 * - 1 - LPUART receiver active (LPUART_RX input not idle).
 */
/*@{*/
#define BP_LPUART_STAT_RAF   (24U)         /*!< Bit position for LPUART_STAT_RAF. */
#define BM_LPUART_STAT_RAF   (0x01000000U) /*!< Bit mask for LPUART_STAT_RAF. */
#define BS_LPUART_STAT_RAF   (1U)          /*!< Bit field size in bits for LPUART_STAT_RAF. */

/*! @brief Read current value of the LPUART_STAT_RAF field. */
#define BR_LPUART_STAT_RAF(x) (BME_UBFX32(HW_LPUART_STAT_ADDR(x), BP_LPUART_STAT_RAF, BS_LPUART_STAT_RAF))
/*@}*/

/*!
 * @name Register LPUART_STAT, field LBKDE[25] (RW)
 *
 * LBKDE selects a longer break character detection length. While LBKDE is set,
 * receive data is not stored in the receive data buffer.
 *
 * Values:
 * - 0 - Break character is detected at length 10 bit times (if M = 0, SBNS = 0)
 *     or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1, SBNS = 1
 *     or M10 = 1, SNBS = 0) or 13 (if M10 = 1, SNBS = 1).
 * - 1 - Break character is detected at length of 11 bit times (if M = 0, SBNS =
 *     0) or 12 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 14 (if M = 1, SBNS =
 *     1 or M10 = 1, SNBS = 0) or 15 (if M10 = 1, SNBS = 1).
 */
/*@{*/
#define BP_LPUART_STAT_LBKDE (25U)         /*!< Bit position for LPUART_STAT_LBKDE. */
#define BM_LPUART_STAT_LBKDE (0x02000000U) /*!< Bit mask for LPUART_STAT_LBKDE. */
#define BS_LPUART_STAT_LBKDE (1U)          /*!< Bit field size in bits for LPUART_STAT_LBKDE. */

/*! @brief Read current value of the LPUART_STAT_LBKDE field. */
#define BR_LPUART_STAT_LBKDE(x) (BME_UBFX32(HW_LPUART_STAT_ADDR(x), BP_LPUART_STAT_LBKDE, BS_LPUART_STAT_LBKDE))

/*! @brief Format value for bitfield LPUART_STAT_LBKDE. */
#define BF_LPUART_STAT_LBKDE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_STAT_LBKDE) & BM_LPUART_STAT_LBKDE)

/*! @brief Set the LBKDE field to a new value. */
#define BW_LPUART_STAT_LBKDE(x, v) (BME_BFI32(HW_LPUART_STAT_ADDR(x), ((uint32_t)(v) << BP_LPUART_STAT_LBKDE), BP_LPUART_STAT_LBKDE, 1))
/*@}*/

/*!
 * @name Register LPUART_STAT, field BRK13[26] (RW)
 *
 * BRK13 selects a longer transmitted break character length. Detection of a
 * framing error is not affected by the state of this bit. This bit should only be
 * changed when the transmitter is disabled.
 *
 * Values:
 * - 0 - Break character is transmitted with length of 10 bit times (if M = 0,
 *     SBNS = 0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1,
 *     SBNS = 1 or M10 = 1, SNBS = 0) or 13 (if M10 = 1, SNBS = 1).
 * - 1 - Break character is transmitted with length of 13 bit times (if M = 0,
 *     SBNS = 0) or 14 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 15 (if M = 1,
 *     SBNS = 1 or M10 = 1, SNBS = 0) or 16 (if M10 = 1, SNBS = 1).
 */
/*@{*/
#define BP_LPUART_STAT_BRK13 (26U)         /*!< Bit position for LPUART_STAT_BRK13. */
#define BM_LPUART_STAT_BRK13 (0x04000000U) /*!< Bit mask for LPUART_STAT_BRK13. */
#define BS_LPUART_STAT_BRK13 (1U)          /*!< Bit field size in bits for LPUART_STAT_BRK13. */

/*! @brief Read current value of the LPUART_STAT_BRK13 field. */
#define BR_LPUART_STAT_BRK13(x) (BME_UBFX32(HW_LPUART_STAT_ADDR(x), BP_LPUART_STAT_BRK13, BS_LPUART_STAT_BRK13))

/*! @brief Format value for bitfield LPUART_STAT_BRK13. */
#define BF_LPUART_STAT_BRK13(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_STAT_BRK13) & BM_LPUART_STAT_BRK13)

/*! @brief Set the BRK13 field to a new value. */
#define BW_LPUART_STAT_BRK13(x, v) (BME_BFI32(HW_LPUART_STAT_ADDR(x), ((uint32_t)(v) << BP_LPUART_STAT_BRK13), BP_LPUART_STAT_BRK13, 1))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RWUID[27] (RW)
 *
 * For RWU on idle character, RWUID controls whether the idle character that
 * wakes up the receiver sets the IDLE bit. For address match wakeup, RWUID controls
 * if the IDLE bit is set when the address does not match. This bit should only
 * be changed when the receiver is disabled.
 *
 * Values:
 * - 0 - During receive standby state (RWU = 1), the IDLE bit does not get set
 *     upon detection of an idle character. During address match wakeup, the IDLE
 *     bit does not get set when an address does not match.
 * - 1 - During receive standby state (RWU = 1), the IDLE bit gets set upon
 *     detection of an idle character. During address match wakeup, the IDLE bit does
 *     get set when an address does not match.
 */
/*@{*/
#define BP_LPUART_STAT_RWUID (27U)         /*!< Bit position for LPUART_STAT_RWUID. */
#define BM_LPUART_STAT_RWUID (0x08000000U) /*!< Bit mask for LPUART_STAT_RWUID. */
#define BS_LPUART_STAT_RWUID (1U)          /*!< Bit field size in bits for LPUART_STAT_RWUID. */

/*! @brief Read current value of the LPUART_STAT_RWUID field. */
#define BR_LPUART_STAT_RWUID(x) (BME_UBFX32(HW_LPUART_STAT_ADDR(x), BP_LPUART_STAT_RWUID, BS_LPUART_STAT_RWUID))

/*! @brief Format value for bitfield LPUART_STAT_RWUID. */
#define BF_LPUART_STAT_RWUID(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_STAT_RWUID) & BM_LPUART_STAT_RWUID)

/*! @brief Set the RWUID field to a new value. */
#define BW_LPUART_STAT_RWUID(x, v) (BME_BFI32(HW_LPUART_STAT_ADDR(x), ((uint32_t)(v) << BP_LPUART_STAT_RWUID), BP_LPUART_STAT_RWUID, 1))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RXINV[28] (RW)
 *
 * Setting this bit reverses the polarity of the received data input. Setting
 * RXINV inverts the LPUART_RX input for all cases: data bits, start and stop bits,
 * break, and idle.
 *
 * Values:
 * - 0 - Receive data not inverted.
 * - 1 - Receive data inverted.
 */
/*@{*/
#define BP_LPUART_STAT_RXINV (28U)         /*!< Bit position for LPUART_STAT_RXINV. */
#define BM_LPUART_STAT_RXINV (0x10000000U) /*!< Bit mask for LPUART_STAT_RXINV. */
#define BS_LPUART_STAT_RXINV (1U)          /*!< Bit field size in bits for LPUART_STAT_RXINV. */

/*! @brief Read current value of the LPUART_STAT_RXINV field. */
#define BR_LPUART_STAT_RXINV(x) (BME_UBFX32(HW_LPUART_STAT_ADDR(x), BP_LPUART_STAT_RXINV, BS_LPUART_STAT_RXINV))

/*! @brief Format value for bitfield LPUART_STAT_RXINV. */
#define BF_LPUART_STAT_RXINV(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_STAT_RXINV) & BM_LPUART_STAT_RXINV)

/*! @brief Set the RXINV field to a new value. */
#define BW_LPUART_STAT_RXINV(x, v) (BME_BFI32(HW_LPUART_STAT_ADDR(x), ((uint32_t)(v) << BP_LPUART_STAT_RXINV), BP_LPUART_STAT_RXINV, 1))
/*@}*/

/*!
 * @name Register LPUART_STAT, field MSBF[29] (RW)
 *
 * Setting this bit reverses the order of the bits that are transmitted and
 * received on the wire. This bit does not affect the polarity of the bits, the
 * location of the parity bit or the location of the start or stop bits. This bit
 * should only be changed when the transmitter and receiver are both disabled.
 *
 * Values:
 * - 0 - LSB (bit0) is the first bit that is transmitted following the start
 *     bit. Further, the first bit received after the start bit is identified as
 *     bit0.
 * - 1 - MSB (bit9, bit8, bit7 or bit6) is the first bit that is transmitted
 *     following the start bit depending on the setting of CTRL[M], CTRL[PE] and
 *     BAUD[M10]. Further, the first bit received after the start bit is identified
 *     as bit9, bit8, bit7 or bit6 depending on the setting of CTRL[M] and
 *     CTRL[PE].
 */
/*@{*/
#define BP_LPUART_STAT_MSBF  (29U)         /*!< Bit position for LPUART_STAT_MSBF. */
#define BM_LPUART_STAT_MSBF  (0x20000000U) /*!< Bit mask for LPUART_STAT_MSBF. */
#define BS_LPUART_STAT_MSBF  (1U)          /*!< Bit field size in bits for LPUART_STAT_MSBF. */

/*! @brief Read current value of the LPUART_STAT_MSBF field. */
#define BR_LPUART_STAT_MSBF(x) (BME_UBFX32(HW_LPUART_STAT_ADDR(x), BP_LPUART_STAT_MSBF, BS_LPUART_STAT_MSBF))

/*! @brief Format value for bitfield LPUART_STAT_MSBF. */
#define BF_LPUART_STAT_MSBF(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_STAT_MSBF) & BM_LPUART_STAT_MSBF)

/*! @brief Set the MSBF field to a new value. */
#define BW_LPUART_STAT_MSBF(x, v) (BME_BFI32(HW_LPUART_STAT_ADDR(x), ((uint32_t)(v) << BP_LPUART_STAT_MSBF), BP_LPUART_STAT_MSBF, 1))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RXEDGIF[30] (W1C)
 *
 * RXEDGIF is set when an active edge, falling if RXINV = 0, rising if RXINV=1,
 * on the LPUART_RX pin occurs. RXEDGIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0 - No active edge on the receive pin has occurred.
 * - 1 - An active edge on the receive pin has occurred.
 */
/*@{*/
#define BP_LPUART_STAT_RXEDGIF (30U)       /*!< Bit position for LPUART_STAT_RXEDGIF. */
#define BM_LPUART_STAT_RXEDGIF (0x40000000U) /*!< Bit mask for LPUART_STAT_RXEDGIF. */
#define BS_LPUART_STAT_RXEDGIF (1U)        /*!< Bit field size in bits for LPUART_STAT_RXEDGIF. */

/*! @brief Read current value of the LPUART_STAT_RXEDGIF field. */
#define BR_LPUART_STAT_RXEDGIF(x) (BME_UBFX32(HW_LPUART_STAT_ADDR(x), BP_LPUART_STAT_RXEDGIF, BS_LPUART_STAT_RXEDGIF))

/*! @brief Format value for bitfield LPUART_STAT_RXEDGIF. */
#define BF_LPUART_STAT_RXEDGIF(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_STAT_RXEDGIF) & BM_LPUART_STAT_RXEDGIF)

/*! @brief Set the RXEDGIF field to a new value. */
#define BW_LPUART_STAT_RXEDGIF(x, v) (BME_BFI32(HW_LPUART_STAT_ADDR(x), ((uint32_t)(v) << BP_LPUART_STAT_RXEDGIF), BP_LPUART_STAT_RXEDGIF, 1))
/*@}*/

/*!
 * @name Register LPUART_STAT, field LBKDIF[31] (W1C)
 *
 * LBKDIF is set when the LIN break detect circuitry is enabled and a LIN break
 * character is detected. LBKDIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0 - No LIN break character has been detected.
 * - 1 - LIN break character has been detected.
 */
/*@{*/
#define BP_LPUART_STAT_LBKDIF (31U)        /*!< Bit position for LPUART_STAT_LBKDIF. */
#define BM_LPUART_STAT_LBKDIF (0x80000000U) /*!< Bit mask for LPUART_STAT_LBKDIF. */
#define BS_LPUART_STAT_LBKDIF (1U)         /*!< Bit field size in bits for LPUART_STAT_LBKDIF. */

/*! @brief Read current value of the LPUART_STAT_LBKDIF field. */
#define BR_LPUART_STAT_LBKDIF(x) (BME_UBFX32(HW_LPUART_STAT_ADDR(x), BP_LPUART_STAT_LBKDIF, BS_LPUART_STAT_LBKDIF))

/*! @brief Format value for bitfield LPUART_STAT_LBKDIF. */
#define BF_LPUART_STAT_LBKDIF(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_STAT_LBKDIF) & BM_LPUART_STAT_LBKDIF)

/*! @brief Set the LBKDIF field to a new value. */
#define BW_LPUART_STAT_LBKDIF(x, v) (BME_BFI32(HW_LPUART_STAT_ADDR(x), ((uint32_t)(v) << BP_LPUART_STAT_LBKDIF), BP_LPUART_STAT_LBKDIF, 1))
/*@}*/

/*******************************************************************************
 * HW_LPUART_CTRL - LPUART Control Register
 ******************************************************************************/

/*!
 * @brief HW_LPUART_CTRL - LPUART Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This read/write register controls various optional features of the LPUART
 * system. This register should only be altered when the transmitter and receiver
 * are both disabled.
 */
typedef union _hw_lpuart_ctrl
{
    uint32_t U;
    struct _hw_lpuart_ctrl_bitfields
    {
        uint32_t PT : 1;               /*!< [0] Parity Type */
        uint32_t PE : 1;               /*!< [1] Parity Enable */
        uint32_t ILT : 1;              /*!< [2] Idle Line Type Select */
        uint32_t WAKE : 1;             /*!< [3] Receiver Wakeup Method Select */
        uint32_t M : 1;                /*!< [4] 9-Bit or 8-Bit Mode Select */
        uint32_t RSRC : 1;             /*!< [5] Receiver Source Select */
        uint32_t DOZEEN : 1;           /*!< [6] Doze Enable */
        uint32_t LOOPS : 1;            /*!< [7] Loop Mode Select */
        uint32_t IDLECFG : 3;          /*!< [10:8] Idle Configuration */
        uint32_t RESERVED0 : 3;        /*!< [13:11]  */
        uint32_t MA2IE : 1;            /*!< [14] Match 2 Interrupt Enable */
        uint32_t MA1IE : 1;            /*!< [15] Match 1 Interrupt Enable */
        uint32_t SBK : 1;              /*!< [16] Send Break */
        uint32_t RWU : 1;              /*!< [17] Receiver Wakeup Control */
        uint32_t RE : 1;               /*!< [18] Receiver Enable */
        uint32_t TE : 1;               /*!< [19] Transmitter Enable */
        uint32_t ILIE : 1;             /*!< [20] Idle Line Interrupt Enable */
        uint32_t RIE : 1;              /*!< [21] Receiver Interrupt Enable */
        uint32_t TCIE : 1;             /*!< [22] Transmission Complete Interrupt Enable
                                        * for */
        uint32_t TIE : 1;              /*!< [23] Transmit Interrupt Enable */
        uint32_t PEIE : 1;             /*!< [24] Parity Error Interrupt Enable */
        uint32_t FEIE : 1;             /*!< [25] Framing Error Interrupt Enable */
        uint32_t NEIE : 1;             /*!< [26] Noise Error Interrupt Enable */
        uint32_t ORIE : 1;             /*!< [27] Overrun Interrupt Enable */
        uint32_t TXINV : 1;            /*!< [28] Transmit Data Inversion */
        uint32_t TXDIR : 1;            /*!< [29] LPUART_TX Pin Direction in Single-Wire
                                        * Mode */
        uint32_t R9T8 : 1;             /*!< [30] Receive Bit 9 / Transmit Bit 8 */
        uint32_t R8T9 : 1;             /*!< [31] Receive Bit 8 / Transmit Bit 9 */
    } B;
} hw_lpuart_ctrl_t;

/*!
 * @name Constants and macros for entire LPUART_CTRL register
 */
/*@{*/
#define HW_LPUART_CTRL_ADDR(x)   ((uint32_t)(x) + 0x8U)

#define HW_LPUART_CTRL(x)        (*(__IO hw_lpuart_ctrl_t *) HW_LPUART_CTRL_ADDR(x))
#define HW_LPUART_CTRL_RD(x)     (HW_LPUART_CTRL(x).U)
#define HW_LPUART_CTRL_WR(x, v)  (HW_LPUART_CTRL(x).U = (v))
#define HW_LPUART_CTRL_SET(x, v) (BME_OR32(HW_LPUART_CTRL_ADDR(x), (uint32_t)(v)))
#define HW_LPUART_CTRL_CLR(x, v) (BME_AND32(HW_LPUART_CTRL_ADDR(x), (uint32_t)(~(v))))
#define HW_LPUART_CTRL_TOG(x, v) (BME_XOR32(HW_LPUART_CTRL_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LPUART_CTRL bitfields
 */

/*!
 * @name Register LPUART_CTRL, field PT[0] (RW)
 *
 * Provided parity is enabled (PE = 1), this bit selects even or odd parity. Odd
 * parity means the total number of 1s in the data character, including the
 * parity bit, is odd. Even parity means the total number of 1s in the data
 * character, including the parity bit, is even.
 *
 * Values:
 * - 0 - Even parity.
 * - 1 - Odd parity.
 */
/*@{*/
#define BP_LPUART_CTRL_PT    (0U)          /*!< Bit position for LPUART_CTRL_PT. */
#define BM_LPUART_CTRL_PT    (0x00000001U) /*!< Bit mask for LPUART_CTRL_PT. */
#define BS_LPUART_CTRL_PT    (1U)          /*!< Bit field size in bits for LPUART_CTRL_PT. */

/*! @brief Read current value of the LPUART_CTRL_PT field. */
#define BR_LPUART_CTRL_PT(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_PT, BS_LPUART_CTRL_PT))

/*! @brief Format value for bitfield LPUART_CTRL_PT. */
#define BF_LPUART_CTRL_PT(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_PT) & BM_LPUART_CTRL_PT)

/*! @brief Set the PT field to a new value. */
#define BW_LPUART_CTRL_PT(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_PT), BP_LPUART_CTRL_PT, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field PE[1] (RW)
 *
 * Enables hardware parity generation and checking. When parity is enabled, the
 * bit immediately before the stop bit is treated as the parity bit.
 *
 * Values:
 * - 0 - No hardware parity generation or checking.
 * - 1 - Parity enabled.
 */
/*@{*/
#define BP_LPUART_CTRL_PE    (1U)          /*!< Bit position for LPUART_CTRL_PE. */
#define BM_LPUART_CTRL_PE    (0x00000002U) /*!< Bit mask for LPUART_CTRL_PE. */
#define BS_LPUART_CTRL_PE    (1U)          /*!< Bit field size in bits for LPUART_CTRL_PE. */

/*! @brief Read current value of the LPUART_CTRL_PE field. */
#define BR_LPUART_CTRL_PE(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_PE, BS_LPUART_CTRL_PE))

/*! @brief Format value for bitfield LPUART_CTRL_PE. */
#define BF_LPUART_CTRL_PE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_PE) & BM_LPUART_CTRL_PE)

/*! @brief Set the PE field to a new value. */
#define BW_LPUART_CTRL_PE(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_PE), BP_LPUART_CTRL_PE, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field ILT[2] (RW)
 *
 * Determines when the receiver starts counting logic 1s as idle character bits.
 * The count begins either after a valid start bit or after the stop bit. If the
 * count begins after the start bit, then a string of logic 1s preceding the
 * stop bit can cause false recognition of an idle character. Beginning the count
 * after the stop bit avoids false idle character recognition, but requires
 * properly synchronized transmissions. In case the LPUART is programmed with ILT = 1, a
 * logic 0 is automatically shifted after a received stop bit, therefore
 * resetting the idle count.
 *
 * Values:
 * - 0 - Idle character bit count starts after start bit.
 * - 1 - Idle character bit count starts after stop bit.
 */
/*@{*/
#define BP_LPUART_CTRL_ILT   (2U)          /*!< Bit position for LPUART_CTRL_ILT. */
#define BM_LPUART_CTRL_ILT   (0x00000004U) /*!< Bit mask for LPUART_CTRL_ILT. */
#define BS_LPUART_CTRL_ILT   (1U)          /*!< Bit field size in bits for LPUART_CTRL_ILT. */

/*! @brief Read current value of the LPUART_CTRL_ILT field. */
#define BR_LPUART_CTRL_ILT(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_ILT, BS_LPUART_CTRL_ILT))

/*! @brief Format value for bitfield LPUART_CTRL_ILT. */
#define BF_LPUART_CTRL_ILT(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_ILT) & BM_LPUART_CTRL_ILT)

/*! @brief Set the ILT field to a new value. */
#define BW_LPUART_CTRL_ILT(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_ILT), BP_LPUART_CTRL_ILT, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field WAKE[3] (RW)
 *
 * Determines which condition wakes the LPUART when RWU=1: Address mark in the
 * most significant bit position of a received data character, or An idle
 * condition on the receive pin input signal.
 *
 * Values:
 * - 0 - Configures RWU for idle-line wakeup.
 * - 1 - Configures RWU with address-mark wakeup.
 */
/*@{*/
#define BP_LPUART_CTRL_WAKE  (3U)          /*!< Bit position for LPUART_CTRL_WAKE. */
#define BM_LPUART_CTRL_WAKE  (0x00000008U) /*!< Bit mask for LPUART_CTRL_WAKE. */
#define BS_LPUART_CTRL_WAKE  (1U)          /*!< Bit field size in bits for LPUART_CTRL_WAKE. */

/*! @brief Read current value of the LPUART_CTRL_WAKE field. */
#define BR_LPUART_CTRL_WAKE(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_WAKE, BS_LPUART_CTRL_WAKE))

/*! @brief Format value for bitfield LPUART_CTRL_WAKE. */
#define BF_LPUART_CTRL_WAKE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_WAKE) & BM_LPUART_CTRL_WAKE)

/*! @brief Set the WAKE field to a new value. */
#define BW_LPUART_CTRL_WAKE(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_WAKE), BP_LPUART_CTRL_WAKE, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field M[4] (RW)
 *
 * Values:
 * - 0 - Receiver and transmitter use 8-bit data characters.
 * - 1 - Receiver and transmitter use 9-bit data characters.
 */
/*@{*/
#define BP_LPUART_CTRL_M     (4U)          /*!< Bit position for LPUART_CTRL_M. */
#define BM_LPUART_CTRL_M     (0x00000010U) /*!< Bit mask for LPUART_CTRL_M. */
#define BS_LPUART_CTRL_M     (1U)          /*!< Bit field size in bits for LPUART_CTRL_M. */

/*! @brief Read current value of the LPUART_CTRL_M field. */
#define BR_LPUART_CTRL_M(x)  (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_M, BS_LPUART_CTRL_M))

/*! @brief Format value for bitfield LPUART_CTRL_M. */
#define BF_LPUART_CTRL_M(v)  ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_M) & BM_LPUART_CTRL_M)

/*! @brief Set the M field to a new value. */
#define BW_LPUART_CTRL_M(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_M), BP_LPUART_CTRL_M, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RSRC[5] (RW)
 *
 * This field has no meaning or effect unless the LOOPS field is set. When LOOPS
 * is set, the RSRC field determines the source for the receiver shift register
 * input.
 *
 * Values:
 * - 0 - Provided LOOPS is set, RSRC is cleared, selects internal loop back mode
 *     and the LPUART does not use the LPUART_RX pin.
 * - 1 - Single-wire LPUART mode where the LPUART_TX pin is connected to the
 *     transmitter output and receiver input.
 */
/*@{*/
#define BP_LPUART_CTRL_RSRC  (5U)          /*!< Bit position for LPUART_CTRL_RSRC. */
#define BM_LPUART_CTRL_RSRC  (0x00000020U) /*!< Bit mask for LPUART_CTRL_RSRC. */
#define BS_LPUART_CTRL_RSRC  (1U)          /*!< Bit field size in bits for LPUART_CTRL_RSRC. */

/*! @brief Read current value of the LPUART_CTRL_RSRC field. */
#define BR_LPUART_CTRL_RSRC(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_RSRC, BS_LPUART_CTRL_RSRC))

/*! @brief Format value for bitfield LPUART_CTRL_RSRC. */
#define BF_LPUART_CTRL_RSRC(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_RSRC) & BM_LPUART_CTRL_RSRC)

/*! @brief Set the RSRC field to a new value. */
#define BW_LPUART_CTRL_RSRC(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_RSRC), BP_LPUART_CTRL_RSRC, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field DOZEEN[6] (RW)
 *
 * Values:
 * - 0 - LPUART is enabled in Doze mode.
 * - 1 - LPUART is disabled in Doze mode.
 */
/*@{*/
#define BP_LPUART_CTRL_DOZEEN (6U)         /*!< Bit position for LPUART_CTRL_DOZEEN. */
#define BM_LPUART_CTRL_DOZEEN (0x00000040U) /*!< Bit mask for LPUART_CTRL_DOZEEN. */
#define BS_LPUART_CTRL_DOZEEN (1U)         /*!< Bit field size in bits for LPUART_CTRL_DOZEEN. */

/*! @brief Read current value of the LPUART_CTRL_DOZEEN field. */
#define BR_LPUART_CTRL_DOZEEN(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_DOZEEN, BS_LPUART_CTRL_DOZEEN))

/*! @brief Format value for bitfield LPUART_CTRL_DOZEEN. */
#define BF_LPUART_CTRL_DOZEEN(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_DOZEEN) & BM_LPUART_CTRL_DOZEEN)

/*! @brief Set the DOZEEN field to a new value. */
#define BW_LPUART_CTRL_DOZEEN(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_DOZEEN), BP_LPUART_CTRL_DOZEEN, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field LOOPS[7] (RW)
 *
 * When LOOPS is set, the LPUART_RX pin is disconnected from the LPUART and the
 * transmitter output is internally connected to the receiver input. The
 * transmitter and the receiver must be enabled to use the loop function.
 *
 * Values:
 * - 0 - Normal operation - LPUART_RX and LPUART_TX use separate pins.
 * - 1 - Loop mode or single-wire mode where transmitter outputs are internally
 *     connected to receiver input (see RSRC bit).
 */
/*@{*/
#define BP_LPUART_CTRL_LOOPS (7U)          /*!< Bit position for LPUART_CTRL_LOOPS. */
#define BM_LPUART_CTRL_LOOPS (0x00000080U) /*!< Bit mask for LPUART_CTRL_LOOPS. */
#define BS_LPUART_CTRL_LOOPS (1U)          /*!< Bit field size in bits for LPUART_CTRL_LOOPS. */

/*! @brief Read current value of the LPUART_CTRL_LOOPS field. */
#define BR_LPUART_CTRL_LOOPS(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_LOOPS, BS_LPUART_CTRL_LOOPS))

/*! @brief Format value for bitfield LPUART_CTRL_LOOPS. */
#define BF_LPUART_CTRL_LOOPS(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_LOOPS) & BM_LPUART_CTRL_LOOPS)

/*! @brief Set the LOOPS field to a new value. */
#define BW_LPUART_CTRL_LOOPS(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_LOOPS), BP_LPUART_CTRL_LOOPS, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field IDLECFG[10:8] (RW)
 *
 * Configures the number of idle characters that must be received before the
 * IDLE flag is set.
 *
 * Values:
 * - 000 - 1 idle character
 * - 001 - 2 idle characters
 * - 010 - 4 idle characters
 * - 011 - 8 idle characters
 * - 100 - 16 idle characters
 * - 101 - 32 idle characters
 * - 110 - 64 idle characters
 * - 111 - 128 idle characters
 */
/*@{*/
#define BP_LPUART_CTRL_IDLECFG (8U)        /*!< Bit position for LPUART_CTRL_IDLECFG. */
#define BM_LPUART_CTRL_IDLECFG (0x00000700U) /*!< Bit mask for LPUART_CTRL_IDLECFG. */
#define BS_LPUART_CTRL_IDLECFG (3U)        /*!< Bit field size in bits for LPUART_CTRL_IDLECFG. */

/*! @brief Read current value of the LPUART_CTRL_IDLECFG field. */
#define BR_LPUART_CTRL_IDLECFG(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_IDLECFG, BS_LPUART_CTRL_IDLECFG))

/*! @brief Format value for bitfield LPUART_CTRL_IDLECFG. */
#define BF_LPUART_CTRL_IDLECFG(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_IDLECFG) & BM_LPUART_CTRL_IDLECFG)

/*! @brief Set the IDLECFG field to a new value. */
#define BW_LPUART_CTRL_IDLECFG(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_IDLECFG), BP_LPUART_CTRL_IDLECFG, 3))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field MA2IE[14] (RW)
 *
 * Values:
 * - 0 - MA2F interrupt disabled
 * - 1 - MA2F interrupt enabled
 */
/*@{*/
#define BP_LPUART_CTRL_MA2IE (14U)         /*!< Bit position for LPUART_CTRL_MA2IE. */
#define BM_LPUART_CTRL_MA2IE (0x00004000U) /*!< Bit mask for LPUART_CTRL_MA2IE. */
#define BS_LPUART_CTRL_MA2IE (1U)          /*!< Bit field size in bits for LPUART_CTRL_MA2IE. */

/*! @brief Read current value of the LPUART_CTRL_MA2IE field. */
#define BR_LPUART_CTRL_MA2IE(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_MA2IE, BS_LPUART_CTRL_MA2IE))

/*! @brief Format value for bitfield LPUART_CTRL_MA2IE. */
#define BF_LPUART_CTRL_MA2IE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_MA2IE) & BM_LPUART_CTRL_MA2IE)

/*! @brief Set the MA2IE field to a new value. */
#define BW_LPUART_CTRL_MA2IE(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_MA2IE), BP_LPUART_CTRL_MA2IE, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field MA1IE[15] (RW)
 *
 * Values:
 * - 0 - MA1F interrupt disabled
 * - 1 - MA1F interrupt enabled
 */
/*@{*/
#define BP_LPUART_CTRL_MA1IE (15U)         /*!< Bit position for LPUART_CTRL_MA1IE. */
#define BM_LPUART_CTRL_MA1IE (0x00008000U) /*!< Bit mask for LPUART_CTRL_MA1IE. */
#define BS_LPUART_CTRL_MA1IE (1U)          /*!< Bit field size in bits for LPUART_CTRL_MA1IE. */

/*! @brief Read current value of the LPUART_CTRL_MA1IE field. */
#define BR_LPUART_CTRL_MA1IE(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_MA1IE, BS_LPUART_CTRL_MA1IE))

/*! @brief Format value for bitfield LPUART_CTRL_MA1IE. */
#define BF_LPUART_CTRL_MA1IE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_MA1IE) & BM_LPUART_CTRL_MA1IE)

/*! @brief Set the MA1IE field to a new value. */
#define BW_LPUART_CTRL_MA1IE(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_MA1IE), BP_LPUART_CTRL_MA1IE, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field SBK[16] (RW)
 *
 * Writing a 1 and then a 0 to SBK queues a break character in the transmit data
 * stream. Additional break characters of 10 to 13, or 13 to 16 if
 * LPUART_STATBRK13] is set, bit times of logic 0 are queued as long as SBK is set. Depending
 * on the timing of the set and clear of SBK relative to the information
 * currently being transmitted, a second break character may be queued before software
 * clears SBK.
 *
 * Values:
 * - 0 - Normal transmitter operation.
 * - 1 - Queue break character(s) to be sent.
 */
/*@{*/
#define BP_LPUART_CTRL_SBK   (16U)         /*!< Bit position for LPUART_CTRL_SBK. */
#define BM_LPUART_CTRL_SBK   (0x00010000U) /*!< Bit mask for LPUART_CTRL_SBK. */
#define BS_LPUART_CTRL_SBK   (1U)          /*!< Bit field size in bits for LPUART_CTRL_SBK. */

/*! @brief Read current value of the LPUART_CTRL_SBK field. */
#define BR_LPUART_CTRL_SBK(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_SBK, BS_LPUART_CTRL_SBK))

/*! @brief Format value for bitfield LPUART_CTRL_SBK. */
#define BF_LPUART_CTRL_SBK(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_SBK) & BM_LPUART_CTRL_SBK)

/*! @brief Set the SBK field to a new value. */
#define BW_LPUART_CTRL_SBK(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_SBK), BP_LPUART_CTRL_SBK, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RWU[17] (RW)
 *
 * This field can be set to place the LPUART receiver in a standby state. RWU
 * automatically clears when an RWU event occurs, that is, an IDLE event when
 * CTRL[WAKE] is clear or an address match when CTRL[WAKE] is set with STAT[RWUID] is
 * clear. RWU must be set only with CTRL[WAKE] = 0 (wakeup on idle) if the
 * channel is currently not idle. This can be determined by STAT[RAF]. If the flag is
 * set to wake up an IDLE event and the channel is already idle, it is possible
 * that the LPUART will discard data. This is because the data must be received or
 * a LIN break detected after an IDLE is detected before IDLE is allowed to
 * reasserted.
 *
 * Values:
 * - 0 - Normal receiver operation.
 * - 1 - LPUART receiver in standby waiting for wakeup condition.
 */
/*@{*/
#define BP_LPUART_CTRL_RWU   (17U)         /*!< Bit position for LPUART_CTRL_RWU. */
#define BM_LPUART_CTRL_RWU   (0x00020000U) /*!< Bit mask for LPUART_CTRL_RWU. */
#define BS_LPUART_CTRL_RWU   (1U)          /*!< Bit field size in bits for LPUART_CTRL_RWU. */

/*! @brief Read current value of the LPUART_CTRL_RWU field. */
#define BR_LPUART_CTRL_RWU(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_RWU, BS_LPUART_CTRL_RWU))

/*! @brief Format value for bitfield LPUART_CTRL_RWU. */
#define BF_LPUART_CTRL_RWU(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_RWU) & BM_LPUART_CTRL_RWU)

/*! @brief Set the RWU field to a new value. */
#define BW_LPUART_CTRL_RWU(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_RWU), BP_LPUART_CTRL_RWU, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RE[18] (RW)
 *
 * Enables the LPUART receiver. When RE is written to 0, this register bit will
 * read as 1 until the receiver finishes receiving the current character (if any).
 *
 * Values:
 * - 0 - Receiver disabled.
 * - 1 - Receiver enabled.
 */
/*@{*/
#define BP_LPUART_CTRL_RE    (18U)         /*!< Bit position for LPUART_CTRL_RE. */
#define BM_LPUART_CTRL_RE    (0x00040000U) /*!< Bit mask for LPUART_CTRL_RE. */
#define BS_LPUART_CTRL_RE    (1U)          /*!< Bit field size in bits for LPUART_CTRL_RE. */

/*! @brief Read current value of the LPUART_CTRL_RE field. */
#define BR_LPUART_CTRL_RE(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_RE, BS_LPUART_CTRL_RE))

/*! @brief Format value for bitfield LPUART_CTRL_RE. */
#define BF_LPUART_CTRL_RE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_RE) & BM_LPUART_CTRL_RE)

/*! @brief Set the RE field to a new value. */
#define BW_LPUART_CTRL_RE(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_RE), BP_LPUART_CTRL_RE, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TE[19] (RW)
 *
 * Enables the LPUART transmitter. TE can also be used to queue an idle preamble
 * by clearing and then setting TE. When TE is cleared, this register bit will
 * read as 1 until the transmitter has completed the current character and the
 * LPUART_TX pin is tristated.
 *
 * Values:
 * - 0 - Transmitter disabled.
 * - 1 - Transmitter enabled.
 */
/*@{*/
#define BP_LPUART_CTRL_TE    (19U)         /*!< Bit position for LPUART_CTRL_TE. */
#define BM_LPUART_CTRL_TE    (0x00080000U) /*!< Bit mask for LPUART_CTRL_TE. */
#define BS_LPUART_CTRL_TE    (1U)          /*!< Bit field size in bits for LPUART_CTRL_TE. */

/*! @brief Read current value of the LPUART_CTRL_TE field. */
#define BR_LPUART_CTRL_TE(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_TE, BS_LPUART_CTRL_TE))

/*! @brief Format value for bitfield LPUART_CTRL_TE. */
#define BF_LPUART_CTRL_TE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_TE) & BM_LPUART_CTRL_TE)

/*! @brief Set the TE field to a new value. */
#define BW_LPUART_CTRL_TE(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_TE), BP_LPUART_CTRL_TE, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field ILIE[20] (RW)
 *
 * ILIE enables the idle line flag, STAT[IDLE], to generate interrupt requests.
 *
 * Values:
 * - 0 - Hardware interrupts from IDLE disabled; use polling.
 * - 1 - Hardware interrupt requested when IDLE flag is 1.
 */
/*@{*/
#define BP_LPUART_CTRL_ILIE  (20U)         /*!< Bit position for LPUART_CTRL_ILIE. */
#define BM_LPUART_CTRL_ILIE  (0x00100000U) /*!< Bit mask for LPUART_CTRL_ILIE. */
#define BS_LPUART_CTRL_ILIE  (1U)          /*!< Bit field size in bits for LPUART_CTRL_ILIE. */

/*! @brief Read current value of the LPUART_CTRL_ILIE field. */
#define BR_LPUART_CTRL_ILIE(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_ILIE, BS_LPUART_CTRL_ILIE))

/*! @brief Format value for bitfield LPUART_CTRL_ILIE. */
#define BF_LPUART_CTRL_ILIE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_ILIE) & BM_LPUART_CTRL_ILIE)

/*! @brief Set the ILIE field to a new value. */
#define BW_LPUART_CTRL_ILIE(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_ILIE), BP_LPUART_CTRL_ILIE, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RIE[21] (RW)
 *
 * Enables STAT[RDRF] to generate interrupt requests.
 *
 * Values:
 * - 0 - Hardware interrupts from RDRF disabled; use polling.
 * - 1 - Hardware interrupt requested when RDRF flag is 1.
 */
/*@{*/
#define BP_LPUART_CTRL_RIE   (21U)         /*!< Bit position for LPUART_CTRL_RIE. */
#define BM_LPUART_CTRL_RIE   (0x00200000U) /*!< Bit mask for LPUART_CTRL_RIE. */
#define BS_LPUART_CTRL_RIE   (1U)          /*!< Bit field size in bits for LPUART_CTRL_RIE. */

/*! @brief Read current value of the LPUART_CTRL_RIE field. */
#define BR_LPUART_CTRL_RIE(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_RIE, BS_LPUART_CTRL_RIE))

/*! @brief Format value for bitfield LPUART_CTRL_RIE. */
#define BF_LPUART_CTRL_RIE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_RIE) & BM_LPUART_CTRL_RIE)

/*! @brief Set the RIE field to a new value. */
#define BW_LPUART_CTRL_RIE(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_RIE), BP_LPUART_CTRL_RIE, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TCIE[22] (RW)
 *
 * TCIE enables the transmission complete flag, TC, to generate interrupt
 * requests.
 *
 * Values:
 * - 0 - Hardware interrupts from TC disabled; use polling.
 * - 1 - Hardware interrupt requested when TC flag is 1.
 */
/*@{*/
#define BP_LPUART_CTRL_TCIE  (22U)         /*!< Bit position for LPUART_CTRL_TCIE. */
#define BM_LPUART_CTRL_TCIE  (0x00400000U) /*!< Bit mask for LPUART_CTRL_TCIE. */
#define BS_LPUART_CTRL_TCIE  (1U)          /*!< Bit field size in bits for LPUART_CTRL_TCIE. */

/*! @brief Read current value of the LPUART_CTRL_TCIE field. */
#define BR_LPUART_CTRL_TCIE(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_TCIE, BS_LPUART_CTRL_TCIE))

/*! @brief Format value for bitfield LPUART_CTRL_TCIE. */
#define BF_LPUART_CTRL_TCIE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_TCIE) & BM_LPUART_CTRL_TCIE)

/*! @brief Set the TCIE field to a new value. */
#define BW_LPUART_CTRL_TCIE(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_TCIE), BP_LPUART_CTRL_TCIE, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TIE[23] (RW)
 *
 * Enables STAT[TDRE] to generate interrupt requests.
 *
 * Values:
 * - 0 - Hardware interrupts from TDRE disabled; use polling.
 * - 1 - Hardware interrupt requested when TDRE flag is 1.
 */
/*@{*/
#define BP_LPUART_CTRL_TIE   (23U)         /*!< Bit position for LPUART_CTRL_TIE. */
#define BM_LPUART_CTRL_TIE   (0x00800000U) /*!< Bit mask for LPUART_CTRL_TIE. */
#define BS_LPUART_CTRL_TIE   (1U)          /*!< Bit field size in bits for LPUART_CTRL_TIE. */

/*! @brief Read current value of the LPUART_CTRL_TIE field. */
#define BR_LPUART_CTRL_TIE(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_TIE, BS_LPUART_CTRL_TIE))

/*! @brief Format value for bitfield LPUART_CTRL_TIE. */
#define BF_LPUART_CTRL_TIE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_TIE) & BM_LPUART_CTRL_TIE)

/*! @brief Set the TIE field to a new value. */
#define BW_LPUART_CTRL_TIE(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_TIE), BP_LPUART_CTRL_TIE, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field PEIE[24] (RW)
 *
 * This bit enables the parity error flag (PF) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0 - PF interrupts disabled; use polling).
 * - 1 - Hardware interrupt requested when PF is set.
 */
/*@{*/
#define BP_LPUART_CTRL_PEIE  (24U)         /*!< Bit position for LPUART_CTRL_PEIE. */
#define BM_LPUART_CTRL_PEIE  (0x01000000U) /*!< Bit mask for LPUART_CTRL_PEIE. */
#define BS_LPUART_CTRL_PEIE  (1U)          /*!< Bit field size in bits for LPUART_CTRL_PEIE. */

/*! @brief Read current value of the LPUART_CTRL_PEIE field. */
#define BR_LPUART_CTRL_PEIE(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_PEIE, BS_LPUART_CTRL_PEIE))

/*! @brief Format value for bitfield LPUART_CTRL_PEIE. */
#define BF_LPUART_CTRL_PEIE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_PEIE) & BM_LPUART_CTRL_PEIE)

/*! @brief Set the PEIE field to a new value. */
#define BW_LPUART_CTRL_PEIE(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_PEIE), BP_LPUART_CTRL_PEIE, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field FEIE[25] (RW)
 *
 * This bit enables the framing error flag (FE) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0 - FE interrupts disabled; use polling.
 * - 1 - Hardware interrupt requested when FE is set.
 */
/*@{*/
#define BP_LPUART_CTRL_FEIE  (25U)         /*!< Bit position for LPUART_CTRL_FEIE. */
#define BM_LPUART_CTRL_FEIE  (0x02000000U) /*!< Bit mask for LPUART_CTRL_FEIE. */
#define BS_LPUART_CTRL_FEIE  (1U)          /*!< Bit field size in bits for LPUART_CTRL_FEIE. */

/*! @brief Read current value of the LPUART_CTRL_FEIE field. */
#define BR_LPUART_CTRL_FEIE(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_FEIE, BS_LPUART_CTRL_FEIE))

/*! @brief Format value for bitfield LPUART_CTRL_FEIE. */
#define BF_LPUART_CTRL_FEIE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_FEIE) & BM_LPUART_CTRL_FEIE)

/*! @brief Set the FEIE field to a new value. */
#define BW_LPUART_CTRL_FEIE(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_FEIE), BP_LPUART_CTRL_FEIE, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field NEIE[26] (RW)
 *
 * This bit enables the noise flag (NF) to generate hardware interrupt requests.
 *
 * Values:
 * - 0 - NF interrupts disabled; use polling.
 * - 1 - Hardware interrupt requested when NF is set.
 */
/*@{*/
#define BP_LPUART_CTRL_NEIE  (26U)         /*!< Bit position for LPUART_CTRL_NEIE. */
#define BM_LPUART_CTRL_NEIE  (0x04000000U) /*!< Bit mask for LPUART_CTRL_NEIE. */
#define BS_LPUART_CTRL_NEIE  (1U)          /*!< Bit field size in bits for LPUART_CTRL_NEIE. */

/*! @brief Read current value of the LPUART_CTRL_NEIE field. */
#define BR_LPUART_CTRL_NEIE(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_NEIE, BS_LPUART_CTRL_NEIE))

/*! @brief Format value for bitfield LPUART_CTRL_NEIE. */
#define BF_LPUART_CTRL_NEIE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_NEIE) & BM_LPUART_CTRL_NEIE)

/*! @brief Set the NEIE field to a new value. */
#define BW_LPUART_CTRL_NEIE(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_NEIE), BP_LPUART_CTRL_NEIE, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field ORIE[27] (RW)
 *
 * This bit enables the overrun flag (OR) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0 - OR interrupts disabled; use polling.
 * - 1 - Hardware interrupt requested when OR is set.
 */
/*@{*/
#define BP_LPUART_CTRL_ORIE  (27U)         /*!< Bit position for LPUART_CTRL_ORIE. */
#define BM_LPUART_CTRL_ORIE  (0x08000000U) /*!< Bit mask for LPUART_CTRL_ORIE. */
#define BS_LPUART_CTRL_ORIE  (1U)          /*!< Bit field size in bits for LPUART_CTRL_ORIE. */

/*! @brief Read current value of the LPUART_CTRL_ORIE field. */
#define BR_LPUART_CTRL_ORIE(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_ORIE, BS_LPUART_CTRL_ORIE))

/*! @brief Format value for bitfield LPUART_CTRL_ORIE. */
#define BF_LPUART_CTRL_ORIE(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_ORIE) & BM_LPUART_CTRL_ORIE)

/*! @brief Set the ORIE field to a new value. */
#define BW_LPUART_CTRL_ORIE(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_ORIE), BP_LPUART_CTRL_ORIE, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TXINV[28] (RW)
 *
 * Setting this bit reverses the polarity of the transmitted data output.
 * Setting TXINV inverts the LPUART_TX output for all cases: data bits, start and stop
 * bits, break, and idle.
 *
 * Values:
 * - 0 - Transmit data not inverted.
 * - 1 - Transmit data inverted.
 */
/*@{*/
#define BP_LPUART_CTRL_TXINV (28U)         /*!< Bit position for LPUART_CTRL_TXINV. */
#define BM_LPUART_CTRL_TXINV (0x10000000U) /*!< Bit mask for LPUART_CTRL_TXINV. */
#define BS_LPUART_CTRL_TXINV (1U)          /*!< Bit field size in bits for LPUART_CTRL_TXINV. */

/*! @brief Read current value of the LPUART_CTRL_TXINV field. */
#define BR_LPUART_CTRL_TXINV(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_TXINV, BS_LPUART_CTRL_TXINV))

/*! @brief Format value for bitfield LPUART_CTRL_TXINV. */
#define BF_LPUART_CTRL_TXINV(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_TXINV) & BM_LPUART_CTRL_TXINV)

/*! @brief Set the TXINV field to a new value. */
#define BW_LPUART_CTRL_TXINV(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_TXINV), BP_LPUART_CTRL_TXINV, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TXDIR[29] (RW)
 *
 * When the LPUART is configured for single-wire half-duplex operation (LOOPS =
 * RSRC = 1), this bit determines the direction of data at the LPUART_TX pin.
 * When clearing TXDIR, the transmitter will finish receiving the current character
 * (if any) before the receiver starts receiving data from the LPUART_TX pin.
 *
 * Values:
 * - 0 - LPUART_TX pin is an input in single-wire mode.
 * - 1 - LPUART_TX pin is an output in single-wire mode.
 */
/*@{*/
#define BP_LPUART_CTRL_TXDIR (29U)         /*!< Bit position for LPUART_CTRL_TXDIR. */
#define BM_LPUART_CTRL_TXDIR (0x20000000U) /*!< Bit mask for LPUART_CTRL_TXDIR. */
#define BS_LPUART_CTRL_TXDIR (1U)          /*!< Bit field size in bits for LPUART_CTRL_TXDIR. */

/*! @brief Read current value of the LPUART_CTRL_TXDIR field. */
#define BR_LPUART_CTRL_TXDIR(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_TXDIR, BS_LPUART_CTRL_TXDIR))

/*! @brief Format value for bitfield LPUART_CTRL_TXDIR. */
#define BF_LPUART_CTRL_TXDIR(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_TXDIR) & BM_LPUART_CTRL_TXDIR)

/*! @brief Set the TXDIR field to a new value. */
#define BW_LPUART_CTRL_TXDIR(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_TXDIR), BP_LPUART_CTRL_TXDIR, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field R9T8[30] (RW)
 *
 * R9 is the tenth data bit received when the LPUART is configured for 10-bit
 * data formats. When reading 10-bit data, read R9 before reading LPUART_DATA T8 is
 * the ninth data bit received when the LPUART is configured for 9-bit or 10-bit
 * data formats. When writing 9-bit or 10-bit data, write T8 before writing
 * LPUART_DATA. If T8 does not need to change from its previous value, such as when
 * it is used to generate address mark or parity, they it need not be written each
 * time LPUART_DATA is written.
 */
/*@{*/
#define BP_LPUART_CTRL_R9T8  (30U)         /*!< Bit position for LPUART_CTRL_R9T8. */
#define BM_LPUART_CTRL_R9T8  (0x40000000U) /*!< Bit mask for LPUART_CTRL_R9T8. */
#define BS_LPUART_CTRL_R9T8  (1U)          /*!< Bit field size in bits for LPUART_CTRL_R9T8. */

/*! @brief Read current value of the LPUART_CTRL_R9T8 field. */
#define BR_LPUART_CTRL_R9T8(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_R9T8, BS_LPUART_CTRL_R9T8))

/*! @brief Format value for bitfield LPUART_CTRL_R9T8. */
#define BF_LPUART_CTRL_R9T8(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_R9T8) & BM_LPUART_CTRL_R9T8)

/*! @brief Set the R9T8 field to a new value. */
#define BW_LPUART_CTRL_R9T8(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_R9T8), BP_LPUART_CTRL_R9T8, 1))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field R8T9[31] (RW)
 *
 * R8 is the ninth data bit received when the LPUART is configured for 9-bit or
 * 10-bit data formats. When reading 9-bit or 10-bit data, read R8 before reading
 * LPUART_DATA. T9 is the tenth data bit received when the LPUART is configured
 * for 10-bit data formats. When writing 10-bit data, write T9 before writing
 * LPUART_DATA. If T9 does not need to change from its previous value, such as when
 * it is used to generate address mark or parity, they it need not be written
 * each time LPUART_DATA is written.
 */
/*@{*/
#define BP_LPUART_CTRL_R8T9  (31U)         /*!< Bit position for LPUART_CTRL_R8T9. */
#define BM_LPUART_CTRL_R8T9  (0x80000000U) /*!< Bit mask for LPUART_CTRL_R8T9. */
#define BS_LPUART_CTRL_R8T9  (1U)          /*!< Bit field size in bits for LPUART_CTRL_R8T9. */

/*! @brief Read current value of the LPUART_CTRL_R8T9 field. */
#define BR_LPUART_CTRL_R8T9(x) (BME_UBFX32(HW_LPUART_CTRL_ADDR(x), BP_LPUART_CTRL_R8T9, BS_LPUART_CTRL_R8T9))

/*! @brief Format value for bitfield LPUART_CTRL_R8T9. */
#define BF_LPUART_CTRL_R8T9(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_CTRL_R8T9) & BM_LPUART_CTRL_R8T9)

/*! @brief Set the R8T9 field to a new value. */
#define BW_LPUART_CTRL_R8T9(x, v) (BME_BFI32(HW_LPUART_CTRL_ADDR(x), ((uint32_t)(v) << BP_LPUART_CTRL_R8T9), BP_LPUART_CTRL_R8T9, 1))
/*@}*/

/*******************************************************************************
 * HW_LPUART_DATA - LPUART Data Register
 ******************************************************************************/

/*!
 * @brief HW_LPUART_DATA - LPUART Data Register (RW)
 *
 * Reset value: 0x00001000U
 *
 * This register is actually two separate registers. Reads return the contents
 * of the read-only receive data buffer and writes go to the write-only transmit
 * data buffer. Reads and writes of this register are also involved in the
 * automatic flag clearing mechanisms for some of the LPUART status flags.
 */
typedef union _hw_lpuart_data
{
    uint32_t U;
    struct _hw_lpuart_data_bitfields
    {
        uint32_t R0T0 : 1;             /*!< [0]  */
        uint32_t R1T1 : 1;             /*!< [1]  */
        uint32_t R2T2 : 1;             /*!< [2]  */
        uint32_t R3T3 : 1;             /*!< [3]  */
        uint32_t R4T4 : 1;             /*!< [4]  */
        uint32_t R5T5 : 1;             /*!< [5]  */
        uint32_t R6T6 : 1;             /*!< [6]  */
        uint32_t R7T7 : 1;             /*!< [7]  */
        uint32_t R8T8 : 1;             /*!< [8]  */
        uint32_t R9T9 : 1;             /*!< [9]  */
        uint32_t RESERVED0 : 1;        /*!< [10]  */
        uint32_t IDLINE : 1;           /*!< [11] Idle Line */
        uint32_t RXEMPT : 1;           /*!< [12] Receive Buffer Empty */
        uint32_t FRETSC : 1;           /*!< [13] Frame Error / Transmit Special
                                        * Character */
        uint32_t PARITYE : 1;          /*!< [14]  */
        uint32_t NOISY : 1;            /*!< [15]  */
        uint32_t RESERVED1 : 16;       /*!< [31:16]  */
    } B;
} hw_lpuart_data_t;

/*!
 * @name Constants and macros for entire LPUART_DATA register
 */
/*@{*/
#define HW_LPUART_DATA_ADDR(x)   ((uint32_t)(x) + 0xCU)

#define HW_LPUART_DATA(x)        (*(__IO hw_lpuart_data_t *) HW_LPUART_DATA_ADDR(x))
#define HW_LPUART_DATA_RD(x)     (HW_LPUART_DATA(x).U)
#define HW_LPUART_DATA_WR(x, v)  (HW_LPUART_DATA(x).U = (v))
#define HW_LPUART_DATA_SET(x, v) (BME_OR32(HW_LPUART_DATA_ADDR(x), (uint32_t)(v)))
#define HW_LPUART_DATA_CLR(x, v) (BME_AND32(HW_LPUART_DATA_ADDR(x), (uint32_t)(~(v))))
#define HW_LPUART_DATA_TOG(x, v) (BME_XOR32(HW_LPUART_DATA_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LPUART_DATA bitfields
 */

/*!
 * @name Register LPUART_DATA, field R0T0[0] (RW)
 *
 * Read receive data buffer 0 or write transmit data buffer 0.
 */
/*@{*/
#define BP_LPUART_DATA_R0T0  (0U)          /*!< Bit position for LPUART_DATA_R0T0. */
#define BM_LPUART_DATA_R0T0  (0x00000001U) /*!< Bit mask for LPUART_DATA_R0T0. */
#define BS_LPUART_DATA_R0T0  (1U)          /*!< Bit field size in bits for LPUART_DATA_R0T0. */

/*! @brief Read current value of the LPUART_DATA_R0T0 field. */
#define BR_LPUART_DATA_R0T0(x) (BME_UBFX32(HW_LPUART_DATA_ADDR(x), BP_LPUART_DATA_R0T0, BS_LPUART_DATA_R0T0))

/*! @brief Format value for bitfield LPUART_DATA_R0T0. */
#define BF_LPUART_DATA_R0T0(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_DATA_R0T0) & BM_LPUART_DATA_R0T0)

/*! @brief Set the R0T0 field to a new value. */
#define BW_LPUART_DATA_R0T0(x, v) (BME_BFI32(HW_LPUART_DATA_ADDR(x), ((uint32_t)(v) << BP_LPUART_DATA_R0T0), BP_LPUART_DATA_R0T0, 1))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R1T1[1] (RW)
 *
 * Read receive data buffer 1 or write transmit data buffer 1.
 */
/*@{*/
#define BP_LPUART_DATA_R1T1  (1U)          /*!< Bit position for LPUART_DATA_R1T1. */
#define BM_LPUART_DATA_R1T1  (0x00000002U) /*!< Bit mask for LPUART_DATA_R1T1. */
#define BS_LPUART_DATA_R1T1  (1U)          /*!< Bit field size in bits for LPUART_DATA_R1T1. */

/*! @brief Read current value of the LPUART_DATA_R1T1 field. */
#define BR_LPUART_DATA_R1T1(x) (BME_UBFX32(HW_LPUART_DATA_ADDR(x), BP_LPUART_DATA_R1T1, BS_LPUART_DATA_R1T1))

/*! @brief Format value for bitfield LPUART_DATA_R1T1. */
#define BF_LPUART_DATA_R1T1(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_DATA_R1T1) & BM_LPUART_DATA_R1T1)

/*! @brief Set the R1T1 field to a new value. */
#define BW_LPUART_DATA_R1T1(x, v) (BME_BFI32(HW_LPUART_DATA_ADDR(x), ((uint32_t)(v) << BP_LPUART_DATA_R1T1), BP_LPUART_DATA_R1T1, 1))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R2T2[2] (RW)
 *
 * Read receive data buffer 2 or write transmit data buffer 2.
 */
/*@{*/
#define BP_LPUART_DATA_R2T2  (2U)          /*!< Bit position for LPUART_DATA_R2T2. */
#define BM_LPUART_DATA_R2T2  (0x00000004U) /*!< Bit mask for LPUART_DATA_R2T2. */
#define BS_LPUART_DATA_R2T2  (1U)          /*!< Bit field size in bits for LPUART_DATA_R2T2. */

/*! @brief Read current value of the LPUART_DATA_R2T2 field. */
#define BR_LPUART_DATA_R2T2(x) (BME_UBFX32(HW_LPUART_DATA_ADDR(x), BP_LPUART_DATA_R2T2, BS_LPUART_DATA_R2T2))

/*! @brief Format value for bitfield LPUART_DATA_R2T2. */
#define BF_LPUART_DATA_R2T2(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_DATA_R2T2) & BM_LPUART_DATA_R2T2)

/*! @brief Set the R2T2 field to a new value. */
#define BW_LPUART_DATA_R2T2(x, v) (BME_BFI32(HW_LPUART_DATA_ADDR(x), ((uint32_t)(v) << BP_LPUART_DATA_R2T2), BP_LPUART_DATA_R2T2, 1))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R3T3[3] (RW)
 *
 * Read receive data buffer 3 or write transmit data buffer 3.
 */
/*@{*/
#define BP_LPUART_DATA_R3T3  (3U)          /*!< Bit position for LPUART_DATA_R3T3. */
#define BM_LPUART_DATA_R3T3  (0x00000008U) /*!< Bit mask for LPUART_DATA_R3T3. */
#define BS_LPUART_DATA_R3T3  (1U)          /*!< Bit field size in bits for LPUART_DATA_R3T3. */

/*! @brief Read current value of the LPUART_DATA_R3T3 field. */
#define BR_LPUART_DATA_R3T3(x) (BME_UBFX32(HW_LPUART_DATA_ADDR(x), BP_LPUART_DATA_R3T3, BS_LPUART_DATA_R3T3))

/*! @brief Format value for bitfield LPUART_DATA_R3T3. */
#define BF_LPUART_DATA_R3T3(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_DATA_R3T3) & BM_LPUART_DATA_R3T3)

/*! @brief Set the R3T3 field to a new value. */
#define BW_LPUART_DATA_R3T3(x, v) (BME_BFI32(HW_LPUART_DATA_ADDR(x), ((uint32_t)(v) << BP_LPUART_DATA_R3T3), BP_LPUART_DATA_R3T3, 1))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R4T4[4] (RW)
 *
 * Read receive data buffer 4 or write transmit data buffer 4.
 */
/*@{*/
#define BP_LPUART_DATA_R4T4  (4U)          /*!< Bit position for LPUART_DATA_R4T4. */
#define BM_LPUART_DATA_R4T4  (0x00000010U) /*!< Bit mask for LPUART_DATA_R4T4. */
#define BS_LPUART_DATA_R4T4  (1U)          /*!< Bit field size in bits for LPUART_DATA_R4T4. */

/*! @brief Read current value of the LPUART_DATA_R4T4 field. */
#define BR_LPUART_DATA_R4T4(x) (BME_UBFX32(HW_LPUART_DATA_ADDR(x), BP_LPUART_DATA_R4T4, BS_LPUART_DATA_R4T4))

/*! @brief Format value for bitfield LPUART_DATA_R4T4. */
#define BF_LPUART_DATA_R4T4(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_DATA_R4T4) & BM_LPUART_DATA_R4T4)

/*! @brief Set the R4T4 field to a new value. */
#define BW_LPUART_DATA_R4T4(x, v) (BME_BFI32(HW_LPUART_DATA_ADDR(x), ((uint32_t)(v) << BP_LPUART_DATA_R4T4), BP_LPUART_DATA_R4T4, 1))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R5T5[5] (RW)
 *
 * Read receive data buffer 5 or write transmit data buffer 5.
 */
/*@{*/
#define BP_LPUART_DATA_R5T5  (5U)          /*!< Bit position for LPUART_DATA_R5T5. */
#define BM_LPUART_DATA_R5T5  (0x00000020U) /*!< Bit mask for LPUART_DATA_R5T5. */
#define BS_LPUART_DATA_R5T5  (1U)          /*!< Bit field size in bits for LPUART_DATA_R5T5. */

/*! @brief Read current value of the LPUART_DATA_R5T5 field. */
#define BR_LPUART_DATA_R5T5(x) (BME_UBFX32(HW_LPUART_DATA_ADDR(x), BP_LPUART_DATA_R5T5, BS_LPUART_DATA_R5T5))

/*! @brief Format value for bitfield LPUART_DATA_R5T5. */
#define BF_LPUART_DATA_R5T5(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_DATA_R5T5) & BM_LPUART_DATA_R5T5)

/*! @brief Set the R5T5 field to a new value. */
#define BW_LPUART_DATA_R5T5(x, v) (BME_BFI32(HW_LPUART_DATA_ADDR(x), ((uint32_t)(v) << BP_LPUART_DATA_R5T5), BP_LPUART_DATA_R5T5, 1))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R6T6[6] (RW)
 *
 * Read receive data buffer 6 or write transmit data buffer 6.
 */
/*@{*/
#define BP_LPUART_DATA_R6T6  (6U)          /*!< Bit position for LPUART_DATA_R6T6. */
#define BM_LPUART_DATA_R6T6  (0x00000040U) /*!< Bit mask for LPUART_DATA_R6T6. */
#define BS_LPUART_DATA_R6T6  (1U)          /*!< Bit field size in bits for LPUART_DATA_R6T6. */

/*! @brief Read current value of the LPUART_DATA_R6T6 field. */
#define BR_LPUART_DATA_R6T6(x) (BME_UBFX32(HW_LPUART_DATA_ADDR(x), BP_LPUART_DATA_R6T6, BS_LPUART_DATA_R6T6))

/*! @brief Format value for bitfield LPUART_DATA_R6T6. */
#define BF_LPUART_DATA_R6T6(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_DATA_R6T6) & BM_LPUART_DATA_R6T6)

/*! @brief Set the R6T6 field to a new value. */
#define BW_LPUART_DATA_R6T6(x, v) (BME_BFI32(HW_LPUART_DATA_ADDR(x), ((uint32_t)(v) << BP_LPUART_DATA_R6T6), BP_LPUART_DATA_R6T6, 1))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R7T7[7] (RW)
 *
 * Read receive data buffer 7 or write transmit data buffer 7.
 */
/*@{*/
#define BP_LPUART_DATA_R7T7  (7U)          /*!< Bit position for LPUART_DATA_R7T7. */
#define BM_LPUART_DATA_R7T7  (0x00000080U) /*!< Bit mask for LPUART_DATA_R7T7. */
#define BS_LPUART_DATA_R7T7  (1U)          /*!< Bit field size in bits for LPUART_DATA_R7T7. */

/*! @brief Read current value of the LPUART_DATA_R7T7 field. */
#define BR_LPUART_DATA_R7T7(x) (BME_UBFX32(HW_LPUART_DATA_ADDR(x), BP_LPUART_DATA_R7T7, BS_LPUART_DATA_R7T7))

/*! @brief Format value for bitfield LPUART_DATA_R7T7. */
#define BF_LPUART_DATA_R7T7(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_DATA_R7T7) & BM_LPUART_DATA_R7T7)

/*! @brief Set the R7T7 field to a new value. */
#define BW_LPUART_DATA_R7T7(x, v) (BME_BFI32(HW_LPUART_DATA_ADDR(x), ((uint32_t)(v) << BP_LPUART_DATA_R7T7), BP_LPUART_DATA_R7T7, 1))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R8T8[8] (RW)
 *
 * Read receive data buffer 8 or write transmit data buffer 8.
 */
/*@{*/
#define BP_LPUART_DATA_R8T8  (8U)          /*!< Bit position for LPUART_DATA_R8T8. */
#define BM_LPUART_DATA_R8T8  (0x00000100U) /*!< Bit mask for LPUART_DATA_R8T8. */
#define BS_LPUART_DATA_R8T8  (1U)          /*!< Bit field size in bits for LPUART_DATA_R8T8. */

/*! @brief Read current value of the LPUART_DATA_R8T8 field. */
#define BR_LPUART_DATA_R8T8(x) (BME_UBFX32(HW_LPUART_DATA_ADDR(x), BP_LPUART_DATA_R8T8, BS_LPUART_DATA_R8T8))

/*! @brief Format value for bitfield LPUART_DATA_R8T8. */
#define BF_LPUART_DATA_R8T8(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_DATA_R8T8) & BM_LPUART_DATA_R8T8)

/*! @brief Set the R8T8 field to a new value. */
#define BW_LPUART_DATA_R8T8(x, v) (BME_BFI32(HW_LPUART_DATA_ADDR(x), ((uint32_t)(v) << BP_LPUART_DATA_R8T8), BP_LPUART_DATA_R8T8, 1))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R9T9[9] (RW)
 *
 * Read receive data buffer 9 or write transmit data buffer 9.
 */
/*@{*/
#define BP_LPUART_DATA_R9T9  (9U)          /*!< Bit position for LPUART_DATA_R9T9. */
#define BM_LPUART_DATA_R9T9  (0x00000200U) /*!< Bit mask for LPUART_DATA_R9T9. */
#define BS_LPUART_DATA_R9T9  (1U)          /*!< Bit field size in bits for LPUART_DATA_R9T9. */

/*! @brief Read current value of the LPUART_DATA_R9T9 field. */
#define BR_LPUART_DATA_R9T9(x) (BME_UBFX32(HW_LPUART_DATA_ADDR(x), BP_LPUART_DATA_R9T9, BS_LPUART_DATA_R9T9))

/*! @brief Format value for bitfield LPUART_DATA_R9T9. */
#define BF_LPUART_DATA_R9T9(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_DATA_R9T9) & BM_LPUART_DATA_R9T9)

/*! @brief Set the R9T9 field to a new value. */
#define BW_LPUART_DATA_R9T9(x, v) (BME_BFI32(HW_LPUART_DATA_ADDR(x), ((uint32_t)(v) << BP_LPUART_DATA_R9T9), BP_LPUART_DATA_R9T9, 1))
/*@}*/

/*!
 * @name Register LPUART_DATA, field IDLINE[11] (RO)
 *
 * Indicates the receiver line was idle before receiving the character in
 * DATA[9:0]. Unlike the IDLE flag, this bit can set for the first character received
 * when the receiver is first enabled.
 *
 * Values:
 * - 0 - Receiver was not idle before receiving this character.
 * - 1 - Receiver was idle before receiving this character.
 */
/*@{*/
#define BP_LPUART_DATA_IDLINE (11U)        /*!< Bit position for LPUART_DATA_IDLINE. */
#define BM_LPUART_DATA_IDLINE (0x00000800U) /*!< Bit mask for LPUART_DATA_IDLINE. */
#define BS_LPUART_DATA_IDLINE (1U)         /*!< Bit field size in bits for LPUART_DATA_IDLINE. */

/*! @brief Read current value of the LPUART_DATA_IDLINE field. */
#define BR_LPUART_DATA_IDLINE(x) (BME_UBFX32(HW_LPUART_DATA_ADDR(x), BP_LPUART_DATA_IDLINE, BS_LPUART_DATA_IDLINE))
/*@}*/

/*!
 * @name Register LPUART_DATA, field RXEMPT[12] (RO)
 *
 * Asserts when there is no data in the receive buffer. This field does not take
 * into account data that is in the receive shift register.
 *
 * Values:
 * - 0 - Receive buffer contains valid data.
 * - 1 - Receive buffer is empty, data returned on read is not valid.
 */
/*@{*/
#define BP_LPUART_DATA_RXEMPT (12U)        /*!< Bit position for LPUART_DATA_RXEMPT. */
#define BM_LPUART_DATA_RXEMPT (0x00001000U) /*!< Bit mask for LPUART_DATA_RXEMPT. */
#define BS_LPUART_DATA_RXEMPT (1U)         /*!< Bit field size in bits for LPUART_DATA_RXEMPT. */

/*! @brief Read current value of the LPUART_DATA_RXEMPT field. */
#define BR_LPUART_DATA_RXEMPT(x) (BME_UBFX32(HW_LPUART_DATA_ADDR(x), BP_LPUART_DATA_RXEMPT, BS_LPUART_DATA_RXEMPT))
/*@}*/

/*!
 * @name Register LPUART_DATA, field FRETSC[13] (RW)
 *
 * For reads, indicates the current received dataword contained in DATA[R9:R0]
 * was received with a frame error. For writes, indicates a break or idle
 * character is to be transmitted instead of the contents in DATA[T9:T0]. T9 is used to
 * indicate a break character when 0 and a idle character when 1, he contents of
 * DATA[T8:T0] should be zero.
 *
 * Values:
 * - 0 - The dataword was received without a frame error on read, transmit a
 *     normal character on write.
 * - 1 - The dataword was received with a frame error, transmit an idle or break
 *     character on transmit.
 */
/*@{*/
#define BP_LPUART_DATA_FRETSC (13U)        /*!< Bit position for LPUART_DATA_FRETSC. */
#define BM_LPUART_DATA_FRETSC (0x00002000U) /*!< Bit mask for LPUART_DATA_FRETSC. */
#define BS_LPUART_DATA_FRETSC (1U)         /*!< Bit field size in bits for LPUART_DATA_FRETSC. */

/*! @brief Read current value of the LPUART_DATA_FRETSC field. */
#define BR_LPUART_DATA_FRETSC(x) (BME_UBFX32(HW_LPUART_DATA_ADDR(x), BP_LPUART_DATA_FRETSC, BS_LPUART_DATA_FRETSC))

/*! @brief Format value for bitfield LPUART_DATA_FRETSC. */
#define BF_LPUART_DATA_FRETSC(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_DATA_FRETSC) & BM_LPUART_DATA_FRETSC)

/*! @brief Set the FRETSC field to a new value. */
#define BW_LPUART_DATA_FRETSC(x, v) (BME_BFI32(HW_LPUART_DATA_ADDR(x), ((uint32_t)(v) << BP_LPUART_DATA_FRETSC), BP_LPUART_DATA_FRETSC, 1))
/*@}*/

/*!
 * @name Register LPUART_DATA, field PARITYE[14] (RO)
 *
 * The current received dataword contained in DATA[R9:R0] was received with a
 * parity error.
 *
 * Values:
 * - 0 - The dataword was received without a parity error.
 * - 1 - The dataword was received with a parity error.
 */
/*@{*/
#define BP_LPUART_DATA_PARITYE (14U)       /*!< Bit position for LPUART_DATA_PARITYE. */
#define BM_LPUART_DATA_PARITYE (0x00004000U) /*!< Bit mask for LPUART_DATA_PARITYE. */
#define BS_LPUART_DATA_PARITYE (1U)        /*!< Bit field size in bits for LPUART_DATA_PARITYE. */

/*! @brief Read current value of the LPUART_DATA_PARITYE field. */
#define BR_LPUART_DATA_PARITYE(x) (BME_UBFX32(HW_LPUART_DATA_ADDR(x), BP_LPUART_DATA_PARITYE, BS_LPUART_DATA_PARITYE))
/*@}*/

/*!
 * @name Register LPUART_DATA, field NOISY[15] (RO)
 *
 * The current received dataword contained in DATA[R9:R0] was received with
 * noise.
 *
 * Values:
 * - 0 - The dataword was received without noise.
 * - 1 - The data was received with noise.
 */
/*@{*/
#define BP_LPUART_DATA_NOISY (15U)         /*!< Bit position for LPUART_DATA_NOISY. */
#define BM_LPUART_DATA_NOISY (0x00008000U) /*!< Bit mask for LPUART_DATA_NOISY. */
#define BS_LPUART_DATA_NOISY (1U)          /*!< Bit field size in bits for LPUART_DATA_NOISY. */

/*! @brief Read current value of the LPUART_DATA_NOISY field. */
#define BR_LPUART_DATA_NOISY(x) (BME_UBFX32(HW_LPUART_DATA_ADDR(x), BP_LPUART_DATA_NOISY, BS_LPUART_DATA_NOISY))
/*@}*/

/*******************************************************************************
 * HW_LPUART_MATCH - LPUART Match Address Register
 ******************************************************************************/

/*!
 * @brief HW_LPUART_MATCH - LPUART Match Address Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_lpuart_match
{
    uint32_t U;
    struct _hw_lpuart_match_bitfields
    {
        uint32_t MA1 : 10;             /*!< [9:0] Match Address 1 */
        uint32_t RESERVED0 : 6;        /*!< [15:10]  */
        uint32_t MA2 : 10;             /*!< [25:16] Match Address 2 */
        uint32_t RESERVED1 : 6;        /*!< [31:26]  */
    } B;
} hw_lpuart_match_t;

/*!
 * @name Constants and macros for entire LPUART_MATCH register
 */
/*@{*/
#define HW_LPUART_MATCH_ADDR(x)  ((uint32_t)(x) + 0x10U)

#define HW_LPUART_MATCH(x)       (*(__IO hw_lpuart_match_t *) HW_LPUART_MATCH_ADDR(x))
#define HW_LPUART_MATCH_RD(x)    (HW_LPUART_MATCH(x).U)
#define HW_LPUART_MATCH_WR(x, v) (HW_LPUART_MATCH(x).U = (v))
#define HW_LPUART_MATCH_SET(x, v) (BME_OR32(HW_LPUART_MATCH_ADDR(x), (uint32_t)(v)))
#define HW_LPUART_MATCH_CLR(x, v) (BME_AND32(HW_LPUART_MATCH_ADDR(x), (uint32_t)(~(v))))
#define HW_LPUART_MATCH_TOG(x, v) (BME_XOR32(HW_LPUART_MATCH_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual LPUART_MATCH bitfields
 */

/*!
 * @name Register LPUART_MATCH, field MA1[9:0] (RW)
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated BAUD[MAEN] bit is set. If a match
 * occurs, the following data is transferred to the data register. If a match
 * fails, the following data is discarded. Software should only write a MA register
 * when the associated BAUD[MAEN] bit is clear.
 */
/*@{*/
#define BP_LPUART_MATCH_MA1  (0U)          /*!< Bit position for LPUART_MATCH_MA1. */
#define BM_LPUART_MATCH_MA1  (0x000003FFU) /*!< Bit mask for LPUART_MATCH_MA1. */
#define BS_LPUART_MATCH_MA1  (10U)         /*!< Bit field size in bits for LPUART_MATCH_MA1. */

/*! @brief Read current value of the LPUART_MATCH_MA1 field. */
#define BR_LPUART_MATCH_MA1(x) (BME_UBFX32(HW_LPUART_MATCH_ADDR(x), BP_LPUART_MATCH_MA1, BS_LPUART_MATCH_MA1))

/*! @brief Format value for bitfield LPUART_MATCH_MA1. */
#define BF_LPUART_MATCH_MA1(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_MATCH_MA1) & BM_LPUART_MATCH_MA1)

/*! @brief Set the MA1 field to a new value. */
#define BW_LPUART_MATCH_MA1(x, v) (BME_BFI32(HW_LPUART_MATCH_ADDR(x), ((uint32_t)(v) << BP_LPUART_MATCH_MA1), BP_LPUART_MATCH_MA1, 10))
/*@}*/

/*!
 * @name Register LPUART_MATCH, field MA2[25:16] (RW)
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated BAUD[MAEN] bit is set. If a match
 * occurs, the following data is transferred to the data register. If a match
 * fails, the following data is discarded. Software should only write a MA register
 * when the associated BAUD[MAEN] bit is clear.
 */
/*@{*/
#define BP_LPUART_MATCH_MA2  (16U)         /*!< Bit position for LPUART_MATCH_MA2. */
#define BM_LPUART_MATCH_MA2  (0x03FF0000U) /*!< Bit mask for LPUART_MATCH_MA2. */
#define BS_LPUART_MATCH_MA2  (10U)         /*!< Bit field size in bits for LPUART_MATCH_MA2. */

/*! @brief Read current value of the LPUART_MATCH_MA2 field. */
#define BR_LPUART_MATCH_MA2(x) (BME_UBFX32(HW_LPUART_MATCH_ADDR(x), BP_LPUART_MATCH_MA2, BS_LPUART_MATCH_MA2))

/*! @brief Format value for bitfield LPUART_MATCH_MA2. */
#define BF_LPUART_MATCH_MA2(v) ((uint32_t)((uint32_t)(v) << BP_LPUART_MATCH_MA2) & BM_LPUART_MATCH_MA2)

/*! @brief Set the MA2 field to a new value. */
#define BW_LPUART_MATCH_MA2(x, v) (BME_BFI32(HW_LPUART_MATCH_ADDR(x), ((uint32_t)(v) << BP_LPUART_MATCH_MA2), BP_LPUART_MATCH_MA2, 10))
/*@}*/

/*******************************************************************************
 * hw_lpuart_t - module struct
 ******************************************************************************/
/*!
 * @brief All LPUART module registers.
 */
#pragma pack(1)
typedef struct _hw_lpuart
{
    __IO hw_lpuart_baud_t BAUD;            /*!< [0x0] LPUART Baud Rate Register */
    __IO hw_lpuart_stat_t STAT;            /*!< [0x4] LPUART Status Register */
    __IO hw_lpuart_ctrl_t CTRL;            /*!< [0x8] LPUART Control Register */
    __IO hw_lpuart_data_t DATA;            /*!< [0xC] LPUART Data Register */
    __IO hw_lpuart_match_t MATCH;          /*!< [0x10] LPUART Match Address Register */
} hw_lpuart_t;
#pragma pack()

/*! @brief Macro to access all LPUART registers. */
/*! @param x LPUART module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_LPUART_REGS(LPUART0_BASE)</code>. */
#define HW_LPUART_REGS(x) (*(hw_lpuart_t *)(x))

/*
 * MKL43Z4 MCG
 *
 * Multipurpose Clock Generator Lite
 *
 * Registers defined in this header file:
 * - HW_MCG_C1 - MCG Control Register 1
 * - HW_MCG_C2 - MCG Control Register 2
 * - HW_MCG_S - MCG Status Register
 * - HW_MCG_SC - MCG Status and Control Register
 * - HW_MCG_HCTRIM - MCG High-frequency IRC Coarse Trim Register
 * - HW_MCG_HTTRIM - MCG High-frequency IRC Tempco (Temperature Coefficient) Trim Register
 * - HW_MCG_HFTRIM - MCG High-frequency IRC Fine Trim Register
 * - HW_MCG_MC - MCG Miscellaneous Control Register
 * - HW_MCG_LTRIMRNG - MCG Low-frequency IRC Trim Range Register
 * - HW_MCG_LFTRIM - MCG Low-frequency IRC8M Trim Register
 * - HW_MCG_LSTRIM - MCG Low-frequency IRC2M Trim Register
 *
 * - hw_mcg_t - Struct containing all module registers.
 */

#define HW_MCG_INSTANCE_COUNT (1U) /*!< Number of instances of the MCG module. */
#define HW_MCG (0U) /*!< Instance number for MCG. */

/*******************************************************************************
 * HW_MCG_C1 - MCG Control Register 1
 ******************************************************************************/

/*!
 * @brief HW_MCG_C1 - MCG Control Register 1 (RW)
 *
 * Reset value: 0x40U
 */
typedef union _hw_mcg_c1
{
    uint8_t U;
    struct _hw_mcg_c1_bitfields
    {
        uint8_t IREFSTEN : 1;          /*!< [0] Internal Reference Stop Enable */
        uint8_t IRCLKEN : 1;           /*!< [1] Internal Reference Clock Enable */
        uint8_t RESERVED0 : 4;         /*!< [5:2]  */
        uint8_t CLKS : 2;              /*!< [7:6] Clock Source Select */
    } B;
} hw_mcg_c1_t;

/*!
 * @name Constants and macros for entire MCG_C1 register
 */
/*@{*/
#define HW_MCG_C1_ADDR(x)        ((uint32_t)(x) + 0x0U)

#define HW_MCG_C1(x)             (*(__IO hw_mcg_c1_t *) HW_MCG_C1_ADDR(x))
#define HW_MCG_C1_RD(x)          (HW_MCG_C1(x).U)
#define HW_MCG_C1_WR(x, v)       (HW_MCG_C1(x).U = (v))
#define HW_MCG_C1_SET(x, v)      (BME_OR8(HW_MCG_C1_ADDR(x), (uint8_t)(v)))
#define HW_MCG_C1_CLR(x, v)      (BME_AND8(HW_MCG_C1_ADDR(x), (uint8_t)(~(v))))
#define HW_MCG_C1_TOG(x, v)      (BME_XOR8(HW_MCG_C1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual MCG_C1 bitfields
 */

/*!
 * @name Register MCG_C1, field IREFSTEN[0] (RW)
 *
 * Controls whether the IRC source remains enabled when the MCG_Lite enters Stop
 * mode.
 *
 * Values:
 * - 0 - LIRC is disabled in Stop mode.
 * - 1 - LIRC is enabled in Stop mode, if IRCLKEN is set.
 */
/*@{*/
#define BP_MCG_C1_IREFSTEN   (0U)          /*!< Bit position for MCG_C1_IREFSTEN. */
#define BM_MCG_C1_IREFSTEN   (0x01U)       /*!< Bit mask for MCG_C1_IREFSTEN. */
#define BS_MCG_C1_IREFSTEN   (1U)          /*!< Bit field size in bits for MCG_C1_IREFSTEN. */

/*! @brief Read current value of the MCG_C1_IREFSTEN field. */
#define BR_MCG_C1_IREFSTEN(x) (BME_UBFX8(HW_MCG_C1_ADDR(x), BP_MCG_C1_IREFSTEN, BS_MCG_C1_IREFSTEN))

/*! @brief Format value for bitfield MCG_C1_IREFSTEN. */
#define BF_MCG_C1_IREFSTEN(v) ((uint8_t)((uint8_t)(v) << BP_MCG_C1_IREFSTEN) & BM_MCG_C1_IREFSTEN)

/*! @brief Set the IREFSTEN field to a new value. */
#define BW_MCG_C1_IREFSTEN(x, v) (BME_BFI8(HW_MCG_C1_ADDR(x), ((uint8_t)(v) << BP_MCG_C1_IREFSTEN), BP_MCG_C1_IREFSTEN, 1))
/*@}*/

/*!
 * @name Register MCG_C1, field IRCLKEN[1] (RW)
 *
 * Enables the IRC source.
 *
 * Values:
 * - 0 - LIRC is disabled.
 * - 1 - LIRC is enabled.
 */
/*@{*/
#define BP_MCG_C1_IRCLKEN    (1U)          /*!< Bit position for MCG_C1_IRCLKEN. */
#define BM_MCG_C1_IRCLKEN    (0x02U)       /*!< Bit mask for MCG_C1_IRCLKEN. */
#define BS_MCG_C1_IRCLKEN    (1U)          /*!< Bit field size in bits for MCG_C1_IRCLKEN. */

/*! @brief Read current value of the MCG_C1_IRCLKEN field. */
#define BR_MCG_C1_IRCLKEN(x) (BME_UBFX8(HW_MCG_C1_ADDR(x), BP_MCG_C1_IRCLKEN, BS_MCG_C1_IRCLKEN))

/*! @brief Format value for bitfield MCG_C1_IRCLKEN. */
#define BF_MCG_C1_IRCLKEN(v) ((uint8_t)((uint8_t)(v) << BP_MCG_C1_IRCLKEN) & BM_MCG_C1_IRCLKEN)

/*! @brief Set the IRCLKEN field to a new value. */
#define BW_MCG_C1_IRCLKEN(x, v) (BME_BFI8(HW_MCG_C1_ADDR(x), ((uint8_t)(v) << BP_MCG_C1_IRCLKEN), BP_MCG_C1_IRCLKEN, 1))
/*@}*/

/*!
 * @name Register MCG_C1, field CLKS[7:6] (RW)
 *
 * Selects the clock source for MCGOUTCLK.
 *
 * Values:
 * - 00 - Selects HIRC clock as the main clock source. This is HIRC mode.
 * - 01 - Selects LIRC clock as the main clock source. This is LIRC2M or LIRC8M
 *     mode.
 * - 10 - Selects external clock as the main clock source. This is EXT mode.
 * - 11 - Reserved. Writing 11 takes no effect.
 */
/*@{*/
#define BP_MCG_C1_CLKS       (6U)          /*!< Bit position for MCG_C1_CLKS. */
#define BM_MCG_C1_CLKS       (0xC0U)       /*!< Bit mask for MCG_C1_CLKS. */
#define BS_MCG_C1_CLKS       (2U)          /*!< Bit field size in bits for MCG_C1_CLKS. */

/*! @brief Read current value of the MCG_C1_CLKS field. */
#define BR_MCG_C1_CLKS(x)    (BME_UBFX8(HW_MCG_C1_ADDR(x), BP_MCG_C1_CLKS, BS_MCG_C1_CLKS))

/*! @brief Format value for bitfield MCG_C1_CLKS. */
#define BF_MCG_C1_CLKS(v)    ((uint8_t)((uint8_t)(v) << BP_MCG_C1_CLKS) & BM_MCG_C1_CLKS)

/*! @brief Set the CLKS field to a new value. */
#define BW_MCG_C1_CLKS(x, v) (BME_BFI8(HW_MCG_C1_ADDR(x), ((uint8_t)(v) << BP_MCG_C1_CLKS), BP_MCG_C1_CLKS, 2))
/*@}*/

/*******************************************************************************
 * HW_MCG_C2 - MCG Control Register 2
 ******************************************************************************/

/*!
 * @brief HW_MCG_C2 - MCG Control Register 2 (RW)
 *
 * Reset value: 0x01U
 */
typedef union _hw_mcg_c2
{
    uint8_t U;
    struct _hw_mcg_c2_bitfields
    {
        uint8_t IRCS : 1;              /*!< [0] Low-frequency Internal Reference Clock
                                        * Select */
        uint8_t RESERVED0 : 1;         /*!< [1]  */
        uint8_t EREFS0 : 1;            /*!< [2] External Clock Source Select */
        uint8_t HGO0 : 1;              /*!< [3] Crystal Oscillator Operation Mode Select */
        uint8_t RANGE0 : 2;            /*!< [5:4] External Clock Source Frequency Range
                                        * Select */
        uint8_t RESERVED1 : 2;         /*!< [7:6]  */
    } B;
} hw_mcg_c2_t;

/*!
 * @name Constants and macros for entire MCG_C2 register
 */
/*@{*/
#define HW_MCG_C2_ADDR(x)        ((uint32_t)(x) + 0x1U)

#define HW_MCG_C2(x)             (*(__IO hw_mcg_c2_t *) HW_MCG_C2_ADDR(x))
#define HW_MCG_C2_RD(x)          (HW_MCG_C2(x).U)
#define HW_MCG_C2_WR(x, v)       (HW_MCG_C2(x).U = (v))
#define HW_MCG_C2_SET(x, v)      (BME_OR8(HW_MCG_C2_ADDR(x), (uint8_t)(v)))
#define HW_MCG_C2_CLR(x, v)      (BME_AND8(HW_MCG_C2_ADDR(x), (uint8_t)(~(v))))
#define HW_MCG_C2_TOG(x, v)      (BME_XOR8(HW_MCG_C2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual MCG_C2 bitfields
 */

/*!
 * @name Register MCG_C2, field IRCS[0] (RW)
 *
 * Controls the LIRC to work at 2 MHz or 8 MHz mode.
 *
 * Values:
 * - 0 - LIRC is in 2 MHz mode.
 * - 1 - LIRC is in 8 MHz mode.
 */
/*@{*/
#define BP_MCG_C2_IRCS       (0U)          /*!< Bit position for MCG_C2_IRCS. */
#define BM_MCG_C2_IRCS       (0x01U)       /*!< Bit mask for MCG_C2_IRCS. */
#define BS_MCG_C2_IRCS       (1U)          /*!< Bit field size in bits for MCG_C2_IRCS. */

/*! @brief Read current value of the MCG_C2_IRCS field. */
#define BR_MCG_C2_IRCS(x)    (BME_UBFX8(HW_MCG_C2_ADDR(x), BP_MCG_C2_IRCS, BS_MCG_C2_IRCS))

/*! @brief Format value for bitfield MCG_C2_IRCS. */
#define BF_MCG_C2_IRCS(v)    ((uint8_t)((uint8_t)(v) << BP_MCG_C2_IRCS) & BM_MCG_C2_IRCS)

/*! @brief Set the IRCS field to a new value. */
#define BW_MCG_C2_IRCS(x, v) (BME_BFI8(HW_MCG_C2_ADDR(x), ((uint8_t)(v) << BP_MCG_C2_IRCS), BP_MCG_C2_IRCS, 1))
/*@}*/

/*!
 * @name Register MCG_C2, field EREFS0[2] (RW)
 *
 * Selects the source for the external reference clock. See the Oscillator (OSC)
 * chapter for more details.
 *
 * Values:
 * - 0 - External clock requested.
 * - 1 - Oscillator requested.
 */
/*@{*/
#define BP_MCG_C2_EREFS0     (2U)          /*!< Bit position for MCG_C2_EREFS0. */
#define BM_MCG_C2_EREFS0     (0x04U)       /*!< Bit mask for MCG_C2_EREFS0. */
#define BS_MCG_C2_EREFS0     (1U)          /*!< Bit field size in bits for MCG_C2_EREFS0. */

/*! @brief Read current value of the MCG_C2_EREFS0 field. */
#define BR_MCG_C2_EREFS0(x)  (BME_UBFX8(HW_MCG_C2_ADDR(x), BP_MCG_C2_EREFS0, BS_MCG_C2_EREFS0))

/*! @brief Format value for bitfield MCG_C2_EREFS0. */
#define BF_MCG_C2_EREFS0(v)  ((uint8_t)((uint8_t)(v) << BP_MCG_C2_EREFS0) & BM_MCG_C2_EREFS0)

/*! @brief Set the EREFS0 field to a new value. */
#define BW_MCG_C2_EREFS0(x, v) (BME_BFI8(HW_MCG_C2_ADDR(x), ((uint8_t)(v) << BP_MCG_C2_EREFS0), BP_MCG_C2_EREFS0, 1))
/*@}*/

/*!
 * @name Register MCG_C2, field HGO0[3] (RW)
 *
 * Selects the crystal oscillator mode of operation. See the Oscillator (OSC)
 * chapter for more details.
 *
 * Values:
 * - 0 - Configure crystal oscillator for low-power operation.
 * - 1 - Configure crystal oscillator for high-gain operation.
 */
/*@{*/
#define BP_MCG_C2_HGO0       (3U)          /*!< Bit position for MCG_C2_HGO0. */
#define BM_MCG_C2_HGO0       (0x08U)       /*!< Bit mask for MCG_C2_HGO0. */
#define BS_MCG_C2_HGO0       (1U)          /*!< Bit field size in bits for MCG_C2_HGO0. */

/*! @brief Read current value of the MCG_C2_HGO0 field. */
#define BR_MCG_C2_HGO0(x)    (BME_UBFX8(HW_MCG_C2_ADDR(x), BP_MCG_C2_HGO0, BS_MCG_C2_HGO0))

/*! @brief Format value for bitfield MCG_C2_HGO0. */
#define BF_MCG_C2_HGO0(v)    ((uint8_t)((uint8_t)(v) << BP_MCG_C2_HGO0) & BM_MCG_C2_HGO0)

/*! @brief Set the HGO0 field to a new value. */
#define BW_MCG_C2_HGO0(x, v) (BME_BFI8(HW_MCG_C2_ADDR(x), ((uint8_t)(v) << BP_MCG_C2_HGO0), BP_MCG_C2_HGO0, 1))
/*@}*/

/*!
 * @name Register MCG_C2, field RANGE0[5:4] (RW)
 *
 * Selects the frequency for the crystal oscillator or the external clock
 * source. See the Oscillator (OSC) chapter for more details and refer to the chip
 * datasheet for the frequency ranges used.
 *
 * Values:
 * - 00 - Low frequency range selected for the crystal oscillator or the
 *     external clock source.
 * - 01 - High frequency range selected for the crystal oscillator or the
 *     external clock source.
 * - 10 - Very high frequency range selected for the crystal oscillator or the
 *     external clock source.
 * - 11 - Very high frequency range selected for the crystal oscillator or the
 *     external clock source. Same effect as 10.
 */
/*@{*/
#define BP_MCG_C2_RANGE0     (4U)          /*!< Bit position for MCG_C2_RANGE0. */
#define BM_MCG_C2_RANGE0     (0x30U)       /*!< Bit mask for MCG_C2_RANGE0. */
#define BS_MCG_C2_RANGE0     (2U)          /*!< Bit field size in bits for MCG_C2_RANGE0. */

/*! @brief Read current value of the MCG_C2_RANGE0 field. */
#define BR_MCG_C2_RANGE0(x)  (BME_UBFX8(HW_MCG_C2_ADDR(x), BP_MCG_C2_RANGE0, BS_MCG_C2_RANGE0))

/*! @brief Format value for bitfield MCG_C2_RANGE0. */
#define BF_MCG_C2_RANGE0(v)  ((uint8_t)((uint8_t)(v) << BP_MCG_C2_RANGE0) & BM_MCG_C2_RANGE0)

/*! @brief Set the RANGE0 field to a new value. */
#define BW_MCG_C2_RANGE0(x, v) (BME_BFI8(HW_MCG_C2_ADDR(x), ((uint8_t)(v) << BP_MCG_C2_RANGE0), BP_MCG_C2_RANGE0, 2))
/*@}*/

/*******************************************************************************
 * HW_MCG_S - MCG Status Register
 ******************************************************************************/

/*!
 * @brief HW_MCG_S - MCG Status Register (RO)
 *
 * Reset value: 0x04U
 */
typedef union _hw_mcg_s
{
    uint8_t U;
    struct _hw_mcg_s_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t OSCINIT0 : 1;          /*!< [1] OSC Initialization Status */
        uint8_t CLKST : 2;             /*!< [3:2] Clock Mode Status */
        uint8_t RESERVED1 : 4;         /*!< [7:4]  */
    } B;
} hw_mcg_s_t;

/*!
 * @name Constants and macros for entire MCG_S register
 */
/*@{*/
#define HW_MCG_S_ADDR(x)         ((uint32_t)(x) + 0x6U)

#define HW_MCG_S(x)              (*(__I hw_mcg_s_t *) HW_MCG_S_ADDR(x))
#define HW_MCG_S_RD(x)           (HW_MCG_S(x).U)
/*@}*/

/*
 * Constants & macros for individual MCG_S bitfields
 */

/*!
 * @name Register MCG_S, field OSCINIT0[1] (RO)
 *
 * This flag, which resets to 0, is set to 1 after the initialization cycles of
 * the crystal oscillator clock are completed. After being set, the bit is
 * cleared to 0 if the OSC is subsequently disabled. See the Oscillator (OSC) chapter
 * for more information.
 *
 * Values:
 * - 0 - OSC is not ready.
 * - 1 - OSC clock is ready.
 */
/*@{*/
#define BP_MCG_S_OSCINIT0    (1U)          /*!< Bit position for MCG_S_OSCINIT0. */
#define BM_MCG_S_OSCINIT0    (0x02U)       /*!< Bit mask for MCG_S_OSCINIT0. */
#define BS_MCG_S_OSCINIT0    (1U)          /*!< Bit field size in bits for MCG_S_OSCINIT0. */

/*! @brief Read current value of the MCG_S_OSCINIT0 field. */
#define BR_MCG_S_OSCINIT0(x) (BME_UBFX8(HW_MCG_S_ADDR(x), BP_MCG_S_OSCINIT0, BS_MCG_S_OSCINIT0))
/*@}*/

/*!
 * @name Register MCG_S, field CLKST[3:2] (RO)
 *
 * Indicates the current clock mode. This field does not update immediately
 * after a write to MCG_C1[CLKS] due to internal synchronization between clock
 * domains.
 *
 * Values:
 * - 00 - HIRC clock is selected as the main clock source, and MCG_Lite works at
 *     HIRC mode.
 * - 01 - LIRC clock is selected as the main clock source, and MCG_Lite works at
 *     LIRC2M or LIRC8M mode.
 * - 10 - External clock is selected as the main clock source, and MCG_Lite
 *     works at EXT mode.
 * - 11 - Reserved.
 */
/*@{*/
#define BP_MCG_S_CLKST       (2U)          /*!< Bit position for MCG_S_CLKST. */
#define BM_MCG_S_CLKST       (0x0CU)       /*!< Bit mask for MCG_S_CLKST. */
#define BS_MCG_S_CLKST       (2U)          /*!< Bit field size in bits for MCG_S_CLKST. */

/*! @brief Read current value of the MCG_S_CLKST field. */
#define BR_MCG_S_CLKST(x)    (BME_UBFX8(HW_MCG_S_ADDR(x), BP_MCG_S_CLKST, BS_MCG_S_CLKST))
/*@}*/

/*******************************************************************************
 * HW_MCG_SC - MCG Status and Control Register
 ******************************************************************************/

/*!
 * @brief HW_MCG_SC - MCG Status and Control Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_sc
{
    uint8_t U;
    struct _hw_mcg_sc_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t FCRDIV : 3;            /*!< [3:1] Low-frequency Internal Reference Clock
                                        * Divider */
        uint8_t RESERVED1 : 4;         /*!< [7:4]  */
    } B;
} hw_mcg_sc_t;

/*!
 * @name Constants and macros for entire MCG_SC register
 */
/*@{*/
#define HW_MCG_SC_ADDR(x)        ((uint32_t)(x) + 0x8U)

#define HW_MCG_SC(x)             (*(__IO hw_mcg_sc_t *) HW_MCG_SC_ADDR(x))
#define HW_MCG_SC_RD(x)          (HW_MCG_SC(x).U)
#define HW_MCG_SC_WR(x, v)       (HW_MCG_SC(x).U = (v))
#define HW_MCG_SC_SET(x, v)      (BME_OR8(HW_MCG_SC_ADDR(x), (uint8_t)(v)))
#define HW_MCG_SC_CLR(x, v)      (BME_AND8(HW_MCG_SC_ADDR(x), (uint8_t)(~(v))))
#define HW_MCG_SC_TOG(x, v)      (BME_XOR8(HW_MCG_SC_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual MCG_SC bitfields
 */

/*!
 * @name Register MCG_SC, field FCRDIV[3:1] (RW)
 *
 * Selects the factor value to divide the LIRC source.
 *
 * Values:
 * - 000 - Division factor is 1.
 * - 001 - Division factor is 2.
 * - 010 - Division factor is 4.
 * - 011 - Division factor is 8.
 * - 100 - Division factor is 16.
 * - 101 - Division factor is 32.
 * - 110 - Division factor is 64.
 * - 111 - Division factor is 128.
 */
/*@{*/
#define BP_MCG_SC_FCRDIV     (1U)          /*!< Bit position for MCG_SC_FCRDIV. */
#define BM_MCG_SC_FCRDIV     (0x0EU)       /*!< Bit mask for MCG_SC_FCRDIV. */
#define BS_MCG_SC_FCRDIV     (3U)          /*!< Bit field size in bits for MCG_SC_FCRDIV. */

/*! @brief Read current value of the MCG_SC_FCRDIV field. */
#define BR_MCG_SC_FCRDIV(x)  (BME_UBFX8(HW_MCG_SC_ADDR(x), BP_MCG_SC_FCRDIV, BS_MCG_SC_FCRDIV))

/*! @brief Format value for bitfield MCG_SC_FCRDIV. */
#define BF_MCG_SC_FCRDIV(v)  ((uint8_t)((uint8_t)(v) << BP_MCG_SC_FCRDIV) & BM_MCG_SC_FCRDIV)

/*! @brief Set the FCRDIV field to a new value. */
#define BW_MCG_SC_FCRDIV(x, v) (BME_BFI8(HW_MCG_SC_ADDR(x), ((uint8_t)(v) << BP_MCG_SC_FCRDIV), BP_MCG_SC_FCRDIV, 3))
/*@}*/

/*******************************************************************************
 * HW_MCG_HCTRIM - MCG High-frequency IRC Coarse Trim Register
 ******************************************************************************/

/*!
 * @brief HW_MCG_HCTRIM - MCG High-frequency IRC Coarse Trim Register (RO)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_hctrim
{
    uint8_t U;
    struct _hw_mcg_hctrim_bitfields
    {
        uint8_t COARSE_TRIM : 6;       /*!< [5:0] High-frequency IRC Coarse Trim */
        uint8_t RESERVED0 : 2;         /*!< [7:6]  */
    } B;
} hw_mcg_hctrim_t;

/*!
 * @name Constants and macros for entire MCG_HCTRIM register
 */
/*@{*/
#define HW_MCG_HCTRIM_ADDR(x)    ((uint32_t)(x) + 0x14U)

#define HW_MCG_HCTRIM(x)         (*(__I hw_mcg_hctrim_t *) HW_MCG_HCTRIM_ADDR(x))
#define HW_MCG_HCTRIM_RD(x)      (HW_MCG_HCTRIM(x).U)
/*@}*/

/*
 * Constants & macros for individual MCG_HCTRIM bitfields
 */

/*!
 * @name Register MCG_HCTRIM, field COARSE_TRIM[5:0] (RO)
 *
 * Loads from a factory programmed location when out of reset.
 */
/*@{*/
#define BP_MCG_HCTRIM_COARSE_TRIM (0U)     /*!< Bit position for MCG_HCTRIM_COARSE_TRIM. */
#define BM_MCG_HCTRIM_COARSE_TRIM (0x3FU)  /*!< Bit mask for MCG_HCTRIM_COARSE_TRIM. */
#define BS_MCG_HCTRIM_COARSE_TRIM (6U)     /*!< Bit field size in bits for MCG_HCTRIM_COARSE_TRIM. */

/*! @brief Read current value of the MCG_HCTRIM_COARSE_TRIM field. */
#define BR_MCG_HCTRIM_COARSE_TRIM(x) (BME_UBFX8(HW_MCG_HCTRIM_ADDR(x), BP_MCG_HCTRIM_COARSE_TRIM, BS_MCG_HCTRIM_COARSE_TRIM))
/*@}*/

/*******************************************************************************
 * HW_MCG_HTTRIM - MCG High-frequency IRC Tempco (Temperature Coefficient) Trim Register
 ******************************************************************************/

/*!
 * @brief HW_MCG_HTTRIM - MCG High-frequency IRC Tempco (Temperature Coefficient) Trim Register (RO)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_httrim
{
    uint8_t U;
    struct _hw_mcg_httrim_bitfields
    {
        uint8_t TEMPCO_TRIM : 5;       /*!< [4:0] High-frequency IRC Tempco Trim */
        uint8_t RESERVED0 : 3;         /*!< [7:5]  */
    } B;
} hw_mcg_httrim_t;

/*!
 * @name Constants and macros for entire MCG_HTTRIM register
 */
/*@{*/
#define HW_MCG_HTTRIM_ADDR(x)    ((uint32_t)(x) + 0x15U)

#define HW_MCG_HTTRIM(x)         (*(__I hw_mcg_httrim_t *) HW_MCG_HTTRIM_ADDR(x))
#define HW_MCG_HTTRIM_RD(x)      (HW_MCG_HTTRIM(x).U)
/*@}*/

/*
 * Constants & macros for individual MCG_HTTRIM bitfields
 */

/*!
 * @name Register MCG_HTTRIM, field TEMPCO_TRIM[4:0] (RO)
 *
 * Loads from a factory programmed location when out of reset.
 */
/*@{*/
#define BP_MCG_HTTRIM_TEMPCO_TRIM (0U)     /*!< Bit position for MCG_HTTRIM_TEMPCO_TRIM. */
#define BM_MCG_HTTRIM_TEMPCO_TRIM (0x1FU)  /*!< Bit mask for MCG_HTTRIM_TEMPCO_TRIM. */
#define BS_MCG_HTTRIM_TEMPCO_TRIM (5U)     /*!< Bit field size in bits for MCG_HTTRIM_TEMPCO_TRIM. */

/*! @brief Read current value of the MCG_HTTRIM_TEMPCO_TRIM field. */
#define BR_MCG_HTTRIM_TEMPCO_TRIM(x) (BME_UBFX8(HW_MCG_HTTRIM_ADDR(x), BP_MCG_HTTRIM_TEMPCO_TRIM, BS_MCG_HTTRIM_TEMPCO_TRIM))
/*@}*/

/*******************************************************************************
 * HW_MCG_HFTRIM - MCG High-frequency IRC Fine Trim Register
 ******************************************************************************/

/*!
 * @brief HW_MCG_HFTRIM - MCG High-frequency IRC Fine Trim Register (RO)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_hftrim
{
    uint8_t U;
    struct _hw_mcg_hftrim_bitfields
    {
        uint8_t FINE_TRIM : 7;         /*!< [6:0] High-frequency IRC Fine Trim */
        uint8_t RESERVED0 : 1;         /*!< [7]  */
    } B;
} hw_mcg_hftrim_t;

/*!
 * @name Constants and macros for entire MCG_HFTRIM register
 */
/*@{*/
#define HW_MCG_HFTRIM_ADDR(x)    ((uint32_t)(x) + 0x16U)

#define HW_MCG_HFTRIM(x)         (*(__I hw_mcg_hftrim_t *) HW_MCG_HFTRIM_ADDR(x))
#define HW_MCG_HFTRIM_RD(x)      (HW_MCG_HFTRIM(x).U)
/*@}*/

/*
 * Constants & macros for individual MCG_HFTRIM bitfields
 */

/*!
 * @name Register MCG_HFTRIM, field FINE_TRIM[6:0] (RO)
 *
 * Loads from a factory programmed location when out of reset.
 */
/*@{*/
#define BP_MCG_HFTRIM_FINE_TRIM (0U)       /*!< Bit position for MCG_HFTRIM_FINE_TRIM. */
#define BM_MCG_HFTRIM_FINE_TRIM (0x7FU)    /*!< Bit mask for MCG_HFTRIM_FINE_TRIM. */
#define BS_MCG_HFTRIM_FINE_TRIM (7U)       /*!< Bit field size in bits for MCG_HFTRIM_FINE_TRIM. */

/*! @brief Read current value of the MCG_HFTRIM_FINE_TRIM field. */
#define BR_MCG_HFTRIM_FINE_TRIM(x) (BME_UBFX8(HW_MCG_HFTRIM_ADDR(x), BP_MCG_HFTRIM_FINE_TRIM, BS_MCG_HFTRIM_FINE_TRIM))
/*@}*/

/*******************************************************************************
 * HW_MCG_MC - MCG Miscellaneous Control Register
 ******************************************************************************/

/*!
 * @brief HW_MCG_MC - MCG Miscellaneous Control Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_mc
{
    uint8_t U;
    struct _hw_mcg_mc_bitfields
    {
        uint8_t LIRC_DIV2 : 3;         /*!< [2:0] Second Low-frequency Internal
                                        * Reference Clock Divider */
        uint8_t RESERVED0 : 4;         /*!< [6:3]  */
        uint8_t HIRCEN : 1;            /*!< [7] High-frequency IRC Enable */
    } B;
} hw_mcg_mc_t;

/*!
 * @name Constants and macros for entire MCG_MC register
 */
/*@{*/
#define HW_MCG_MC_ADDR(x)        ((uint32_t)(x) + 0x18U)

#define HW_MCG_MC(x)             (*(__IO hw_mcg_mc_t *) HW_MCG_MC_ADDR(x))
#define HW_MCG_MC_RD(x)          (HW_MCG_MC(x).U)
#define HW_MCG_MC_WR(x, v)       (HW_MCG_MC(x).U = (v))
#define HW_MCG_MC_SET(x, v)      (BME_OR8(HW_MCG_MC_ADDR(x), (uint8_t)(v)))
#define HW_MCG_MC_CLR(x, v)      (BME_AND8(HW_MCG_MC_ADDR(x), (uint8_t)(~(v))))
#define HW_MCG_MC_TOG(x, v)      (BME_XOR8(HW_MCG_MC_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual MCG_MC bitfields
 */

/*!
 * @name Register MCG_MC, field LIRC_DIV2[2:0] (RW)
 *
 * Selects the factor value to further divide the LIRC source.
 *
 * Values:
 * - 000 - Division factor is 1.
 * - 001 - Division factor is 2.
 * - 010 - Division factor is 4.
 * - 011 - Division factor is 8.
 * - 100 - Division factor is 16.
 * - 101 - Division factor is 32.
 * - 110 - Division factor is 64.
 * - 111 - Division factor is 128.
 */
/*@{*/
#define BP_MCG_MC_LIRC_DIV2  (0U)          /*!< Bit position for MCG_MC_LIRC_DIV2. */
#define BM_MCG_MC_LIRC_DIV2  (0x07U)       /*!< Bit mask for MCG_MC_LIRC_DIV2. */
#define BS_MCG_MC_LIRC_DIV2  (3U)          /*!< Bit field size in bits for MCG_MC_LIRC_DIV2. */

/*! @brief Read current value of the MCG_MC_LIRC_DIV2 field. */
#define BR_MCG_MC_LIRC_DIV2(x) (BME_UBFX8(HW_MCG_MC_ADDR(x), BP_MCG_MC_LIRC_DIV2, BS_MCG_MC_LIRC_DIV2))

/*! @brief Format value for bitfield MCG_MC_LIRC_DIV2. */
#define BF_MCG_MC_LIRC_DIV2(v) ((uint8_t)((uint8_t)(v) << BP_MCG_MC_LIRC_DIV2) & BM_MCG_MC_LIRC_DIV2)

/*! @brief Set the LIRC_DIV2 field to a new value. */
#define BW_MCG_MC_LIRC_DIV2(x, v) (BME_BFI8(HW_MCG_MC_ADDR(x), ((uint8_t)(v) << BP_MCG_MC_LIRC_DIV2), BP_MCG_MC_LIRC_DIV2, 3))
/*@}*/

/*!
 * @name Register MCG_MC, field HIRCEN[7] (RW)
 *
 * Enables the HIRC, even when MCG_Lite is not working at HIRC mode.
 *
 * Values:
 * - 0 - HIRC source is not enabled.
 * - 1 - HIRC source is enabled.
 */
/*@{*/
#define BP_MCG_MC_HIRCEN     (7U)          /*!< Bit position for MCG_MC_HIRCEN. */
#define BM_MCG_MC_HIRCEN     (0x80U)       /*!< Bit mask for MCG_MC_HIRCEN. */
#define BS_MCG_MC_HIRCEN     (1U)          /*!< Bit field size in bits for MCG_MC_HIRCEN. */

/*! @brief Read current value of the MCG_MC_HIRCEN field. */
#define BR_MCG_MC_HIRCEN(x)  (BME_UBFX8(HW_MCG_MC_ADDR(x), BP_MCG_MC_HIRCEN, BS_MCG_MC_HIRCEN))

/*! @brief Format value for bitfield MCG_MC_HIRCEN. */
#define BF_MCG_MC_HIRCEN(v)  ((uint8_t)((uint8_t)(v) << BP_MCG_MC_HIRCEN) & BM_MCG_MC_HIRCEN)

/*! @brief Set the HIRCEN field to a new value. */
#define BW_MCG_MC_HIRCEN(x, v) (BME_BFI8(HW_MCG_MC_ADDR(x), ((uint8_t)(v) << BP_MCG_MC_HIRCEN), BP_MCG_MC_HIRCEN, 1))
/*@}*/

/*******************************************************************************
 * HW_MCG_LTRIMRNG - MCG Low-frequency IRC Trim Range Register
 ******************************************************************************/

/*!
 * @brief HW_MCG_LTRIMRNG - MCG Low-frequency IRC Trim Range Register (RO)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_ltrimrng
{
    uint8_t U;
    struct _hw_mcg_ltrimrng_bitfields
    {
        uint8_t STRIMRNG : 2;          /*!< [1:0] LIRC Slow TRIM (2 MHz) Range */
        uint8_t FTRIMRNG : 2;          /*!< [3:2] LIRC Fast TRIM (8 MHz) Range */
        uint8_t RESERVED0 : 4;         /*!< [7:4]  */
    } B;
} hw_mcg_ltrimrng_t;

/*!
 * @name Constants and macros for entire MCG_LTRIMRNG register
 */
/*@{*/
#define HW_MCG_LTRIMRNG_ADDR(x)  ((uint32_t)(x) + 0x19U)

#define HW_MCG_LTRIMRNG(x)       (*(__I hw_mcg_ltrimrng_t *) HW_MCG_LTRIMRNG_ADDR(x))
#define HW_MCG_LTRIMRNG_RD(x)    (HW_MCG_LTRIMRNG(x).U)
/*@}*/

/*
 * Constants & macros for individual MCG_LTRIMRNG bitfields
 */

/*!
 * @name Register MCG_LTRIMRNG, field STRIMRNG[1:0] (RO)
 *
 * Trim effect level of LSTRIM can be enlarged by setting this field. Loads from
 * a factory programmed location when out of reset.
 *
 * Values:
 * - 00 - Frequency shift by 10%.
 * - 01 - No frequency shift.
 * - 10 - No frequency shift.
 * - 11 - Frequency shift by -10%.
 */
/*@{*/
#define BP_MCG_LTRIMRNG_STRIMRNG (0U)      /*!< Bit position for MCG_LTRIMRNG_STRIMRNG. */
#define BM_MCG_LTRIMRNG_STRIMRNG (0x03U)   /*!< Bit mask for MCG_LTRIMRNG_STRIMRNG. */
#define BS_MCG_LTRIMRNG_STRIMRNG (2U)      /*!< Bit field size in bits for MCG_LTRIMRNG_STRIMRNG. */

/*! @brief Read current value of the MCG_LTRIMRNG_STRIMRNG field. */
#define BR_MCG_LTRIMRNG_STRIMRNG(x) (BME_UBFX8(HW_MCG_LTRIMRNG_ADDR(x), BP_MCG_LTRIMRNG_STRIMRNG, BS_MCG_LTRIMRNG_STRIMRNG))
/*@}*/

/*!
 * @name Register MCG_LTRIMRNG, field FTRIMRNG[3:2] (RO)
 *
 * Trim effect level of LFTRIM can be enlarged by setting this field. Loads from
 * a factory programmed location when out of reset.
 *
 * Values:
 * - 00 - Frequency shift by 10%.
 * - 01 - No frequency shift.
 * - 10 - No frequency shift.
 * - 11 - Frequency shift by -10%.
 */
/*@{*/
#define BP_MCG_LTRIMRNG_FTRIMRNG (2U)      /*!< Bit position for MCG_LTRIMRNG_FTRIMRNG. */
#define BM_MCG_LTRIMRNG_FTRIMRNG (0x0CU)   /*!< Bit mask for MCG_LTRIMRNG_FTRIMRNG. */
#define BS_MCG_LTRIMRNG_FTRIMRNG (2U)      /*!< Bit field size in bits for MCG_LTRIMRNG_FTRIMRNG. */

/*! @brief Read current value of the MCG_LTRIMRNG_FTRIMRNG field. */
#define BR_MCG_LTRIMRNG_FTRIMRNG(x) (BME_UBFX8(HW_MCG_LTRIMRNG_ADDR(x), BP_MCG_LTRIMRNG_FTRIMRNG, BS_MCG_LTRIMRNG_FTRIMRNG))
/*@}*/

/*******************************************************************************
 * HW_MCG_LFTRIM - MCG Low-frequency IRC8M Trim Register
 ******************************************************************************/

/*!
 * @brief HW_MCG_LFTRIM - MCG Low-frequency IRC8M Trim Register (RO)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_lftrim
{
    uint8_t U;
    struct _hw_mcg_lftrim_bitfields
    {
        uint8_t LIRC_FTRIM : 7;        /*!< [6:0] LIRC8M TRIM */
        uint8_t RESERVED0 : 1;         /*!< [7]  */
    } B;
} hw_mcg_lftrim_t;

/*!
 * @name Constants and macros for entire MCG_LFTRIM register
 */
/*@{*/
#define HW_MCG_LFTRIM_ADDR(x)    ((uint32_t)(x) + 0x1AU)

#define HW_MCG_LFTRIM(x)         (*(__I hw_mcg_lftrim_t *) HW_MCG_LFTRIM_ADDR(x))
#define HW_MCG_LFTRIM_RD(x)      (HW_MCG_LFTRIM(x).U)
/*@}*/

/*
 * Constants & macros for individual MCG_LFTRIM bitfields
 */

/*!
 * @name Register MCG_LFTRIM, field LIRC_FTRIM[6:0] (RO)
 *
 * Loads from a factory programmed location when out of reset.
 */
/*@{*/
#define BP_MCG_LFTRIM_LIRC_FTRIM (0U)      /*!< Bit position for MCG_LFTRIM_LIRC_FTRIM. */
#define BM_MCG_LFTRIM_LIRC_FTRIM (0x7FU)   /*!< Bit mask for MCG_LFTRIM_LIRC_FTRIM. */
#define BS_MCG_LFTRIM_LIRC_FTRIM (7U)      /*!< Bit field size in bits for MCG_LFTRIM_LIRC_FTRIM. */

/*! @brief Read current value of the MCG_LFTRIM_LIRC_FTRIM field. */
#define BR_MCG_LFTRIM_LIRC_FTRIM(x) (BME_UBFX8(HW_MCG_LFTRIM_ADDR(x), BP_MCG_LFTRIM_LIRC_FTRIM, BS_MCG_LFTRIM_LIRC_FTRIM))
/*@}*/

/*******************************************************************************
 * HW_MCG_LSTRIM - MCG Low-frequency IRC2M Trim Register
 ******************************************************************************/

/*!
 * @brief HW_MCG_LSTRIM - MCG Low-frequency IRC2M Trim Register (RO)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_lstrim
{
    uint8_t U;
    struct _hw_mcg_lstrim_bitfields
    {
        uint8_t LIRC_STRIM : 7;        /*!< [6:0] LIRC2M TRIM */
        uint8_t RESERVED0 : 1;         /*!< [7]  */
    } B;
} hw_mcg_lstrim_t;

/*!
 * @name Constants and macros for entire MCG_LSTRIM register
 */
/*@{*/
#define HW_MCG_LSTRIM_ADDR(x)    ((uint32_t)(x) + 0x1BU)

#define HW_MCG_LSTRIM(x)         (*(__I hw_mcg_lstrim_t *) HW_MCG_LSTRIM_ADDR(x))
#define HW_MCG_LSTRIM_RD(x)      (HW_MCG_LSTRIM(x).U)
/*@}*/

/*
 * Constants & macros for individual MCG_LSTRIM bitfields
 */

/*!
 * @name Register MCG_LSTRIM, field LIRC_STRIM[6:0] (RO)
 *
 * Loads from a factory programmed location when out of reset.
 */
/*@{*/
#define BP_MCG_LSTRIM_LIRC_STRIM (0U)      /*!< Bit position for MCG_LSTRIM_LIRC_STRIM. */
#define BM_MCG_LSTRIM_LIRC_STRIM (0x7FU)   /*!< Bit mask for MCG_LSTRIM_LIRC_STRIM. */
#define BS_MCG_LSTRIM_LIRC_STRIM (7U)      /*!< Bit field size in bits for MCG_LSTRIM_LIRC_STRIM. */

/*! @brief Read current value of the MCG_LSTRIM_LIRC_STRIM field. */
#define BR_MCG_LSTRIM_LIRC_STRIM(x) (BME_UBFX8(HW_MCG_LSTRIM_ADDR(x), BP_MCG_LSTRIM_LIRC_STRIM, BS_MCG_LSTRIM_LIRC_STRIM))
/*@}*/

/*******************************************************************************
 * hw_mcg_t - module struct
 ******************************************************************************/
/*!
 * @brief All MCG module registers.
 */
#pragma pack(1)
typedef struct _hw_mcg
{
    __IO hw_mcg_c1_t C1;                   /*!< [0x0] MCG Control Register 1 */
    __IO hw_mcg_c2_t C2;                   /*!< [0x1] MCG Control Register 2 */
    uint8_t _reserved0[4];
    __I hw_mcg_s_t S;                      /*!< [0x6] MCG Status Register */
    uint8_t _reserved1[1];
    __IO hw_mcg_sc_t SC;                   /*!< [0x8] MCG Status and Control Register */
    uint8_t _reserved2[11];
    __I hw_mcg_hctrim_t HCTRIM;            /*!< [0x14] MCG High-frequency IRC Coarse Trim Register */
    __I hw_mcg_httrim_t HTTRIM;            /*!< [0x15] MCG High-frequency IRC Tempco (Temperature Coefficient) Trim Register */
    __I hw_mcg_hftrim_t HFTRIM;            /*!< [0x16] MCG High-frequency IRC Fine Trim Register */
    uint8_t _reserved3[1];
    __IO hw_mcg_mc_t MC;                   /*!< [0x18] MCG Miscellaneous Control Register */
    __I hw_mcg_ltrimrng_t LTRIMRNG;        /*!< [0x19] MCG Low-frequency IRC Trim Range Register */
    __I hw_mcg_lftrim_t LFTRIM;            /*!< [0x1A] MCG Low-frequency IRC8M Trim Register */
    __I hw_mcg_lstrim_t LSTRIM;            /*!< [0x1B] MCG Low-frequency IRC2M Trim Register */
} hw_mcg_t;
#pragma pack()

/*! @brief Macro to access all MCG registers. */
/*! @param x MCG module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_MCG_REGS(MCG_BASE)</code>. */
#define HW_MCG_REGS(x) (*(hw_mcg_t *)(x))

/*
 * MKL43Z4 MCM
 *
 * Core Platform Miscellaneous Control Module
 *
 * Registers defined in this header file:
 * - HW_MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration
 * - HW_MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration
 * - HW_MCM_PLACR - Platform Control Register
 * - HW_MCM_CPO - Compute Operation Control Register
 *
 * - hw_mcm_t - Struct containing all module registers.
 */

#define HW_MCM_INSTANCE_COUNT (1U) /*!< Number of instances of the MCM module. */
#define HW_MCM (0U) /*!< Instance number for MCM. */

/*******************************************************************************
 * HW_MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration
 ******************************************************************************/

/*!
 * @brief HW_MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration (RO)
 *
 * Reset value: 0x0007U
 *
 * PLASC is a 16-bit read-only register identifying the presence/absence of bus
 * slave connections to the device's crossbar switch.
 */
typedef union _hw_mcm_plasc
{
    uint16_t U;
    struct _hw_mcm_plasc_bitfields
    {
        uint16_t ASC : 8;              /*!< [7:0] Each bit in the ASC field indicates
                                        * whether there is a corresponding connection to the crossbar switch's slave
                                        * input port. */
        uint16_t RESERVED0 : 8;        /*!< [15:8]  */
    } B;
} hw_mcm_plasc_t;

/*!
 * @name Constants and macros for entire MCM_PLASC register
 */
/*@{*/
#define HW_MCM_PLASC_ADDR(x)     ((uint32_t)(x) + 0x8U)

#define HW_MCM_PLASC(x)          (*(__I hw_mcm_plasc_t *) HW_MCM_PLASC_ADDR(x))
#define HW_MCM_PLASC_RD(x)       (HW_MCM_PLASC(x).U)
/*@}*/

/*
 * Constants & macros for individual MCM_PLASC bitfields
 */

/*!
 * @name Register MCM_PLASC, field ASC[7:0] (RO)
 *
 * Values:
 * - 0 - A bus slave connection to AXBS input port n is absent.
 * - 1 - A bus slave connection to AXBS input port n is present.
 */
/*@{*/
#define BP_MCM_PLASC_ASC     (0U)          /*!< Bit position for MCM_PLASC_ASC. */
#define BM_MCM_PLASC_ASC     (0x00FFU)     /*!< Bit mask for MCM_PLASC_ASC. */
#define BS_MCM_PLASC_ASC     (8U)          /*!< Bit field size in bits for MCM_PLASC_ASC. */

/*! @brief Read current value of the MCM_PLASC_ASC field. */
#define BR_MCM_PLASC_ASC(x)  (HW_MCM_PLASC(x).B.ASC)
/*@}*/

/*******************************************************************************
 * HW_MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration
 ******************************************************************************/

/*!
 * @brief HW_MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration (RO)
 *
 * Reset value: 0x000DU
 *
 * PLAMC is a 16-bit read-only register identifying the presence/absence of bus
 * master connections to the device's crossbar switch.
 */
typedef union _hw_mcm_plamc
{
    uint16_t U;
    struct _hw_mcm_plamc_bitfields
    {
        uint16_t AMC : 8;              /*!< [7:0] Each bit in the AMC field indicates
                                        * whether there is a corresponding connection to the AXBS master input port. */
        uint16_t RESERVED0 : 8;        /*!< [15:8]  */
    } B;
} hw_mcm_plamc_t;

/*!
 * @name Constants and macros for entire MCM_PLAMC register
 */
/*@{*/
#define HW_MCM_PLAMC_ADDR(x)     ((uint32_t)(x) + 0xAU)

#define HW_MCM_PLAMC(x)          (*(__I hw_mcm_plamc_t *) HW_MCM_PLAMC_ADDR(x))
#define HW_MCM_PLAMC_RD(x)       (HW_MCM_PLAMC(x).U)
/*@}*/

/*
 * Constants & macros for individual MCM_PLAMC bitfields
 */

/*!
 * @name Register MCM_PLAMC, field AMC[7:0] (RO)
 *
 * Values:
 * - 0 - A bus master connection to AXBS input port n is absent
 * - 1 - A bus master connection to AXBS input port n is present
 */
/*@{*/
#define BP_MCM_PLAMC_AMC     (0U)          /*!< Bit position for MCM_PLAMC_AMC. */
#define BM_MCM_PLAMC_AMC     (0x00FFU)     /*!< Bit mask for MCM_PLAMC_AMC. */
#define BS_MCM_PLAMC_AMC     (8U)          /*!< Bit field size in bits for MCM_PLAMC_AMC. */

/*! @brief Read current value of the MCM_PLAMC_AMC field. */
#define BR_MCM_PLAMC_AMC(x)  (HW_MCM_PLAMC(x).B.AMC)
/*@}*/

/*******************************************************************************
 * HW_MCM_PLACR - Platform Control Register
 ******************************************************************************/

/*!
 * @brief HW_MCM_PLACR - Platform Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The PLACR register selects the arbitration policy for the crossbar masters
 * and configures the flash memory controller. The speculation buffer and cache in
 * the flash memory controller is configurable via PLACR[15:10 ]. The speculation
 * buffer is enabled only for instructions after reset. It is possible to have
 * these states for the speculation buffer: DFCS EFDS Description 0 0 Speculation
 * buffer is on for instruction and off for data. 0 1 Speculation buffer is on
 * for instruction and on for data. 1 X Speculation buffer is off. The cache in
 * flash controller is enabled and caching both instruction and data type fetches
 * after reset. It is possible to have these states for the cache: DFCC DFCIC DFCDA
 * Description 0 0 0 Cache is on for both instruction and data. 0 0 1 Cache is
 * on for instruction and off for data. 0 1 0 Cache is off for instruction and on
 * for data. 0 1 1 Cache is off for both instruction and data. 1 X X Cache is off.
 */
typedef union _hw_mcm_placr
{
    uint32_t U;
    struct _hw_mcm_placr_bitfields
    {
        uint32_t RESERVED0 : 9;        /*!< [8:0]  */
        uint32_t ARB : 1;              /*!< [9] Arbitration select */
        uint32_t CFCC : 1;             /*!< [10] Clear Flash Controller Cache */
        uint32_t DFCDA : 1;            /*!< [11] Disable Flash Controller Data Caching */
        uint32_t DFCIC : 1;            /*!< [12] Disable Flash Controller Instruction
                                        * Caching */
        uint32_t DFCC : 1;             /*!< [13] Disable Flash Controller Cache */
        uint32_t EFDS : 1;             /*!< [14] Enable Flash Data Speculation */
        uint32_t DFCS : 1;             /*!< [15] Disable Flash Controller Speculation */
        uint32_t ESFC : 1;             /*!< [16] Enable Stalling Flash Controller */
        uint32_t RESERVED1 : 15;       /*!< [31:17]  */
    } B;
} hw_mcm_placr_t;

/*!
 * @name Constants and macros for entire MCM_PLACR register
 */
/*@{*/
#define HW_MCM_PLACR_ADDR(x)     ((uint32_t)(x) + 0xCU)

#define HW_MCM_PLACR(x)          (*(__IO hw_mcm_placr_t *) HW_MCM_PLACR_ADDR(x))
#define HW_MCM_PLACR_RD(x)       (HW_MCM_PLACR(x).U)
#define HW_MCM_PLACR_WR(x, v)    (HW_MCM_PLACR(x).U = (v))
#define HW_MCM_PLACR_SET(x, v)   (HW_MCM_PLACR_WR(x, HW_MCM_PLACR_RD(x) |  (v)))
#define HW_MCM_PLACR_CLR(x, v)   (HW_MCM_PLACR_WR(x, HW_MCM_PLACR_RD(x) & ~(v)))
#define HW_MCM_PLACR_TOG(x, v)   (HW_MCM_PLACR_WR(x, HW_MCM_PLACR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MCM_PLACR bitfields
 */

/*!
 * @name Register MCM_PLACR, field ARB[9] (RW)
 *
 * Values:
 * - 0 - Fixed-priority arbitration for the crossbar masters
 * - 1 - Round-robin arbitration for the crossbar masters
 */
/*@{*/
#define BP_MCM_PLACR_ARB     (9U)          /*!< Bit position for MCM_PLACR_ARB. */
#define BM_MCM_PLACR_ARB     (0x00000200U) /*!< Bit mask for MCM_PLACR_ARB. */
#define BS_MCM_PLACR_ARB     (1U)          /*!< Bit field size in bits for MCM_PLACR_ARB. */

/*! @brief Read current value of the MCM_PLACR_ARB field. */
#define BR_MCM_PLACR_ARB(x)  (HW_MCM_PLACR(x).B.ARB)

/*! @brief Format value for bitfield MCM_PLACR_ARB. */
#define BF_MCM_PLACR_ARB(v)  ((uint32_t)((uint32_t)(v) << BP_MCM_PLACR_ARB) & BM_MCM_PLACR_ARB)

/*! @brief Set the ARB field to a new value. */
#define BW_MCM_PLACR_ARB(x, v) (HW_MCM_PLACR_WR(x, (HW_MCM_PLACR_RD(x) & ~BM_MCM_PLACR_ARB) | BF_MCM_PLACR_ARB(v)))
/*@}*/

/*!
 * @name Register MCM_PLACR, field CFCC[10] (WORZ)
 *
 * Writing a 1 to this field clears the cache. Writing a 0 to this field is
 * ignored. This field always reads as 0.
 */
/*@{*/
#define BP_MCM_PLACR_CFCC    (10U)         /*!< Bit position for MCM_PLACR_CFCC. */
#define BM_MCM_PLACR_CFCC    (0x00000400U) /*!< Bit mask for MCM_PLACR_CFCC. */
#define BS_MCM_PLACR_CFCC    (1U)          /*!< Bit field size in bits for MCM_PLACR_CFCC. */

/*! @brief Format value for bitfield MCM_PLACR_CFCC. */
#define BF_MCM_PLACR_CFCC(v) ((uint32_t)((uint32_t)(v) << BP_MCM_PLACR_CFCC) & BM_MCM_PLACR_CFCC)

/*! @brief Set the CFCC field to a new value. */
#define BW_MCM_PLACR_CFCC(x, v) (HW_MCM_PLACR_WR(x, (HW_MCM_PLACR_RD(x) & ~BM_MCM_PLACR_CFCC) | BF_MCM_PLACR_CFCC(v)))
/*@}*/

/*!
 * @name Register MCM_PLACR, field DFCDA[11] (RW)
 *
 * Disables flash controller data caching.
 *
 * Values:
 * - 0 - Enable flash controller data caching
 * - 1 - Disable flash controller data caching.
 */
/*@{*/
#define BP_MCM_PLACR_DFCDA   (11U)         /*!< Bit position for MCM_PLACR_DFCDA. */
#define BM_MCM_PLACR_DFCDA   (0x00000800U) /*!< Bit mask for MCM_PLACR_DFCDA. */
#define BS_MCM_PLACR_DFCDA   (1U)          /*!< Bit field size in bits for MCM_PLACR_DFCDA. */

/*! @brief Read current value of the MCM_PLACR_DFCDA field. */
#define BR_MCM_PLACR_DFCDA(x) (HW_MCM_PLACR(x).B.DFCDA)

/*! @brief Format value for bitfield MCM_PLACR_DFCDA. */
#define BF_MCM_PLACR_DFCDA(v) ((uint32_t)((uint32_t)(v) << BP_MCM_PLACR_DFCDA) & BM_MCM_PLACR_DFCDA)

/*! @brief Set the DFCDA field to a new value. */
#define BW_MCM_PLACR_DFCDA(x, v) (HW_MCM_PLACR_WR(x, (HW_MCM_PLACR_RD(x) & ~BM_MCM_PLACR_DFCDA) | BF_MCM_PLACR_DFCDA(v)))
/*@}*/

/*!
 * @name Register MCM_PLACR, field DFCIC[12] (RW)
 *
 * Disables flash controller instruction caching.
 *
 * Values:
 * - 0 - Enable flash controller instruction caching.
 * - 1 - Disable flash controller instruction caching.
 */
/*@{*/
#define BP_MCM_PLACR_DFCIC   (12U)         /*!< Bit position for MCM_PLACR_DFCIC. */
#define BM_MCM_PLACR_DFCIC   (0x00001000U) /*!< Bit mask for MCM_PLACR_DFCIC. */
#define BS_MCM_PLACR_DFCIC   (1U)          /*!< Bit field size in bits for MCM_PLACR_DFCIC. */

/*! @brief Read current value of the MCM_PLACR_DFCIC field. */
#define BR_MCM_PLACR_DFCIC(x) (HW_MCM_PLACR(x).B.DFCIC)

/*! @brief Format value for bitfield MCM_PLACR_DFCIC. */
#define BF_MCM_PLACR_DFCIC(v) ((uint32_t)((uint32_t)(v) << BP_MCM_PLACR_DFCIC) & BM_MCM_PLACR_DFCIC)

/*! @brief Set the DFCIC field to a new value. */
#define BW_MCM_PLACR_DFCIC(x, v) (HW_MCM_PLACR_WR(x, (HW_MCM_PLACR_RD(x) & ~BM_MCM_PLACR_DFCIC) | BF_MCM_PLACR_DFCIC(v)))
/*@}*/

/*!
 * @name Register MCM_PLACR, field DFCC[13] (RW)
 *
 * Disables flash controller cache.
 *
 * Values:
 * - 0 - Enable flash controller cache.
 * - 1 - Disable flash controller cache.
 */
/*@{*/
#define BP_MCM_PLACR_DFCC    (13U)         /*!< Bit position for MCM_PLACR_DFCC. */
#define BM_MCM_PLACR_DFCC    (0x00002000U) /*!< Bit mask for MCM_PLACR_DFCC. */
#define BS_MCM_PLACR_DFCC    (1U)          /*!< Bit field size in bits for MCM_PLACR_DFCC. */

/*! @brief Read current value of the MCM_PLACR_DFCC field. */
#define BR_MCM_PLACR_DFCC(x) (HW_MCM_PLACR(x).B.DFCC)

/*! @brief Format value for bitfield MCM_PLACR_DFCC. */
#define BF_MCM_PLACR_DFCC(v) ((uint32_t)((uint32_t)(v) << BP_MCM_PLACR_DFCC) & BM_MCM_PLACR_DFCC)

/*! @brief Set the DFCC field to a new value. */
#define BW_MCM_PLACR_DFCC(x, v) (HW_MCM_PLACR_WR(x, (HW_MCM_PLACR_RD(x) & ~BM_MCM_PLACR_DFCC) | BF_MCM_PLACR_DFCC(v)))
/*@}*/

/*!
 * @name Register MCM_PLACR, field EFDS[14] (RW)
 *
 * Enables flash data speculation.
 *
 * Values:
 * - 0 - Disable flash data speculation.
 * - 1 - Enable flash data speculation.
 */
/*@{*/
#define BP_MCM_PLACR_EFDS    (14U)         /*!< Bit position for MCM_PLACR_EFDS. */
#define BM_MCM_PLACR_EFDS    (0x00004000U) /*!< Bit mask for MCM_PLACR_EFDS. */
#define BS_MCM_PLACR_EFDS    (1U)          /*!< Bit field size in bits for MCM_PLACR_EFDS. */

/*! @brief Read current value of the MCM_PLACR_EFDS field. */
#define BR_MCM_PLACR_EFDS(x) (HW_MCM_PLACR(x).B.EFDS)

/*! @brief Format value for bitfield MCM_PLACR_EFDS. */
#define BF_MCM_PLACR_EFDS(v) ((uint32_t)((uint32_t)(v) << BP_MCM_PLACR_EFDS) & BM_MCM_PLACR_EFDS)

/*! @brief Set the EFDS field to a new value. */
#define BW_MCM_PLACR_EFDS(x, v) (HW_MCM_PLACR_WR(x, (HW_MCM_PLACR_RD(x) & ~BM_MCM_PLACR_EFDS) | BF_MCM_PLACR_EFDS(v)))
/*@}*/

/*!
 * @name Register MCM_PLACR, field DFCS[15] (RW)
 *
 * Disables flash controller speculation.
 *
 * Values:
 * - 0 - Enable flash controller speculation.
 * - 1 - Disable flash controller speculation.
 */
/*@{*/
#define BP_MCM_PLACR_DFCS    (15U)         /*!< Bit position for MCM_PLACR_DFCS. */
#define BM_MCM_PLACR_DFCS    (0x00008000U) /*!< Bit mask for MCM_PLACR_DFCS. */
#define BS_MCM_PLACR_DFCS    (1U)          /*!< Bit field size in bits for MCM_PLACR_DFCS. */

/*! @brief Read current value of the MCM_PLACR_DFCS field. */
#define BR_MCM_PLACR_DFCS(x) (HW_MCM_PLACR(x).B.DFCS)

/*! @brief Format value for bitfield MCM_PLACR_DFCS. */
#define BF_MCM_PLACR_DFCS(v) ((uint32_t)((uint32_t)(v) << BP_MCM_PLACR_DFCS) & BM_MCM_PLACR_DFCS)

/*! @brief Set the DFCS field to a new value. */
#define BW_MCM_PLACR_DFCS(x, v) (HW_MCM_PLACR_WR(x, (HW_MCM_PLACR_RD(x) & ~BM_MCM_PLACR_DFCS) | BF_MCM_PLACR_DFCS(v)))
/*@}*/

/*!
 * @name Register MCM_PLACR, field ESFC[16] (RW)
 *
 * Enables stalling flash controller when flash is busy. When software needs to
 * access the flash memory while a flash memory resource is being manipulated by
 * a flash command, software can enable a stall mechanism to avoid a read
 * collision. The stall mechanism allows software to execute code from the same block on
 * which flash operations are being performed. However, software must ensure the
 * sector the flash operations are being performed on is not the same sector
 * from which the code is executing. ESFC enables the stall mechanism. This bit must
 * be set only just before the flash operation is executed and must be cleared
 * when the operation completes.
 *
 * Values:
 * - 0 - Disable stalling flash controller when flash is busy.
 * - 1 - Enable stalling flash controller when flash is busy.
 */
/*@{*/
#define BP_MCM_PLACR_ESFC    (16U)         /*!< Bit position for MCM_PLACR_ESFC. */
#define BM_MCM_PLACR_ESFC    (0x00010000U) /*!< Bit mask for MCM_PLACR_ESFC. */
#define BS_MCM_PLACR_ESFC    (1U)          /*!< Bit field size in bits for MCM_PLACR_ESFC. */

/*! @brief Read current value of the MCM_PLACR_ESFC field. */
#define BR_MCM_PLACR_ESFC(x) (HW_MCM_PLACR(x).B.ESFC)

/*! @brief Format value for bitfield MCM_PLACR_ESFC. */
#define BF_MCM_PLACR_ESFC(v) ((uint32_t)((uint32_t)(v) << BP_MCM_PLACR_ESFC) & BM_MCM_PLACR_ESFC)

/*! @brief Set the ESFC field to a new value. */
#define BW_MCM_PLACR_ESFC(x, v) (HW_MCM_PLACR_WR(x, (HW_MCM_PLACR_RD(x) & ~BM_MCM_PLACR_ESFC) | BF_MCM_PLACR_ESFC(v)))
/*@}*/

/*******************************************************************************
 * HW_MCM_CPO - Compute Operation Control Register
 ******************************************************************************/

/*!
 * @brief HW_MCM_CPO - Compute Operation Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls the Compute Operation.
 */
typedef union _hw_mcm_cpo
{
    uint32_t U;
    struct _hw_mcm_cpo_bitfields
    {
        uint32_t CPOREQ : 1;           /*!< [0] Compute Operation Request */
        uint32_t CPOACK : 1;           /*!< [1] Compute Operation Acknowledge */
        uint32_t CPOWOI : 1;           /*!< [2] Compute Operation Wake-up on Interrupt
                                        * */
        uint32_t RESERVED0 : 29;       /*!< [31:3]  */
    } B;
} hw_mcm_cpo_t;

/*!
 * @name Constants and macros for entire MCM_CPO register
 */
/*@{*/
#define HW_MCM_CPO_ADDR(x)       ((uint32_t)(x) + 0x40U)

#define HW_MCM_CPO(x)            (*(__IO hw_mcm_cpo_t *) HW_MCM_CPO_ADDR(x))
#define HW_MCM_CPO_RD(x)         (HW_MCM_CPO(x).U)
#define HW_MCM_CPO_WR(x, v)      (HW_MCM_CPO(x).U = (v))
#define HW_MCM_CPO_SET(x, v)     (HW_MCM_CPO_WR(x, HW_MCM_CPO_RD(x) |  (v)))
#define HW_MCM_CPO_CLR(x, v)     (HW_MCM_CPO_WR(x, HW_MCM_CPO_RD(x) & ~(v)))
#define HW_MCM_CPO_TOG(x, v)     (HW_MCM_CPO_WR(x, HW_MCM_CPO_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MCM_CPO bitfields
 */

/*!
 * @name Register MCM_CPO, field CPOREQ[0] (RW)
 *
 * This bit is auto-cleared by vector fetching if CPOWOI = 1.
 *
 * Values:
 * - 0 - Request is cleared.
 * - 1 - Request Compute Operation.
 */
/*@{*/
#define BP_MCM_CPO_CPOREQ    (0U)          /*!< Bit position for MCM_CPO_CPOREQ. */
#define BM_MCM_CPO_CPOREQ    (0x00000001U) /*!< Bit mask for MCM_CPO_CPOREQ. */
#define BS_MCM_CPO_CPOREQ    (1U)          /*!< Bit field size in bits for MCM_CPO_CPOREQ. */

/*! @brief Read current value of the MCM_CPO_CPOREQ field. */
#define BR_MCM_CPO_CPOREQ(x) (HW_MCM_CPO(x).B.CPOREQ)

/*! @brief Format value for bitfield MCM_CPO_CPOREQ. */
#define BF_MCM_CPO_CPOREQ(v) ((uint32_t)((uint32_t)(v) << BP_MCM_CPO_CPOREQ) & BM_MCM_CPO_CPOREQ)

/*! @brief Set the CPOREQ field to a new value. */
#define BW_MCM_CPO_CPOREQ(x, v) (HW_MCM_CPO_WR(x, (HW_MCM_CPO_RD(x) & ~BM_MCM_CPO_CPOREQ) | BF_MCM_CPO_CPOREQ(v)))
/*@}*/

/*!
 * @name Register MCM_CPO, field CPOACK[1] (RO)
 *
 * Values:
 * - 0 - Compute operation entry has not completed or compute operation exit has
 *     completed.
 * - 1 - Compute operation entry has completed or compute operation exit has not
 *     completed.
 */
/*@{*/
#define BP_MCM_CPO_CPOACK    (1U)          /*!< Bit position for MCM_CPO_CPOACK. */
#define BM_MCM_CPO_CPOACK    (0x00000002U) /*!< Bit mask for MCM_CPO_CPOACK. */
#define BS_MCM_CPO_CPOACK    (1U)          /*!< Bit field size in bits for MCM_CPO_CPOACK. */

/*! @brief Read current value of the MCM_CPO_CPOACK field. */
#define BR_MCM_CPO_CPOACK(x) (HW_MCM_CPO(x).B.CPOACK)
/*@}*/

/*!
 * @name Register MCM_CPO, field CPOWOI[2] (RW)
 *
 * Values:
 * - 0 - No effect.
 * - 1 - When set, the CPOREQ is cleared on any interrupt or exception vector
 *     fetch.
 */
/*@{*/
#define BP_MCM_CPO_CPOWOI    (2U)          /*!< Bit position for MCM_CPO_CPOWOI. */
#define BM_MCM_CPO_CPOWOI    (0x00000004U) /*!< Bit mask for MCM_CPO_CPOWOI. */
#define BS_MCM_CPO_CPOWOI    (1U)          /*!< Bit field size in bits for MCM_CPO_CPOWOI. */

/*! @brief Read current value of the MCM_CPO_CPOWOI field. */
#define BR_MCM_CPO_CPOWOI(x) (HW_MCM_CPO(x).B.CPOWOI)

/*! @brief Format value for bitfield MCM_CPO_CPOWOI. */
#define BF_MCM_CPO_CPOWOI(v) ((uint32_t)((uint32_t)(v) << BP_MCM_CPO_CPOWOI) & BM_MCM_CPO_CPOWOI)

/*! @brief Set the CPOWOI field to a new value. */
#define BW_MCM_CPO_CPOWOI(x, v) (HW_MCM_CPO_WR(x, (HW_MCM_CPO_RD(x) & ~BM_MCM_CPO_CPOWOI) | BF_MCM_CPO_CPOWOI(v)))
/*@}*/

/*******************************************************************************
 * hw_mcm_t - module struct
 ******************************************************************************/
/*!
 * @brief All MCM module registers.
 */
#pragma pack(1)
typedef struct _hw_mcm
{
    uint8_t _reserved0[8];
    __I hw_mcm_plasc_t PLASC;              /*!< [0x8] Crossbar Switch (AXBS) Slave Configuration */
    __I hw_mcm_plamc_t PLAMC;              /*!< [0xA] Crossbar Switch (AXBS) Master Configuration */
    __IO hw_mcm_placr_t PLACR;             /*!< [0xC] Platform Control Register */
    uint8_t _reserved1[48];
    __IO hw_mcm_cpo_t CPO;                 /*!< [0x40] Compute Operation Control Register */
} hw_mcm_t;
#pragma pack()

/*! @brief Macro to access all MCM registers. */
/*! @param x MCM module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_MCM_REGS(MCM_BASE)</code>. */
#define HW_MCM_REGS(x) (*(hw_mcm_t *)(x))

/*
 * MKL43Z4 MTB
 *
 * Micro Trace Buffer
 *
 * Registers defined in this header file:
 * - HW_MTB_POSITION - MTB Position Register
 * - HW_MTB_MASTER - MTB Master Register
 * - HW_MTB_FLOW - MTB Flow Register
 * - HW_MTB_BASE - MTB Base Register
 * - HW_MTB_MODECTRL - Integration Mode Control Register
 * - HW_MTB_TAGSET - Claim TAG Set Register
 * - HW_MTB_TAGCLEAR - Claim TAG Clear Register
 * - HW_MTB_LOCKACCESS - Lock Access Register
 * - HW_MTB_LOCKSTAT - Lock Status Register
 * - HW_MTB_AUTHSTAT - Authentication Status Register
 * - HW_MTB_DEVICEARCH - Device Architecture Register
 * - HW_MTB_DEVICECFG - Device Configuration Register
 * - HW_MTB_DEVICETYPID - Device Type Identifier Register
 * - HW_MTB_PERIPHID4 - Peripheral ID Register
 * - HW_MTB_PERIPHID5 - Peripheral ID Register
 * - HW_MTB_PERIPHID6 - Peripheral ID Register
 * - HW_MTB_PERIPHID7 - Peripheral ID Register
 * - HW_MTB_PERIPHID0 - Peripheral ID Register
 * - HW_MTB_PERIPHID1 - Peripheral ID Register
 * - HW_MTB_PERIPHID2 - Peripheral ID Register
 * - HW_MTB_PERIPHID3 - Peripheral ID Register
 * - HW_MTB_COMPIDn - Component ID Register
 *
 * - hw_mtb_t - Struct containing all module registers.
 */

#define HW_MTB_INSTANCE_COUNT (1U) /*!< Number of instances of the MTB module. */
#define HW_MTB (0U) /*!< Instance number for MTB. */

/*******************************************************************************
 * HW_MTB_POSITION - MTB Position Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_POSITION - MTB Position Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTB_POSITION register contains the Trace Write Address Pointer and Wrap
 * fields. This register can be modified by the explicit programming model writes.
 * It is also automatically updated by the MTB hardware when trace packets are
 * being recorded. The base address of the system RAM in the memory map dictates
 * special consideration for the placement of the MTB. Consider the following
 * guidelines: For the standard configuration where the size of the MTB is <= 25% of
 * the total RAM capacity, it is recommended the MTB be based at the address
 * defined by the MTB_BASE register. The read-only MTB_BASE register is defined by
 * the expression (0x2000_0000 - (RAM_Size/4)). For this configuration, the
 * MTB_POSITION register is initialized to MTB_BASE & 0x0000_7FF8. If the size of the
 * MTB is more than 25% but less than or equal to 50% of the total RAM capacity, it
 * is recommended the MTB be based at address 0x2000_0000. In this
 * configuration, the MTB_POSITION register is initialized to (0x2000_0000 & 0x0000_7FF8) =
 * 0x0000_00000. Following these two suggested placements provides a full-featured
 * circular memory buffer containing program trace packets. In the unlikely event
 * an even larger trace buffer is required, a write-once capacity of 75% of the
 * total RAM capacity can be based at address 0x2000_0000. The MTB_POSITION
 * register is initialized to (0x2000_0000 & 0x0000_7FF8) = 0x0000_0000. However, this
 * configuration cannot support operation as a circular queue and instead
 * requires the use of the MTB_FLOW[WATERMARK] capability to automatically disable
 * tracing or halting the processor as the number of packet writes approach the
 * buffer capacity. See the MTB_FLOW register description for more details.
 */
typedef union _hw_mtb_position
{
    uint32_t U;
    struct _hw_mtb_position_bitfields
    {
        uint32_t RESERVED0 : 2;        /*!< [1:0]  */
        uint32_t WRAP : 1;             /*!< [2] WRAP */
        uint32_t POINTER : 29;         /*!< [31:3] Trace Packet Address Pointer[28:0]
                                        * */
    } B;
} hw_mtb_position_t;

/*!
 * @name Constants and macros for entire MTB_POSITION register
 */
/*@{*/
#define HW_MTB_POSITION_ADDR(x)  ((uint32_t)(x) + 0x0U)

#define HW_MTB_POSITION(x)       (*(__IO hw_mtb_position_t *) HW_MTB_POSITION_ADDR(x))
#define HW_MTB_POSITION_RD(x)    (HW_MTB_POSITION(x).U)
#define HW_MTB_POSITION_WR(x, v) (HW_MTB_POSITION(x).U = (v))
#define HW_MTB_POSITION_SET(x, v) (HW_MTB_POSITION_WR(x, HW_MTB_POSITION_RD(x) |  (v)))
#define HW_MTB_POSITION_CLR(x, v) (HW_MTB_POSITION_WR(x, HW_MTB_POSITION_RD(x) & ~(v)))
#define HW_MTB_POSITION_TOG(x, v) (HW_MTB_POSITION_WR(x, HW_MTB_POSITION_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MTB_POSITION bitfields
 */

/*!
 * @name Register MTB_POSITION, field WRAP[2] (RW)
 *
 * This field is set to 1 automatically when the POINTER value wraps as
 * determined by the MTB_MASTER[MASK] field in the MASTER Trace Control Register. A debug
 * agent might use the WRAP field to determine whether the trace information
 * above and below the pointer address is valid.
 */
/*@{*/
#define BP_MTB_POSITION_WRAP (2U)          /*!< Bit position for MTB_POSITION_WRAP. */
#define BM_MTB_POSITION_WRAP (0x00000004U) /*!< Bit mask for MTB_POSITION_WRAP. */
#define BS_MTB_POSITION_WRAP (1U)          /*!< Bit field size in bits for MTB_POSITION_WRAP. */

/*! @brief Read current value of the MTB_POSITION_WRAP field. */
#define BR_MTB_POSITION_WRAP(x) (HW_MTB_POSITION(x).B.WRAP)

/*! @brief Format value for bitfield MTB_POSITION_WRAP. */
#define BF_MTB_POSITION_WRAP(v) ((uint32_t)((uint32_t)(v) << BP_MTB_POSITION_WRAP) & BM_MTB_POSITION_WRAP)

/*! @brief Set the WRAP field to a new value. */
#define BW_MTB_POSITION_WRAP(x, v) (HW_MTB_POSITION_WR(x, (HW_MTB_POSITION_RD(x) & ~BM_MTB_POSITION_WRAP) | BF_MTB_POSITION_WRAP(v)))
/*@}*/

/*!
 * @name Register MTB_POSITION, field POINTER[31:3] (RW)
 *
 * Because a packet consists of two words, the POINTER field is the address of
 * the first word of a packet. This field contains bits[31:3] of the RAM address
 * where the next trace packet is written. Therefore, it points to an unused
 * location and is automatically incremented. A debug agent can calculate the system
 * memory map address for the current location in the MTB using the following
 * "generic" equation: Given mtb_size = 1 << (MTB_MASTER[MASK] + 4), systemAddress =
 * MTB_BASE + (((MTB_POSITION & 0xFFFF_FFF8) + (mtb_size - (MTB_BASE &
 * (mtb_size-1)))) & 0x0000_7FF8); For this device, a simpler expression also applies. See
 * the following pseudo-code: if ((MTB_POSITION >> 13) == 0x3) systemAddress =
 * (0x1FFF << 16) + (0x1 << 15) + (MTB_POSITION & 0x7FF8); else systemAddress =
 * (0x2000 << 16) + (0x0 << 15) + (MTB_POSITION & 0x7FF8); The size of the RAM is
 * parameterized and the most significant bits of the POINTER field are RAZ/WI. For
 * these devices, POSITION[31:15] == POSITION[POINTER[28:12]] are RAZ/WI.
 * Therefore, the active bits in this field are POSITION[14:3] ==
 * POSITION[POINTER[11:0]].
 */
/*@{*/
#define BP_MTB_POSITION_POINTER (3U)       /*!< Bit position for MTB_POSITION_POINTER. */
#define BM_MTB_POSITION_POINTER (0xFFFFFFF8U) /*!< Bit mask for MTB_POSITION_POINTER. */
#define BS_MTB_POSITION_POINTER (29U)      /*!< Bit field size in bits for MTB_POSITION_POINTER. */

/*! @brief Read current value of the MTB_POSITION_POINTER field. */
#define BR_MTB_POSITION_POINTER(x) (HW_MTB_POSITION(x).B.POINTER)

/*! @brief Format value for bitfield MTB_POSITION_POINTER. */
#define BF_MTB_POSITION_POINTER(v) ((uint32_t)((uint32_t)(v) << BP_MTB_POSITION_POINTER) & BM_MTB_POSITION_POINTER)

/*! @brief Set the POINTER field to a new value. */
#define BW_MTB_POSITION_POINTER(x, v) (HW_MTB_POSITION_WR(x, (HW_MTB_POSITION_RD(x) & ~BM_MTB_POSITION_POINTER) | BF_MTB_POSITION_POINTER(v)))
/*@}*/

/*******************************************************************************
 * HW_MTB_MASTER - MTB Master Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_MASTER - MTB Master Register (RW)
 *
 * Reset value: 0x00000080U
 *
 * The MTB_MASTER register contains the main program trace enable plus other
 * trace controls. This register can be modified by the explicit programming model
 * writes. MTB_MASTER[EN] and MTB_MASTER[HALTREQ] fields are also automatically
 * updated by the MTB hardware. Before MTB_MASTER[EN] or MTB_MASTER[TSTARTEN] are
 * set to 1, the software must initialize the MTB_POSITION and MTB_FLOW registers.
 * If MTB_FLOW[WATERMARK] is used to stop tracing or to halt the processor,
 * MTB_MASTER[MASK] must still be set to a value that prevents MTB_POSITION[POINTER]
 * from wrapping before it reaches the MTB_FLOW[WATERMARK] value. The format of
 * this mask field is different than MTBDWT_MASKn[MASK].
 */
typedef union _hw_mtb_master
{
    uint32_t U;
    struct _hw_mtb_master_bitfields
    {
        uint32_t MASK : 5;             /*!< [4:0] Mask */
        uint32_t TSTARTEN : 1;         /*!< [5] Trace Start Input Enable */
        uint32_t TSTOPEN : 1;          /*!< [6] Trace Stop Input Enable */
        uint32_t SFRWPRIV : 1;         /*!< [7] Special Function Register Write
                                        * Privilege */
        uint32_t RAMPRIV : 1;          /*!< [8] RAM Privilege */
        uint32_t HALTREQ : 1;          /*!< [9] Halt Request */
        uint32_t RESERVED0 : 21;       /*!< [30:10]  */
        uint32_t EN : 1;               /*!< [31] Main Trace Enable */
    } B;
} hw_mtb_master_t;

/*!
 * @name Constants and macros for entire MTB_MASTER register
 */
/*@{*/
#define HW_MTB_MASTER_ADDR(x)    ((uint32_t)(x) + 0x4U)

#define HW_MTB_MASTER(x)         (*(__IO hw_mtb_master_t *) HW_MTB_MASTER_ADDR(x))
#define HW_MTB_MASTER_RD(x)      (HW_MTB_MASTER(x).U)
#define HW_MTB_MASTER_WR(x, v)   (HW_MTB_MASTER(x).U = (v))
#define HW_MTB_MASTER_SET(x, v)  (HW_MTB_MASTER_WR(x, HW_MTB_MASTER_RD(x) |  (v)))
#define HW_MTB_MASTER_CLR(x, v)  (HW_MTB_MASTER_WR(x, HW_MTB_MASTER_RD(x) & ~(v)))
#define HW_MTB_MASTER_TOG(x, v)  (HW_MTB_MASTER_WR(x, HW_MTB_MASTER_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MTB_MASTER bitfields
 */

/*!
 * @name Register MTB_MASTER, field MASK[4:0] (RW)
 *
 * This value determines the maximum size of the trace buffer in RAM. It
 * specifies the most-significant bit of the MTB_POSITION[POINTER] field that can be
 * updated by automatic increment. If the trace tries to advance past this power of
 * 2, the MTB_POSITION[WRAP] bit is set to 1, the MTB_POSITION[MASK+3:3] ==
 * MTB_POSITION[POINTER[MASK:0]] bits are set to 0, and the MTB_POSITION[14:MASK+3] ==
 * MTB_POSITION[POINTER[11:MASK+1]] bits remain unchanged. This field causes the
 * trace packet information to be stored in a circular buffer of size 2^[MASK+4]
 * bytes, that can be positioned in memory at multiples of this size. As
 * detailed in the MTB_POSITION description, typical "upper limits" for the MTB size are
 * RAM_Size/4 or RAM_Size/2. Values greater than the maximum have the same
 * effect as the maximum.
 */
/*@{*/
#define BP_MTB_MASTER_MASK   (0U)          /*!< Bit position for MTB_MASTER_MASK. */
#define BM_MTB_MASTER_MASK   (0x0000001FU) /*!< Bit mask for MTB_MASTER_MASK. */
#define BS_MTB_MASTER_MASK   (5U)          /*!< Bit field size in bits for MTB_MASTER_MASK. */

/*! @brief Read current value of the MTB_MASTER_MASK field. */
#define BR_MTB_MASTER_MASK(x) (HW_MTB_MASTER(x).B.MASK)

/*! @brief Format value for bitfield MTB_MASTER_MASK. */
#define BF_MTB_MASTER_MASK(v) ((uint32_t)((uint32_t)(v) << BP_MTB_MASTER_MASK) & BM_MTB_MASTER_MASK)

/*! @brief Set the MASK field to a new value. */
#define BW_MTB_MASTER_MASK(x, v) (HW_MTB_MASTER_WR(x, (HW_MTB_MASTER_RD(x) & ~BM_MTB_MASTER_MASK) | BF_MTB_MASTER_MASK(v)))
/*@}*/

/*!
 * @name Register MTB_MASTER, field TSTARTEN[5] (RW)
 *
 * If this field is 1 and the TSTART signal is HIGH, then EN is set to 1.
 * Tracing continues until a stop condition occurs.
 */
/*@{*/
#define BP_MTB_MASTER_TSTARTEN (5U)        /*!< Bit position for MTB_MASTER_TSTARTEN. */
#define BM_MTB_MASTER_TSTARTEN (0x00000020U) /*!< Bit mask for MTB_MASTER_TSTARTEN. */
#define BS_MTB_MASTER_TSTARTEN (1U)        /*!< Bit field size in bits for MTB_MASTER_TSTARTEN. */

/*! @brief Read current value of the MTB_MASTER_TSTARTEN field. */
#define BR_MTB_MASTER_TSTARTEN(x) (HW_MTB_MASTER(x).B.TSTARTEN)

/*! @brief Format value for bitfield MTB_MASTER_TSTARTEN. */
#define BF_MTB_MASTER_TSTARTEN(v) ((uint32_t)((uint32_t)(v) << BP_MTB_MASTER_TSTARTEN) & BM_MTB_MASTER_TSTARTEN)

/*! @brief Set the TSTARTEN field to a new value. */
#define BW_MTB_MASTER_TSTARTEN(x, v) (HW_MTB_MASTER_WR(x, (HW_MTB_MASTER_RD(x) & ~BM_MTB_MASTER_TSTARTEN) | BF_MTB_MASTER_TSTARTEN(v)))
/*@}*/

/*!
 * @name Register MTB_MASTER, field TSTOPEN[6] (RW)
 *
 * If this field is 1 and the TSTOP signal is HIGH, then EN is set to 0. If a
 * trace packet is being written to memory, the write is completed before tracing
 * is stopped.
 */
/*@{*/
#define BP_MTB_MASTER_TSTOPEN (6U)         /*!< Bit position for MTB_MASTER_TSTOPEN. */
#define BM_MTB_MASTER_TSTOPEN (0x00000040U) /*!< Bit mask for MTB_MASTER_TSTOPEN. */
#define BS_MTB_MASTER_TSTOPEN (1U)         /*!< Bit field size in bits for MTB_MASTER_TSTOPEN. */

/*! @brief Read current value of the MTB_MASTER_TSTOPEN field. */
#define BR_MTB_MASTER_TSTOPEN(x) (HW_MTB_MASTER(x).B.TSTOPEN)

/*! @brief Format value for bitfield MTB_MASTER_TSTOPEN. */
#define BF_MTB_MASTER_TSTOPEN(v) ((uint32_t)((uint32_t)(v) << BP_MTB_MASTER_TSTOPEN) & BM_MTB_MASTER_TSTOPEN)

/*! @brief Set the TSTOPEN field to a new value. */
#define BW_MTB_MASTER_TSTOPEN(x, v) (HW_MTB_MASTER_WR(x, (HW_MTB_MASTER_RD(x) & ~BM_MTB_MASTER_TSTOPEN) | BF_MTB_MASTER_TSTOPEN(v)))
/*@}*/

/*!
 * @name Register MTB_MASTER, field SFRWPRIV[7] (RW)
 *
 * If this field is 0, then user or privileged AHB read and write accesses to
 * the MTB_RAM Special Function Registers (programming model) are permitted. If
 * this field is 1, then only privileged write accesses are permitted; user write
 * accesses are ignored. The HPROT[1] signal determines if an access is user or
 * privileged. Note MTB_RAM SFR read access are not controlled by this bit and are
 * always permitted.
 */
/*@{*/
#define BP_MTB_MASTER_SFRWPRIV (7U)        /*!< Bit position for MTB_MASTER_SFRWPRIV. */
#define BM_MTB_MASTER_SFRWPRIV (0x00000080U) /*!< Bit mask for MTB_MASTER_SFRWPRIV. */
#define BS_MTB_MASTER_SFRWPRIV (1U)        /*!< Bit field size in bits for MTB_MASTER_SFRWPRIV. */

/*! @brief Read current value of the MTB_MASTER_SFRWPRIV field. */
#define BR_MTB_MASTER_SFRWPRIV(x) (HW_MTB_MASTER(x).B.SFRWPRIV)

/*! @brief Format value for bitfield MTB_MASTER_SFRWPRIV. */
#define BF_MTB_MASTER_SFRWPRIV(v) ((uint32_t)((uint32_t)(v) << BP_MTB_MASTER_SFRWPRIV) & BM_MTB_MASTER_SFRWPRIV)

/*! @brief Set the SFRWPRIV field to a new value. */
#define BW_MTB_MASTER_SFRWPRIV(x, v) (HW_MTB_MASTER_WR(x, (HW_MTB_MASTER_RD(x) & ~BM_MTB_MASTER_SFRWPRIV) | BF_MTB_MASTER_SFRWPRIV(v)))
/*@}*/

/*!
 * @name Register MTB_MASTER, field RAMPRIV[8] (RW)
 *
 * If this field is 0, then user or privileged AHB read and write accesses to
 * the RAM are permitted. If this field is 1, then only privileged AHB read and
 * write accesses to the RAM are permitted and user accesses are RAZ/WI. The
 * HPROT[1] signal determines if an access is a user or privileged mode reference.
 */
/*@{*/
#define BP_MTB_MASTER_RAMPRIV (8U)         /*!< Bit position for MTB_MASTER_RAMPRIV. */
#define BM_MTB_MASTER_RAMPRIV (0x00000100U) /*!< Bit mask for MTB_MASTER_RAMPRIV. */
#define BS_MTB_MASTER_RAMPRIV (1U)         /*!< Bit field size in bits for MTB_MASTER_RAMPRIV. */

/*! @brief Read current value of the MTB_MASTER_RAMPRIV field. */
#define BR_MTB_MASTER_RAMPRIV(x) (HW_MTB_MASTER(x).B.RAMPRIV)

/*! @brief Format value for bitfield MTB_MASTER_RAMPRIV. */
#define BF_MTB_MASTER_RAMPRIV(v) ((uint32_t)((uint32_t)(v) << BP_MTB_MASTER_RAMPRIV) & BM_MTB_MASTER_RAMPRIV)

/*! @brief Set the RAMPRIV field to a new value. */
#define BW_MTB_MASTER_RAMPRIV(x, v) (HW_MTB_MASTER_WR(x, (HW_MTB_MASTER_RD(x) & ~BM_MTB_MASTER_RAMPRIV) | BF_MTB_MASTER_RAMPRIV(v)))
/*@}*/

/*!
 * @name Register MTB_MASTER, field HALTREQ[9] (RW)
 *
 * This field is connected to the halt request signal of the trace logic,
 * EDBGRQ. When HALTREQ is set to 1, the EDBFGRQ is asserted if DBGEN (invasive debug
 * enable, one of the debug authentication interface signals) is also HIGH.
 * HALTREQ can be automatically set to 1 using MTB_FLOW[WATERMARK].
 */
/*@{*/
#define BP_MTB_MASTER_HALTREQ (9U)         /*!< Bit position for MTB_MASTER_HALTREQ. */
#define BM_MTB_MASTER_HALTREQ (0x00000200U) /*!< Bit mask for MTB_MASTER_HALTREQ. */
#define BS_MTB_MASTER_HALTREQ (1U)         /*!< Bit field size in bits for MTB_MASTER_HALTREQ. */

/*! @brief Read current value of the MTB_MASTER_HALTREQ field. */
#define BR_MTB_MASTER_HALTREQ(x) (HW_MTB_MASTER(x).B.HALTREQ)

/*! @brief Format value for bitfield MTB_MASTER_HALTREQ. */
#define BF_MTB_MASTER_HALTREQ(v) ((uint32_t)((uint32_t)(v) << BP_MTB_MASTER_HALTREQ) & BM_MTB_MASTER_HALTREQ)

/*! @brief Set the HALTREQ field to a new value. */
#define BW_MTB_MASTER_HALTREQ(x, v) (HW_MTB_MASTER_WR(x, (HW_MTB_MASTER_RD(x) & ~BM_MTB_MASTER_HALTREQ) | BF_MTB_MASTER_HALTREQ(v)))
/*@}*/

/*!
 * @name Register MTB_MASTER, field EN[31] (RW)
 *
 * When this field is 1, trace data is written into the RAM memory location
 * addressed by MTB_POSITION[POINTER]. The MTB_POSITION[POINTER] value auto
 * increments after the trace data packet is written. EN can be automatically set to 0
 * using the MTB_FLOW[WATERMARK] field and the MTB_FLOW[AUTOSTOP] bit. EN is
 * automatically set to 1 if TSTARTEN is 1 and the TSTART signal is HIGH. EN is
 * automatically set to 0 if TSTOPEN is 1 and the TSTOP signal is HIGH. If EN is set to 0
 * because MTB_FLOW[WATERMARK] is set, then it is not automatically set to 1 if
 * TSTARTEN is 1 and the TSTART input is HIGH. In this case, tracing can only be
 * restarted if MTB_FLOW[WATERMARK] or MTB_POSITION[POINTER] value is changed by
 * software.
 */
/*@{*/
#define BP_MTB_MASTER_EN     (31U)         /*!< Bit position for MTB_MASTER_EN. */
#define BM_MTB_MASTER_EN     (0x80000000U) /*!< Bit mask for MTB_MASTER_EN. */
#define BS_MTB_MASTER_EN     (1U)          /*!< Bit field size in bits for MTB_MASTER_EN. */

/*! @brief Read current value of the MTB_MASTER_EN field. */
#define BR_MTB_MASTER_EN(x)  (HW_MTB_MASTER(x).B.EN)

/*! @brief Format value for bitfield MTB_MASTER_EN. */
#define BF_MTB_MASTER_EN(v)  ((uint32_t)((uint32_t)(v) << BP_MTB_MASTER_EN) & BM_MTB_MASTER_EN)

/*! @brief Set the EN field to a new value. */
#define BW_MTB_MASTER_EN(x, v) (HW_MTB_MASTER_WR(x, (HW_MTB_MASTER_RD(x) & ~BM_MTB_MASTER_EN) | BF_MTB_MASTER_EN(v)))
/*@}*/

/*******************************************************************************
 * HW_MTB_FLOW - MTB Flow Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_FLOW - MTB Flow Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTB_FLOW register contains the watermark address and the
 * autostop/autohalt control bits. If tracing is stopped using the watermark autostop feature, it
 * cannot be restarted until software clears the watermark autostop. This can be
 * achieved in one of the following ways: Changing the MTB_POSITION[POINTER]
 * field value to point to the beginning of the trace buffer, or Setting
 * MTB_FLOW[AUTOSTOP] = 0. A debug agent can use MTB_FLOW[AUTOSTOP] to fill the trace buffer
 * once only without halting the processor. A debug agent can use
 * MTB_FLOW[AUTOHALT] to fill the trace buffer once before causing the Cortex-M0+ processor to
 * enter the Debug state. To enter Debug state, the Cortex-M0+ processor might
 * have to perform additional branch type operations. Therefore, the
 * MTB_FLOW[WATERMARK] field must be set below the final entry in the trace buffer region.
 */
typedef union _hw_mtb_flow
{
    uint32_t U;
    struct _hw_mtb_flow_bitfields
    {
        uint32_t AUTOSTOP : 1;         /*!< [0] AUTOSTOP */
        uint32_t AUTOHALT : 1;         /*!< [1] AUTOHALT */
        uint32_t RESERVED0 : 1;        /*!< [2]  */
        uint32_t WATERMARK : 29;       /*!< [31:3] WATERMARK[28:0] */
    } B;
} hw_mtb_flow_t;

/*!
 * @name Constants and macros for entire MTB_FLOW register
 */
/*@{*/
#define HW_MTB_FLOW_ADDR(x)      ((uint32_t)(x) + 0x8U)

#define HW_MTB_FLOW(x)           (*(__IO hw_mtb_flow_t *) HW_MTB_FLOW_ADDR(x))
#define HW_MTB_FLOW_RD(x)        (HW_MTB_FLOW(x).U)
#define HW_MTB_FLOW_WR(x, v)     (HW_MTB_FLOW(x).U = (v))
#define HW_MTB_FLOW_SET(x, v)    (HW_MTB_FLOW_WR(x, HW_MTB_FLOW_RD(x) |  (v)))
#define HW_MTB_FLOW_CLR(x, v)    (HW_MTB_FLOW_WR(x, HW_MTB_FLOW_RD(x) & ~(v)))
#define HW_MTB_FLOW_TOG(x, v)    (HW_MTB_FLOW_WR(x, HW_MTB_FLOW_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MTB_FLOW bitfields
 */

/*!
 * @name Register MTB_FLOW, field AUTOSTOP[0] (RW)
 *
 * If this field is 1 and WATERMARK is equal to MTB_POSITION[POINTER], then
 * MTB_MASTER[EN] is automatically set to 0. This stops tracing.
 */
/*@{*/
#define BP_MTB_FLOW_AUTOSTOP (0U)          /*!< Bit position for MTB_FLOW_AUTOSTOP. */
#define BM_MTB_FLOW_AUTOSTOP (0x00000001U) /*!< Bit mask for MTB_FLOW_AUTOSTOP. */
#define BS_MTB_FLOW_AUTOSTOP (1U)          /*!< Bit field size in bits for MTB_FLOW_AUTOSTOP. */

/*! @brief Read current value of the MTB_FLOW_AUTOSTOP field. */
#define BR_MTB_FLOW_AUTOSTOP(x) (HW_MTB_FLOW(x).B.AUTOSTOP)

/*! @brief Format value for bitfield MTB_FLOW_AUTOSTOP. */
#define BF_MTB_FLOW_AUTOSTOP(v) ((uint32_t)((uint32_t)(v) << BP_MTB_FLOW_AUTOSTOP) & BM_MTB_FLOW_AUTOSTOP)

/*! @brief Set the AUTOSTOP field to a new value. */
#define BW_MTB_FLOW_AUTOSTOP(x, v) (HW_MTB_FLOW_WR(x, (HW_MTB_FLOW_RD(x) & ~BM_MTB_FLOW_AUTOSTOP) | BF_MTB_FLOW_AUTOSTOP(v)))
/*@}*/

/*!
 * @name Register MTB_FLOW, field AUTOHALT[1] (RW)
 *
 * If this field is 1 and WATERMARK is equal to MTB_POSITION[POINTER], then
 * MTB_MASTER[HALTREQ] is automatically set to 1. If the DBGEN signal is HIGH, the
 * MTB asserts this halt request to the Cortex-M0+ processor by asserting the
 * EDBGRQ signal.
 */
/*@{*/
#define BP_MTB_FLOW_AUTOHALT (1U)          /*!< Bit position for MTB_FLOW_AUTOHALT. */
#define BM_MTB_FLOW_AUTOHALT (0x00000002U) /*!< Bit mask for MTB_FLOW_AUTOHALT. */
#define BS_MTB_FLOW_AUTOHALT (1U)          /*!< Bit field size in bits for MTB_FLOW_AUTOHALT. */

/*! @brief Read current value of the MTB_FLOW_AUTOHALT field. */
#define BR_MTB_FLOW_AUTOHALT(x) (HW_MTB_FLOW(x).B.AUTOHALT)

/*! @brief Format value for bitfield MTB_FLOW_AUTOHALT. */
#define BF_MTB_FLOW_AUTOHALT(v) ((uint32_t)((uint32_t)(v) << BP_MTB_FLOW_AUTOHALT) & BM_MTB_FLOW_AUTOHALT)

/*! @brief Set the AUTOHALT field to a new value. */
#define BW_MTB_FLOW_AUTOHALT(x, v) (HW_MTB_FLOW_WR(x, (HW_MTB_FLOW_RD(x) & ~BM_MTB_FLOW_AUTOHALT) | BF_MTB_FLOW_AUTOHALT(v)))
/*@}*/

/*!
 * @name Register MTB_FLOW, field WATERMARK[31:3] (RW)
 *
 * This field contains an address in the same format as the
 * MTB_POSITION[POINTER] field. When MTB_POSITION[POINTER] matches the WATERMARK field value, actions
 * defined by the AUTOHALT and AUTOSTOP bits are performed.
 */
/*@{*/
#define BP_MTB_FLOW_WATERMARK (3U)         /*!< Bit position for MTB_FLOW_WATERMARK. */
#define BM_MTB_FLOW_WATERMARK (0xFFFFFFF8U) /*!< Bit mask for MTB_FLOW_WATERMARK. */
#define BS_MTB_FLOW_WATERMARK (29U)        /*!< Bit field size in bits for MTB_FLOW_WATERMARK. */

/*! @brief Read current value of the MTB_FLOW_WATERMARK field. */
#define BR_MTB_FLOW_WATERMARK(x) (HW_MTB_FLOW(x).B.WATERMARK)

/*! @brief Format value for bitfield MTB_FLOW_WATERMARK. */
#define BF_MTB_FLOW_WATERMARK(v) ((uint32_t)((uint32_t)(v) << BP_MTB_FLOW_WATERMARK) & BM_MTB_FLOW_WATERMARK)

/*! @brief Set the WATERMARK field to a new value. */
#define BW_MTB_FLOW_WATERMARK(x, v) (HW_MTB_FLOW_WR(x, (HW_MTB_FLOW_RD(x) & ~BM_MTB_FLOW_WATERMARK) | BF_MTB_FLOW_WATERMARK(v)))
/*@}*/

/*******************************************************************************
 * HW_MTB_BASE - MTB Base Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_BASE - MTB Base Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The read-only MTB_BASE Register indicates where the RAM is located in the
 * system memory map. This register is provided to enable auto discovery of the MTB
 * RAM location, by a debug agent and is defined by a hardware design parameter.
 * For this device, the base address is defined by the expression:
 * MTB_BASE[BASEADDR] = 0x2000_0000 - (RAM_Size/4)
 */
typedef union _hw_mtb_base
{
    uint32_t U;
    struct _hw_mtb_base_bitfields
    {
        uint32_t BASEADDR : 32;        /*!< [31:0] BASEADDR */
    } B;
} hw_mtb_base_t;

/*!
 * @name Constants and macros for entire MTB_BASE register
 */
/*@{*/
#define HW_MTB_BASE_ADDR(x)      ((uint32_t)(x) + 0xCU)

#define HW_MTB_BASE(x)           (*(__I hw_mtb_base_t *) HW_MTB_BASE_ADDR(x))
#define HW_MTB_BASE_RD(x)        (HW_MTB_BASE(x).U)
/*@}*/

/*
 * Constants & macros for individual MTB_BASE bitfields
 */

/*!
 * @name Register MTB_BASE, field BASEADDR[31:0] (RO)
 *
 * This value is defined with a hardwired signal and the expression: 0x2000_0000
 * - (RAM_Size/4). For example, if the total RAM capacity is 16 KB, this field
 * is 0x1FFF_F000.
 */
/*@{*/
#define BP_MTB_BASE_BASEADDR (0U)          /*!< Bit position for MTB_BASE_BASEADDR. */
#define BM_MTB_BASE_BASEADDR (0xFFFFFFFFU) /*!< Bit mask for MTB_BASE_BASEADDR. */
#define BS_MTB_BASE_BASEADDR (32U)         /*!< Bit field size in bits for MTB_BASE_BASEADDR. */

/*! @brief Read current value of the MTB_BASE_BASEADDR field. */
#define BR_MTB_BASE_BASEADDR(x) (HW_MTB_BASE(x).U)
/*@}*/

/*******************************************************************************
 * HW_MTB_MODECTRL - Integration Mode Control Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_MODECTRL - Integration Mode Control Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register enables the device to switch from a functional mode, or default
 * behavior, into integration mode. It is hardwired to specific values used
 * during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtb_modectrl
{
    uint32_t U;
    struct _hw_mtb_modectrl_bitfields
    {
        uint32_t MODECTRL : 32;        /*!< [31:0] MODECTRL */
    } B;
} hw_mtb_modectrl_t;

/*!
 * @name Constants and macros for entire MTB_MODECTRL register
 */
/*@{*/
#define HW_MTB_MODECTRL_ADDR(x)  ((uint32_t)(x) + 0xF00U)

#define HW_MTB_MODECTRL(x)       (*(__I hw_mtb_modectrl_t *) HW_MTB_MODECTRL_ADDR(x))
#define HW_MTB_MODECTRL_RD(x)    (HW_MTB_MODECTRL(x).U)
/*@}*/

/*
 * Constants & macros for individual MTB_MODECTRL bitfields
 */

/*!
 * @name Register MTB_MODECTRL, field MODECTRL[31:0] (RO)
 *
 * Hardwired to 0x0000_0000
 */
/*@{*/
#define BP_MTB_MODECTRL_MODECTRL (0U)      /*!< Bit position for MTB_MODECTRL_MODECTRL. */
#define BM_MTB_MODECTRL_MODECTRL (0xFFFFFFFFU) /*!< Bit mask for MTB_MODECTRL_MODECTRL. */
#define BS_MTB_MODECTRL_MODECTRL (32U)     /*!< Bit field size in bits for MTB_MODECTRL_MODECTRL. */

/*! @brief Read current value of the MTB_MODECTRL_MODECTRL field. */
#define BR_MTB_MODECTRL_MODECTRL(x) (HW_MTB_MODECTRL(x).U)
/*@}*/

/*******************************************************************************
 * HW_MTB_TAGSET - Claim TAG Set Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_TAGSET - Claim TAG Set Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Claim Tag Set Register returns the number of bits that can be set on a
 * read, and enables individual bits to be set on a write. It is hardwired to
 * specific values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtb_tagset
{
    uint32_t U;
    struct _hw_mtb_tagset_bitfields
    {
        uint32_t TAGSET : 32;          /*!< [31:0] TAGSET */
    } B;
} hw_mtb_tagset_t;

/*!
 * @name Constants and macros for entire MTB_TAGSET register
 */
/*@{*/
#define HW_MTB_TAGSET_ADDR(x)    ((uint32_t)(x) + 0xFA0U)

#define HW_MTB_TAGSET(x)         (*(__I hw_mtb_tagset_t *) HW_MTB_TAGSET_ADDR(x))
#define HW_MTB_TAGSET_RD(x)      (HW_MTB_TAGSET(x).U)
/*@}*/

/*
 * Constants & macros for individual MTB_TAGSET bitfields
 */

/*!
 * @name Register MTB_TAGSET, field TAGSET[31:0] (RO)
 *
 * Hardwired to 0x0000_0000
 */
/*@{*/
#define BP_MTB_TAGSET_TAGSET (0U)          /*!< Bit position for MTB_TAGSET_TAGSET. */
#define BM_MTB_TAGSET_TAGSET (0xFFFFFFFFU) /*!< Bit mask for MTB_TAGSET_TAGSET. */
#define BS_MTB_TAGSET_TAGSET (32U)         /*!< Bit field size in bits for MTB_TAGSET_TAGSET. */

/*! @brief Read current value of the MTB_TAGSET_TAGSET field. */
#define BR_MTB_TAGSET_TAGSET(x) (HW_MTB_TAGSET(x).U)
/*@}*/

/*******************************************************************************
 * HW_MTB_TAGCLEAR - Claim TAG Clear Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_TAGCLEAR - Claim TAG Clear Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The read/write Claim Tag Clear Register is used to read the claim status on
 * debug resources. A read indicates the claim tag status. Writing 1 to a specific
 * bit clears the corresponding claim tag to 0. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtb_tagclear
{
    uint32_t U;
    struct _hw_mtb_tagclear_bitfields
    {
        uint32_t TAGCLEAR : 32;        /*!< [31:0] TAGCLEAR */
    } B;
} hw_mtb_tagclear_t;

/*!
 * @name Constants and macros for entire MTB_TAGCLEAR register
 */
/*@{*/
#define HW_MTB_TAGCLEAR_ADDR(x)  ((uint32_t)(x) + 0xFA4U)

#define HW_MTB_TAGCLEAR(x)       (*(__I hw_mtb_tagclear_t *) HW_MTB_TAGCLEAR_ADDR(x))
#define HW_MTB_TAGCLEAR_RD(x)    (HW_MTB_TAGCLEAR(x).U)
/*@}*/

/*
 * Constants & macros for individual MTB_TAGCLEAR bitfields
 */

/*!
 * @name Register MTB_TAGCLEAR, field TAGCLEAR[31:0] (RO)
 *
 * Hardwired to 0x0000_0000
 */
/*@{*/
#define BP_MTB_TAGCLEAR_TAGCLEAR (0U)      /*!< Bit position for MTB_TAGCLEAR_TAGCLEAR. */
#define BM_MTB_TAGCLEAR_TAGCLEAR (0xFFFFFFFFU) /*!< Bit mask for MTB_TAGCLEAR_TAGCLEAR. */
#define BS_MTB_TAGCLEAR_TAGCLEAR (32U)     /*!< Bit field size in bits for MTB_TAGCLEAR_TAGCLEAR. */

/*! @brief Read current value of the MTB_TAGCLEAR_TAGCLEAR field. */
#define BR_MTB_TAGCLEAR_TAGCLEAR(x) (HW_MTB_TAGCLEAR(x).U)
/*@}*/

/*******************************************************************************
 * HW_MTB_LOCKACCESS - Lock Access Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_LOCKACCESS - Lock Access Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Lock Access Register enables a write access to component registers. It is
 * hardwired to specific values used during the auto-discovery process by an
 * external debug agent.
 */
typedef union _hw_mtb_lockaccess
{
    uint32_t U;
    struct _hw_mtb_lockaccess_bitfields
    {
        uint32_t LOCKACCESS : 32;      /*!< [31:0]  */
    } B;
} hw_mtb_lockaccess_t;

/*!
 * @name Constants and macros for entire MTB_LOCKACCESS register
 */
/*@{*/
#define HW_MTB_LOCKACCESS_ADDR(x) ((uint32_t)(x) + 0xFB0U)

#define HW_MTB_LOCKACCESS(x)     (*(__I hw_mtb_lockaccess_t *) HW_MTB_LOCKACCESS_ADDR(x))
#define HW_MTB_LOCKACCESS_RD(x)  (HW_MTB_LOCKACCESS(x).U)
/*@}*/

/*
 * Constants & macros for individual MTB_LOCKACCESS bitfields
 */

/*!
 * @name Register MTB_LOCKACCESS, field LOCKACCESS[31:0] (RO)
 *
 * Hardwired to 0x0000_0000
 */
/*@{*/
#define BP_MTB_LOCKACCESS_LOCKACCESS (0U)  /*!< Bit position for MTB_LOCKACCESS_LOCKACCESS. */
#define BM_MTB_LOCKACCESS_LOCKACCESS (0xFFFFFFFFU) /*!< Bit mask for MTB_LOCKACCESS_LOCKACCESS. */
#define BS_MTB_LOCKACCESS_LOCKACCESS (32U) /*!< Bit field size in bits for MTB_LOCKACCESS_LOCKACCESS. */

/*! @brief Read current value of the MTB_LOCKACCESS_LOCKACCESS field. */
#define BR_MTB_LOCKACCESS_LOCKACCESS(x) (HW_MTB_LOCKACCESS(x).U)
/*@}*/

/*******************************************************************************
 * HW_MTB_LOCKSTAT - Lock Status Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_LOCKSTAT - Lock Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Lock Status Register indicates the status of the lock control mechanism.
 * This register is used in conjunction with the Lock Access Register. It is
 * hardwired to specific values used during the auto-discovery process by an external
 * debug agent.
 */
typedef union _hw_mtb_lockstat
{
    uint32_t U;
    struct _hw_mtb_lockstat_bitfields
    {
        uint32_t LOCKSTAT : 32;        /*!< [31:0] LOCKSTAT */
    } B;
} hw_mtb_lockstat_t;

/*!
 * @name Constants and macros for entire MTB_LOCKSTAT register
 */
/*@{*/
#define HW_MTB_LOCKSTAT_ADDR(x)  ((uint32_t)(x) + 0xFB4U)

#define HW_MTB_LOCKSTAT(x)       (*(__I hw_mtb_lockstat_t *) HW_MTB_LOCKSTAT_ADDR(x))
#define HW_MTB_LOCKSTAT_RD(x)    (HW_MTB_LOCKSTAT(x).U)
/*@}*/

/*
 * Constants & macros for individual MTB_LOCKSTAT bitfields
 */

/*!
 * @name Register MTB_LOCKSTAT, field LOCKSTAT[31:0] (RO)
 *
 * Hardwired to 0x0000_0000
 */
/*@{*/
#define BP_MTB_LOCKSTAT_LOCKSTAT (0U)      /*!< Bit position for MTB_LOCKSTAT_LOCKSTAT. */
#define BM_MTB_LOCKSTAT_LOCKSTAT (0xFFFFFFFFU) /*!< Bit mask for MTB_LOCKSTAT_LOCKSTAT. */
#define BS_MTB_LOCKSTAT_LOCKSTAT (32U)     /*!< Bit field size in bits for MTB_LOCKSTAT_LOCKSTAT. */

/*! @brief Read current value of the MTB_LOCKSTAT_LOCKSTAT field. */
#define BR_MTB_LOCKSTAT_LOCKSTAT(x) (HW_MTB_LOCKSTAT(x).U)
/*@}*/

/*******************************************************************************
 * HW_MTB_AUTHSTAT - Authentication Status Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_AUTHSTAT - Authentication Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Authentication Status Register reports the required security level and
 * current status of the security enable bit pairs. Where functionality changes on
 * a given security level, this change must be reported in this register. It is
 * connected to specific signals used during the auto-discovery process by an
 * external debug agent. MTB_AUTHSTAT[3:2] indicates if nonsecure, noninvasive debug
 * is enabled or disabled, while MTB_AUTHSTAT[1:0] indicates the enabled/disabled
 * state of nonsecure, invasive debug. For both 2-bit fields, 0b10 indicates the
 * functionality is disabled and 0b11 indicates it is enabled.
 */
typedef union _hw_mtb_authstat
{
    uint32_t U;
    struct _hw_mtb_authstat_bitfields
    {
        uint32_t BIT0 : 1;             /*!< [0]  */
        uint32_t BIT1 : 1;             /*!< [1] BIT1 */
        uint32_t BIT2 : 1;             /*!< [2] BIT2 */
        uint32_t BIT3 : 1;             /*!< [3] BIT3 */
        uint32_t RESERVED0 : 28;       /*!< [31:4]  */
    } B;
} hw_mtb_authstat_t;

/*!
 * @name Constants and macros for entire MTB_AUTHSTAT register
 */
/*@{*/
#define HW_MTB_AUTHSTAT_ADDR(x)  ((uint32_t)(x) + 0xFB8U)

#define HW_MTB_AUTHSTAT(x)       (*(__I hw_mtb_authstat_t *) HW_MTB_AUTHSTAT_ADDR(x))
#define HW_MTB_AUTHSTAT_RD(x)    (HW_MTB_AUTHSTAT(x).U)
/*@}*/

/*
 * Constants & macros for individual MTB_AUTHSTAT bitfields
 */

/*!
 * @name Register MTB_AUTHSTAT, field BIT0[0] (RO)
 *
 * Connected to DBGEN.
 */
/*@{*/
#define BP_MTB_AUTHSTAT_BIT0 (0U)          /*!< Bit position for MTB_AUTHSTAT_BIT0. */
#define BM_MTB_AUTHSTAT_BIT0 (0x00000001U) /*!< Bit mask for MTB_AUTHSTAT_BIT0. */
#define BS_MTB_AUTHSTAT_BIT0 (1U)          /*!< Bit field size in bits for MTB_AUTHSTAT_BIT0. */

/*! @brief Read current value of the MTB_AUTHSTAT_BIT0 field. */
#define BR_MTB_AUTHSTAT_BIT0(x) (HW_MTB_AUTHSTAT(x).B.BIT0)
/*@}*/

/*!
 * @name Register MTB_AUTHSTAT, field BIT1[1] (ROO)
 *
 * Hardwired to 1.
 */
/*@{*/
#define BP_MTB_AUTHSTAT_BIT1 (1U)          /*!< Bit position for MTB_AUTHSTAT_BIT1. */
#define BM_MTB_AUTHSTAT_BIT1 (0x00000002U) /*!< Bit mask for MTB_AUTHSTAT_BIT1. */
#define BS_MTB_AUTHSTAT_BIT1 (1U)          /*!< Bit field size in bits for MTB_AUTHSTAT_BIT1. */

/*! @brief Read current value of the MTB_AUTHSTAT_BIT1 field. */
#define BR_MTB_AUTHSTAT_BIT1(x) (HW_MTB_AUTHSTAT(x).B.BIT1)
/*@}*/

/*!
 * @name Register MTB_AUTHSTAT, field BIT2[2] (RO)
 *
 * Connected to NIDEN or DBGEN signal.
 */
/*@{*/
#define BP_MTB_AUTHSTAT_BIT2 (2U)          /*!< Bit position for MTB_AUTHSTAT_BIT2. */
#define BM_MTB_AUTHSTAT_BIT2 (0x00000004U) /*!< Bit mask for MTB_AUTHSTAT_BIT2. */
#define BS_MTB_AUTHSTAT_BIT2 (1U)          /*!< Bit field size in bits for MTB_AUTHSTAT_BIT2. */

/*! @brief Read current value of the MTB_AUTHSTAT_BIT2 field. */
#define BR_MTB_AUTHSTAT_BIT2(x) (HW_MTB_AUTHSTAT(x).B.BIT2)
/*@}*/

/*!
 * @name Register MTB_AUTHSTAT, field BIT3[3] (ROO)
 *
 * Hardwired to 1.
 */
/*@{*/
#define BP_MTB_AUTHSTAT_BIT3 (3U)          /*!< Bit position for MTB_AUTHSTAT_BIT3. */
#define BM_MTB_AUTHSTAT_BIT3 (0x00000008U) /*!< Bit mask for MTB_AUTHSTAT_BIT3. */
#define BS_MTB_AUTHSTAT_BIT3 (1U)          /*!< Bit field size in bits for MTB_AUTHSTAT_BIT3. */

/*! @brief Read current value of the MTB_AUTHSTAT_BIT3 field. */
#define BR_MTB_AUTHSTAT_BIT3(x) (HW_MTB_AUTHSTAT(x).B.BIT3)
/*@}*/

/*******************************************************************************
 * HW_MTB_DEVICEARCH - Device Architecture Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_DEVICEARCH - Device Architecture Register (RO)
 *
 * Reset value: 0x47700A31U
 *
 * This register indicates the device architecture. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtb_devicearch
{
    uint32_t U;
    struct _hw_mtb_devicearch_bitfields
    {
        uint32_t DEVICEARCH : 32;      /*!< [31:0] DEVICEARCH */
    } B;
} hw_mtb_devicearch_t;

/*!
 * @name Constants and macros for entire MTB_DEVICEARCH register
 */
/*@{*/
#define HW_MTB_DEVICEARCH_ADDR(x) ((uint32_t)(x) + 0xFBCU)

#define HW_MTB_DEVICEARCH(x)     (*(__I hw_mtb_devicearch_t *) HW_MTB_DEVICEARCH_ADDR(x))
#define HW_MTB_DEVICEARCH_RD(x)  (HW_MTB_DEVICEARCH(x).U)
/*@}*/

/*
 * Constants & macros for individual MTB_DEVICEARCH bitfields
 */

/*!
 * @name Register MTB_DEVICEARCH, field DEVICEARCH[31:0] (RO)
 *
 * Hardwired to 0x4770_0A31.
 */
/*@{*/
#define BP_MTB_DEVICEARCH_DEVICEARCH (0U)  /*!< Bit position for MTB_DEVICEARCH_DEVICEARCH. */
#define BM_MTB_DEVICEARCH_DEVICEARCH (0xFFFFFFFFU) /*!< Bit mask for MTB_DEVICEARCH_DEVICEARCH. */
#define BS_MTB_DEVICEARCH_DEVICEARCH (32U) /*!< Bit field size in bits for MTB_DEVICEARCH_DEVICEARCH. */

/*! @brief Read current value of the MTB_DEVICEARCH_DEVICEARCH field. */
#define BR_MTB_DEVICEARCH_DEVICEARCH(x) (HW_MTB_DEVICEARCH(x).U)
/*@}*/

/*******************************************************************************
 * HW_MTB_DEVICECFG - Device Configuration Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_DEVICECFG - Device Configuration Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register indicates the device configuration. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtb_devicecfg
{
    uint32_t U;
    struct _hw_mtb_devicecfg_bitfields
    {
        uint32_t DEVICECFG : 32;       /*!< [31:0] DEVICECFG */
    } B;
} hw_mtb_devicecfg_t;

/*!
 * @name Constants and macros for entire MTB_DEVICECFG register
 */
/*@{*/
#define HW_MTB_DEVICECFG_ADDR(x) ((uint32_t)(x) + 0xFC8U)

#define HW_MTB_DEVICECFG(x)      (*(__I hw_mtb_devicecfg_t *) HW_MTB_DEVICECFG_ADDR(x))
#define HW_MTB_DEVICECFG_RD(x)   (HW_MTB_DEVICECFG(x).U)
/*@}*/

/*
 * Constants & macros for individual MTB_DEVICECFG bitfields
 */

/*!
 * @name Register MTB_DEVICECFG, field DEVICECFG[31:0] (RO)
 *
 * Hardwired to 0x0000_0000.
 */
/*@{*/
#define BP_MTB_DEVICECFG_DEVICECFG (0U)    /*!< Bit position for MTB_DEVICECFG_DEVICECFG. */
#define BM_MTB_DEVICECFG_DEVICECFG (0xFFFFFFFFU) /*!< Bit mask for MTB_DEVICECFG_DEVICECFG. */
#define BS_MTB_DEVICECFG_DEVICECFG (32U)   /*!< Bit field size in bits for MTB_DEVICECFG_DEVICECFG. */

/*! @brief Read current value of the MTB_DEVICECFG_DEVICECFG field. */
#define BR_MTB_DEVICECFG_DEVICECFG(x) (HW_MTB_DEVICECFG(x).U)
/*@}*/

/*******************************************************************************
 * HW_MTB_DEVICETYPID - Device Type Identifier Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_DEVICETYPID - Device Type Identifier Register (RO)
 *
 * Reset value: 0x00000031U
 *
 * This register indicates the device type ID. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtb_devicetypid
{
    uint32_t U;
    struct _hw_mtb_devicetypid_bitfields
    {
        uint32_t DEVICETYPID : 32;     /*!< [31:0] DEVICETYPID */
    } B;
} hw_mtb_devicetypid_t;

/*!
 * @name Constants and macros for entire MTB_DEVICETYPID register
 */
/*@{*/
#define HW_MTB_DEVICETYPID_ADDR(x) ((uint32_t)(x) + 0xFCCU)

#define HW_MTB_DEVICETYPID(x)    (*(__I hw_mtb_devicetypid_t *) HW_MTB_DEVICETYPID_ADDR(x))
#define HW_MTB_DEVICETYPID_RD(x) (HW_MTB_DEVICETYPID(x).U)
/*@}*/

/*
 * Constants & macros for individual MTB_DEVICETYPID bitfields
 */

/*!
 * @name Register MTB_DEVICETYPID, field DEVICETYPID[31:0] (RO)
 *
 * Hardwired to 0x0000_0031.
 */
/*@{*/
#define BP_MTB_DEVICETYPID_DEVICETYPID (0U) /*!< Bit position for MTB_DEVICETYPID_DEVICETYPID. */
#define BM_MTB_DEVICETYPID_DEVICETYPID (0xFFFFFFFFU) /*!< Bit mask for MTB_DEVICETYPID_DEVICETYPID. */
#define BS_MTB_DEVICETYPID_DEVICETYPID (32U) /*!< Bit field size in bits for MTB_DEVICETYPID_DEVICETYPID. */

/*! @brief Read current value of the MTB_DEVICETYPID_DEVICETYPID field. */
#define BR_MTB_DEVICETYPID_DEVICETYPID(x) (HW_MTB_DEVICETYPID(x).U)
/*@}*/

/*******************************************************************************
 * HW_MTB_PERIPHID4 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_PERIPHID4 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtb_periphid4
{
    uint32_t U;
    struct _hw_mtb_periphid4_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_mtb_periphid4_t;

/*!
 * @name Constants and macros for entire MTB_PERIPHID4 register
 */
/*@{*/
#define HW_MTB_PERIPHID4_ADDR(x) ((uint32_t)(x) + 0xFD0U)

#define HW_MTB_PERIPHID4(x)      (*(__I hw_mtb_periphid4_t *) HW_MTB_PERIPHID4_ADDR(x))
#define HW_MTB_PERIPHID4_RD(x)   (HW_MTB_PERIPHID4(x).U)
/*@}*/

/*
 * Constants & macros for individual MTB_PERIPHID4 bitfields
 */

/*!
 * @name Register MTB_PERIPHID4, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID4 is hardwired to 0x0000_0004; ID0 to 0x0000_0032; ID1 to
 * 0x0000_00B9; ID2 to 0x0000_001B; and all the others to 0x0000_0000.
 */
/*@{*/
#define BP_MTB_PERIPHID4_PERIPHID (0U)     /*!< Bit position for MTB_PERIPHID4_PERIPHID. */
#define BM_MTB_PERIPHID4_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for MTB_PERIPHID4_PERIPHID. */
#define BS_MTB_PERIPHID4_PERIPHID (32U)    /*!< Bit field size in bits for MTB_PERIPHID4_PERIPHID. */

/*! @brief Read current value of the MTB_PERIPHID4_PERIPHID field. */
#define BR_MTB_PERIPHID4_PERIPHID(x) (HW_MTB_PERIPHID4(x).U)
/*@}*/
/*******************************************************************************
 * HW_MTB_PERIPHID5 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_PERIPHID5 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtb_periphid5
{
    uint32_t U;
    struct _hw_mtb_periphid5_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_mtb_periphid5_t;

/*!
 * @name Constants and macros for entire MTB_PERIPHID5 register
 */
/*@{*/
#define HW_MTB_PERIPHID5_ADDR(x) ((uint32_t)(x) + 0xFD4U)

#define HW_MTB_PERIPHID5(x)      (*(__I hw_mtb_periphid5_t *) HW_MTB_PERIPHID5_ADDR(x))
#define HW_MTB_PERIPHID5_RD(x)   (HW_MTB_PERIPHID5(x).U)
/*@}*/

/*
 * Constants & macros for individual MTB_PERIPHID5 bitfields
 */

/*!
 * @name Register MTB_PERIPHID5, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID4 is hardwired to 0x0000_0004; ID0 to 0x0000_0032; ID1 to
 * 0x0000_00B9; ID2 to 0x0000_001B; and all the others to 0x0000_0000.
 */
/*@{*/
#define BP_MTB_PERIPHID5_PERIPHID (0U)     /*!< Bit position for MTB_PERIPHID5_PERIPHID. */
#define BM_MTB_PERIPHID5_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for MTB_PERIPHID5_PERIPHID. */
#define BS_MTB_PERIPHID5_PERIPHID (32U)    /*!< Bit field size in bits for MTB_PERIPHID5_PERIPHID. */

/*! @brief Read current value of the MTB_PERIPHID5_PERIPHID field. */
#define BR_MTB_PERIPHID5_PERIPHID(x) (HW_MTB_PERIPHID5(x).U)
/*@}*/
/*******************************************************************************
 * HW_MTB_PERIPHID6 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_PERIPHID6 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtb_periphid6
{
    uint32_t U;
    struct _hw_mtb_periphid6_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_mtb_periphid6_t;

/*!
 * @name Constants and macros for entire MTB_PERIPHID6 register
 */
/*@{*/
#define HW_MTB_PERIPHID6_ADDR(x) ((uint32_t)(x) + 0xFD8U)

#define HW_MTB_PERIPHID6(x)      (*(__I hw_mtb_periphid6_t *) HW_MTB_PERIPHID6_ADDR(x))
#define HW_MTB_PERIPHID6_RD(x)   (HW_MTB_PERIPHID6(x).U)
/*@}*/

/*
 * Constants & macros for individual MTB_PERIPHID6 bitfields
 */

/*!
 * @name Register MTB_PERIPHID6, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID4 is hardwired to 0x0000_0004; ID0 to 0x0000_0032; ID1 to
 * 0x0000_00B9; ID2 to 0x0000_001B; and all the others to 0x0000_0000.
 */
/*@{*/
#define BP_MTB_PERIPHID6_PERIPHID (0U)     /*!< Bit position for MTB_PERIPHID6_PERIPHID. */
#define BM_MTB_PERIPHID6_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for MTB_PERIPHID6_PERIPHID. */
#define BS_MTB_PERIPHID6_PERIPHID (32U)    /*!< Bit field size in bits for MTB_PERIPHID6_PERIPHID. */

/*! @brief Read current value of the MTB_PERIPHID6_PERIPHID field. */
#define BR_MTB_PERIPHID6_PERIPHID(x) (HW_MTB_PERIPHID6(x).U)
/*@}*/
/*******************************************************************************
 * HW_MTB_PERIPHID7 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_PERIPHID7 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtb_periphid7
{
    uint32_t U;
    struct _hw_mtb_periphid7_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_mtb_periphid7_t;

/*!
 * @name Constants and macros for entire MTB_PERIPHID7 register
 */
/*@{*/
#define HW_MTB_PERIPHID7_ADDR(x) ((uint32_t)(x) + 0xFDCU)

#define HW_MTB_PERIPHID7(x)      (*(__I hw_mtb_periphid7_t *) HW_MTB_PERIPHID7_ADDR(x))
#define HW_MTB_PERIPHID7_RD(x)   (HW_MTB_PERIPHID7(x).U)
/*@}*/

/*
 * Constants & macros for individual MTB_PERIPHID7 bitfields
 */

/*!
 * @name Register MTB_PERIPHID7, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID4 is hardwired to 0x0000_0004; ID0 to 0x0000_0032; ID1 to
 * 0x0000_00B9; ID2 to 0x0000_001B; and all the others to 0x0000_0000.
 */
/*@{*/
#define BP_MTB_PERIPHID7_PERIPHID (0U)     /*!< Bit position for MTB_PERIPHID7_PERIPHID. */
#define BM_MTB_PERIPHID7_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for MTB_PERIPHID7_PERIPHID. */
#define BS_MTB_PERIPHID7_PERIPHID (32U)    /*!< Bit field size in bits for MTB_PERIPHID7_PERIPHID. */

/*! @brief Read current value of the MTB_PERIPHID7_PERIPHID field. */
#define BR_MTB_PERIPHID7_PERIPHID(x) (HW_MTB_PERIPHID7(x).U)
/*@}*/
/*******************************************************************************
 * HW_MTB_PERIPHID0 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_PERIPHID0 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtb_periphid0
{
    uint32_t U;
    struct _hw_mtb_periphid0_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_mtb_periphid0_t;

/*!
 * @name Constants and macros for entire MTB_PERIPHID0 register
 */
/*@{*/
#define HW_MTB_PERIPHID0_ADDR(x) ((uint32_t)(x) + 0xFE0U)

#define HW_MTB_PERIPHID0(x)      (*(__I hw_mtb_periphid0_t *) HW_MTB_PERIPHID0_ADDR(x))
#define HW_MTB_PERIPHID0_RD(x)   (HW_MTB_PERIPHID0(x).U)
/*@}*/

/*
 * Constants & macros for individual MTB_PERIPHID0 bitfields
 */

/*!
 * @name Register MTB_PERIPHID0, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID4 is hardwired to 0x0000_0004; ID0 to 0x0000_0032; ID1 to
 * 0x0000_00B9; ID2 to 0x0000_001B; and all the others to 0x0000_0000.
 */
/*@{*/
#define BP_MTB_PERIPHID0_PERIPHID (0U)     /*!< Bit position for MTB_PERIPHID0_PERIPHID. */
#define BM_MTB_PERIPHID0_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for MTB_PERIPHID0_PERIPHID. */
#define BS_MTB_PERIPHID0_PERIPHID (32U)    /*!< Bit field size in bits for MTB_PERIPHID0_PERIPHID. */

/*! @brief Read current value of the MTB_PERIPHID0_PERIPHID field. */
#define BR_MTB_PERIPHID0_PERIPHID(x) (HW_MTB_PERIPHID0(x).U)
/*@}*/
/*******************************************************************************
 * HW_MTB_PERIPHID1 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_PERIPHID1 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtb_periphid1
{
    uint32_t U;
    struct _hw_mtb_periphid1_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_mtb_periphid1_t;

/*!
 * @name Constants and macros for entire MTB_PERIPHID1 register
 */
/*@{*/
#define HW_MTB_PERIPHID1_ADDR(x) ((uint32_t)(x) + 0xFE4U)

#define HW_MTB_PERIPHID1(x)      (*(__I hw_mtb_periphid1_t *) HW_MTB_PERIPHID1_ADDR(x))
#define HW_MTB_PERIPHID1_RD(x)   (HW_MTB_PERIPHID1(x).U)
/*@}*/

/*
 * Constants & macros for individual MTB_PERIPHID1 bitfields
 */

/*!
 * @name Register MTB_PERIPHID1, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID4 is hardwired to 0x0000_0004; ID0 to 0x0000_0032; ID1 to
 * 0x0000_00B9; ID2 to 0x0000_001B; and all the others to 0x0000_0000.
 */
/*@{*/
#define BP_MTB_PERIPHID1_PERIPHID (0U)     /*!< Bit position for MTB_PERIPHID1_PERIPHID. */
#define BM_MTB_PERIPHID1_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for MTB_PERIPHID1_PERIPHID. */
#define BS_MTB_PERIPHID1_PERIPHID (32U)    /*!< Bit field size in bits for MTB_PERIPHID1_PERIPHID. */

/*! @brief Read current value of the MTB_PERIPHID1_PERIPHID field. */
#define BR_MTB_PERIPHID1_PERIPHID(x) (HW_MTB_PERIPHID1(x).U)
/*@}*/
/*******************************************************************************
 * HW_MTB_PERIPHID2 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_PERIPHID2 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtb_periphid2
{
    uint32_t U;
    struct _hw_mtb_periphid2_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_mtb_periphid2_t;

/*!
 * @name Constants and macros for entire MTB_PERIPHID2 register
 */
/*@{*/
#define HW_MTB_PERIPHID2_ADDR(x) ((uint32_t)(x) + 0xFE8U)

#define HW_MTB_PERIPHID2(x)      (*(__I hw_mtb_periphid2_t *) HW_MTB_PERIPHID2_ADDR(x))
#define HW_MTB_PERIPHID2_RD(x)   (HW_MTB_PERIPHID2(x).U)
/*@}*/

/*
 * Constants & macros for individual MTB_PERIPHID2 bitfields
 */

/*!
 * @name Register MTB_PERIPHID2, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID4 is hardwired to 0x0000_0004; ID0 to 0x0000_0032; ID1 to
 * 0x0000_00B9; ID2 to 0x0000_001B; and all the others to 0x0000_0000.
 */
/*@{*/
#define BP_MTB_PERIPHID2_PERIPHID (0U)     /*!< Bit position for MTB_PERIPHID2_PERIPHID. */
#define BM_MTB_PERIPHID2_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for MTB_PERIPHID2_PERIPHID. */
#define BS_MTB_PERIPHID2_PERIPHID (32U)    /*!< Bit field size in bits for MTB_PERIPHID2_PERIPHID. */

/*! @brief Read current value of the MTB_PERIPHID2_PERIPHID field. */
#define BR_MTB_PERIPHID2_PERIPHID(x) (HW_MTB_PERIPHID2(x).U)
/*@}*/
/*******************************************************************************
 * HW_MTB_PERIPHID3 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_PERIPHID3 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtb_periphid3
{
    uint32_t U;
    struct _hw_mtb_periphid3_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_mtb_periphid3_t;

/*!
 * @name Constants and macros for entire MTB_PERIPHID3 register
 */
/*@{*/
#define HW_MTB_PERIPHID3_ADDR(x) ((uint32_t)(x) + 0xFECU)

#define HW_MTB_PERIPHID3(x)      (*(__I hw_mtb_periphid3_t *) HW_MTB_PERIPHID3_ADDR(x))
#define HW_MTB_PERIPHID3_RD(x)   (HW_MTB_PERIPHID3(x).U)
/*@}*/

/*
 * Constants & macros for individual MTB_PERIPHID3 bitfields
 */

/*!
 * @name Register MTB_PERIPHID3, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID4 is hardwired to 0x0000_0004; ID0 to 0x0000_0032; ID1 to
 * 0x0000_00B9; ID2 to 0x0000_001B; and all the others to 0x0000_0000.
 */
/*@{*/
#define BP_MTB_PERIPHID3_PERIPHID (0U)     /*!< Bit position for MTB_PERIPHID3_PERIPHID. */
#define BM_MTB_PERIPHID3_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for MTB_PERIPHID3_PERIPHID. */
#define BS_MTB_PERIPHID3_PERIPHID (32U)    /*!< Bit field size in bits for MTB_PERIPHID3_PERIPHID. */

/*! @brief Read current value of the MTB_PERIPHID3_PERIPHID field. */
#define BR_MTB_PERIPHID3_PERIPHID(x) (HW_MTB_PERIPHID3(x).U)
/*@}*/

/*******************************************************************************
 * HW_MTB_COMPIDn - Component ID Register
 ******************************************************************************/

/*!
 * @brief HW_MTB_COMPIDn - Component ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the component IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtb_compidn
{
    uint32_t U;
    struct _hw_mtb_compidn_bitfields
    {
        uint32_t COMPID : 32;          /*!< [31:0] Component ID */
    } B;
} hw_mtb_compidn_t;

/*!
 * @name Constants and macros for entire MTB_COMPIDn register
 */
/*@{*/
#define HW_MTB_COMPIDn_COUNT (4U)

#define HW_MTB_COMPIDn_ADDR(x, n) ((uint32_t)(x) + 0xFF0U + (0x4U * (n)))

#define HW_MTB_COMPIDn(x, n)     (*(__I hw_mtb_compidn_t *) HW_MTB_COMPIDn_ADDR(x, n))
#define HW_MTB_COMPIDn_RD(x, n)  (HW_MTB_COMPIDn(x, n).U)
/*@}*/

/*
 * Constants & macros for individual MTB_COMPIDn bitfields
 */

/*!
 * @name Register MTB_COMPIDn, field COMPID[31:0] (RO)
 *
 * Component ID0 is hardwired to 0x0000_000D; ID1 to 0x0000_0090; ID2 to
 * 0x0000_0005; ID3 to 0x0000_00B1.
 */
/*@{*/
#define BP_MTB_COMPIDn_COMPID (0U)         /*!< Bit position for MTB_COMPIDn_COMPID. */
#define BM_MTB_COMPIDn_COMPID (0xFFFFFFFFU) /*!< Bit mask for MTB_COMPIDn_COMPID. */
#define BS_MTB_COMPIDn_COMPID (32U)        /*!< Bit field size in bits for MTB_COMPIDn_COMPID. */

/*! @brief Read current value of the MTB_COMPIDn_COMPID field. */
#define BR_MTB_COMPIDn_COMPID(x, n) (HW_MTB_COMPIDn(x, n).U)
/*@}*/

/*******************************************************************************
 * hw_mtb_t - module struct
 ******************************************************************************/
/*!
 * @brief All MTB module registers.
 */
#pragma pack(1)
typedef struct _hw_mtb
{
    __IO hw_mtb_position_t POSITION;       /*!< [0x0] MTB Position Register */
    __IO hw_mtb_master_t MASTER;           /*!< [0x4] MTB Master Register */
    __IO hw_mtb_flow_t FLOW;               /*!< [0x8] MTB Flow Register */
    __I hw_mtb_base_t BASE;                /*!< [0xC] MTB Base Register */
    uint8_t _reserved0[3824];
    __I hw_mtb_modectrl_t MODECTRL;        /*!< [0xF00] Integration Mode Control Register */
    uint8_t _reserved1[156];
    __I hw_mtb_tagset_t TAGSET;            /*!< [0xFA0] Claim TAG Set Register */
    __I hw_mtb_tagclear_t TAGCLEAR;        /*!< [0xFA4] Claim TAG Clear Register */
    uint8_t _reserved2[8];
    __I hw_mtb_lockaccess_t LOCKACCESS;    /*!< [0xFB0] Lock Access Register */
    __I hw_mtb_lockstat_t LOCKSTAT;        /*!< [0xFB4] Lock Status Register */
    __I hw_mtb_authstat_t AUTHSTAT;        /*!< [0xFB8] Authentication Status Register */
    __I hw_mtb_devicearch_t DEVICEARCH;    /*!< [0xFBC] Device Architecture Register */
    uint8_t _reserved3[8];
    __I hw_mtb_devicecfg_t DEVICECFG;      /*!< [0xFC8] Device Configuration Register */
    __I hw_mtb_devicetypid_t DEVICETYPID;  /*!< [0xFCC] Device Type Identifier Register */
    __I hw_mtb_periphid4_t PERIPHID4;      /*!< [0xFD0] Peripheral ID Register */
    __I hw_mtb_periphid5_t PERIPHID5;      /*!< [0xFD4] Peripheral ID Register */
    __I hw_mtb_periphid6_t PERIPHID6;      /*!< [0xFD8] Peripheral ID Register */
    __I hw_mtb_periphid7_t PERIPHID7;      /*!< [0xFDC] Peripheral ID Register */
    __I hw_mtb_periphid0_t PERIPHID0;      /*!< [0xFE0] Peripheral ID Register */
    __I hw_mtb_periphid1_t PERIPHID1;      /*!< [0xFE4] Peripheral ID Register */
    __I hw_mtb_periphid2_t PERIPHID2;      /*!< [0xFE8] Peripheral ID Register */
    __I hw_mtb_periphid3_t PERIPHID3;      /*!< [0xFEC] Peripheral ID Register */
    __I hw_mtb_compidn_t COMPIDn[4];       /*!< [0xFF0] Component ID Register */
} hw_mtb_t;
#pragma pack()

/*! @brief Macro to access all MTB registers. */
/*! @param x MTB module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_MTB_REGS(MTB_BASE)</code>. */
#define HW_MTB_REGS(x) (*(hw_mtb_t *)(x))

/*
 * MKL43Z4 MTBDWT
 *
 * MTB data watchpoint and trace
 *
 * Registers defined in this header file:
 * - HW_MTBDWT_CTRL - MTB DWT Control Register
 * - HW_MTBDWT_COMP0 - MTB_DWT Comparator Register
 * - HW_MTBDWT_MASK0 - MTB_DWT Comparator Mask Register
 * - HW_MTBDWT_FCT0 - MTB_DWT Comparator Function Register 0
 * - HW_MTBDWT_COMP1 - MTB_DWT Comparator Register
 * - HW_MTBDWT_MASK1 - MTB_DWT Comparator Mask Register
 * - HW_MTBDWT_FCT1 - MTB_DWT Comparator Function Register 1
 * - HW_MTBDWT_TBCTRL - MTB_DWT Trace Buffer Control Register
 * - HW_MTBDWT_DEVICECFG - Device Configuration Register
 * - HW_MTBDWT_DEVICETYPID - Device Type Identifier Register
 * - HW_MTBDWT_PERIPHID4 - Peripheral ID Register
 * - HW_MTBDWT_PERIPHID5 - Peripheral ID Register
 * - HW_MTBDWT_PERIPHID6 - Peripheral ID Register
 * - HW_MTBDWT_PERIPHID7 - Peripheral ID Register
 * - HW_MTBDWT_PERIPHID0 - Peripheral ID Register
 * - HW_MTBDWT_PERIPHID1 - Peripheral ID Register
 * - HW_MTBDWT_PERIPHID2 - Peripheral ID Register
 * - HW_MTBDWT_PERIPHID3 - Peripheral ID Register
 * - HW_MTBDWT_COMPIDn - Component ID Register
 *
 * - hw_mtbdwt_t - Struct containing all module registers.
 */

#define HW_MTBDWT_INSTANCE_COUNT (1U) /*!< Number of instances of the MTBDWT module. */
#define HW_MTBDWT (0U) /*!< Instance number for MTBDWT. */

/*******************************************************************************
 * HW_MTBDWT_CTRL - MTB DWT Control Register
 ******************************************************************************/

/*!
 * @brief HW_MTBDWT_CTRL - MTB DWT Control Register (RO)
 *
 * Reset value: 0x2F000000U
 *
 * The MTBDWT_CTRL register provides read-only information on the watchpoint
 * configuration for the MTB_DWT.
 */
typedef union _hw_mtbdwt_ctrl
{
    uint32_t U;
    struct _hw_mtbdwt_ctrl_bitfields
    {
        uint32_t DWTCFGCTRL : 28;      /*!< [27:0] DWT configuration controls */
        uint32_t NUMCMP : 4;           /*!< [31:28] Number of comparators */
    } B;
} hw_mtbdwt_ctrl_t;

/*!
 * @name Constants and macros for entire MTBDWT_CTRL register
 */
/*@{*/
#define HW_MTBDWT_CTRL_ADDR(x)   ((uint32_t)(x) + 0x0U)

#define HW_MTBDWT_CTRL(x)        (*(__I hw_mtbdwt_ctrl_t *) HW_MTBDWT_CTRL_ADDR(x))
#define HW_MTBDWT_CTRL_RD(x)     (HW_MTBDWT_CTRL(x).U)
/*@}*/

/*
 * Constants & macros for individual MTBDWT_CTRL bitfields
 */

/*!
 * @name Register MTBDWT_CTRL, field DWTCFGCTRL[27:0] (RO)
 *
 * This field is hardwired to 0xF00_0000, disabling all the remaining DWT
 * functionality. The specific fields and their state are: MTBDWT_CTRL[27] = NOTRCPKT =
 * 1, trace sample and exception trace is not supported MTBDWT_CTRL[26] =
 * NOEXTTRIG = 1, external match signals are not supported MTBDWT_CTRL[25] = NOCYCCNT =
 * 1, cycle counter is not supported MTBDWT_CTRL[24] = NOPRFCNT = 1, profiling
 * counters are not supported MTBDWT_CTRL[22] = CYCEBTENA = 0, no POSTCNT
 * underflow packets generated MTBDWT_CTRL[21] = FOLDEVTENA = 0, no folded instruction
 * counter overflow events MTBDWT_CTRL[20] = LSUEVTENA = 0, no LSU counter overflow
 * events MTBDWT_CTRL[19] = SLEEPEVTENA = 0, no sleep counter overflow events
 * MTBDWT_CTRL[18] = EXCEVTENA = 0, no exception overhead counter events
 * MTBDWT_CTRL[17] = CPIEVTENA = 0, no CPI counter overflow events MTBDWT_CTRL[16] =
 * EXCTRCENA = 0, generation of exception trace disabled MTBDWT_CTRL[12] = PCSAMPLENA =
 * 0, no periodic PC sample packets generated MTBDWT_CTRL[11:10] = SYNCTAP = 0,
 * no synchronization packets MTBDWT_CTRL[9] = CYCTAP = 0, cycle counter is not
 * supported MTBDWT_CTRL[8:5] = POSTINIT = 0, cycle counter is not supported
 * MTBDWT_CTRL[4:1] = POSTPRESET = 0, cycle counter is not supported MTBDWT_CTRL[0] =
 * CYCCNTENA = 0, cycle counter is not supported
 */
/*@{*/
#define BP_MTBDWT_CTRL_DWTCFGCTRL (0U)     /*!< Bit position for MTBDWT_CTRL_DWTCFGCTRL. */
#define BM_MTBDWT_CTRL_DWTCFGCTRL (0x0FFFFFFFU) /*!< Bit mask for MTBDWT_CTRL_DWTCFGCTRL. */
#define BS_MTBDWT_CTRL_DWTCFGCTRL (28U)    /*!< Bit field size in bits for MTBDWT_CTRL_DWTCFGCTRL. */

/*! @brief Read current value of the MTBDWT_CTRL_DWTCFGCTRL field. */
#define BR_MTBDWT_CTRL_DWTCFGCTRL(x) (HW_MTBDWT_CTRL(x).B.DWTCFGCTRL)
/*@}*/

/*!
 * @name Register MTBDWT_CTRL, field NUMCMP[31:28] (RO)
 *
 * The MTB_DWT implements two comparators.
 */
/*@{*/
#define BP_MTBDWT_CTRL_NUMCMP (28U)        /*!< Bit position for MTBDWT_CTRL_NUMCMP. */
#define BM_MTBDWT_CTRL_NUMCMP (0xF0000000U) /*!< Bit mask for MTBDWT_CTRL_NUMCMP. */
#define BS_MTBDWT_CTRL_NUMCMP (4U)         /*!< Bit field size in bits for MTBDWT_CTRL_NUMCMP. */

/*! @brief Read current value of the MTBDWT_CTRL_NUMCMP field. */
#define BR_MTBDWT_CTRL_NUMCMP(x) (HW_MTBDWT_CTRL(x).B.NUMCMP)
/*@}*/

/*******************************************************************************
 * HW_MTBDWT_COMP0 - MTB_DWT Comparator Register
 ******************************************************************************/

/*!
 * @brief HW_MTBDWT_COMP0 - MTB_DWT Comparator Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTBDWT_COMPn registers provide the reference value for comparator n.
 */
typedef union _hw_mtbdwt_comp0
{
    uint32_t U;
    struct _hw_mtbdwt_comp0_bitfields
    {
        uint32_t COMP : 32;            /*!< [31:0] Reference value for comparison */
    } B;
} hw_mtbdwt_comp0_t;

/*!
 * @name Constants and macros for entire MTBDWT_COMP0 register
 */
/*@{*/
#define HW_MTBDWT_COMP0_ADDR(x)  ((uint32_t)(x) + 0x20U)

#define HW_MTBDWT_COMP0(x)       (*(__IO hw_mtbdwt_comp0_t *) HW_MTBDWT_COMP0_ADDR(x))
#define HW_MTBDWT_COMP0_RD(x)    (HW_MTBDWT_COMP0(x).U)
#define HW_MTBDWT_COMP0_WR(x, v) (HW_MTBDWT_COMP0(x).U = (v))
#define HW_MTBDWT_COMP0_SET(x, v) (HW_MTBDWT_COMP0_WR(x, HW_MTBDWT_COMP0_RD(x) |  (v)))
#define HW_MTBDWT_COMP0_CLR(x, v) (HW_MTBDWT_COMP0_WR(x, HW_MTBDWT_COMP0_RD(x) & ~(v)))
#define HW_MTBDWT_COMP0_TOG(x, v) (HW_MTBDWT_COMP0_WR(x, HW_MTBDWT_COMP0_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MTBDWT_COMP0 bitfields
 */

/*!
 * @name Register MTBDWT_COMP0, field COMP[31:0] (RW)
 *
 * If MTBDWT_COMP0 is used for a data value comparator and the access size is
 * byte or halfword, the data value must be replicated across all appropriate byte
 * lanes of this register. For example, if the data is a byte-sized "x" value,
 * then COMP[31:24] = COMP[23:16] = COMP[15:8] = COMP[7:0] = "x". Likewise, if the
 * data is a halfword-size "y" value, then COMP[31:16] = COMP[15:0] = "y".
 */
/*@{*/
#define BP_MTBDWT_COMP0_COMP (0U)          /*!< Bit position for MTBDWT_COMP0_COMP. */
#define BM_MTBDWT_COMP0_COMP (0xFFFFFFFFU) /*!< Bit mask for MTBDWT_COMP0_COMP. */
#define BS_MTBDWT_COMP0_COMP (32U)         /*!< Bit field size in bits for MTBDWT_COMP0_COMP. */

/*! @brief Read current value of the MTBDWT_COMP0_COMP field. */
#define BR_MTBDWT_COMP0_COMP(x) (HW_MTBDWT_COMP0(x).U)

/*! @brief Format value for bitfield MTBDWT_COMP0_COMP. */
#define BF_MTBDWT_COMP0_COMP(v) ((uint32_t)((uint32_t)(v) << BP_MTBDWT_COMP0_COMP) & BM_MTBDWT_COMP0_COMP)

/*! @brief Set the COMP field to a new value. */
#define BW_MTBDWT_COMP0_COMP(x, v) (HW_MTBDWT_COMP0_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_MTBDWT_MASK0 - MTB_DWT Comparator Mask Register
 ******************************************************************************/

/*!
 * @brief HW_MTBDWT_MASK0 - MTB_DWT Comparator Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTBDWT_MASKn registers define the size of the ignore mask applied to the
 * reference address for address range matching by comparator n. Note the format
 * of this mask field is different than the MTB_MASTER[MASK].
 */
typedef union _hw_mtbdwt_mask0
{
    uint32_t U;
    struct _hw_mtbdwt_mask0_bitfields
    {
        uint32_t MASK : 5;             /*!< [4:0] MASK */
        uint32_t RESERVED0 : 27;       /*!< [31:5]  */
    } B;
} hw_mtbdwt_mask0_t;

/*!
 * @name Constants and macros for entire MTBDWT_MASK0 register
 */
/*@{*/
#define HW_MTBDWT_MASK0_ADDR(x)  ((uint32_t)(x) + 0x24U)

#define HW_MTBDWT_MASK0(x)       (*(__IO hw_mtbdwt_mask0_t *) HW_MTBDWT_MASK0_ADDR(x))
#define HW_MTBDWT_MASK0_RD(x)    (HW_MTBDWT_MASK0(x).U)
#define HW_MTBDWT_MASK0_WR(x, v) (HW_MTBDWT_MASK0(x).U = (v))
#define HW_MTBDWT_MASK0_SET(x, v) (HW_MTBDWT_MASK0_WR(x, HW_MTBDWT_MASK0_RD(x) |  (v)))
#define HW_MTBDWT_MASK0_CLR(x, v) (HW_MTBDWT_MASK0_WR(x, HW_MTBDWT_MASK0_RD(x) & ~(v)))
#define HW_MTBDWT_MASK0_TOG(x, v) (HW_MTBDWT_MASK0_WR(x, HW_MTBDWT_MASK0_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MTBDWT_MASK0 bitfields
 */

/*!
 * @name Register MTBDWT_MASK0, field MASK[4:0] (RW)
 *
 * The value of the ignore mask, 0-31 bits, is applied to address range
 * matching. MASK = 0 is used to include all bits of the address in the comparison,
 * except if MASK = 0 and the comparator is configured to watch instruction fetch
 * addresses, address bit [0] is ignored by the hardware since all fetches must be at
 * least halfword aligned. For MASK != 0 and regardless of watch type, address
 * bits [x-1:0] are ignored in the address comparison. Using a mask means the
 * comparator matches on a range of addresses, defined by the unmasked most
 * significant bits of the address, bits [31:x]. The maximum MASK value is 24, producing a
 * 16 Mbyte mask. An attempted write of a MASK value > 24 is limited by the
 * MTBDWT hardware to 24. If MTBDWT_COMP0 is used as a data value comparator, then
 * MTBDWT_MASK0 should be programmed to zero.
 */
/*@{*/
#define BP_MTBDWT_MASK0_MASK (0U)          /*!< Bit position for MTBDWT_MASK0_MASK. */
#define BM_MTBDWT_MASK0_MASK (0x0000001FU) /*!< Bit mask for MTBDWT_MASK0_MASK. */
#define BS_MTBDWT_MASK0_MASK (5U)          /*!< Bit field size in bits for MTBDWT_MASK0_MASK. */

/*! @brief Read current value of the MTBDWT_MASK0_MASK field. */
#define BR_MTBDWT_MASK0_MASK(x) (HW_MTBDWT_MASK0(x).B.MASK)

/*! @brief Format value for bitfield MTBDWT_MASK0_MASK. */
#define BF_MTBDWT_MASK0_MASK(v) ((uint32_t)((uint32_t)(v) << BP_MTBDWT_MASK0_MASK) & BM_MTBDWT_MASK0_MASK)

/*! @brief Set the MASK field to a new value. */
#define BW_MTBDWT_MASK0_MASK(x, v) (HW_MTBDWT_MASK0_WR(x, (HW_MTBDWT_MASK0_RD(x) & ~BM_MTBDWT_MASK0_MASK) | BF_MTBDWT_MASK0_MASK(v)))
/*@}*/

/*******************************************************************************
 * HW_MTBDWT_FCT0 - MTB_DWT Comparator Function Register 0
 ******************************************************************************/

/*!
 * @brief HW_MTBDWT_FCT0 - MTB_DWT Comparator Function Register 0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTBDWT_FCTn registers control the operation of comparator n.
 */
typedef union _hw_mtbdwt_fct0
{
    uint32_t U;
    struct _hw_mtbdwt_fct0_bitfields
    {
        uint32_t FUNCTION : 4;         /*!< [3:0] Function */
        uint32_t RESERVED0 : 4;        /*!< [7:4]  */
        uint32_t DATAVMATCH : 1;       /*!< [8] Data Value Match */
        uint32_t RESERVED1 : 1;        /*!< [9]  */
        uint32_t DATAVSIZE : 2;        /*!< [11:10] Data Value Size */
        uint32_t DATAVADDR0 : 4;       /*!< [15:12] Data Value Address 0 */
        uint32_t RESERVED2 : 8;        /*!< [23:16]  */
        uint32_t MATCHED : 1;          /*!< [24] Comparator match */
        uint32_t RESERVED3 : 7;        /*!< [31:25]  */
    } B;
} hw_mtbdwt_fct0_t;

/*!
 * @name Constants and macros for entire MTBDWT_FCT0 register
 */
/*@{*/
#define HW_MTBDWT_FCT0_ADDR(x)   ((uint32_t)(x) + 0x28U)

#define HW_MTBDWT_FCT0(x)        (*(__IO hw_mtbdwt_fct0_t *) HW_MTBDWT_FCT0_ADDR(x))
#define HW_MTBDWT_FCT0_RD(x)     (HW_MTBDWT_FCT0(x).U)
#define HW_MTBDWT_FCT0_WR(x, v)  (HW_MTBDWT_FCT0(x).U = (v))
#define HW_MTBDWT_FCT0_SET(x, v) (HW_MTBDWT_FCT0_WR(x, HW_MTBDWT_FCT0_RD(x) |  (v)))
#define HW_MTBDWT_FCT0_CLR(x, v) (HW_MTBDWT_FCT0_WR(x, HW_MTBDWT_FCT0_RD(x) & ~(v)))
#define HW_MTBDWT_FCT0_TOG(x, v) (HW_MTBDWT_FCT0_WR(x, HW_MTBDWT_FCT0_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MTBDWT_FCT0 bitfields
 */

/*!
 * @name Register MTBDWT_FCT0, field FUNCTION[3:0] (RW)
 *
 * Selects the action taken on a comparator match. If MTBDWT_COMP0 is used for a
 * data value and MTBDWT_COMP1 for an address value, then MTBDWT_FCT1[FUNCTION]
 * must be set to zero. For this configuration, MTBDWT_MASK1 can be set to a
 * non-zero value, so the combined comparators match on a range of addresses.
 *
 * Values:
 * - 0000 - Disabled.
 * - 0100 - Instruction fetch.
 * - 0101 - Data operand read.
 * - 0110 - Data operand write.
 * - 0111 - Data operand (read + write).
 */
/*@{*/
#define BP_MTBDWT_FCT0_FUNCTION (0U)       /*!< Bit position for MTBDWT_FCT0_FUNCTION. */
#define BM_MTBDWT_FCT0_FUNCTION (0x0000000FU) /*!< Bit mask for MTBDWT_FCT0_FUNCTION. */
#define BS_MTBDWT_FCT0_FUNCTION (4U)       /*!< Bit field size in bits for MTBDWT_FCT0_FUNCTION. */

/*! @brief Read current value of the MTBDWT_FCT0_FUNCTION field. */
#define BR_MTBDWT_FCT0_FUNCTION(x) (HW_MTBDWT_FCT0(x).B.FUNCTION)

/*! @brief Format value for bitfield MTBDWT_FCT0_FUNCTION. */
#define BF_MTBDWT_FCT0_FUNCTION(v) ((uint32_t)((uint32_t)(v) << BP_MTBDWT_FCT0_FUNCTION) & BM_MTBDWT_FCT0_FUNCTION)

/*! @brief Set the FUNCTION field to a new value. */
#define BW_MTBDWT_FCT0_FUNCTION(x, v) (HW_MTBDWT_FCT0_WR(x, (HW_MTBDWT_FCT0_RD(x) & ~BM_MTBDWT_FCT0_FUNCTION) | BF_MTBDWT_FCT0_FUNCTION(v)))
/*@}*/

/*!
 * @name Register MTBDWT_FCT0, field DATAVMATCH[8] (RW)
 *
 * When this field is 1, it enables data value comparison. For this
 * implementation, MTBDWT_COMP0 supports address or data value comparisons; MTBDWT_COMP1 only
 * supports address comparisons.
 *
 * Values:
 * - 0 - Perform address comparison.
 * - 1 - Perform data value comparison.
 */
/*@{*/
#define BP_MTBDWT_FCT0_DATAVMATCH (8U)     /*!< Bit position for MTBDWT_FCT0_DATAVMATCH. */
#define BM_MTBDWT_FCT0_DATAVMATCH (0x00000100U) /*!< Bit mask for MTBDWT_FCT0_DATAVMATCH. */
#define BS_MTBDWT_FCT0_DATAVMATCH (1U)     /*!< Bit field size in bits for MTBDWT_FCT0_DATAVMATCH. */

/*! @brief Read current value of the MTBDWT_FCT0_DATAVMATCH field. */
#define BR_MTBDWT_FCT0_DATAVMATCH(x) (HW_MTBDWT_FCT0(x).B.DATAVMATCH)

/*! @brief Format value for bitfield MTBDWT_FCT0_DATAVMATCH. */
#define BF_MTBDWT_FCT0_DATAVMATCH(v) ((uint32_t)((uint32_t)(v) << BP_MTBDWT_FCT0_DATAVMATCH) & BM_MTBDWT_FCT0_DATAVMATCH)

/*! @brief Set the DATAVMATCH field to a new value. */
#define BW_MTBDWT_FCT0_DATAVMATCH(x, v) (HW_MTBDWT_FCT0_WR(x, (HW_MTBDWT_FCT0_RD(x) & ~BM_MTBDWT_FCT0_DATAVMATCH) | BF_MTBDWT_FCT0_DATAVMATCH(v)))
/*@}*/

/*!
 * @name Register MTBDWT_FCT0, field DATAVSIZE[11:10] (RW)
 *
 * For data value matching, this field defines the size of the required data
 * comparison.
 *
 * Values:
 * - 00 - Byte.
 * - 01 - Halfword.
 * - 10 - Word.
 * - 11 - Reserved. Any attempts to use this value results in UNPREDICTABLE
 *     behavior.
 */
/*@{*/
#define BP_MTBDWT_FCT0_DATAVSIZE (10U)     /*!< Bit position for MTBDWT_FCT0_DATAVSIZE. */
#define BM_MTBDWT_FCT0_DATAVSIZE (0x00000C00U) /*!< Bit mask for MTBDWT_FCT0_DATAVSIZE. */
#define BS_MTBDWT_FCT0_DATAVSIZE (2U)      /*!< Bit field size in bits for MTBDWT_FCT0_DATAVSIZE. */

/*! @brief Read current value of the MTBDWT_FCT0_DATAVSIZE field. */
#define BR_MTBDWT_FCT0_DATAVSIZE(x) (HW_MTBDWT_FCT0(x).B.DATAVSIZE)

/*! @brief Format value for bitfield MTBDWT_FCT0_DATAVSIZE. */
#define BF_MTBDWT_FCT0_DATAVSIZE(v) ((uint32_t)((uint32_t)(v) << BP_MTBDWT_FCT0_DATAVSIZE) & BM_MTBDWT_FCT0_DATAVSIZE)

/*! @brief Set the DATAVSIZE field to a new value. */
#define BW_MTBDWT_FCT0_DATAVSIZE(x, v) (HW_MTBDWT_FCT0_WR(x, (HW_MTBDWT_FCT0_RD(x) & ~BM_MTBDWT_FCT0_DATAVSIZE) | BF_MTBDWT_FCT0_DATAVSIZE(v)))
/*@}*/

/*!
 * @name Register MTBDWT_FCT0, field DATAVADDR0[15:12] (RW)
 *
 * Since the MTB_DWT implements two comparators, the DATAVADDR0 field is
 * restricted to values {0,1}. When the DATAVMATCH bit is asserted, this field defines
 * the comparator number to use for linked address comparison. If MTBDWT_COMP0 is
 * used as a data watchpoint and MTBDWT_COMP1 as an address watchpoint,
 * DATAVADDR0 must be set.
 */
/*@{*/
#define BP_MTBDWT_FCT0_DATAVADDR0 (12U)    /*!< Bit position for MTBDWT_FCT0_DATAVADDR0. */
#define BM_MTBDWT_FCT0_DATAVADDR0 (0x0000F000U) /*!< Bit mask for MTBDWT_FCT0_DATAVADDR0. */
#define BS_MTBDWT_FCT0_DATAVADDR0 (4U)     /*!< Bit field size in bits for MTBDWT_FCT0_DATAVADDR0. */

/*! @brief Read current value of the MTBDWT_FCT0_DATAVADDR0 field. */
#define BR_MTBDWT_FCT0_DATAVADDR0(x) (HW_MTBDWT_FCT0(x).B.DATAVADDR0)

/*! @brief Format value for bitfield MTBDWT_FCT0_DATAVADDR0. */
#define BF_MTBDWT_FCT0_DATAVADDR0(v) ((uint32_t)((uint32_t)(v) << BP_MTBDWT_FCT0_DATAVADDR0) & BM_MTBDWT_FCT0_DATAVADDR0)

/*! @brief Set the DATAVADDR0 field to a new value. */
#define BW_MTBDWT_FCT0_DATAVADDR0(x, v) (HW_MTBDWT_FCT0_WR(x, (HW_MTBDWT_FCT0_RD(x) & ~BM_MTBDWT_FCT0_DATAVADDR0) | BF_MTBDWT_FCT0_DATAVADDR0(v)))
/*@}*/

/*!
 * @name Register MTBDWT_FCT0, field MATCHED[24] (RO)
 *
 * If this read-only flag is asserted, it indicates the operation defined by the
 * FUNCTION field occurred since the last read of the register. Reading the
 * register clears this bit.
 *
 * Values:
 * - 0 - No match.
 * - 1 - Match occurred.
 */
/*@{*/
#define BP_MTBDWT_FCT0_MATCHED (24U)       /*!< Bit position for MTBDWT_FCT0_MATCHED. */
#define BM_MTBDWT_FCT0_MATCHED (0x01000000U) /*!< Bit mask for MTBDWT_FCT0_MATCHED. */
#define BS_MTBDWT_FCT0_MATCHED (1U)        /*!< Bit field size in bits for MTBDWT_FCT0_MATCHED. */

/*! @brief Read current value of the MTBDWT_FCT0_MATCHED field. */
#define BR_MTBDWT_FCT0_MATCHED(x) (HW_MTBDWT_FCT0(x).B.MATCHED)
/*@}*/

/*******************************************************************************
 * HW_MTBDWT_COMP1 - MTB_DWT Comparator Register
 ******************************************************************************/

/*!
 * @brief HW_MTBDWT_COMP1 - MTB_DWT Comparator Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTBDWT_COMPn registers provide the reference value for comparator n.
 */
typedef union _hw_mtbdwt_comp1
{
    uint32_t U;
    struct _hw_mtbdwt_comp1_bitfields
    {
        uint32_t COMP : 32;            /*!< [31:0] Reference value for comparison */
    } B;
} hw_mtbdwt_comp1_t;

/*!
 * @name Constants and macros for entire MTBDWT_COMP1 register
 */
/*@{*/
#define HW_MTBDWT_COMP1_ADDR(x)  ((uint32_t)(x) + 0x30U)

#define HW_MTBDWT_COMP1(x)       (*(__IO hw_mtbdwt_comp1_t *) HW_MTBDWT_COMP1_ADDR(x))
#define HW_MTBDWT_COMP1_RD(x)    (HW_MTBDWT_COMP1(x).U)
#define HW_MTBDWT_COMP1_WR(x, v) (HW_MTBDWT_COMP1(x).U = (v))
#define HW_MTBDWT_COMP1_SET(x, v) (HW_MTBDWT_COMP1_WR(x, HW_MTBDWT_COMP1_RD(x) |  (v)))
#define HW_MTBDWT_COMP1_CLR(x, v) (HW_MTBDWT_COMP1_WR(x, HW_MTBDWT_COMP1_RD(x) & ~(v)))
#define HW_MTBDWT_COMP1_TOG(x, v) (HW_MTBDWT_COMP1_WR(x, HW_MTBDWT_COMP1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MTBDWT_COMP1 bitfields
 */

/*!
 * @name Register MTBDWT_COMP1, field COMP[31:0] (RW)
 *
 * If MTBDWT_COMP0 is used for a data value comparator and the access size is
 * byte or halfword, the data value must be replicated across all appropriate byte
 * lanes of this register. For example, if the data is a byte-sized "x" value,
 * then COMP[31:24] = COMP[23:16] = COMP[15:8] = COMP[7:0] = "x". Likewise, if the
 * data is a halfword-size "y" value, then COMP[31:16] = COMP[15:0] = "y".
 */
/*@{*/
#define BP_MTBDWT_COMP1_COMP (0U)          /*!< Bit position for MTBDWT_COMP1_COMP. */
#define BM_MTBDWT_COMP1_COMP (0xFFFFFFFFU) /*!< Bit mask for MTBDWT_COMP1_COMP. */
#define BS_MTBDWT_COMP1_COMP (32U)         /*!< Bit field size in bits for MTBDWT_COMP1_COMP. */

/*! @brief Read current value of the MTBDWT_COMP1_COMP field. */
#define BR_MTBDWT_COMP1_COMP(x) (HW_MTBDWT_COMP1(x).U)

/*! @brief Format value for bitfield MTBDWT_COMP1_COMP. */
#define BF_MTBDWT_COMP1_COMP(v) ((uint32_t)((uint32_t)(v) << BP_MTBDWT_COMP1_COMP) & BM_MTBDWT_COMP1_COMP)

/*! @brief Set the COMP field to a new value. */
#define BW_MTBDWT_COMP1_COMP(x, v) (HW_MTBDWT_COMP1_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_MTBDWT_MASK1 - MTB_DWT Comparator Mask Register
 ******************************************************************************/

/*!
 * @brief HW_MTBDWT_MASK1 - MTB_DWT Comparator Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTBDWT_MASKn registers define the size of the ignore mask applied to the
 * reference address for address range matching by comparator n. Note the format
 * of this mask field is different than the MTB_MASTER[MASK].
 */
typedef union _hw_mtbdwt_mask1
{
    uint32_t U;
    struct _hw_mtbdwt_mask1_bitfields
    {
        uint32_t MASK : 5;             /*!< [4:0] MASK */
        uint32_t RESERVED0 : 27;       /*!< [31:5]  */
    } B;
} hw_mtbdwt_mask1_t;

/*!
 * @name Constants and macros for entire MTBDWT_MASK1 register
 */
/*@{*/
#define HW_MTBDWT_MASK1_ADDR(x)  ((uint32_t)(x) + 0x34U)

#define HW_MTBDWT_MASK1(x)       (*(__IO hw_mtbdwt_mask1_t *) HW_MTBDWT_MASK1_ADDR(x))
#define HW_MTBDWT_MASK1_RD(x)    (HW_MTBDWT_MASK1(x).U)
#define HW_MTBDWT_MASK1_WR(x, v) (HW_MTBDWT_MASK1(x).U = (v))
#define HW_MTBDWT_MASK1_SET(x, v) (HW_MTBDWT_MASK1_WR(x, HW_MTBDWT_MASK1_RD(x) |  (v)))
#define HW_MTBDWT_MASK1_CLR(x, v) (HW_MTBDWT_MASK1_WR(x, HW_MTBDWT_MASK1_RD(x) & ~(v)))
#define HW_MTBDWT_MASK1_TOG(x, v) (HW_MTBDWT_MASK1_WR(x, HW_MTBDWT_MASK1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MTBDWT_MASK1 bitfields
 */

/*!
 * @name Register MTBDWT_MASK1, field MASK[4:0] (RW)
 *
 * The value of the ignore mask, 0-31 bits, is applied to address range
 * matching. MASK = 0 is used to include all bits of the address in the comparison,
 * except if MASK = 0 and the comparator is configured to watch instruction fetch
 * addresses, address bit [0] is ignored by the hardware since all fetches must be at
 * least halfword aligned. For MASK != 0 and regardless of watch type, address
 * bits [x-1:0] are ignored in the address comparison. Using a mask means the
 * comparator matches on a range of addresses, defined by the unmasked most
 * significant bits of the address, bits [31:x]. The maximum MASK value is 24, producing a
 * 16 Mbyte mask. An attempted write of a MASK value > 24 is limited by the
 * MTBDWT hardware to 24. If MTBDWT_COMP0 is used as a data value comparator, then
 * MTBDWT_MASK0 should be programmed to zero.
 */
/*@{*/
#define BP_MTBDWT_MASK1_MASK (0U)          /*!< Bit position for MTBDWT_MASK1_MASK. */
#define BM_MTBDWT_MASK1_MASK (0x0000001FU) /*!< Bit mask for MTBDWT_MASK1_MASK. */
#define BS_MTBDWT_MASK1_MASK (5U)          /*!< Bit field size in bits for MTBDWT_MASK1_MASK. */

/*! @brief Read current value of the MTBDWT_MASK1_MASK field. */
#define BR_MTBDWT_MASK1_MASK(x) (HW_MTBDWT_MASK1(x).B.MASK)

/*! @brief Format value for bitfield MTBDWT_MASK1_MASK. */
#define BF_MTBDWT_MASK1_MASK(v) ((uint32_t)((uint32_t)(v) << BP_MTBDWT_MASK1_MASK) & BM_MTBDWT_MASK1_MASK)

/*! @brief Set the MASK field to a new value. */
#define BW_MTBDWT_MASK1_MASK(x, v) (HW_MTBDWT_MASK1_WR(x, (HW_MTBDWT_MASK1_RD(x) & ~BM_MTBDWT_MASK1_MASK) | BF_MTBDWT_MASK1_MASK(v)))
/*@}*/

/*******************************************************************************
 * HW_MTBDWT_FCT1 - MTB_DWT Comparator Function Register 1
 ******************************************************************************/

/*!
 * @brief HW_MTBDWT_FCT1 - MTB_DWT Comparator Function Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTBDWT_FCTn registers control the operation of comparator n. Since the
 * MTB_DWT only supports data value comparisons on comparator 0, there are several
 * fields in the MTBDWT_FCT1 register that are RAZ/WI (bits 12, 11:10, 8).
 */
typedef union _hw_mtbdwt_fct1
{
    uint32_t U;
    struct _hw_mtbdwt_fct1_bitfields
    {
        uint32_t FUNCTION : 4;         /*!< [3:0] Function */
        uint32_t RESERVED0 : 20;       /*!< [23:4]  */
        uint32_t MATCHED : 1;          /*!< [24] Comparator match */
        uint32_t RESERVED1 : 7;        /*!< [31:25]  */
    } B;
} hw_mtbdwt_fct1_t;

/*!
 * @name Constants and macros for entire MTBDWT_FCT1 register
 */
/*@{*/
#define HW_MTBDWT_FCT1_ADDR(x)   ((uint32_t)(x) + 0x38U)

#define HW_MTBDWT_FCT1(x)        (*(__IO hw_mtbdwt_fct1_t *) HW_MTBDWT_FCT1_ADDR(x))
#define HW_MTBDWT_FCT1_RD(x)     (HW_MTBDWT_FCT1(x).U)
#define HW_MTBDWT_FCT1_WR(x, v)  (HW_MTBDWT_FCT1(x).U = (v))
#define HW_MTBDWT_FCT1_SET(x, v) (HW_MTBDWT_FCT1_WR(x, HW_MTBDWT_FCT1_RD(x) |  (v)))
#define HW_MTBDWT_FCT1_CLR(x, v) (HW_MTBDWT_FCT1_WR(x, HW_MTBDWT_FCT1_RD(x) & ~(v)))
#define HW_MTBDWT_FCT1_TOG(x, v) (HW_MTBDWT_FCT1_WR(x, HW_MTBDWT_FCT1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MTBDWT_FCT1 bitfields
 */

/*!
 * @name Register MTBDWT_FCT1, field FUNCTION[3:0] (RW)
 *
 * Selects the action taken on a comparator match. If MTBDWT_COMP0 is used for a
 * data value and MTBDWT_COMP1 for an address value, then MTBDWT_FCT1[FUNCTION]
 * must be set to zero. For this configuration, MTBDWT_MASK1 can be set to a
 * non-zero value, so the combined comparators match on a range of addresses.
 *
 * Values:
 * - 0000 - Disabled.
 * - 0100 - Instruction fetch.
 * - 0101 - Data operand read.
 * - 0110 - Data operand write.
 * - 0111 - Data operand (read + write).
 */
/*@{*/
#define BP_MTBDWT_FCT1_FUNCTION (0U)       /*!< Bit position for MTBDWT_FCT1_FUNCTION. */
#define BM_MTBDWT_FCT1_FUNCTION (0x0000000FU) /*!< Bit mask for MTBDWT_FCT1_FUNCTION. */
#define BS_MTBDWT_FCT1_FUNCTION (4U)       /*!< Bit field size in bits for MTBDWT_FCT1_FUNCTION. */

/*! @brief Read current value of the MTBDWT_FCT1_FUNCTION field. */
#define BR_MTBDWT_FCT1_FUNCTION(x) (HW_MTBDWT_FCT1(x).B.FUNCTION)

/*! @brief Format value for bitfield MTBDWT_FCT1_FUNCTION. */
#define BF_MTBDWT_FCT1_FUNCTION(v) ((uint32_t)((uint32_t)(v) << BP_MTBDWT_FCT1_FUNCTION) & BM_MTBDWT_FCT1_FUNCTION)

/*! @brief Set the FUNCTION field to a new value. */
#define BW_MTBDWT_FCT1_FUNCTION(x, v) (HW_MTBDWT_FCT1_WR(x, (HW_MTBDWT_FCT1_RD(x) & ~BM_MTBDWT_FCT1_FUNCTION) | BF_MTBDWT_FCT1_FUNCTION(v)))
/*@}*/

/*!
 * @name Register MTBDWT_FCT1, field MATCHED[24] (RO)
 *
 * If this read-only flag is asserted, it indicates the operation defined by the
 * FUNCTION field occurred since the last read of the register. Reading the
 * register clears this bit.
 *
 * Values:
 * - 0 - No match.
 * - 1 - Match occurred.
 */
/*@{*/
#define BP_MTBDWT_FCT1_MATCHED (24U)       /*!< Bit position for MTBDWT_FCT1_MATCHED. */
#define BM_MTBDWT_FCT1_MATCHED (0x01000000U) /*!< Bit mask for MTBDWT_FCT1_MATCHED. */
#define BS_MTBDWT_FCT1_MATCHED (1U)        /*!< Bit field size in bits for MTBDWT_FCT1_MATCHED. */

/*! @brief Read current value of the MTBDWT_FCT1_MATCHED field. */
#define BR_MTBDWT_FCT1_MATCHED(x) (HW_MTBDWT_FCT1(x).B.MATCHED)
/*@}*/

/*******************************************************************************
 * HW_MTBDWT_TBCTRL - MTB_DWT Trace Buffer Control Register
 ******************************************************************************/

/*!
 * @brief HW_MTBDWT_TBCTRL - MTB_DWT Trace Buffer Control Register (RW)
 *
 * Reset value: 0x20000000U
 *
 * The MTBDWT_TBCTRL register defines how the watchpoint comparisons control the
 * actual trace buffer operation. Recall the MTB supports starting and stopping
 * the program trace based on the watchpoint comparisons signaled via TSTART and
 * TSTOP. The watchpoint comparison signals are enabled in the MTB's control
 * logic by setting the appropriate enable bits, MTB_MASTER[TSTARTEN, TSTOPEN]. In
 * the event of simultaneous assertion of both TSTART and TSTOP, TSTART takes
 * priority.
 */
typedef union _hw_mtbdwt_tbctrl
{
    uint32_t U;
    struct _hw_mtbdwt_tbctrl_bitfields
    {
        uint32_t ACOMP0 : 1;           /*!< [0] Action based on Comparator 0 match */
        uint32_t ACOMP1 : 1;           /*!< [1] Action based on Comparator 1 match */
        uint32_t RESERVED0 : 26;       /*!< [27:2]  */
        uint32_t NUMCOMP : 4;          /*!< [31:28] Number of Comparators */
    } B;
} hw_mtbdwt_tbctrl_t;

/*!
 * @name Constants and macros for entire MTBDWT_TBCTRL register
 */
/*@{*/
#define HW_MTBDWT_TBCTRL_ADDR(x) ((uint32_t)(x) + 0x200U)

#define HW_MTBDWT_TBCTRL(x)      (*(__IO hw_mtbdwt_tbctrl_t *) HW_MTBDWT_TBCTRL_ADDR(x))
#define HW_MTBDWT_TBCTRL_RD(x)   (HW_MTBDWT_TBCTRL(x).U)
#define HW_MTBDWT_TBCTRL_WR(x, v) (HW_MTBDWT_TBCTRL(x).U = (v))
#define HW_MTBDWT_TBCTRL_SET(x, v) (HW_MTBDWT_TBCTRL_WR(x, HW_MTBDWT_TBCTRL_RD(x) |  (v)))
#define HW_MTBDWT_TBCTRL_CLR(x, v) (HW_MTBDWT_TBCTRL_WR(x, HW_MTBDWT_TBCTRL_RD(x) & ~(v)))
#define HW_MTBDWT_TBCTRL_TOG(x, v) (HW_MTBDWT_TBCTRL_WR(x, HW_MTBDWT_TBCTRL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MTBDWT_TBCTRL bitfields
 */

/*!
 * @name Register MTBDWT_TBCTRL, field ACOMP0[0] (RW)
 *
 * When the MTBDWT_FCT0[MATCHED] is set, it indicates MTBDWT_COMP0 address
 * compare has triggered and the trace buffer's recording state is changed. The
 * assertion of MTBDWT_FCT0[MATCHED] is caused by the following conditions: Address
 * match in MTBDWT_COMP0 when MTBDWT_FCT0[DATAVMATCH] = 0 Data match in MTBDWT_COMP0
 * when MTBDWT_FCT0[DATAVMATCH, DATAVADDR0] = {1,0} Data match in MTBDWT_COMP0
 * and address match in MTBDWT_COMP1 when MTBDWT_FCT0[DATAVMATCH, DATAVADDR0] =
 * {1,1}
 *
 * Values:
 * - 0 - Trigger TSTOP based on the assertion of MTBDWT_FCT0[MATCHED].
 * - 1 - Trigger TSTART based on the assertion of MTBDWT_FCT0[MATCHED].
 */
/*@{*/
#define BP_MTBDWT_TBCTRL_ACOMP0 (0U)       /*!< Bit position for MTBDWT_TBCTRL_ACOMP0. */
#define BM_MTBDWT_TBCTRL_ACOMP0 (0x00000001U) /*!< Bit mask for MTBDWT_TBCTRL_ACOMP0. */
#define BS_MTBDWT_TBCTRL_ACOMP0 (1U)       /*!< Bit field size in bits for MTBDWT_TBCTRL_ACOMP0. */

/*! @brief Read current value of the MTBDWT_TBCTRL_ACOMP0 field. */
#define BR_MTBDWT_TBCTRL_ACOMP0(x) (HW_MTBDWT_TBCTRL(x).B.ACOMP0)

/*! @brief Format value for bitfield MTBDWT_TBCTRL_ACOMP0. */
#define BF_MTBDWT_TBCTRL_ACOMP0(v) ((uint32_t)((uint32_t)(v) << BP_MTBDWT_TBCTRL_ACOMP0) & BM_MTBDWT_TBCTRL_ACOMP0)

/*! @brief Set the ACOMP0 field to a new value. */
#define BW_MTBDWT_TBCTRL_ACOMP0(x, v) (HW_MTBDWT_TBCTRL_WR(x, (HW_MTBDWT_TBCTRL_RD(x) & ~BM_MTBDWT_TBCTRL_ACOMP0) | BF_MTBDWT_TBCTRL_ACOMP0(v)))
/*@}*/

/*!
 * @name Register MTBDWT_TBCTRL, field ACOMP1[1] (RW)
 *
 * When the MTBDWT_FCT1[MATCHED] is set, it indicates MTBDWT_COMP1 address
 * compare has triggered and the trace buffer's recording state is changed.
 *
 * Values:
 * - 0 - Trigger TSTOP based on the assertion of MTBDWT_FCT1[MATCHED].
 * - 1 - Trigger TSTART based on the assertion of MTBDWT_FCT1[MATCHED].
 */
/*@{*/
#define BP_MTBDWT_TBCTRL_ACOMP1 (1U)       /*!< Bit position for MTBDWT_TBCTRL_ACOMP1. */
#define BM_MTBDWT_TBCTRL_ACOMP1 (0x00000002U) /*!< Bit mask for MTBDWT_TBCTRL_ACOMP1. */
#define BS_MTBDWT_TBCTRL_ACOMP1 (1U)       /*!< Bit field size in bits for MTBDWT_TBCTRL_ACOMP1. */

/*! @brief Read current value of the MTBDWT_TBCTRL_ACOMP1 field. */
#define BR_MTBDWT_TBCTRL_ACOMP1(x) (HW_MTBDWT_TBCTRL(x).B.ACOMP1)

/*! @brief Format value for bitfield MTBDWT_TBCTRL_ACOMP1. */
#define BF_MTBDWT_TBCTRL_ACOMP1(v) ((uint32_t)((uint32_t)(v) << BP_MTBDWT_TBCTRL_ACOMP1) & BM_MTBDWT_TBCTRL_ACOMP1)

/*! @brief Set the ACOMP1 field to a new value. */
#define BW_MTBDWT_TBCTRL_ACOMP1(x, v) (HW_MTBDWT_TBCTRL_WR(x, (HW_MTBDWT_TBCTRL_RD(x) & ~BM_MTBDWT_TBCTRL_ACOMP1) | BF_MTBDWT_TBCTRL_ACOMP1(v)))
/*@}*/

/*!
 * @name Register MTBDWT_TBCTRL, field NUMCOMP[31:28] (RO)
 *
 * This read-only field specifies the number of comparators in the MTB_DWT. This
 * implementation includes two registers.
 */
/*@{*/
#define BP_MTBDWT_TBCTRL_NUMCOMP (28U)     /*!< Bit position for MTBDWT_TBCTRL_NUMCOMP. */
#define BM_MTBDWT_TBCTRL_NUMCOMP (0xF0000000U) /*!< Bit mask for MTBDWT_TBCTRL_NUMCOMP. */
#define BS_MTBDWT_TBCTRL_NUMCOMP (4U)      /*!< Bit field size in bits for MTBDWT_TBCTRL_NUMCOMP. */

/*! @brief Read current value of the MTBDWT_TBCTRL_NUMCOMP field. */
#define BR_MTBDWT_TBCTRL_NUMCOMP(x) (HW_MTBDWT_TBCTRL(x).B.NUMCOMP)
/*@}*/

/*******************************************************************************
 * HW_MTBDWT_DEVICECFG - Device Configuration Register
 ******************************************************************************/

/*!
 * @brief HW_MTBDWT_DEVICECFG - Device Configuration Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register indicates the device configuration. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtbdwt_devicecfg
{
    uint32_t U;
    struct _hw_mtbdwt_devicecfg_bitfields
    {
        uint32_t DEVICECFG : 32;       /*!< [31:0] DEVICECFG */
    } B;
} hw_mtbdwt_devicecfg_t;

/*!
 * @name Constants and macros for entire MTBDWT_DEVICECFG register
 */
/*@{*/
#define HW_MTBDWT_DEVICECFG_ADDR(x) ((uint32_t)(x) + 0xFC8U)

#define HW_MTBDWT_DEVICECFG(x)   (*(__I hw_mtbdwt_devicecfg_t *) HW_MTBDWT_DEVICECFG_ADDR(x))
#define HW_MTBDWT_DEVICECFG_RD(x) (HW_MTBDWT_DEVICECFG(x).U)
/*@}*/

/*
 * Constants & macros for individual MTBDWT_DEVICECFG bitfields
 */

/*!
 * @name Register MTBDWT_DEVICECFG, field DEVICECFG[31:0] (RO)
 *
 * Hardwired to 0x0000_0000.
 */
/*@{*/
#define BP_MTBDWT_DEVICECFG_DEVICECFG (0U) /*!< Bit position for MTBDWT_DEVICECFG_DEVICECFG. */
#define BM_MTBDWT_DEVICECFG_DEVICECFG (0xFFFFFFFFU) /*!< Bit mask for MTBDWT_DEVICECFG_DEVICECFG. */
#define BS_MTBDWT_DEVICECFG_DEVICECFG (32U) /*!< Bit field size in bits for MTBDWT_DEVICECFG_DEVICECFG. */

/*! @brief Read current value of the MTBDWT_DEVICECFG_DEVICECFG field. */
#define BR_MTBDWT_DEVICECFG_DEVICECFG(x) (HW_MTBDWT_DEVICECFG(x).U)
/*@}*/

/*******************************************************************************
 * HW_MTBDWT_DEVICETYPID - Device Type Identifier Register
 ******************************************************************************/

/*!
 * @brief HW_MTBDWT_DEVICETYPID - Device Type Identifier Register (RO)
 *
 * Reset value: 0x00000004U
 *
 * This register indicates the device type ID. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtbdwt_devicetypid
{
    uint32_t U;
    struct _hw_mtbdwt_devicetypid_bitfields
    {
        uint32_t DEVICETYPID : 32;     /*!< [31:0] DEVICETYPID */
    } B;
} hw_mtbdwt_devicetypid_t;

/*!
 * @name Constants and macros for entire MTBDWT_DEVICETYPID register
 */
/*@{*/
#define HW_MTBDWT_DEVICETYPID_ADDR(x) ((uint32_t)(x) + 0xFCCU)

#define HW_MTBDWT_DEVICETYPID(x) (*(__I hw_mtbdwt_devicetypid_t *) HW_MTBDWT_DEVICETYPID_ADDR(x))
#define HW_MTBDWT_DEVICETYPID_RD(x) (HW_MTBDWT_DEVICETYPID(x).U)
/*@}*/

/*
 * Constants & macros for individual MTBDWT_DEVICETYPID bitfields
 */

/*!
 * @name Register MTBDWT_DEVICETYPID, field DEVICETYPID[31:0] (RO)
 *
 * Hardwired to 0x0000_0004.
 */
/*@{*/
#define BP_MTBDWT_DEVICETYPID_DEVICETYPID (0U) /*!< Bit position for MTBDWT_DEVICETYPID_DEVICETYPID. */
#define BM_MTBDWT_DEVICETYPID_DEVICETYPID (0xFFFFFFFFU) /*!< Bit mask for MTBDWT_DEVICETYPID_DEVICETYPID. */
#define BS_MTBDWT_DEVICETYPID_DEVICETYPID (32U) /*!< Bit field size in bits for MTBDWT_DEVICETYPID_DEVICETYPID. */

/*! @brief Read current value of the MTBDWT_DEVICETYPID_DEVICETYPID field. */
#define BR_MTBDWT_DEVICETYPID_DEVICETYPID(x) (HW_MTBDWT_DEVICETYPID(x).U)
/*@}*/

/*******************************************************************************
 * HW_MTBDWT_PERIPHID4 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_MTBDWT_PERIPHID4 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtbdwt_periphid4
{
    uint32_t U;
    struct _hw_mtbdwt_periphid4_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_mtbdwt_periphid4_t;

/*!
 * @name Constants and macros for entire MTBDWT_PERIPHID4 register
 */
/*@{*/
#define HW_MTBDWT_PERIPHID4_ADDR(x) ((uint32_t)(x) + 0xFD0U)

#define HW_MTBDWT_PERIPHID4(x)   (*(__I hw_mtbdwt_periphid4_t *) HW_MTBDWT_PERIPHID4_ADDR(x))
#define HW_MTBDWT_PERIPHID4_RD(x) (HW_MTBDWT_PERIPHID4(x).U)
/*@}*/

/*
 * Constants & macros for individual MTBDWT_PERIPHID4 bitfields
 */

/*!
 * @name Register MTBDWT_PERIPHID4, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID1 is hardwired to 0x0000_00E0; ID2 to 0x0000_0008; and all the
 * others to 0x0000_0000.
 */
/*@{*/
#define BP_MTBDWT_PERIPHID4_PERIPHID (0U)  /*!< Bit position for MTBDWT_PERIPHID4_PERIPHID. */
#define BM_MTBDWT_PERIPHID4_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for MTBDWT_PERIPHID4_PERIPHID. */
#define BS_MTBDWT_PERIPHID4_PERIPHID (32U) /*!< Bit field size in bits for MTBDWT_PERIPHID4_PERIPHID. */

/*! @brief Read current value of the MTBDWT_PERIPHID4_PERIPHID field. */
#define BR_MTBDWT_PERIPHID4_PERIPHID(x) (HW_MTBDWT_PERIPHID4(x).U)
/*@}*/
/*******************************************************************************
 * HW_MTBDWT_PERIPHID5 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_MTBDWT_PERIPHID5 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtbdwt_periphid5
{
    uint32_t U;
    struct _hw_mtbdwt_periphid5_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_mtbdwt_periphid5_t;

/*!
 * @name Constants and macros for entire MTBDWT_PERIPHID5 register
 */
/*@{*/
#define HW_MTBDWT_PERIPHID5_ADDR(x) ((uint32_t)(x) + 0xFD4U)

#define HW_MTBDWT_PERIPHID5(x)   (*(__I hw_mtbdwt_periphid5_t *) HW_MTBDWT_PERIPHID5_ADDR(x))
#define HW_MTBDWT_PERIPHID5_RD(x) (HW_MTBDWT_PERIPHID5(x).U)
/*@}*/

/*
 * Constants & macros for individual MTBDWT_PERIPHID5 bitfields
 */

/*!
 * @name Register MTBDWT_PERIPHID5, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID1 is hardwired to 0x0000_00E0; ID2 to 0x0000_0008; and all the
 * others to 0x0000_0000.
 */
/*@{*/
#define BP_MTBDWT_PERIPHID5_PERIPHID (0U)  /*!< Bit position for MTBDWT_PERIPHID5_PERIPHID. */
#define BM_MTBDWT_PERIPHID5_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for MTBDWT_PERIPHID5_PERIPHID. */
#define BS_MTBDWT_PERIPHID5_PERIPHID (32U) /*!< Bit field size in bits for MTBDWT_PERIPHID5_PERIPHID. */

/*! @brief Read current value of the MTBDWT_PERIPHID5_PERIPHID field. */
#define BR_MTBDWT_PERIPHID5_PERIPHID(x) (HW_MTBDWT_PERIPHID5(x).U)
/*@}*/
/*******************************************************************************
 * HW_MTBDWT_PERIPHID6 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_MTBDWT_PERIPHID6 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtbdwt_periphid6
{
    uint32_t U;
    struct _hw_mtbdwt_periphid6_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_mtbdwt_periphid6_t;

/*!
 * @name Constants and macros for entire MTBDWT_PERIPHID6 register
 */
/*@{*/
#define HW_MTBDWT_PERIPHID6_ADDR(x) ((uint32_t)(x) + 0xFD8U)

#define HW_MTBDWT_PERIPHID6(x)   (*(__I hw_mtbdwt_periphid6_t *) HW_MTBDWT_PERIPHID6_ADDR(x))
#define HW_MTBDWT_PERIPHID6_RD(x) (HW_MTBDWT_PERIPHID6(x).U)
/*@}*/

/*
 * Constants & macros for individual MTBDWT_PERIPHID6 bitfields
 */

/*!
 * @name Register MTBDWT_PERIPHID6, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID1 is hardwired to 0x0000_00E0; ID2 to 0x0000_0008; and all the
 * others to 0x0000_0000.
 */
/*@{*/
#define BP_MTBDWT_PERIPHID6_PERIPHID (0U)  /*!< Bit position for MTBDWT_PERIPHID6_PERIPHID. */
#define BM_MTBDWT_PERIPHID6_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for MTBDWT_PERIPHID6_PERIPHID. */
#define BS_MTBDWT_PERIPHID6_PERIPHID (32U) /*!< Bit field size in bits for MTBDWT_PERIPHID6_PERIPHID. */

/*! @brief Read current value of the MTBDWT_PERIPHID6_PERIPHID field. */
#define BR_MTBDWT_PERIPHID6_PERIPHID(x) (HW_MTBDWT_PERIPHID6(x).U)
/*@}*/
/*******************************************************************************
 * HW_MTBDWT_PERIPHID7 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_MTBDWT_PERIPHID7 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtbdwt_periphid7
{
    uint32_t U;
    struct _hw_mtbdwt_periphid7_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_mtbdwt_periphid7_t;

/*!
 * @name Constants and macros for entire MTBDWT_PERIPHID7 register
 */
/*@{*/
#define HW_MTBDWT_PERIPHID7_ADDR(x) ((uint32_t)(x) + 0xFDCU)

#define HW_MTBDWT_PERIPHID7(x)   (*(__I hw_mtbdwt_periphid7_t *) HW_MTBDWT_PERIPHID7_ADDR(x))
#define HW_MTBDWT_PERIPHID7_RD(x) (HW_MTBDWT_PERIPHID7(x).U)
/*@}*/

/*
 * Constants & macros for individual MTBDWT_PERIPHID7 bitfields
 */

/*!
 * @name Register MTBDWT_PERIPHID7, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID1 is hardwired to 0x0000_00E0; ID2 to 0x0000_0008; and all the
 * others to 0x0000_0000.
 */
/*@{*/
#define BP_MTBDWT_PERIPHID7_PERIPHID (0U)  /*!< Bit position for MTBDWT_PERIPHID7_PERIPHID. */
#define BM_MTBDWT_PERIPHID7_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for MTBDWT_PERIPHID7_PERIPHID. */
#define BS_MTBDWT_PERIPHID7_PERIPHID (32U) /*!< Bit field size in bits for MTBDWT_PERIPHID7_PERIPHID. */

/*! @brief Read current value of the MTBDWT_PERIPHID7_PERIPHID field. */
#define BR_MTBDWT_PERIPHID7_PERIPHID(x) (HW_MTBDWT_PERIPHID7(x).U)
/*@}*/
/*******************************************************************************
 * HW_MTBDWT_PERIPHID0 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_MTBDWT_PERIPHID0 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtbdwt_periphid0
{
    uint32_t U;
    struct _hw_mtbdwt_periphid0_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_mtbdwt_periphid0_t;

/*!
 * @name Constants and macros for entire MTBDWT_PERIPHID0 register
 */
/*@{*/
#define HW_MTBDWT_PERIPHID0_ADDR(x) ((uint32_t)(x) + 0xFE0U)

#define HW_MTBDWT_PERIPHID0(x)   (*(__I hw_mtbdwt_periphid0_t *) HW_MTBDWT_PERIPHID0_ADDR(x))
#define HW_MTBDWT_PERIPHID0_RD(x) (HW_MTBDWT_PERIPHID0(x).U)
/*@}*/

/*
 * Constants & macros for individual MTBDWT_PERIPHID0 bitfields
 */

/*!
 * @name Register MTBDWT_PERIPHID0, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID1 is hardwired to 0x0000_00E0; ID2 to 0x0000_0008; and all the
 * others to 0x0000_0000.
 */
/*@{*/
#define BP_MTBDWT_PERIPHID0_PERIPHID (0U)  /*!< Bit position for MTBDWT_PERIPHID0_PERIPHID. */
#define BM_MTBDWT_PERIPHID0_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for MTBDWT_PERIPHID0_PERIPHID. */
#define BS_MTBDWT_PERIPHID0_PERIPHID (32U) /*!< Bit field size in bits for MTBDWT_PERIPHID0_PERIPHID. */

/*! @brief Read current value of the MTBDWT_PERIPHID0_PERIPHID field. */
#define BR_MTBDWT_PERIPHID0_PERIPHID(x) (HW_MTBDWT_PERIPHID0(x).U)
/*@}*/
/*******************************************************************************
 * HW_MTBDWT_PERIPHID1 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_MTBDWT_PERIPHID1 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtbdwt_periphid1
{
    uint32_t U;
    struct _hw_mtbdwt_periphid1_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_mtbdwt_periphid1_t;

/*!
 * @name Constants and macros for entire MTBDWT_PERIPHID1 register
 */
/*@{*/
#define HW_MTBDWT_PERIPHID1_ADDR(x) ((uint32_t)(x) + 0xFE4U)

#define HW_MTBDWT_PERIPHID1(x)   (*(__I hw_mtbdwt_periphid1_t *) HW_MTBDWT_PERIPHID1_ADDR(x))
#define HW_MTBDWT_PERIPHID1_RD(x) (HW_MTBDWT_PERIPHID1(x).U)
/*@}*/

/*
 * Constants & macros for individual MTBDWT_PERIPHID1 bitfields
 */

/*!
 * @name Register MTBDWT_PERIPHID1, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID1 is hardwired to 0x0000_00E0; ID2 to 0x0000_0008; and all the
 * others to 0x0000_0000.
 */
/*@{*/
#define BP_MTBDWT_PERIPHID1_PERIPHID (0U)  /*!< Bit position for MTBDWT_PERIPHID1_PERIPHID. */
#define BM_MTBDWT_PERIPHID1_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for MTBDWT_PERIPHID1_PERIPHID. */
#define BS_MTBDWT_PERIPHID1_PERIPHID (32U) /*!< Bit field size in bits for MTBDWT_PERIPHID1_PERIPHID. */

/*! @brief Read current value of the MTBDWT_PERIPHID1_PERIPHID field. */
#define BR_MTBDWT_PERIPHID1_PERIPHID(x) (HW_MTBDWT_PERIPHID1(x).U)
/*@}*/
/*******************************************************************************
 * HW_MTBDWT_PERIPHID2 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_MTBDWT_PERIPHID2 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtbdwt_periphid2
{
    uint32_t U;
    struct _hw_mtbdwt_periphid2_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_mtbdwt_periphid2_t;

/*!
 * @name Constants and macros for entire MTBDWT_PERIPHID2 register
 */
/*@{*/
#define HW_MTBDWT_PERIPHID2_ADDR(x) ((uint32_t)(x) + 0xFE8U)

#define HW_MTBDWT_PERIPHID2(x)   (*(__I hw_mtbdwt_periphid2_t *) HW_MTBDWT_PERIPHID2_ADDR(x))
#define HW_MTBDWT_PERIPHID2_RD(x) (HW_MTBDWT_PERIPHID2(x).U)
/*@}*/

/*
 * Constants & macros for individual MTBDWT_PERIPHID2 bitfields
 */

/*!
 * @name Register MTBDWT_PERIPHID2, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID1 is hardwired to 0x0000_00E0; ID2 to 0x0000_0008; and all the
 * others to 0x0000_0000.
 */
/*@{*/
#define BP_MTBDWT_PERIPHID2_PERIPHID (0U)  /*!< Bit position for MTBDWT_PERIPHID2_PERIPHID. */
#define BM_MTBDWT_PERIPHID2_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for MTBDWT_PERIPHID2_PERIPHID. */
#define BS_MTBDWT_PERIPHID2_PERIPHID (32U) /*!< Bit field size in bits for MTBDWT_PERIPHID2_PERIPHID. */

/*! @brief Read current value of the MTBDWT_PERIPHID2_PERIPHID field. */
#define BR_MTBDWT_PERIPHID2_PERIPHID(x) (HW_MTBDWT_PERIPHID2(x).U)
/*@}*/
/*******************************************************************************
 * HW_MTBDWT_PERIPHID3 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_MTBDWT_PERIPHID3 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtbdwt_periphid3
{
    uint32_t U;
    struct _hw_mtbdwt_periphid3_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_mtbdwt_periphid3_t;

/*!
 * @name Constants and macros for entire MTBDWT_PERIPHID3 register
 */
/*@{*/
#define HW_MTBDWT_PERIPHID3_ADDR(x) ((uint32_t)(x) + 0xFECU)

#define HW_MTBDWT_PERIPHID3(x)   (*(__I hw_mtbdwt_periphid3_t *) HW_MTBDWT_PERIPHID3_ADDR(x))
#define HW_MTBDWT_PERIPHID3_RD(x) (HW_MTBDWT_PERIPHID3(x).U)
/*@}*/

/*
 * Constants & macros for individual MTBDWT_PERIPHID3 bitfields
 */

/*!
 * @name Register MTBDWT_PERIPHID3, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID1 is hardwired to 0x0000_00E0; ID2 to 0x0000_0008; and all the
 * others to 0x0000_0000.
 */
/*@{*/
#define BP_MTBDWT_PERIPHID3_PERIPHID (0U)  /*!< Bit position for MTBDWT_PERIPHID3_PERIPHID. */
#define BM_MTBDWT_PERIPHID3_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for MTBDWT_PERIPHID3_PERIPHID. */
#define BS_MTBDWT_PERIPHID3_PERIPHID (32U) /*!< Bit field size in bits for MTBDWT_PERIPHID3_PERIPHID. */

/*! @brief Read current value of the MTBDWT_PERIPHID3_PERIPHID field. */
#define BR_MTBDWT_PERIPHID3_PERIPHID(x) (HW_MTBDWT_PERIPHID3(x).U)
/*@}*/

/*******************************************************************************
 * HW_MTBDWT_COMPIDn - Component ID Register
 ******************************************************************************/

/*!
 * @brief HW_MTBDWT_COMPIDn - Component ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the component IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_mtbdwt_compidn
{
    uint32_t U;
    struct _hw_mtbdwt_compidn_bitfields
    {
        uint32_t COMPID : 32;          /*!< [31:0] Component ID */
    } B;
} hw_mtbdwt_compidn_t;

/*!
 * @name Constants and macros for entire MTBDWT_COMPIDn register
 */
/*@{*/
#define HW_MTBDWT_COMPIDn_COUNT (4U)

#define HW_MTBDWT_COMPIDn_ADDR(x, n) ((uint32_t)(x) + 0xFF0U + (0x4U * (n)))

#define HW_MTBDWT_COMPIDn(x, n)  (*(__I hw_mtbdwt_compidn_t *) HW_MTBDWT_COMPIDn_ADDR(x, n))
#define HW_MTBDWT_COMPIDn_RD(x, n) (HW_MTBDWT_COMPIDn(x, n).U)
/*@}*/

/*
 * Constants & macros for individual MTBDWT_COMPIDn bitfields
 */

/*!
 * @name Register MTBDWT_COMPIDn, field COMPID[31:0] (RO)
 *
 * Component ID0 is hardwired to 0x0000_000D; ID1 to 0x0000_0090; ID2 to
 * 0x0000_0005; ID3 to 0x0000_00B1.
 */
/*@{*/
#define BP_MTBDWT_COMPIDn_COMPID (0U)      /*!< Bit position for MTBDWT_COMPIDn_COMPID. */
#define BM_MTBDWT_COMPIDn_COMPID (0xFFFFFFFFU) /*!< Bit mask for MTBDWT_COMPIDn_COMPID. */
#define BS_MTBDWT_COMPIDn_COMPID (32U)     /*!< Bit field size in bits for MTBDWT_COMPIDn_COMPID. */

/*! @brief Read current value of the MTBDWT_COMPIDn_COMPID field. */
#define BR_MTBDWT_COMPIDn_COMPID(x, n) (HW_MTBDWT_COMPIDn(x, n).U)
/*@}*/

/*******************************************************************************
 * hw_mtbdwt_t - module struct
 ******************************************************************************/
/*!
 * @brief All MTBDWT module registers.
 */
#pragma pack(1)
typedef struct _hw_mtbdwt
{
    __I hw_mtbdwt_ctrl_t CTRL;             /*!< [0x0] MTB DWT Control Register */
    uint8_t _reserved0[28];
    __IO hw_mtbdwt_comp0_t COMP0;          /*!< [0x20] MTB_DWT Comparator Register */
    __IO hw_mtbdwt_mask0_t MASK0;          /*!< [0x24] MTB_DWT Comparator Mask Register */
    __IO hw_mtbdwt_fct0_t FCT0;            /*!< [0x28] MTB_DWT Comparator Function Register 0 */
    uint8_t _reserved1[4];
    __IO hw_mtbdwt_comp1_t COMP1;          /*!< [0x30] MTB_DWT Comparator Register */
    __IO hw_mtbdwt_mask1_t MASK1;          /*!< [0x34] MTB_DWT Comparator Mask Register */
    __IO hw_mtbdwt_fct1_t FCT1;            /*!< [0x38] MTB_DWT Comparator Function Register 1 */
    uint8_t _reserved2[452];
    __IO hw_mtbdwt_tbctrl_t TBCTRL;        /*!< [0x200] MTB_DWT Trace Buffer Control Register */
    uint8_t _reserved3[3524];
    __I hw_mtbdwt_devicecfg_t DEVICECFG;   /*!< [0xFC8] Device Configuration Register */
    __I hw_mtbdwt_devicetypid_t DEVICETYPID; /*!< [0xFCC] Device Type Identifier Register */
    __I hw_mtbdwt_periphid4_t PERIPHID4;   /*!< [0xFD0] Peripheral ID Register */
    __I hw_mtbdwt_periphid5_t PERIPHID5;   /*!< [0xFD4] Peripheral ID Register */
    __I hw_mtbdwt_periphid6_t PERIPHID6;   /*!< [0xFD8] Peripheral ID Register */
    __I hw_mtbdwt_periphid7_t PERIPHID7;   /*!< [0xFDC] Peripheral ID Register */
    __I hw_mtbdwt_periphid0_t PERIPHID0;   /*!< [0xFE0] Peripheral ID Register */
    __I hw_mtbdwt_periphid1_t PERIPHID1;   /*!< [0xFE4] Peripheral ID Register */
    __I hw_mtbdwt_periphid2_t PERIPHID2;   /*!< [0xFE8] Peripheral ID Register */
    __I hw_mtbdwt_periphid3_t PERIPHID3;   /*!< [0xFEC] Peripheral ID Register */
    __I hw_mtbdwt_compidn_t COMPIDn[4];    /*!< [0xFF0] Component ID Register */
} hw_mtbdwt_t;
#pragma pack()

/*! @brief Macro to access all MTBDWT registers. */
/*! @param x MTBDWT module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_MTBDWT_REGS(MTBDWT_BASE)</code>. */
#define HW_MTBDWT_REGS(x) (*(hw_mtbdwt_t *)(x))

/*
 * MKL43Z4 NV
 *
 * Flash configuration field
 *
 * Registers defined in this header file:
 * - HW_NV_BACKKEY3 - Backdoor Comparison Key 3.
 * - HW_NV_BACKKEY2 - Backdoor Comparison Key 2.
 * - HW_NV_BACKKEY1 - Backdoor Comparison Key 1.
 * - HW_NV_BACKKEY0 - Backdoor Comparison Key 0.
 * - HW_NV_BACKKEY7 - Backdoor Comparison Key 7.
 * - HW_NV_BACKKEY6 - Backdoor Comparison Key 6.
 * - HW_NV_BACKKEY5 - Backdoor Comparison Key 5.
 * - HW_NV_BACKKEY4 - Backdoor Comparison Key 4.
 * - HW_NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register
 * - HW_NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register
 * - HW_NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register
 * - HW_NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register
 * - HW_NV_FSEC - Non-volatile Flash Security Register
 * - HW_NV_FOPT - Non-volatile Flash Option Register
 *
 * - hw_nv_t - Struct containing all module registers.
 */

#define HW_NV_INSTANCE_COUNT (1U) /*!< Number of instances of the NV module. */
#define HW_FTFA_FlashConfig (0U) /*!< Instance number for FTFA_FlashConfig. */

/*******************************************************************************
 * HW_NV_BACKKEY3 - Backdoor Comparison Key 3.
 ******************************************************************************/

/*!
 * @brief HW_NV_BACKKEY3 - Backdoor Comparison Key 3. (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_backkey3
{
    uint8_t U;
    struct _hw_nv_backkey3_bitfields
    {
        uint8_t KEY : 8;               /*!< [7:0] Backdoor Comparison Key. */
    } B;
} hw_nv_backkey3_t;

/*!
 * @name Constants and macros for entire NV_BACKKEY3 register
 */
/*@{*/
#define HW_NV_BACKKEY3_ADDR(x)   ((uint32_t)(x) + 0x0U)

#define HW_NV_BACKKEY3(x)        (*(__I hw_nv_backkey3_t *) HW_NV_BACKKEY3_ADDR(x))
#define HW_NV_BACKKEY3_RD(x)     (HW_NV_BACKKEY3(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_BACKKEY3 bitfields
 */

/*!
 * @name Register NV_BACKKEY3, field KEY[7:0] (RO)
 */
/*@{*/
#define BP_NV_BACKKEY3_KEY   (0U)          /*!< Bit position for NV_BACKKEY3_KEY. */
#define BM_NV_BACKKEY3_KEY   (0xFFU)       /*!< Bit mask for NV_BACKKEY3_KEY. */
#define BS_NV_BACKKEY3_KEY   (8U)          /*!< Bit field size in bits for NV_BACKKEY3_KEY. */

/*! @brief Read current value of the NV_BACKKEY3_KEY field. */
#define BR_NV_BACKKEY3_KEY(x) (HW_NV_BACKKEY3(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_BACKKEY2 - Backdoor Comparison Key 2.
 ******************************************************************************/

/*!
 * @brief HW_NV_BACKKEY2 - Backdoor Comparison Key 2. (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_backkey2
{
    uint8_t U;
    struct _hw_nv_backkey2_bitfields
    {
        uint8_t KEY : 8;               /*!< [7:0] Backdoor Comparison Key. */
    } B;
} hw_nv_backkey2_t;

/*!
 * @name Constants and macros for entire NV_BACKKEY2 register
 */
/*@{*/
#define HW_NV_BACKKEY2_ADDR(x)   ((uint32_t)(x) + 0x1U)

#define HW_NV_BACKKEY2(x)        (*(__I hw_nv_backkey2_t *) HW_NV_BACKKEY2_ADDR(x))
#define HW_NV_BACKKEY2_RD(x)     (HW_NV_BACKKEY2(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_BACKKEY2 bitfields
 */

/*!
 * @name Register NV_BACKKEY2, field KEY[7:0] (RO)
 */
/*@{*/
#define BP_NV_BACKKEY2_KEY   (0U)          /*!< Bit position for NV_BACKKEY2_KEY. */
#define BM_NV_BACKKEY2_KEY   (0xFFU)       /*!< Bit mask for NV_BACKKEY2_KEY. */
#define BS_NV_BACKKEY2_KEY   (8U)          /*!< Bit field size in bits for NV_BACKKEY2_KEY. */

/*! @brief Read current value of the NV_BACKKEY2_KEY field. */
#define BR_NV_BACKKEY2_KEY(x) (HW_NV_BACKKEY2(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_BACKKEY1 - Backdoor Comparison Key 1.
 ******************************************************************************/

/*!
 * @brief HW_NV_BACKKEY1 - Backdoor Comparison Key 1. (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_backkey1
{
    uint8_t U;
    struct _hw_nv_backkey1_bitfields
    {
        uint8_t KEY : 8;               /*!< [7:0] Backdoor Comparison Key. */
    } B;
} hw_nv_backkey1_t;

/*!
 * @name Constants and macros for entire NV_BACKKEY1 register
 */
/*@{*/
#define HW_NV_BACKKEY1_ADDR(x)   ((uint32_t)(x) + 0x2U)

#define HW_NV_BACKKEY1(x)        (*(__I hw_nv_backkey1_t *) HW_NV_BACKKEY1_ADDR(x))
#define HW_NV_BACKKEY1_RD(x)     (HW_NV_BACKKEY1(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_BACKKEY1 bitfields
 */

/*!
 * @name Register NV_BACKKEY1, field KEY[7:0] (RO)
 */
/*@{*/
#define BP_NV_BACKKEY1_KEY   (0U)          /*!< Bit position for NV_BACKKEY1_KEY. */
#define BM_NV_BACKKEY1_KEY   (0xFFU)       /*!< Bit mask for NV_BACKKEY1_KEY. */
#define BS_NV_BACKKEY1_KEY   (8U)          /*!< Bit field size in bits for NV_BACKKEY1_KEY. */

/*! @brief Read current value of the NV_BACKKEY1_KEY field. */
#define BR_NV_BACKKEY1_KEY(x) (HW_NV_BACKKEY1(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_BACKKEY0 - Backdoor Comparison Key 0.
 ******************************************************************************/

/*!
 * @brief HW_NV_BACKKEY0 - Backdoor Comparison Key 0. (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_backkey0
{
    uint8_t U;
    struct _hw_nv_backkey0_bitfields
    {
        uint8_t KEY : 8;               /*!< [7:0] Backdoor Comparison Key. */
    } B;
} hw_nv_backkey0_t;

/*!
 * @name Constants and macros for entire NV_BACKKEY0 register
 */
/*@{*/
#define HW_NV_BACKKEY0_ADDR(x)   ((uint32_t)(x) + 0x3U)

#define HW_NV_BACKKEY0(x)        (*(__I hw_nv_backkey0_t *) HW_NV_BACKKEY0_ADDR(x))
#define HW_NV_BACKKEY0_RD(x)     (HW_NV_BACKKEY0(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_BACKKEY0 bitfields
 */

/*!
 * @name Register NV_BACKKEY0, field KEY[7:0] (RO)
 */
/*@{*/
#define BP_NV_BACKKEY0_KEY   (0U)          /*!< Bit position for NV_BACKKEY0_KEY. */
#define BM_NV_BACKKEY0_KEY   (0xFFU)       /*!< Bit mask for NV_BACKKEY0_KEY. */
#define BS_NV_BACKKEY0_KEY   (8U)          /*!< Bit field size in bits for NV_BACKKEY0_KEY. */

/*! @brief Read current value of the NV_BACKKEY0_KEY field. */
#define BR_NV_BACKKEY0_KEY(x) (HW_NV_BACKKEY0(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_BACKKEY7 - Backdoor Comparison Key 7.
 ******************************************************************************/

/*!
 * @brief HW_NV_BACKKEY7 - Backdoor Comparison Key 7. (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_backkey7
{
    uint8_t U;
    struct _hw_nv_backkey7_bitfields
    {
        uint8_t KEY : 8;               /*!< [7:0] Backdoor Comparison Key. */
    } B;
} hw_nv_backkey7_t;

/*!
 * @name Constants and macros for entire NV_BACKKEY7 register
 */
/*@{*/
#define HW_NV_BACKKEY7_ADDR(x)   ((uint32_t)(x) + 0x4U)

#define HW_NV_BACKKEY7(x)        (*(__I hw_nv_backkey7_t *) HW_NV_BACKKEY7_ADDR(x))
#define HW_NV_BACKKEY7_RD(x)     (HW_NV_BACKKEY7(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_BACKKEY7 bitfields
 */

/*!
 * @name Register NV_BACKKEY7, field KEY[7:0] (RO)
 */
/*@{*/
#define BP_NV_BACKKEY7_KEY   (0U)          /*!< Bit position for NV_BACKKEY7_KEY. */
#define BM_NV_BACKKEY7_KEY   (0xFFU)       /*!< Bit mask for NV_BACKKEY7_KEY. */
#define BS_NV_BACKKEY7_KEY   (8U)          /*!< Bit field size in bits for NV_BACKKEY7_KEY. */

/*! @brief Read current value of the NV_BACKKEY7_KEY field. */
#define BR_NV_BACKKEY7_KEY(x) (HW_NV_BACKKEY7(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_BACKKEY6 - Backdoor Comparison Key 6.
 ******************************************************************************/

/*!
 * @brief HW_NV_BACKKEY6 - Backdoor Comparison Key 6. (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_backkey6
{
    uint8_t U;
    struct _hw_nv_backkey6_bitfields
    {
        uint8_t KEY : 8;               /*!< [7:0] Backdoor Comparison Key. */
    } B;
} hw_nv_backkey6_t;

/*!
 * @name Constants and macros for entire NV_BACKKEY6 register
 */
/*@{*/
#define HW_NV_BACKKEY6_ADDR(x)   ((uint32_t)(x) + 0x5U)

#define HW_NV_BACKKEY6(x)        (*(__I hw_nv_backkey6_t *) HW_NV_BACKKEY6_ADDR(x))
#define HW_NV_BACKKEY6_RD(x)     (HW_NV_BACKKEY6(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_BACKKEY6 bitfields
 */

/*!
 * @name Register NV_BACKKEY6, field KEY[7:0] (RO)
 */
/*@{*/
#define BP_NV_BACKKEY6_KEY   (0U)          /*!< Bit position for NV_BACKKEY6_KEY. */
#define BM_NV_BACKKEY6_KEY   (0xFFU)       /*!< Bit mask for NV_BACKKEY6_KEY. */
#define BS_NV_BACKKEY6_KEY   (8U)          /*!< Bit field size in bits for NV_BACKKEY6_KEY. */

/*! @brief Read current value of the NV_BACKKEY6_KEY field. */
#define BR_NV_BACKKEY6_KEY(x) (HW_NV_BACKKEY6(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_BACKKEY5 - Backdoor Comparison Key 5.
 ******************************************************************************/

/*!
 * @brief HW_NV_BACKKEY5 - Backdoor Comparison Key 5. (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_backkey5
{
    uint8_t U;
    struct _hw_nv_backkey5_bitfields
    {
        uint8_t KEY : 8;               /*!< [7:0] Backdoor Comparison Key. */
    } B;
} hw_nv_backkey5_t;

/*!
 * @name Constants and macros for entire NV_BACKKEY5 register
 */
/*@{*/
#define HW_NV_BACKKEY5_ADDR(x)   ((uint32_t)(x) + 0x6U)

#define HW_NV_BACKKEY5(x)        (*(__I hw_nv_backkey5_t *) HW_NV_BACKKEY5_ADDR(x))
#define HW_NV_BACKKEY5_RD(x)     (HW_NV_BACKKEY5(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_BACKKEY5 bitfields
 */

/*!
 * @name Register NV_BACKKEY5, field KEY[7:0] (RO)
 */
/*@{*/
#define BP_NV_BACKKEY5_KEY   (0U)          /*!< Bit position for NV_BACKKEY5_KEY. */
#define BM_NV_BACKKEY5_KEY   (0xFFU)       /*!< Bit mask for NV_BACKKEY5_KEY. */
#define BS_NV_BACKKEY5_KEY   (8U)          /*!< Bit field size in bits for NV_BACKKEY5_KEY. */

/*! @brief Read current value of the NV_BACKKEY5_KEY field. */
#define BR_NV_BACKKEY5_KEY(x) (HW_NV_BACKKEY5(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_BACKKEY4 - Backdoor Comparison Key 4.
 ******************************************************************************/

/*!
 * @brief HW_NV_BACKKEY4 - Backdoor Comparison Key 4. (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_backkey4
{
    uint8_t U;
    struct _hw_nv_backkey4_bitfields
    {
        uint8_t KEY : 8;               /*!< [7:0] Backdoor Comparison Key. */
    } B;
} hw_nv_backkey4_t;

/*!
 * @name Constants and macros for entire NV_BACKKEY4 register
 */
/*@{*/
#define HW_NV_BACKKEY4_ADDR(x)   ((uint32_t)(x) + 0x7U)

#define HW_NV_BACKKEY4(x)        (*(__I hw_nv_backkey4_t *) HW_NV_BACKKEY4_ADDR(x))
#define HW_NV_BACKKEY4_RD(x)     (HW_NV_BACKKEY4(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_BACKKEY4 bitfields
 */

/*!
 * @name Register NV_BACKKEY4, field KEY[7:0] (RO)
 */
/*@{*/
#define BP_NV_BACKKEY4_KEY   (0U)          /*!< Bit position for NV_BACKKEY4_KEY. */
#define BM_NV_BACKKEY4_KEY   (0xFFU)       /*!< Bit mask for NV_BACKKEY4_KEY. */
#define BS_NV_BACKKEY4_KEY   (8U)          /*!< Bit field size in bits for NV_BACKKEY4_KEY. */

/*! @brief Read current value of the NV_BACKKEY4_KEY field. */
#define BR_NV_BACKKEY4_KEY(x) (HW_NV_BACKKEY4(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register
 ******************************************************************************/

/*!
 * @brief HW_NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_fprot3
{
    uint8_t U;
    struct _hw_nv_fprot3_bitfields
    {
        uint8_t PROT : 8;              /*!< [7:0] P-Flash Region Protect */
    } B;
} hw_nv_fprot3_t;

/*!
 * @name Constants and macros for entire NV_FPROT3 register
 */
/*@{*/
#define HW_NV_FPROT3_ADDR(x)     ((uint32_t)(x) + 0x8U)

#define HW_NV_FPROT3(x)          (*(__I hw_nv_fprot3_t *) HW_NV_FPROT3_ADDR(x))
#define HW_NV_FPROT3_RD(x)       (HW_NV_FPROT3(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_FPROT3 bitfields
 */

/*!
 * @name Register NV_FPROT3, field PROT[7:0] (RO)
 */
/*@{*/
#define BP_NV_FPROT3_PROT    (0U)          /*!< Bit position for NV_FPROT3_PROT. */
#define BM_NV_FPROT3_PROT    (0xFFU)       /*!< Bit mask for NV_FPROT3_PROT. */
#define BS_NV_FPROT3_PROT    (8U)          /*!< Bit field size in bits for NV_FPROT3_PROT. */

/*! @brief Read current value of the NV_FPROT3_PROT field. */
#define BR_NV_FPROT3_PROT(x) (HW_NV_FPROT3(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register
 ******************************************************************************/

/*!
 * @brief HW_NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_fprot2
{
    uint8_t U;
    struct _hw_nv_fprot2_bitfields
    {
        uint8_t PROT : 8;              /*!< [7:0] P-Flash Region Protect */
    } B;
} hw_nv_fprot2_t;

/*!
 * @name Constants and macros for entire NV_FPROT2 register
 */
/*@{*/
#define HW_NV_FPROT2_ADDR(x)     ((uint32_t)(x) + 0x9U)

#define HW_NV_FPROT2(x)          (*(__I hw_nv_fprot2_t *) HW_NV_FPROT2_ADDR(x))
#define HW_NV_FPROT2_RD(x)       (HW_NV_FPROT2(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_FPROT2 bitfields
 */

/*!
 * @name Register NV_FPROT2, field PROT[7:0] (RO)
 */
/*@{*/
#define BP_NV_FPROT2_PROT    (0U)          /*!< Bit position for NV_FPROT2_PROT. */
#define BM_NV_FPROT2_PROT    (0xFFU)       /*!< Bit mask for NV_FPROT2_PROT. */
#define BS_NV_FPROT2_PROT    (8U)          /*!< Bit field size in bits for NV_FPROT2_PROT. */

/*! @brief Read current value of the NV_FPROT2_PROT field. */
#define BR_NV_FPROT2_PROT(x) (HW_NV_FPROT2(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register
 ******************************************************************************/

/*!
 * @brief HW_NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_fprot1
{
    uint8_t U;
    struct _hw_nv_fprot1_bitfields
    {
        uint8_t PROT : 8;              /*!< [7:0] P-Flash Region Protect */
    } B;
} hw_nv_fprot1_t;

/*!
 * @name Constants and macros for entire NV_FPROT1 register
 */
/*@{*/
#define HW_NV_FPROT1_ADDR(x)     ((uint32_t)(x) + 0xAU)

#define HW_NV_FPROT1(x)          (*(__I hw_nv_fprot1_t *) HW_NV_FPROT1_ADDR(x))
#define HW_NV_FPROT1_RD(x)       (HW_NV_FPROT1(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_FPROT1 bitfields
 */

/*!
 * @name Register NV_FPROT1, field PROT[7:0] (RO)
 */
/*@{*/
#define BP_NV_FPROT1_PROT    (0U)          /*!< Bit position for NV_FPROT1_PROT. */
#define BM_NV_FPROT1_PROT    (0xFFU)       /*!< Bit mask for NV_FPROT1_PROT. */
#define BS_NV_FPROT1_PROT    (8U)          /*!< Bit field size in bits for NV_FPROT1_PROT. */

/*! @brief Read current value of the NV_FPROT1_PROT field. */
#define BR_NV_FPROT1_PROT(x) (HW_NV_FPROT1(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register
 ******************************************************************************/

/*!
 * @brief HW_NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_fprot0
{
    uint8_t U;
    struct _hw_nv_fprot0_bitfields
    {
        uint8_t PROT : 8;              /*!< [7:0] P-Flash Region Protect */
    } B;
} hw_nv_fprot0_t;

/*!
 * @name Constants and macros for entire NV_FPROT0 register
 */
/*@{*/
#define HW_NV_FPROT0_ADDR(x)     ((uint32_t)(x) + 0xBU)

#define HW_NV_FPROT0(x)          (*(__I hw_nv_fprot0_t *) HW_NV_FPROT0_ADDR(x))
#define HW_NV_FPROT0_RD(x)       (HW_NV_FPROT0(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_FPROT0 bitfields
 */

/*!
 * @name Register NV_FPROT0, field PROT[7:0] (RO)
 */
/*@{*/
#define BP_NV_FPROT0_PROT    (0U)          /*!< Bit position for NV_FPROT0_PROT. */
#define BM_NV_FPROT0_PROT    (0xFFU)       /*!< Bit mask for NV_FPROT0_PROT. */
#define BS_NV_FPROT0_PROT    (8U)          /*!< Bit field size in bits for NV_FPROT0_PROT. */

/*! @brief Read current value of the NV_FPROT0_PROT field. */
#define BR_NV_FPROT0_PROT(x) (HW_NV_FPROT0(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_FSEC - Non-volatile Flash Security Register
 ******************************************************************************/

/*!
 * @brief HW_NV_FSEC - Non-volatile Flash Security Register (RO)
 *
 * Reset value: 0xFFU
 *
 * Allows the user to customize the operation of the MCU at boot time
 */
typedef union _hw_nv_fsec
{
    uint8_t U;
    struct _hw_nv_fsec_bitfields
    {
        uint8_t SEC : 2;               /*!< [1:0] Flash Security */
        uint8_t FSLACC : 2;            /*!< [3:2] Freescale Failure Analysis Access Code
                                        * */
        uint8_t MEEN : 2;              /*!< [5:4]  */
        uint8_t KEYEN : 2;             /*!< [7:6] Backdoor Key Security Enable */
    } B;
} hw_nv_fsec_t;

/*!
 * @name Constants and macros for entire NV_FSEC register
 */
/*@{*/
#define HW_NV_FSEC_ADDR(x)       ((uint32_t)(x) + 0xCU)

#define HW_NV_FSEC(x)            (*(__I hw_nv_fsec_t *) HW_NV_FSEC_ADDR(x))
#define HW_NV_FSEC_RD(x)         (HW_NV_FSEC(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_FSEC bitfields
 */

/*!
 * @name Register NV_FSEC, field SEC[1:0] (RO)
 *
 * Values:
 * - 10 - MCU security status is unsecure
 * - 11 - MCU security status is secure
 */
/*@{*/
#define BP_NV_FSEC_SEC       (0U)          /*!< Bit position for NV_FSEC_SEC. */
#define BM_NV_FSEC_SEC       (0x03U)       /*!< Bit mask for NV_FSEC_SEC. */
#define BS_NV_FSEC_SEC       (2U)          /*!< Bit field size in bits for NV_FSEC_SEC. */

/*! @brief Read current value of the NV_FSEC_SEC field. */
#define BR_NV_FSEC_SEC(x)    (HW_NV_FSEC(x).B.SEC)
/*@}*/

/*!
 * @name Register NV_FSEC, field FSLACC[3:2] (RO)
 *
 * Values:
 * - 10 - Freescale factory access denied
 * - 11 - Freescale factory access granted
 */
/*@{*/
#define BP_NV_FSEC_FSLACC    (2U)          /*!< Bit position for NV_FSEC_FSLACC. */
#define BM_NV_FSEC_FSLACC    (0x0CU)       /*!< Bit mask for NV_FSEC_FSLACC. */
#define BS_NV_FSEC_FSLACC    (2U)          /*!< Bit field size in bits for NV_FSEC_FSLACC. */

/*! @brief Read current value of the NV_FSEC_FSLACC field. */
#define BR_NV_FSEC_FSLACC(x) (HW_NV_FSEC(x).B.FSLACC)
/*@}*/

/*!
 * @name Register NV_FSEC, field MEEN[5:4] (RO)
 *
 * Values:
 * - 10 - Mass erase is disabled
 * - 11 - Mass erase is enabled
 */
/*@{*/
#define BP_NV_FSEC_MEEN      (4U)          /*!< Bit position for NV_FSEC_MEEN. */
#define BM_NV_FSEC_MEEN      (0x30U)       /*!< Bit mask for NV_FSEC_MEEN. */
#define BS_NV_FSEC_MEEN      (2U)          /*!< Bit field size in bits for NV_FSEC_MEEN. */

/*! @brief Read current value of the NV_FSEC_MEEN field. */
#define BR_NV_FSEC_MEEN(x)   (HW_NV_FSEC(x).B.MEEN)
/*@}*/

/*!
 * @name Register NV_FSEC, field KEYEN[7:6] (RO)
 *
 * Values:
 * - 10 - Backdoor key access enabled
 * - 11 - Backdoor key access disabled
 */
/*@{*/
#define BP_NV_FSEC_KEYEN     (6U)          /*!< Bit position for NV_FSEC_KEYEN. */
#define BM_NV_FSEC_KEYEN     (0xC0U)       /*!< Bit mask for NV_FSEC_KEYEN. */
#define BS_NV_FSEC_KEYEN     (2U)          /*!< Bit field size in bits for NV_FSEC_KEYEN. */

/*! @brief Read current value of the NV_FSEC_KEYEN field. */
#define BR_NV_FSEC_KEYEN(x)  (HW_NV_FSEC(x).B.KEYEN)
/*@}*/

/*******************************************************************************
 * HW_NV_FOPT - Non-volatile Flash Option Register
 ******************************************************************************/

/*!
 * @brief HW_NV_FOPT - Non-volatile Flash Option Register (RO)
 *
 * Reset value: 0x3FU
 */
typedef union _hw_nv_fopt
{
    uint8_t U;
    struct _hw_nv_fopt_bitfields
    {
        uint8_t LPBOOT0 : 1;           /*!< [0]  */
        uint8_t BOOTPIN_OPT : 1;       /*!< [1]  */
        uint8_t NMI_DIS : 1;           /*!< [2]  */
        uint8_t RESET_PIN_CFG : 1;     /*!< [3]  */
        uint8_t LPBOOT1 : 1;           /*!< [4]  */
        uint8_t FAST_INIT : 1;         /*!< [5]  */
        uint8_t BOOTSRC_SEL : 2;       /*!< [7:6] Boot source selection */
    } B;
} hw_nv_fopt_t;

/*!
 * @name Constants and macros for entire NV_FOPT register
 */
/*@{*/
#define HW_NV_FOPT_ADDR(x)       ((uint32_t)(x) + 0xDU)

#define HW_NV_FOPT(x)            (*(__I hw_nv_fopt_t *) HW_NV_FOPT_ADDR(x))
#define HW_NV_FOPT_RD(x)         (HW_NV_FOPT(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_FOPT bitfields
 */

/*!
 * @name Register NV_FOPT, field LPBOOT0[0] (RO)
 *
 * Values:
 * - 00 - Core and system clock divider (OUTDIV1) is 0x7 (divide by 8) when
 *     LPBOOT1=0 or 0x1 (divide by 2) when LPBOOT1=1.
 * - 01 - Core and system clock divider (OUTDIV1) is 0x3 (divide by 4) when
 *     LPBOOT1=0 or 0x0 (divide by 1) when LPBOOT1=1.
 */
/*@{*/
#define BP_NV_FOPT_LPBOOT0   (0U)          /*!< Bit position for NV_FOPT_LPBOOT0. */
#define BM_NV_FOPT_LPBOOT0   (0x01U)       /*!< Bit mask for NV_FOPT_LPBOOT0. */
#define BS_NV_FOPT_LPBOOT0   (1U)          /*!< Bit field size in bits for NV_FOPT_LPBOOT0. */

/*! @brief Read current value of the NV_FOPT_LPBOOT0 field. */
#define BR_NV_FOPT_LPBOOT0(x) (HW_NV_FOPT(x).B.LPBOOT0)
/*@}*/

/*!
 * @name Register NV_FOPT, field BOOTPIN_OPT[1] (RO)
 *
 * Values:
 * - 00 - Force Boot from ROM if BOOTCFG0 asserted, where BOOTCFG0 is the boot
 *     config function which is muxed with NMI pin
 * - 01 - Boot source configured by FOPT (BOOTSRC_SEL) bits
 */
/*@{*/
#define BP_NV_FOPT_BOOTPIN_OPT (1U)        /*!< Bit position for NV_FOPT_BOOTPIN_OPT. */
#define BM_NV_FOPT_BOOTPIN_OPT (0x02U)     /*!< Bit mask for NV_FOPT_BOOTPIN_OPT. */
#define BS_NV_FOPT_BOOTPIN_OPT (1U)        /*!< Bit field size in bits for NV_FOPT_BOOTPIN_OPT. */

/*! @brief Read current value of the NV_FOPT_BOOTPIN_OPT field. */
#define BR_NV_FOPT_BOOTPIN_OPT(x) (HW_NV_FOPT(x).B.BOOTPIN_OPT)
/*@}*/

/*!
 * @name Register NV_FOPT, field NMI_DIS[2] (RO)
 *
 * Values:
 * - 00 - NMI interrupts are always blocked
 * - 01 - NMI_b pin/interrupts reset default to enabled
 */
/*@{*/
#define BP_NV_FOPT_NMI_DIS   (2U)          /*!< Bit position for NV_FOPT_NMI_DIS. */
#define BM_NV_FOPT_NMI_DIS   (0x04U)       /*!< Bit mask for NV_FOPT_NMI_DIS. */
#define BS_NV_FOPT_NMI_DIS   (1U)          /*!< Bit field size in bits for NV_FOPT_NMI_DIS. */

/*! @brief Read current value of the NV_FOPT_NMI_DIS field. */
#define BR_NV_FOPT_NMI_DIS(x) (HW_NV_FOPT(x).B.NMI_DIS)
/*@}*/

/*!
 * @name Register NV_FOPT, field RESET_PIN_CFG[3] (RO)
 *
 * Values:
 * - 00 - RESET pin is disabled following a POR and cannot be enabled as reset
 *     function
 * - 01 - RESET_b pin is dedicated
 */
/*@{*/
#define BP_NV_FOPT_RESET_PIN_CFG (3U)      /*!< Bit position for NV_FOPT_RESET_PIN_CFG. */
#define BM_NV_FOPT_RESET_PIN_CFG (0x08U)   /*!< Bit mask for NV_FOPT_RESET_PIN_CFG. */
#define BS_NV_FOPT_RESET_PIN_CFG (1U)      /*!< Bit field size in bits for NV_FOPT_RESET_PIN_CFG. */

/*! @brief Read current value of the NV_FOPT_RESET_PIN_CFG field. */
#define BR_NV_FOPT_RESET_PIN_CFG(x) (HW_NV_FOPT(x).B.RESET_PIN_CFG)
/*@}*/

/*!
 * @name Register NV_FOPT, field LPBOOT1[4] (RO)
 *
 * Values:
 * - 00 - Core and system clock divider (OUTDIV1) is 0x7 (divide by 8) when
 *     LPBOOT0=0 or 0x3 (divide by 4) when LPBOOT0=1.
 * - 01 - Core and system clock divider (OUTDIV1) is 0x1 (divide by 2) when
 *     LPBOOT0=0 or 0x0 (divide by 1) when LPBOOT0=1.
 */
/*@{*/
#define BP_NV_FOPT_LPBOOT1   (4U)          /*!< Bit position for NV_FOPT_LPBOOT1. */
#define BM_NV_FOPT_LPBOOT1   (0x10U)       /*!< Bit mask for NV_FOPT_LPBOOT1. */
#define BS_NV_FOPT_LPBOOT1   (1U)          /*!< Bit field size in bits for NV_FOPT_LPBOOT1. */

/*! @brief Read current value of the NV_FOPT_LPBOOT1 field. */
#define BR_NV_FOPT_LPBOOT1(x) (HW_NV_FOPT(x).B.LPBOOT1)
/*@}*/

/*!
 * @name Register NV_FOPT, field FAST_INIT[5] (RO)
 *
 * Values:
 * - 00 - Slower initialization
 * - 01 - Fast Initialization
 */
/*@{*/
#define BP_NV_FOPT_FAST_INIT (5U)          /*!< Bit position for NV_FOPT_FAST_INIT. */
#define BM_NV_FOPT_FAST_INIT (0x20U)       /*!< Bit mask for NV_FOPT_FAST_INIT. */
#define BS_NV_FOPT_FAST_INIT (1U)          /*!< Bit field size in bits for NV_FOPT_FAST_INIT. */

/*! @brief Read current value of the NV_FOPT_FAST_INIT field. */
#define BR_NV_FOPT_FAST_INIT(x) (HW_NV_FOPT(x).B.FAST_INIT)
/*@}*/

/*!
 * @name Register NV_FOPT, field BOOTSRC_SEL[7:6] (RO)
 *
 * Values:
 * - 00 - Boot from Flash
 * - 10 - Boot from ROM
 * - 11 - Boot from ROM
 */
/*@{*/
#define BP_NV_FOPT_BOOTSRC_SEL (6U)        /*!< Bit position for NV_FOPT_BOOTSRC_SEL. */
#define BM_NV_FOPT_BOOTSRC_SEL (0xC0U)     /*!< Bit mask for NV_FOPT_BOOTSRC_SEL. */
#define BS_NV_FOPT_BOOTSRC_SEL (2U)        /*!< Bit field size in bits for NV_FOPT_BOOTSRC_SEL. */

/*! @brief Read current value of the NV_FOPT_BOOTSRC_SEL field. */
#define BR_NV_FOPT_BOOTSRC_SEL(x) (HW_NV_FOPT(x).B.BOOTSRC_SEL)
/*@}*/

/*******************************************************************************
 * hw_nv_t - module struct
 ******************************************************************************/
/*!
 * @brief All NV module registers.
 */
#pragma pack(1)
typedef struct _hw_nv
{
    __I hw_nv_backkey3_t BACKKEY3;         /*!< [0x0] Backdoor Comparison Key 3. */
    __I hw_nv_backkey2_t BACKKEY2;         /*!< [0x1] Backdoor Comparison Key 2. */
    __I hw_nv_backkey1_t BACKKEY1;         /*!< [0x2] Backdoor Comparison Key 1. */
    __I hw_nv_backkey0_t BACKKEY0;         /*!< [0x3] Backdoor Comparison Key 0. */
    __I hw_nv_backkey7_t BACKKEY7;         /*!< [0x4] Backdoor Comparison Key 7. */
    __I hw_nv_backkey6_t BACKKEY6;         /*!< [0x5] Backdoor Comparison Key 6. */
    __I hw_nv_backkey5_t BACKKEY5;         /*!< [0x6] Backdoor Comparison Key 5. */
    __I hw_nv_backkey4_t BACKKEY4;         /*!< [0x7] Backdoor Comparison Key 4. */
    __I hw_nv_fprot3_t FPROT3;             /*!< [0x8] Non-volatile P-Flash Protection 1 - Low Register */
    __I hw_nv_fprot2_t FPROT2;             /*!< [0x9] Non-volatile P-Flash Protection 1 - High Register */
    __I hw_nv_fprot1_t FPROT1;             /*!< [0xA] Non-volatile P-Flash Protection 0 - Low Register */
    __I hw_nv_fprot0_t FPROT0;             /*!< [0xB] Non-volatile P-Flash Protection 0 - High Register */
    __I hw_nv_fsec_t FSEC;                 /*!< [0xC] Non-volatile Flash Security Register */
    __I hw_nv_fopt_t FOPT;                 /*!< [0xD] Non-volatile Flash Option Register */
} hw_nv_t;
#pragma pack()

/*! @brief Macro to access all NV registers. */
/*! @param x NV module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_NV_REGS(FTFA_FlashConfig_BASE)</code>. */
#define HW_NV_REGS(x)  (*(hw_nv_t *)(x))

/*
 * MKL43Z4 OSC
 *
 * Oscillator
 *
 * Registers defined in this header file:
 * - HW_OSC_CR - OSC Control Register
 *
 * - hw_osc_t - Struct containing all module registers.
 */

#define HW_OSC_INSTANCE_COUNT (1U) /*!< Number of instances of the OSC module. */
#define HW_OSC0 (0U) /*!< Instance number for OSC0. */

/*******************************************************************************
 * HW_OSC_CR - OSC Control Register
 ******************************************************************************/

/*!
 * @brief HW_OSC_CR - OSC Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * After OSC is enabled and starts generating the clocks, the configurations
 * such as low power and frequency range, must not be changed.
 */
typedef union _hw_osc_cr
{
    uint8_t U;
    struct _hw_osc_cr_bitfields
    {
        uint8_t SC16P : 1;             /*!< [0] Oscillator 16 pF Capacitor Load Configure
                                        * */
        uint8_t SC8P : 1;              /*!< [1] Oscillator 8 pF Capacitor Load Configure */
        uint8_t SC4P : 1;              /*!< [2] Oscillator 4 pF Capacitor Load Configure */
        uint8_t SC2P : 1;              /*!< [3] Oscillator 2 pF Capacitor Load Configure */
        uint8_t RESERVED0 : 1;         /*!< [4]  */
        uint8_t EREFSTEN : 1;          /*!< [5] External Reference Stop Enable */
        uint8_t RESERVED1 : 1;         /*!< [6]  */
        uint8_t ERCLKEN : 1;           /*!< [7] External Reference Enable */
    } B;
} hw_osc_cr_t;

/*!
 * @name Constants and macros for entire OSC_CR register
 */
/*@{*/
#define HW_OSC_CR_ADDR(x)        ((uint32_t)(x) + 0x0U)

#define HW_OSC_CR(x)             (*(__IO hw_osc_cr_t *) HW_OSC_CR_ADDR(x))
#define HW_OSC_CR_RD(x)          (HW_OSC_CR(x).U)
#define HW_OSC_CR_WR(x, v)       (HW_OSC_CR(x).U = (v))
#define HW_OSC_CR_SET(x, v)      (BME_OR8(HW_OSC_CR_ADDR(x), (uint8_t)(v)))
#define HW_OSC_CR_CLR(x, v)      (BME_AND8(HW_OSC_CR_ADDR(x), (uint8_t)(~(v))))
#define HW_OSC_CR_TOG(x, v)      (BME_XOR8(HW_OSC_CR_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual OSC_CR bitfields
 */

/*!
 * @name Register OSC_CR, field SC16P[0] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0 - Disable the selection.
 * - 1 - Add 16 pF capacitor to the oscillator load.
 */
/*@{*/
#define BP_OSC_CR_SC16P      (0U)          /*!< Bit position for OSC_CR_SC16P. */
#define BM_OSC_CR_SC16P      (0x01U)       /*!< Bit mask for OSC_CR_SC16P. */
#define BS_OSC_CR_SC16P      (1U)          /*!< Bit field size in bits for OSC_CR_SC16P. */

/*! @brief Read current value of the OSC_CR_SC16P field. */
#define BR_OSC_CR_SC16P(x)   (BME_UBFX8(HW_OSC_CR_ADDR(x), BP_OSC_CR_SC16P, BS_OSC_CR_SC16P))

/*! @brief Format value for bitfield OSC_CR_SC16P. */
#define BF_OSC_CR_SC16P(v)   ((uint8_t)((uint8_t)(v) << BP_OSC_CR_SC16P) & BM_OSC_CR_SC16P)

/*! @brief Set the SC16P field to a new value. */
#define BW_OSC_CR_SC16P(x, v) (BME_BFI8(HW_OSC_CR_ADDR(x), ((uint8_t)(v) << BP_OSC_CR_SC16P), BP_OSC_CR_SC16P, 1))
/*@}*/

/*!
 * @name Register OSC_CR, field SC8P[1] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0 - Disable the selection.
 * - 1 - Add 8 pF capacitor to the oscillator load.
 */
/*@{*/
#define BP_OSC_CR_SC8P       (1U)          /*!< Bit position for OSC_CR_SC8P. */
#define BM_OSC_CR_SC8P       (0x02U)       /*!< Bit mask for OSC_CR_SC8P. */
#define BS_OSC_CR_SC8P       (1U)          /*!< Bit field size in bits for OSC_CR_SC8P. */

/*! @brief Read current value of the OSC_CR_SC8P field. */
#define BR_OSC_CR_SC8P(x)    (BME_UBFX8(HW_OSC_CR_ADDR(x), BP_OSC_CR_SC8P, BS_OSC_CR_SC8P))

/*! @brief Format value for bitfield OSC_CR_SC8P. */
#define BF_OSC_CR_SC8P(v)    ((uint8_t)((uint8_t)(v) << BP_OSC_CR_SC8P) & BM_OSC_CR_SC8P)

/*! @brief Set the SC8P field to a new value. */
#define BW_OSC_CR_SC8P(x, v) (BME_BFI8(HW_OSC_CR_ADDR(x), ((uint8_t)(v) << BP_OSC_CR_SC8P), BP_OSC_CR_SC8P, 1))
/*@}*/

/*!
 * @name Register OSC_CR, field SC4P[2] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0 - Disable the selection.
 * - 1 - Add 4 pF capacitor to the oscillator load.
 */
/*@{*/
#define BP_OSC_CR_SC4P       (2U)          /*!< Bit position for OSC_CR_SC4P. */
#define BM_OSC_CR_SC4P       (0x04U)       /*!< Bit mask for OSC_CR_SC4P. */
#define BS_OSC_CR_SC4P       (1U)          /*!< Bit field size in bits for OSC_CR_SC4P. */

/*! @brief Read current value of the OSC_CR_SC4P field. */
#define BR_OSC_CR_SC4P(x)    (BME_UBFX8(HW_OSC_CR_ADDR(x), BP_OSC_CR_SC4P, BS_OSC_CR_SC4P))

/*! @brief Format value for bitfield OSC_CR_SC4P. */
#define BF_OSC_CR_SC4P(v)    ((uint8_t)((uint8_t)(v) << BP_OSC_CR_SC4P) & BM_OSC_CR_SC4P)

/*! @brief Set the SC4P field to a new value. */
#define BW_OSC_CR_SC4P(x, v) (BME_BFI8(HW_OSC_CR_ADDR(x), ((uint8_t)(v) << BP_OSC_CR_SC4P), BP_OSC_CR_SC4P, 1))
/*@}*/

/*!
 * @name Register OSC_CR, field SC2P[3] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0 - Disable the selection.
 * - 1 - Add 2 pF capacitor to the oscillator load.
 */
/*@{*/
#define BP_OSC_CR_SC2P       (3U)          /*!< Bit position for OSC_CR_SC2P. */
#define BM_OSC_CR_SC2P       (0x08U)       /*!< Bit mask for OSC_CR_SC2P. */
#define BS_OSC_CR_SC2P       (1U)          /*!< Bit field size in bits for OSC_CR_SC2P. */

/*! @brief Read current value of the OSC_CR_SC2P field. */
#define BR_OSC_CR_SC2P(x)    (BME_UBFX8(HW_OSC_CR_ADDR(x), BP_OSC_CR_SC2P, BS_OSC_CR_SC2P))

/*! @brief Format value for bitfield OSC_CR_SC2P. */
#define BF_OSC_CR_SC2P(v)    ((uint8_t)((uint8_t)(v) << BP_OSC_CR_SC2P) & BM_OSC_CR_SC2P)

/*! @brief Set the SC2P field to a new value. */
#define BW_OSC_CR_SC2P(x, v) (BME_BFI8(HW_OSC_CR_ADDR(x), ((uint8_t)(v) << BP_OSC_CR_SC2P), BP_OSC_CR_SC2P, 1))
/*@}*/

/*!
 * @name Register OSC_CR, field EREFSTEN[5] (RW)
 *
 * Controls whether or not the external reference clock (OSCERCLK) remains
 * enabled when MCU enters Stop mode.
 *
 * Values:
 * - 0 - External reference clock is disabled in Stop mode.
 * - 1 - External reference clock stays enabled in Stop mode if ERCLKEN is set
 *     before entering Stop mode.
 */
/*@{*/
#define BP_OSC_CR_EREFSTEN   (5U)          /*!< Bit position for OSC_CR_EREFSTEN. */
#define BM_OSC_CR_EREFSTEN   (0x20U)       /*!< Bit mask for OSC_CR_EREFSTEN. */
#define BS_OSC_CR_EREFSTEN   (1U)          /*!< Bit field size in bits for OSC_CR_EREFSTEN. */

/*! @brief Read current value of the OSC_CR_EREFSTEN field. */
#define BR_OSC_CR_EREFSTEN(x) (BME_UBFX8(HW_OSC_CR_ADDR(x), BP_OSC_CR_EREFSTEN, BS_OSC_CR_EREFSTEN))

/*! @brief Format value for bitfield OSC_CR_EREFSTEN. */
#define BF_OSC_CR_EREFSTEN(v) ((uint8_t)((uint8_t)(v) << BP_OSC_CR_EREFSTEN) & BM_OSC_CR_EREFSTEN)

/*! @brief Set the EREFSTEN field to a new value. */
#define BW_OSC_CR_EREFSTEN(x, v) (BME_BFI8(HW_OSC_CR_ADDR(x), ((uint8_t)(v) << BP_OSC_CR_EREFSTEN), BP_OSC_CR_EREFSTEN, 1))
/*@}*/

/*!
 * @name Register OSC_CR, field ERCLKEN[7] (RW)
 *
 * Enables external reference clock (OSCERCLK).
 *
 * Values:
 * - 0 - External reference clock is inactive.
 * - 1 - External reference clock is enabled.
 */
/*@{*/
#define BP_OSC_CR_ERCLKEN    (7U)          /*!< Bit position for OSC_CR_ERCLKEN. */
#define BM_OSC_CR_ERCLKEN    (0x80U)       /*!< Bit mask for OSC_CR_ERCLKEN. */
#define BS_OSC_CR_ERCLKEN    (1U)          /*!< Bit field size in bits for OSC_CR_ERCLKEN. */

/*! @brief Read current value of the OSC_CR_ERCLKEN field. */
#define BR_OSC_CR_ERCLKEN(x) (BME_UBFX8(HW_OSC_CR_ADDR(x), BP_OSC_CR_ERCLKEN, BS_OSC_CR_ERCLKEN))

/*! @brief Format value for bitfield OSC_CR_ERCLKEN. */
#define BF_OSC_CR_ERCLKEN(v) ((uint8_t)((uint8_t)(v) << BP_OSC_CR_ERCLKEN) & BM_OSC_CR_ERCLKEN)

/*! @brief Set the ERCLKEN field to a new value. */
#define BW_OSC_CR_ERCLKEN(x, v) (BME_BFI8(HW_OSC_CR_ADDR(x), ((uint8_t)(v) << BP_OSC_CR_ERCLKEN), BP_OSC_CR_ERCLKEN, 1))
/*@}*/

/*******************************************************************************
 * hw_osc_t - module struct
 ******************************************************************************/
/*!
 * @brief All OSC module registers.
 */
#pragma pack(1)
typedef struct _hw_osc
{
    __IO hw_osc_cr_t CR;                   /*!< [0x0] OSC Control Register */
} hw_osc_t;
#pragma pack()

/*! @brief Macro to access all OSC registers. */
/*! @param x OSC module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_OSC_REGS(OSC0_BASE)</code>. */
#define HW_OSC_REGS(x) (*(hw_osc_t *)(x))

/*
 * MKL43Z4 PIT
 *
 * Periodic Interrupt Timer
 *
 * Registers defined in this header file:
 * - HW_PIT_MCR - PIT Module Control Register
 * - HW_PIT_LTMR64H - PIT Upper Lifetime Timer Register
 * - HW_PIT_LTMR64L - PIT Lower Lifetime Timer Register
 * - HW_PIT_LDVALn - Timer Load Value Register
 * - HW_PIT_CVALn - Current Timer Value Register
 * - HW_PIT_TCTRLn - Timer Control Register
 * - HW_PIT_TFLGn - Timer Flag Register
 *
 * - hw_pit_t - Struct containing all module registers.
 */

#define HW_PIT_INSTANCE_COUNT (1U) /*!< Number of instances of the PIT module. */
#define HW_PIT (0U) /*!< Instance number for PIT. */

/*******************************************************************************
 * HW_PIT_MCR - PIT Module Control Register
 ******************************************************************************/

/*!
 * @brief HW_PIT_MCR - PIT Module Control Register (RW)
 *
 * Reset value: 0x00000006U
 *
 * This register enables or disables the PIT timer clocks and controls the
 * timers when the PIT enters the Debug mode. Access: User read/write
 */
typedef union _hw_pit_mcr
{
    uint32_t U;
    struct _hw_pit_mcr_bitfields
    {
        uint32_t FRZ : 1;              /*!< [0] Freeze */
        uint32_t MDIS : 1;             /*!< [1] Module Disable - (PIT section) */
        uint32_t RESERVED0 : 30;       /*!< [31:2]  */
    } B;
} hw_pit_mcr_t;

/*!
 * @name Constants and macros for entire PIT_MCR register
 */
/*@{*/
#define HW_PIT_MCR_ADDR(x)       ((uint32_t)(x) + 0x0U)

#define HW_PIT_MCR(x)            (*(__IO hw_pit_mcr_t *) HW_PIT_MCR_ADDR(x))
#define HW_PIT_MCR_RD(x)         (HW_PIT_MCR(x).U)
#define HW_PIT_MCR_WR(x, v)      (HW_PIT_MCR(x).U = (v))
#define HW_PIT_MCR_SET(x, v)     (BME_OR32(HW_PIT_MCR_ADDR(x), (uint32_t)(v)))
#define HW_PIT_MCR_CLR(x, v)     (BME_AND32(HW_PIT_MCR_ADDR(x), (uint32_t)(~(v))))
#define HW_PIT_MCR_TOG(x, v)     (BME_XOR32(HW_PIT_MCR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual PIT_MCR bitfields
 */

/*!
 * @name Register PIT_MCR, field FRZ[0] (RW)
 *
 * Allows the timers to be stopped when the device enters the Debug mode.
 *
 * Values:
 * - 0 - Timers continue to run in Debug mode.
 * - 1 - Timers are stopped in Debug mode.
 */
/*@{*/
#define BP_PIT_MCR_FRZ       (0U)          /*!< Bit position for PIT_MCR_FRZ. */
#define BM_PIT_MCR_FRZ       (0x00000001U) /*!< Bit mask for PIT_MCR_FRZ. */
#define BS_PIT_MCR_FRZ       (1U)          /*!< Bit field size in bits for PIT_MCR_FRZ. */

/*! @brief Read current value of the PIT_MCR_FRZ field. */
#define BR_PIT_MCR_FRZ(x)    (BME_UBFX32(HW_PIT_MCR_ADDR(x), BP_PIT_MCR_FRZ, BS_PIT_MCR_FRZ))

/*! @brief Format value for bitfield PIT_MCR_FRZ. */
#define BF_PIT_MCR_FRZ(v)    ((uint32_t)((uint32_t)(v) << BP_PIT_MCR_FRZ) & BM_PIT_MCR_FRZ)

/*! @brief Set the FRZ field to a new value. */
#define BW_PIT_MCR_FRZ(x, v) (BME_BFI32(HW_PIT_MCR_ADDR(x), ((uint32_t)(v) << BP_PIT_MCR_FRZ), BP_PIT_MCR_FRZ, 1))
/*@}*/

/*!
 * @name Register PIT_MCR, field MDIS[1] (RW)
 *
 * Disables the standard timers. This field must be enabled before any other
 * setup is done.
 *
 * Values:
 * - 0 - Clock for standard PIT timers is enabled.
 * - 1 - Clock for standard PIT timers is disabled.
 */
/*@{*/
#define BP_PIT_MCR_MDIS      (1U)          /*!< Bit position for PIT_MCR_MDIS. */
#define BM_PIT_MCR_MDIS      (0x00000002U) /*!< Bit mask for PIT_MCR_MDIS. */
#define BS_PIT_MCR_MDIS      (1U)          /*!< Bit field size in bits for PIT_MCR_MDIS. */

/*! @brief Read current value of the PIT_MCR_MDIS field. */
#define BR_PIT_MCR_MDIS(x)   (BME_UBFX32(HW_PIT_MCR_ADDR(x), BP_PIT_MCR_MDIS, BS_PIT_MCR_MDIS))

/*! @brief Format value for bitfield PIT_MCR_MDIS. */
#define BF_PIT_MCR_MDIS(v)   ((uint32_t)((uint32_t)(v) << BP_PIT_MCR_MDIS) & BM_PIT_MCR_MDIS)

/*! @brief Set the MDIS field to a new value. */
#define BW_PIT_MCR_MDIS(x, v) (BME_BFI32(HW_PIT_MCR_ADDR(x), ((uint32_t)(v) << BP_PIT_MCR_MDIS), BP_PIT_MCR_MDIS, 1))
/*@}*/

/*******************************************************************************
 * HW_PIT_LTMR64H - PIT Upper Lifetime Timer Register
 ******************************************************************************/

/*!
 * @brief HW_PIT_LTMR64H - PIT Upper Lifetime Timer Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register is intended for applications that chain timer 0 and timer 1 to
 * build a 64-bit lifetimer. Access: User read only
 */
typedef union _hw_pit_ltmr64h
{
    uint32_t U;
    struct _hw_pit_ltmr64h_bitfields
    {
        uint32_t LTH : 32;             /*!< [31:0] Life Timer value */
    } B;
} hw_pit_ltmr64h_t;

/*!
 * @name Constants and macros for entire PIT_LTMR64H register
 */
/*@{*/
#define HW_PIT_LTMR64H_ADDR(x)   ((uint32_t)(x) + 0xE0U)

#define HW_PIT_LTMR64H(x)        (*(__I hw_pit_ltmr64h_t *) HW_PIT_LTMR64H_ADDR(x))
#define HW_PIT_LTMR64H_RD(x)     (HW_PIT_LTMR64H(x).U)
/*@}*/

/*
 * Constants & macros for individual PIT_LTMR64H bitfields
 */

/*!
 * @name Register PIT_LTMR64H, field LTH[31:0] (RO)
 *
 * Shows the timer value of timer 1. If this register is read at a time t1,
 * LTMR64L shows the value of timer 0 at time t1.
 */
/*@{*/
#define BP_PIT_LTMR64H_LTH   (0U)          /*!< Bit position for PIT_LTMR64H_LTH. */
#define BM_PIT_LTMR64H_LTH   (0xFFFFFFFFU) /*!< Bit mask for PIT_LTMR64H_LTH. */
#define BS_PIT_LTMR64H_LTH   (32U)         /*!< Bit field size in bits for PIT_LTMR64H_LTH. */

/*! @brief Read current value of the PIT_LTMR64H_LTH field. */
#define BR_PIT_LTMR64H_LTH(x) (HW_PIT_LTMR64H(x).U)
/*@}*/

/*******************************************************************************
 * HW_PIT_LTMR64L - PIT Lower Lifetime Timer Register
 ******************************************************************************/

/*!
 * @brief HW_PIT_LTMR64L - PIT Lower Lifetime Timer Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register is intended for applications that chain timer 0 and timer 1 to
 * build a 64-bit lifetimer. To use LTMR64H and LTMR64L, timer 0 and timer 1 need
 * to be chained. To obtain the correct value, first read LTMR64H and then
 * LTMR64L. LTMR64H will have the value of CVAL1 at the time of the first access,
 * LTMR64L will have the value of CVAL0 at the time of the first access, therefore
 * the application does not need to worry about carry-over effects of the running
 * counter. Access: User read only
 */
typedef union _hw_pit_ltmr64l
{
    uint32_t U;
    struct _hw_pit_ltmr64l_bitfields
    {
        uint32_t LTL : 32;             /*!< [31:0] Life Timer value */
    } B;
} hw_pit_ltmr64l_t;

/*!
 * @name Constants and macros for entire PIT_LTMR64L register
 */
/*@{*/
#define HW_PIT_LTMR64L_ADDR(x)   ((uint32_t)(x) + 0xE4U)

#define HW_PIT_LTMR64L(x)        (*(__I hw_pit_ltmr64l_t *) HW_PIT_LTMR64L_ADDR(x))
#define HW_PIT_LTMR64L_RD(x)     (HW_PIT_LTMR64L(x).U)
/*@}*/

/*
 * Constants & macros for individual PIT_LTMR64L bitfields
 */

/*!
 * @name Register PIT_LTMR64L, field LTL[31:0] (RO)
 *
 * Shows the value of timer 0 at the time LTMR64H was last read. It will only
 * update if LTMR64H is read.
 */
/*@{*/
#define BP_PIT_LTMR64L_LTL   (0U)          /*!< Bit position for PIT_LTMR64L_LTL. */
#define BM_PIT_LTMR64L_LTL   (0xFFFFFFFFU) /*!< Bit mask for PIT_LTMR64L_LTL. */
#define BS_PIT_LTMR64L_LTL   (32U)         /*!< Bit field size in bits for PIT_LTMR64L_LTL. */

/*! @brief Read current value of the PIT_LTMR64L_LTL field. */
#define BR_PIT_LTMR64L_LTL(x) (HW_PIT_LTMR64L(x).U)
/*@}*/

/*******************************************************************************
 * HW_PIT_LDVALn - Timer Load Value Register
 ******************************************************************************/

/*!
 * @brief HW_PIT_LDVALn - Timer Load Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers select the timeout period for the timer interrupts. Access:
 * User read/write
 */
typedef union _hw_pit_ldvaln
{
    uint32_t U;
    struct _hw_pit_ldvaln_bitfields
    {
        uint32_t TSV : 32;             /*!< [31:0] Timer Start Value */
    } B;
} hw_pit_ldvaln_t;

/*!
 * @name Constants and macros for entire PIT_LDVALn register
 */
/*@{*/
#define HW_PIT_LDVALn_COUNT (2U)

#define HW_PIT_LDVALn_ADDR(x, n) ((uint32_t)(x) + 0x100U + (0x10U * (n)))

#define HW_PIT_LDVALn(x, n)      (*(__IO hw_pit_ldvaln_t *) HW_PIT_LDVALn_ADDR(x, n))
#define HW_PIT_LDVALn_RD(x, n)   (HW_PIT_LDVALn(x, n).U)
#define HW_PIT_LDVALn_WR(x, n, v) (HW_PIT_LDVALn(x, n).U = (v))
#define HW_PIT_LDVALn_SET(x, n, v) (BME_OR32(HW_PIT_LDVALn_ADDR(x, n), (uint32_t)(v)))
#define HW_PIT_LDVALn_CLR(x, n, v) (BME_AND32(HW_PIT_LDVALn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_PIT_LDVALn_TOG(x, n, v) (BME_XOR32(HW_PIT_LDVALn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual PIT_LDVALn bitfields
 */

/*!
 * @name Register PIT_LDVALn, field TSV[31:0] (RW)
 *
 * Sets the timer start value. The timer will count down until it reaches 0,
 * then it will generate an interrupt and load this register value again. Writing a
 * new value to this register will not restart the timer; instead the value will
 * be loaded after the timer expires. To abort the current cycle and start a
 * timer period with the new value, the timer must be disabled and enabled again.
 */
/*@{*/
#define BP_PIT_LDVALn_TSV    (0U)          /*!< Bit position for PIT_LDVALn_TSV. */
#define BM_PIT_LDVALn_TSV    (0xFFFFFFFFU) /*!< Bit mask for PIT_LDVALn_TSV. */
#define BS_PIT_LDVALn_TSV    (32U)         /*!< Bit field size in bits for PIT_LDVALn_TSV. */

/*! @brief Read current value of the PIT_LDVALn_TSV field. */
#define BR_PIT_LDVALn_TSV(x, n) (HW_PIT_LDVALn(x, n).U)

/*! @brief Format value for bitfield PIT_LDVALn_TSV. */
#define BF_PIT_LDVALn_TSV(v) ((uint32_t)((uint32_t)(v) << BP_PIT_LDVALn_TSV) & BM_PIT_LDVALn_TSV)

/*! @brief Set the TSV field to a new value. */
#define BW_PIT_LDVALn_TSV(x, n, v) (HW_PIT_LDVALn_WR(x, n, v))
/*@}*/
/*******************************************************************************
 * HW_PIT_CVALn - Current Timer Value Register
 ******************************************************************************/

/*!
 * @brief HW_PIT_CVALn - Current Timer Value Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the current timer position. Access: User read only
 */
typedef union _hw_pit_cvaln
{
    uint32_t U;
    struct _hw_pit_cvaln_bitfields
    {
        uint32_t TVL : 32;             /*!< [31:0] Current Timer Value */
    } B;
} hw_pit_cvaln_t;

/*!
 * @name Constants and macros for entire PIT_CVALn register
 */
/*@{*/
#define HW_PIT_CVALn_COUNT (2U)

#define HW_PIT_CVALn_ADDR(x, n)  ((uint32_t)(x) + 0x104U + (0x10U * (n)))

#define HW_PIT_CVALn(x, n)       (*(__I hw_pit_cvaln_t *) HW_PIT_CVALn_ADDR(x, n))
#define HW_PIT_CVALn_RD(x, n)    (HW_PIT_CVALn(x, n).U)
/*@}*/

/*
 * Constants & macros for individual PIT_CVALn bitfields
 */

/*!
 * @name Register PIT_CVALn, field TVL[31:0] (RO)
 *
 * Represents the current timer value, if the timer is enabled. If the timer is
 * disabled, do not use this field as its value is unreliable. The timer uses a
 * downcounter. The timer values are frozen in Debug mode if MCR[FRZ] is set.
 */
/*@{*/
#define BP_PIT_CVALn_TVL     (0U)          /*!< Bit position for PIT_CVALn_TVL. */
#define BM_PIT_CVALn_TVL     (0xFFFFFFFFU) /*!< Bit mask for PIT_CVALn_TVL. */
#define BS_PIT_CVALn_TVL     (32U)         /*!< Bit field size in bits for PIT_CVALn_TVL. */

/*! @brief Read current value of the PIT_CVALn_TVL field. */
#define BR_PIT_CVALn_TVL(x, n) (HW_PIT_CVALn(x, n).U)
/*@}*/
/*******************************************************************************
 * HW_PIT_TCTRLn - Timer Control Register
 ******************************************************************************/

/*!
 * @brief HW_PIT_TCTRLn - Timer Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the control bits for each timer. Access: User
 * read/write
 */
typedef union _hw_pit_tctrln
{
    uint32_t U;
    struct _hw_pit_tctrln_bitfields
    {
        uint32_t TEN : 1;              /*!< [0] Timer Enable */
        uint32_t TIE : 1;              /*!< [1] Timer Interrupt Enable */
        uint32_t CHN : 1;              /*!< [2] Chain Mode */
        uint32_t RESERVED0 : 29;       /*!< [31:3]  */
    } B;
} hw_pit_tctrln_t;

/*!
 * @name Constants and macros for entire PIT_TCTRLn register
 */
/*@{*/
#define HW_PIT_TCTRLn_COUNT (2U)

#define HW_PIT_TCTRLn_ADDR(x, n) ((uint32_t)(x) + 0x108U + (0x10U * (n)))

#define HW_PIT_TCTRLn(x, n)      (*(__IO hw_pit_tctrln_t *) HW_PIT_TCTRLn_ADDR(x, n))
#define HW_PIT_TCTRLn_RD(x, n)   (HW_PIT_TCTRLn(x, n).U)
#define HW_PIT_TCTRLn_WR(x, n, v) (HW_PIT_TCTRLn(x, n).U = (v))
#define HW_PIT_TCTRLn_SET(x, n, v) (BME_OR32(HW_PIT_TCTRLn_ADDR(x, n), (uint32_t)(v)))
#define HW_PIT_TCTRLn_CLR(x, n, v) (BME_AND32(HW_PIT_TCTRLn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_PIT_TCTRLn_TOG(x, n, v) (BME_XOR32(HW_PIT_TCTRLn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual PIT_TCTRLn bitfields
 */

/*!
 * @name Register PIT_TCTRLn, field TEN[0] (RW)
 *
 * Enables or disables the timer.
 *
 * Values:
 * - 0 - Timer n is disabled.
 * - 1 - Timer n is enabled.
 */
/*@{*/
#define BP_PIT_TCTRLn_TEN    (0U)          /*!< Bit position for PIT_TCTRLn_TEN. */
#define BM_PIT_TCTRLn_TEN    (0x00000001U) /*!< Bit mask for PIT_TCTRLn_TEN. */
#define BS_PIT_TCTRLn_TEN    (1U)          /*!< Bit field size in bits for PIT_TCTRLn_TEN. */

/*! @brief Read current value of the PIT_TCTRLn_TEN field. */
#define BR_PIT_TCTRLn_TEN(x, n) (BME_UBFX32(HW_PIT_TCTRLn_ADDR(x, n), BP_PIT_TCTRLn_TEN, BS_PIT_TCTRLn_TEN))

/*! @brief Format value for bitfield PIT_TCTRLn_TEN. */
#define BF_PIT_TCTRLn_TEN(v) ((uint32_t)((uint32_t)(v) << BP_PIT_TCTRLn_TEN) & BM_PIT_TCTRLn_TEN)

/*! @brief Set the TEN field to a new value. */
#define BW_PIT_TCTRLn_TEN(x, n, v) (BME_BFI32(HW_PIT_TCTRLn_ADDR(x, n), ((uint32_t)(v) << BP_PIT_TCTRLn_TEN), BP_PIT_TCTRLn_TEN, 1))
/*@}*/

/*!
 * @name Register PIT_TCTRLn, field TIE[1] (RW)
 *
 * When an interrupt is pending, or, TFLGn[TIF] is set, enabling the interrupt
 * will immediately cause an interrupt event. To avoid this, the associated
 * TFLGn[TIF] must be cleared first.
 *
 * Values:
 * - 0 - Interrupt requests from Timer n are disabled.
 * - 1 - Interrupt will be requested whenever TIF is set.
 */
/*@{*/
#define BP_PIT_TCTRLn_TIE    (1U)          /*!< Bit position for PIT_TCTRLn_TIE. */
#define BM_PIT_TCTRLn_TIE    (0x00000002U) /*!< Bit mask for PIT_TCTRLn_TIE. */
#define BS_PIT_TCTRLn_TIE    (1U)          /*!< Bit field size in bits for PIT_TCTRLn_TIE. */

/*! @brief Read current value of the PIT_TCTRLn_TIE field. */
#define BR_PIT_TCTRLn_TIE(x, n) (BME_UBFX32(HW_PIT_TCTRLn_ADDR(x, n), BP_PIT_TCTRLn_TIE, BS_PIT_TCTRLn_TIE))

/*! @brief Format value for bitfield PIT_TCTRLn_TIE. */
#define BF_PIT_TCTRLn_TIE(v) ((uint32_t)((uint32_t)(v) << BP_PIT_TCTRLn_TIE) & BM_PIT_TCTRLn_TIE)

/*! @brief Set the TIE field to a new value. */
#define BW_PIT_TCTRLn_TIE(x, n, v) (BME_BFI32(HW_PIT_TCTRLn_ADDR(x, n), ((uint32_t)(v) << BP_PIT_TCTRLn_TIE), BP_PIT_TCTRLn_TIE, 1))
/*@}*/

/*!
 * @name Register PIT_TCTRLn, field CHN[2] (RW)
 *
 * When activated, Timer n-1 needs to expire before timer n can decrement by 1.
 * Timer 0 cannot be chained.
 *
 * Values:
 * - 0 - Timer is not chained.
 * - 1 - Timer is chained to previous timer. For example, for Channel 2, if this
 *     field is set, Timer 2 is chained to Timer 1.
 */
/*@{*/
#define BP_PIT_TCTRLn_CHN    (2U)          /*!< Bit position for PIT_TCTRLn_CHN. */
#define BM_PIT_TCTRLn_CHN    (0x00000004U) /*!< Bit mask for PIT_TCTRLn_CHN. */
#define BS_PIT_TCTRLn_CHN    (1U)          /*!< Bit field size in bits for PIT_TCTRLn_CHN. */

/*! @brief Read current value of the PIT_TCTRLn_CHN field. */
#define BR_PIT_TCTRLn_CHN(x, n) (BME_UBFX32(HW_PIT_TCTRLn_ADDR(x, n), BP_PIT_TCTRLn_CHN, BS_PIT_TCTRLn_CHN))

/*! @brief Format value for bitfield PIT_TCTRLn_CHN. */
#define BF_PIT_TCTRLn_CHN(v) ((uint32_t)((uint32_t)(v) << BP_PIT_TCTRLn_CHN) & BM_PIT_TCTRLn_CHN)

/*! @brief Set the CHN field to a new value. */
#define BW_PIT_TCTRLn_CHN(x, n, v) (BME_BFI32(HW_PIT_TCTRLn_ADDR(x, n), ((uint32_t)(v) << BP_PIT_TCTRLn_CHN), BP_PIT_TCTRLn_CHN, 1))
/*@}*/
/*******************************************************************************
 * HW_PIT_TFLGn - Timer Flag Register
 ******************************************************************************/

/*!
 * @brief HW_PIT_TFLGn - Timer Flag Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers hold the PIT interrupt flags. Access: User read/write
 */
typedef union _hw_pit_tflgn
{
    uint32_t U;
    struct _hw_pit_tflgn_bitfields
    {
        uint32_t TIF : 1;              /*!< [0] Timer Interrupt Flag */
        uint32_t RESERVED0 : 31;       /*!< [31:1]  */
    } B;
} hw_pit_tflgn_t;

/*!
 * @name Constants and macros for entire PIT_TFLGn register
 */
/*@{*/
#define HW_PIT_TFLGn_COUNT (2U)

#define HW_PIT_TFLGn_ADDR(x, n)  ((uint32_t)(x) + 0x10CU + (0x10U * (n)))

#define HW_PIT_TFLGn(x, n)       (*(__IO hw_pit_tflgn_t *) HW_PIT_TFLGn_ADDR(x, n))
#define HW_PIT_TFLGn_RD(x, n)    (HW_PIT_TFLGn(x, n).U)
#define HW_PIT_TFLGn_WR(x, n, v) (HW_PIT_TFLGn(x, n).U = (v))
#define HW_PIT_TFLGn_SET(x, n, v) (BME_OR32(HW_PIT_TFLGn_ADDR(x, n), (uint32_t)(v)))
#define HW_PIT_TFLGn_CLR(x, n, v) (BME_AND32(HW_PIT_TFLGn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_PIT_TFLGn_TOG(x, n, v) (BME_XOR32(HW_PIT_TFLGn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual PIT_TFLGn bitfields
 */

/*!
 * @name Register PIT_TFLGn, field TIF[0] (W1C)
 *
 * Sets to 1 at the end of the timer period. Writing 1 to this flag clears it.
 * Writing 0 has no effect. If enabled, or, when TCTRLn[TIE] = 1, TIF causes an
 * interrupt request.
 *
 * Values:
 * - 0 - Timeout has not yet occurred.
 * - 1 - Timeout has occurred.
 */
/*@{*/
#define BP_PIT_TFLGn_TIF     (0U)          /*!< Bit position for PIT_TFLGn_TIF. */
#define BM_PIT_TFLGn_TIF     (0x00000001U) /*!< Bit mask for PIT_TFLGn_TIF. */
#define BS_PIT_TFLGn_TIF     (1U)          /*!< Bit field size in bits for PIT_TFLGn_TIF. */

/*! @brief Read current value of the PIT_TFLGn_TIF field. */
#define BR_PIT_TFLGn_TIF(x, n) (BME_UBFX32(HW_PIT_TFLGn_ADDR(x, n), BP_PIT_TFLGn_TIF, BS_PIT_TFLGn_TIF))

/*! @brief Format value for bitfield PIT_TFLGn_TIF. */
#define BF_PIT_TFLGn_TIF(v)  ((uint32_t)((uint32_t)(v) << BP_PIT_TFLGn_TIF) & BM_PIT_TFLGn_TIF)

/*! @brief Set the TIF field to a new value. */
#define BW_PIT_TFLGn_TIF(x, n, v) (BME_BFI32(HW_PIT_TFLGn_ADDR(x, n), ((uint32_t)(v) << BP_PIT_TFLGn_TIF), BP_PIT_TFLGn_TIF, 1))
/*@}*/

/*******************************************************************************
 * hw_pit_t - module struct
 ******************************************************************************/
/*!
 * @brief All PIT module registers.
 */
#pragma pack(1)
typedef struct _hw_pit
{
    __IO hw_pit_mcr_t MCR;                 /*!< [0x0] PIT Module Control Register */
    uint8_t _reserved0[220];
    __I hw_pit_ltmr64h_t LTMR64H;          /*!< [0xE0] PIT Upper Lifetime Timer Register */
    __I hw_pit_ltmr64l_t LTMR64L;          /*!< [0xE4] PIT Lower Lifetime Timer Register */
    uint8_t _reserved1[24];
    struct {
        __IO hw_pit_ldvaln_t LDVALn;       /*!< [0x100] Timer Load Value Register */
        __I hw_pit_cvaln_t CVALn;          /*!< [0x104] Current Timer Value Register */
        __IO hw_pit_tctrln_t TCTRLn;       /*!< [0x108] Timer Control Register */
        __IO hw_pit_tflgn_t TFLGn;         /*!< [0x10C] Timer Flag Register */
    } CHANNEL[2];
} hw_pit_t;
#pragma pack()

/*! @brief Macro to access all PIT registers. */
/*! @param x PIT module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_PIT_REGS(PIT_BASE)</code>. */
#define HW_PIT_REGS(x) (*(hw_pit_t *)(x))

/*
 * MKL43Z4 PMC
 *
 * Power Management Controller
 *
 * Registers defined in this header file:
 * - HW_PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register
 * - HW_PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register
 * - HW_PMC_REGSC - Regulator Status And Control register
 *
 * - hw_pmc_t - Struct containing all module registers.
 */

#define HW_PMC_INSTANCE_COUNT (1U) /*!< Number of instances of the PMC module. */
#define HW_PMC (0U) /*!< Instance number for PMC. */

/*******************************************************************************
 * HW_PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register
 ******************************************************************************/

/*!
 * @brief HW_PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register (RW)
 *
 * Reset value: 0x10U
 *
 * This register contains status and control bits to support the low voltage
 * detect function. This register should be written during the reset initialization
 * program to set the desired controls even if the desired settings are the same
 * as the reset settings. While the device is in the very low power or low
 * leakage modes, the LVD system is disabled regardless of LVDSC1 settings. To protect
 * systems that must have LVD always on, configure the Power Mode Protection
 * (PMPROT) register of the SMC module (SMC_PMPROT) to disallow any very low power or
 * low leakage modes from being enabled. See the device's data sheet for the
 * exact LVD trip voltages. The LVDV bits are reset solely on a POR Only event. The
 * register's other bits are reset on Chip Reset Not VLLS. For more information
 * about these reset types, refer to the Reset section details.
 */
typedef union _hw_pmc_lvdsc1
{
    uint8_t U;
    struct _hw_pmc_lvdsc1_bitfields
    {
        uint8_t LVDV : 2;              /*!< [1:0] Low-Voltage Detect Voltage Select */
        uint8_t RESERVED0 : 2;         /*!< [3:2]  */
        uint8_t LVDRE : 1;             /*!< [4] Low-Voltage Detect Reset Enable */
        uint8_t LVDIE : 1;             /*!< [5] Low-Voltage Detect Interrupt Enable */
        uint8_t LVDACK : 1;            /*!< [6] Low-Voltage Detect Acknowledge */
        uint8_t LVDF : 1;              /*!< [7] Low-Voltage Detect Flag */
    } B;
} hw_pmc_lvdsc1_t;

/*!
 * @name Constants and macros for entire PMC_LVDSC1 register
 */
/*@{*/
#define HW_PMC_LVDSC1_ADDR(x)    ((uint32_t)(x) + 0x0U)

#define HW_PMC_LVDSC1(x)         (*(__IO hw_pmc_lvdsc1_t *) HW_PMC_LVDSC1_ADDR(x))
#define HW_PMC_LVDSC1_RD(x)      (HW_PMC_LVDSC1(x).U)
#define HW_PMC_LVDSC1_WR(x, v)   (HW_PMC_LVDSC1(x).U = (v))
#define HW_PMC_LVDSC1_SET(x, v)  (BME_OR8(HW_PMC_LVDSC1_ADDR(x), (uint8_t)(v)))
#define HW_PMC_LVDSC1_CLR(x, v)  (BME_AND8(HW_PMC_LVDSC1_ADDR(x), (uint8_t)(~(v))))
#define HW_PMC_LVDSC1_TOG(x, v)  (BME_XOR8(HW_PMC_LVDSC1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual PMC_LVDSC1 bitfields
 */

/*!
 * @name Register PMC_LVDSC1, field LVDV[1:0] (RW)
 *
 * Selects the LVD trip point voltage (V LVD ).
 *
 * Values:
 * - 00 - Low trip point selected (V LVD = V LVDL )
 * - 01 - High trip point selected (V LVD = V LVDH )
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
#define BP_PMC_LVDSC1_LVDV   (0U)          /*!< Bit position for PMC_LVDSC1_LVDV. */
#define BM_PMC_LVDSC1_LVDV   (0x03U)       /*!< Bit mask for PMC_LVDSC1_LVDV. */
#define BS_PMC_LVDSC1_LVDV   (2U)          /*!< Bit field size in bits for PMC_LVDSC1_LVDV. */

/*! @brief Read current value of the PMC_LVDSC1_LVDV field. */
#define BR_PMC_LVDSC1_LVDV(x) (BME_UBFX8(HW_PMC_LVDSC1_ADDR(x), BP_PMC_LVDSC1_LVDV, BS_PMC_LVDSC1_LVDV))

/*! @brief Format value for bitfield PMC_LVDSC1_LVDV. */
#define BF_PMC_LVDSC1_LVDV(v) ((uint8_t)((uint8_t)(v) << BP_PMC_LVDSC1_LVDV) & BM_PMC_LVDSC1_LVDV)

/*! @brief Set the LVDV field to a new value. */
#define BW_PMC_LVDSC1_LVDV(x, v) (BME_BFI8(HW_PMC_LVDSC1_ADDR(x), ((uint8_t)(v) << BP_PMC_LVDSC1_LVDV), BP_PMC_LVDSC1_LVDV, 2))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDRE[4] (RW)
 *
 * This write-once bit enables LVDF events to generate a hardware reset.
 * Additional writes are ignored.
 *
 * Values:
 * - 0 - LVDF does not generate hardware resets
 * - 1 - Force an MCU reset when LVDF = 1
 */
/*@{*/
#define BP_PMC_LVDSC1_LVDRE  (4U)          /*!< Bit position for PMC_LVDSC1_LVDRE. */
#define BM_PMC_LVDSC1_LVDRE  (0x10U)       /*!< Bit mask for PMC_LVDSC1_LVDRE. */
#define BS_PMC_LVDSC1_LVDRE  (1U)          /*!< Bit field size in bits for PMC_LVDSC1_LVDRE. */

/*! @brief Read current value of the PMC_LVDSC1_LVDRE field. */
#define BR_PMC_LVDSC1_LVDRE(x) (BME_UBFX8(HW_PMC_LVDSC1_ADDR(x), BP_PMC_LVDSC1_LVDRE, BS_PMC_LVDSC1_LVDRE))

/*! @brief Format value for bitfield PMC_LVDSC1_LVDRE. */
#define BF_PMC_LVDSC1_LVDRE(v) ((uint8_t)((uint8_t)(v) << BP_PMC_LVDSC1_LVDRE) & BM_PMC_LVDSC1_LVDRE)

/*! @brief Set the LVDRE field to a new value. */
#define BW_PMC_LVDSC1_LVDRE(x, v) (BME_BFI8(HW_PMC_LVDSC1_ADDR(x), ((uint8_t)(v) << BP_PMC_LVDSC1_LVDRE), BP_PMC_LVDSC1_LVDRE, 1))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDIE[5] (RW)
 *
 * Enables hardware interrupt requests for LVDF.
 *
 * Values:
 * - 0 - Hardware interrupt disabled (use polling)
 * - 1 - Request a hardware interrupt when LVDF = 1
 */
/*@{*/
#define BP_PMC_LVDSC1_LVDIE  (5U)          /*!< Bit position for PMC_LVDSC1_LVDIE. */
#define BM_PMC_LVDSC1_LVDIE  (0x20U)       /*!< Bit mask for PMC_LVDSC1_LVDIE. */
#define BS_PMC_LVDSC1_LVDIE  (1U)          /*!< Bit field size in bits for PMC_LVDSC1_LVDIE. */

/*! @brief Read current value of the PMC_LVDSC1_LVDIE field. */
#define BR_PMC_LVDSC1_LVDIE(x) (BME_UBFX8(HW_PMC_LVDSC1_ADDR(x), BP_PMC_LVDSC1_LVDIE, BS_PMC_LVDSC1_LVDIE))

/*! @brief Format value for bitfield PMC_LVDSC1_LVDIE. */
#define BF_PMC_LVDSC1_LVDIE(v) ((uint8_t)((uint8_t)(v) << BP_PMC_LVDSC1_LVDIE) & BM_PMC_LVDSC1_LVDIE)

/*! @brief Set the LVDIE field to a new value. */
#define BW_PMC_LVDSC1_LVDIE(x, v) (BME_BFI8(HW_PMC_LVDSC1_ADDR(x), ((uint8_t)(v) << BP_PMC_LVDSC1_LVDIE), BP_PMC_LVDSC1_LVDIE, 1))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDACK[6] (WORZ)
 *
 * This write-only field is used to acknowledge low voltage detection errors.
 * Write 1 to clear LVDF. Reads always return 0.
 */
/*@{*/
#define BP_PMC_LVDSC1_LVDACK (6U)          /*!< Bit position for PMC_LVDSC1_LVDACK. */
#define BM_PMC_LVDSC1_LVDACK (0x40U)       /*!< Bit mask for PMC_LVDSC1_LVDACK. */
#define BS_PMC_LVDSC1_LVDACK (1U)          /*!< Bit field size in bits for PMC_LVDSC1_LVDACK. */

/*! @brief Format value for bitfield PMC_LVDSC1_LVDACK. */
#define BF_PMC_LVDSC1_LVDACK(v) ((uint8_t)((uint8_t)(v) << BP_PMC_LVDSC1_LVDACK) & BM_PMC_LVDSC1_LVDACK)

/*! @brief Set the LVDACK field to a new value. */
#define BW_PMC_LVDSC1_LVDACK(x, v) (BME_BFI8(HW_PMC_LVDSC1_ADDR(x), ((uint8_t)(v) << BP_PMC_LVDSC1_LVDACK), BP_PMC_LVDSC1_LVDACK, 1))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDF[7] (RO)
 *
 * This read-only status field indicates a low-voltage detect event.
 *
 * Values:
 * - 0 - Low-voltage event not detected
 * - 1 - Low-voltage event detected
 */
/*@{*/
#define BP_PMC_LVDSC1_LVDF   (7U)          /*!< Bit position for PMC_LVDSC1_LVDF. */
#define BM_PMC_LVDSC1_LVDF   (0x80U)       /*!< Bit mask for PMC_LVDSC1_LVDF. */
#define BS_PMC_LVDSC1_LVDF   (1U)          /*!< Bit field size in bits for PMC_LVDSC1_LVDF. */

/*! @brief Read current value of the PMC_LVDSC1_LVDF field. */
#define BR_PMC_LVDSC1_LVDF(x) (BME_UBFX8(HW_PMC_LVDSC1_ADDR(x), BP_PMC_LVDSC1_LVDF, BS_PMC_LVDSC1_LVDF))
/*@}*/

/*******************************************************************************
 * HW_PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register
 ******************************************************************************/

/*!
 * @brief HW_PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains status and control bits to support the low voltage
 * warning function. While the device is in the very low power or low leakage modes,
 * the LVD system is disabled regardless of LVDSC2 settings. See the device's
 * data sheet for the exact LVD trip voltages. The LVW trip voltages depend on LVWV
 * and LVDV. LVWV is reset solely on a POR Only event. The other fields of the
 * register are reset on Chip Reset Not VLLS. For more information about these
 * reset types, refer to the Reset section details.
 */
typedef union _hw_pmc_lvdsc2
{
    uint8_t U;
    struct _hw_pmc_lvdsc2_bitfields
    {
        uint8_t LVWV : 2;              /*!< [1:0] Low-Voltage Warning Voltage Select */
        uint8_t RESERVED0 : 3;         /*!< [4:2]  */
        uint8_t LVWIE : 1;             /*!< [5] Low-Voltage Warning Interrupt Enable */
        uint8_t LVWACK : 1;            /*!< [6] Low-Voltage Warning Acknowledge */
        uint8_t LVWF : 1;              /*!< [7] Low-Voltage Warning Flag */
    } B;
} hw_pmc_lvdsc2_t;

/*!
 * @name Constants and macros for entire PMC_LVDSC2 register
 */
/*@{*/
#define HW_PMC_LVDSC2_ADDR(x)    ((uint32_t)(x) + 0x1U)

#define HW_PMC_LVDSC2(x)         (*(__IO hw_pmc_lvdsc2_t *) HW_PMC_LVDSC2_ADDR(x))
#define HW_PMC_LVDSC2_RD(x)      (HW_PMC_LVDSC2(x).U)
#define HW_PMC_LVDSC2_WR(x, v)   (HW_PMC_LVDSC2(x).U = (v))
#define HW_PMC_LVDSC2_SET(x, v)  (BME_OR8(HW_PMC_LVDSC2_ADDR(x), (uint8_t)(v)))
#define HW_PMC_LVDSC2_CLR(x, v)  (BME_AND8(HW_PMC_LVDSC2_ADDR(x), (uint8_t)(~(v))))
#define HW_PMC_LVDSC2_TOG(x, v)  (BME_XOR8(HW_PMC_LVDSC2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual PMC_LVDSC2 bitfields
 */

/*!
 * @name Register PMC_LVDSC2, field LVWV[1:0] (RW)
 *
 * Selects the LVW trip point voltage (VLVW). The actual voltage for the warning
 * depends on LVDSC1[LVDV].
 *
 * Values:
 * - 00 - Low trip point selected (VLVW = VLVW1)
 * - 01 - Mid 1 trip point selected (VLVW = VLVW2)
 * - 10 - Mid 2 trip point selected (VLVW = VLVW3)
 * - 11 - High trip point selected (VLVW = VLVW4)
 */
/*@{*/
#define BP_PMC_LVDSC2_LVWV   (0U)          /*!< Bit position for PMC_LVDSC2_LVWV. */
#define BM_PMC_LVDSC2_LVWV   (0x03U)       /*!< Bit mask for PMC_LVDSC2_LVWV. */
#define BS_PMC_LVDSC2_LVWV   (2U)          /*!< Bit field size in bits for PMC_LVDSC2_LVWV. */

/*! @brief Read current value of the PMC_LVDSC2_LVWV field. */
#define BR_PMC_LVDSC2_LVWV(x) (BME_UBFX8(HW_PMC_LVDSC2_ADDR(x), BP_PMC_LVDSC2_LVWV, BS_PMC_LVDSC2_LVWV))

/*! @brief Format value for bitfield PMC_LVDSC2_LVWV. */
#define BF_PMC_LVDSC2_LVWV(v) ((uint8_t)((uint8_t)(v) << BP_PMC_LVDSC2_LVWV) & BM_PMC_LVDSC2_LVWV)

/*! @brief Set the LVWV field to a new value. */
#define BW_PMC_LVDSC2_LVWV(x, v) (BME_BFI8(HW_PMC_LVDSC2_ADDR(x), ((uint8_t)(v) << BP_PMC_LVDSC2_LVWV), BP_PMC_LVDSC2_LVWV, 2))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWIE[5] (RW)
 *
 * Enables hardware interrupt requests for LVWF.
 *
 * Values:
 * - 0 - Hardware interrupt disabled (use polling)
 * - 1 - Request a hardware interrupt when LVWF = 1
 */
/*@{*/
#define BP_PMC_LVDSC2_LVWIE  (5U)          /*!< Bit position for PMC_LVDSC2_LVWIE. */
#define BM_PMC_LVDSC2_LVWIE  (0x20U)       /*!< Bit mask for PMC_LVDSC2_LVWIE. */
#define BS_PMC_LVDSC2_LVWIE  (1U)          /*!< Bit field size in bits for PMC_LVDSC2_LVWIE. */

/*! @brief Read current value of the PMC_LVDSC2_LVWIE field. */
#define BR_PMC_LVDSC2_LVWIE(x) (BME_UBFX8(HW_PMC_LVDSC2_ADDR(x), BP_PMC_LVDSC2_LVWIE, BS_PMC_LVDSC2_LVWIE))

/*! @brief Format value for bitfield PMC_LVDSC2_LVWIE. */
#define BF_PMC_LVDSC2_LVWIE(v) ((uint8_t)((uint8_t)(v) << BP_PMC_LVDSC2_LVWIE) & BM_PMC_LVDSC2_LVWIE)

/*! @brief Set the LVWIE field to a new value. */
#define BW_PMC_LVDSC2_LVWIE(x, v) (BME_BFI8(HW_PMC_LVDSC2_ADDR(x), ((uint8_t)(v) << BP_PMC_LVDSC2_LVWIE), BP_PMC_LVDSC2_LVWIE, 1))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWACK[6] (WORZ)
 *
 * This write-only field is used to acknowledge low voltage warning errors.
 * Write 1 to clear LVWF. Reads always return 0.
 */
/*@{*/
#define BP_PMC_LVDSC2_LVWACK (6U)          /*!< Bit position for PMC_LVDSC2_LVWACK. */
#define BM_PMC_LVDSC2_LVWACK (0x40U)       /*!< Bit mask for PMC_LVDSC2_LVWACK. */
#define BS_PMC_LVDSC2_LVWACK (1U)          /*!< Bit field size in bits for PMC_LVDSC2_LVWACK. */

/*! @brief Format value for bitfield PMC_LVDSC2_LVWACK. */
#define BF_PMC_LVDSC2_LVWACK(v) ((uint8_t)((uint8_t)(v) << BP_PMC_LVDSC2_LVWACK) & BM_PMC_LVDSC2_LVWACK)

/*! @brief Set the LVWACK field to a new value. */
#define BW_PMC_LVDSC2_LVWACK(x, v) (BME_BFI8(HW_PMC_LVDSC2_ADDR(x), ((uint8_t)(v) << BP_PMC_LVDSC2_LVWACK), BP_PMC_LVDSC2_LVWACK, 1))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWF[7] (RO)
 *
 * This read-only status field indicates a low-voltage warning event. LVWF is
 * set when VSupply transitions below the trip point, or after reset and VSupply is
 * already below VLVW. LVWF may be 1 after power-on reset, therefore, to use LVW
 * interrupt function, before enabling LVWIE, LVWF must be cleared by writing
 * LVWACK first.
 *
 * Values:
 * - 0 - Low-voltage warning event not detected
 * - 1 - Low-voltage warning event detected
 */
/*@{*/
#define BP_PMC_LVDSC2_LVWF   (7U)          /*!< Bit position for PMC_LVDSC2_LVWF. */
#define BM_PMC_LVDSC2_LVWF   (0x80U)       /*!< Bit mask for PMC_LVDSC2_LVWF. */
#define BS_PMC_LVDSC2_LVWF   (1U)          /*!< Bit field size in bits for PMC_LVDSC2_LVWF. */

/*! @brief Read current value of the PMC_LVDSC2_LVWF field. */
#define BR_PMC_LVDSC2_LVWF(x) (BME_UBFX8(HW_PMC_LVDSC2_ADDR(x), BP_PMC_LVDSC2_LVWF, BS_PMC_LVDSC2_LVWF))
/*@}*/

/*******************************************************************************
 * HW_PMC_REGSC - Regulator Status And Control register
 ******************************************************************************/

/*!
 * @brief HW_PMC_REGSC - Regulator Status And Control register (RW)
 *
 * Reset value: 0x04U
 *
 * The PMC contains an internal voltage regulator. The voltage regulator design
 * uses a bandgap reference that is also available through a buffer as input to
 * certain internal peripherals, such as the CMP and ADC. The internal regulator
 * provides a status bit (REGONS) indicating the regulator is in run regulation.
 * This register is reset on Chip Reset Not VLLS and by reset types that trigger
 * Chip Reset not VLLS. See the Reset section details for more information.
 */
typedef union _hw_pmc_regsc
{
    uint8_t U;
    struct _hw_pmc_regsc_bitfields
    {
        uint8_t BGBE : 1;              /*!< [0] Bandgap Buffer Enable */
        uint8_t RESERVED0 : 1;         /*!< [1]  */
        uint8_t REGONS : 1;            /*!< [2] Regulator In Run Regulation Status */
        uint8_t ACKISO : 1;            /*!< [3] Acknowledge Isolation */
        uint8_t BGEN : 1;              /*!< [4] Bandgap Enable In VLPx Operation */
        uint8_t RESERVED1 : 3;         /*!< [7:5]  */
    } B;
} hw_pmc_regsc_t;

/*!
 * @name Constants and macros for entire PMC_REGSC register
 */
/*@{*/
#define HW_PMC_REGSC_ADDR(x)     ((uint32_t)(x) + 0x2U)

#define HW_PMC_REGSC(x)          (*(__IO hw_pmc_regsc_t *) HW_PMC_REGSC_ADDR(x))
#define HW_PMC_REGSC_RD(x)       (HW_PMC_REGSC(x).U)
#define HW_PMC_REGSC_WR(x, v)    (HW_PMC_REGSC(x).U = (v))
#define HW_PMC_REGSC_SET(x, v)   (BME_OR8(HW_PMC_REGSC_ADDR(x), (uint8_t)(v)))
#define HW_PMC_REGSC_CLR(x, v)   (BME_AND8(HW_PMC_REGSC_ADDR(x), (uint8_t)(~(v))))
#define HW_PMC_REGSC_TOG(x, v)   (BME_XOR8(HW_PMC_REGSC_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual PMC_REGSC bitfields
 */

/*!
 * @name Register PMC_REGSC, field BGBE[0] (RW)
 *
 * Enables the bandgap buffer.
 *
 * Values:
 * - 0 - Bandgap buffer not enabled
 * - 1 - Bandgap buffer enabled
 */
/*@{*/
#define BP_PMC_REGSC_BGBE    (0U)          /*!< Bit position for PMC_REGSC_BGBE. */
#define BM_PMC_REGSC_BGBE    (0x01U)       /*!< Bit mask for PMC_REGSC_BGBE. */
#define BS_PMC_REGSC_BGBE    (1U)          /*!< Bit field size in bits for PMC_REGSC_BGBE. */

/*! @brief Read current value of the PMC_REGSC_BGBE field. */
#define BR_PMC_REGSC_BGBE(x) (BME_UBFX8(HW_PMC_REGSC_ADDR(x), BP_PMC_REGSC_BGBE, BS_PMC_REGSC_BGBE))

/*! @brief Format value for bitfield PMC_REGSC_BGBE. */
#define BF_PMC_REGSC_BGBE(v) ((uint8_t)((uint8_t)(v) << BP_PMC_REGSC_BGBE) & BM_PMC_REGSC_BGBE)

/*! @brief Set the BGBE field to a new value. */
#define BW_PMC_REGSC_BGBE(x, v) (BME_BFI8(HW_PMC_REGSC_ADDR(x), ((uint8_t)(v) << BP_PMC_REGSC_BGBE), BP_PMC_REGSC_BGBE, 1))
/*@}*/

/*!
 * @name Register PMC_REGSC, field REGONS[2] (RO)
 *
 * This read-only field provides the current status of the internal voltage
 * regulator.
 *
 * Values:
 * - 0 - Regulator is in stop regulation or in transition to/from it
 * - 1 - Regulator is in run regulation
 */
/*@{*/
#define BP_PMC_REGSC_REGONS  (2U)          /*!< Bit position for PMC_REGSC_REGONS. */
#define BM_PMC_REGSC_REGONS  (0x04U)       /*!< Bit mask for PMC_REGSC_REGONS. */
#define BS_PMC_REGSC_REGONS  (1U)          /*!< Bit field size in bits for PMC_REGSC_REGONS. */

/*! @brief Read current value of the PMC_REGSC_REGONS field. */
#define BR_PMC_REGSC_REGONS(x) (BME_UBFX8(HW_PMC_REGSC_ADDR(x), BP_PMC_REGSC_REGONS, BS_PMC_REGSC_REGONS))
/*@}*/

/*!
 * @name Register PMC_REGSC, field ACKISO[3] (W1C)
 *
 * Reading this field indicates whether certain peripherals and the I/O pads are
 * in a latched state as a result of having been in a VLLS mode. Writing 1 to
 * this field when it is set releases the I/O pads and certain peripherals to their
 * normal run mode state. After recovering from a VLLS mode, user should restore
 * chip configuration before clearing ACKISO. In particular, pin configuration
 * for enabled LLWU wakeup pins should be restored to avoid any LLWU flag from
 * being falsely set when ACKISO is cleared.
 *
 * Values:
 * - 0 - Peripherals and I/O pads are in normal run state.
 * - 1 - Certain peripherals and I/O pads are in an isolated and latched state.
 */
/*@{*/
#define BP_PMC_REGSC_ACKISO  (3U)          /*!< Bit position for PMC_REGSC_ACKISO. */
#define BM_PMC_REGSC_ACKISO  (0x08U)       /*!< Bit mask for PMC_REGSC_ACKISO. */
#define BS_PMC_REGSC_ACKISO  (1U)          /*!< Bit field size in bits for PMC_REGSC_ACKISO. */

/*! @brief Read current value of the PMC_REGSC_ACKISO field. */
#define BR_PMC_REGSC_ACKISO(x) (BME_UBFX8(HW_PMC_REGSC_ADDR(x), BP_PMC_REGSC_ACKISO, BS_PMC_REGSC_ACKISO))

/*! @brief Format value for bitfield PMC_REGSC_ACKISO. */
#define BF_PMC_REGSC_ACKISO(v) ((uint8_t)((uint8_t)(v) << BP_PMC_REGSC_ACKISO) & BM_PMC_REGSC_ACKISO)

/*! @brief Set the ACKISO field to a new value. */
#define BW_PMC_REGSC_ACKISO(x, v) (BME_BFI8(HW_PMC_REGSC_ADDR(x), ((uint8_t)(v) << BP_PMC_REGSC_ACKISO), BP_PMC_REGSC_ACKISO, 1))
/*@}*/

/*!
 * @name Register PMC_REGSC, field BGEN[4] (RW)
 *
 * BGEN controls whether the bandgap is enabled in lower power modes of
 * operation (VLPx, LLS, and VLLSx). When on-chip peripherals require the bandgap voltage
 * reference in low power modes of operation, set BGEN to continue to enable the
 * bandgap operation. When the bandgap voltage reference is not needed in low
 * power modes, clear BGEN to avoid excess power consumption.
 *
 * Values:
 * - 0 - Bandgap voltage reference is disabled in VLPx , LLS , and VLLSx modes.
 * - 1 - Bandgap voltage reference is enabled in VLPx , LLS , and VLLSx modes.
 */
/*@{*/
#define BP_PMC_REGSC_BGEN    (4U)          /*!< Bit position for PMC_REGSC_BGEN. */
#define BM_PMC_REGSC_BGEN    (0x10U)       /*!< Bit mask for PMC_REGSC_BGEN. */
#define BS_PMC_REGSC_BGEN    (1U)          /*!< Bit field size in bits for PMC_REGSC_BGEN. */

/*! @brief Read current value of the PMC_REGSC_BGEN field. */
#define BR_PMC_REGSC_BGEN(x) (BME_UBFX8(HW_PMC_REGSC_ADDR(x), BP_PMC_REGSC_BGEN, BS_PMC_REGSC_BGEN))

/*! @brief Format value for bitfield PMC_REGSC_BGEN. */
#define BF_PMC_REGSC_BGEN(v) ((uint8_t)((uint8_t)(v) << BP_PMC_REGSC_BGEN) & BM_PMC_REGSC_BGEN)

/*! @brief Set the BGEN field to a new value. */
#define BW_PMC_REGSC_BGEN(x, v) (BME_BFI8(HW_PMC_REGSC_ADDR(x), ((uint8_t)(v) << BP_PMC_REGSC_BGEN), BP_PMC_REGSC_BGEN, 1))
/*@}*/

/*******************************************************************************
 * hw_pmc_t - module struct
 ******************************************************************************/
/*!
 * @brief All PMC module registers.
 */
#pragma pack(1)
typedef struct _hw_pmc
{
    __IO hw_pmc_lvdsc1_t LVDSC1;           /*!< [0x0] Low Voltage Detect Status And Control 1 register */
    __IO hw_pmc_lvdsc2_t LVDSC2;           /*!< [0x1] Low Voltage Detect Status And Control 2 register */
    __IO hw_pmc_regsc_t REGSC;             /*!< [0x2] Regulator Status And Control register */
} hw_pmc_t;
#pragma pack()

/*! @brief Macro to access all PMC registers. */
/*! @param x PMC module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_PMC_REGS(PMC_BASE)</code>. */
#define HW_PMC_REGS(x) (*(hw_pmc_t *)(x))

/*
 * MKL43Z4 PORT
 *
 * Pin Control and Interrupts
 *
 * Registers defined in this header file:
 * - HW_PORT_PCRn - Pin Control Register n
 * - HW_PORT_GPCLR - Global Pin Control Low Register
 * - HW_PORT_GPCHR - Global Pin Control High Register
 * - HW_PORT_ISFR - Interrupt Status Flag Register
 *
 * - hw_port_t - Struct containing all module registers.
 */

#define HW_PORT_INSTANCE_COUNT (5U) /*!< Number of instances of the PORT module. */
#define HW_PORTA (0U) /*!< Instance number for PORTA. */
#define HW_PORTB (1U) /*!< Instance number for PORTB. */
#define HW_PORTC (2U) /*!< Instance number for PORTC. */
#define HW_PORTD (3U) /*!< Instance number for PORTD. */
#define HW_PORTE (4U) /*!< Instance number for PORTE. */

/*******************************************************************************
 * HW_PORT_PCRn - Pin Control Register n
 ******************************************************************************/

/*!
 * @brief HW_PORT_PCRn - Pin Control Register n (RW)
 *
 * Reset value: 0x00000706U
 *
 * See the Signal Multiplexing and Pin Assignment chapter for the reset value of
 * this device. See the GPIO Configuration section for details on the available
 * functions for each pin. Do not modify pin configuration registers associated
 * with pins not available in your selected package. All unbonded pins not
 * available in your package will default to DISABLE state for lowest power consumption.
 */
typedef union _hw_port_pcrn
{
    uint32_t U;
    struct _hw_port_pcrn_bitfields
    {
        uint32_t PS : 1;               /*!< [0] Pull Select */
        uint32_t PE : 1;               /*!< [1] Pull Enable */
        uint32_t SRE : 1;              /*!< [2] Slew Rate Enable */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t PFE : 1;              /*!< [4] Passive Filter Enable */
        uint32_t RESERVED1 : 1;        /*!< [5]  */
        uint32_t DSE : 1;              /*!< [6] Drive Strength Enable */
        uint32_t RESERVED2 : 1;        /*!< [7]  */
        uint32_t MUX : 3;              /*!< [10:8] Pin Mux Control */
        uint32_t RESERVED3 : 5;        /*!< [15:11]  */
        uint32_t IRQC : 4;             /*!< [19:16] Interrupt Configuration */
        uint32_t RESERVED4 : 4;        /*!< [23:20]  */
        uint32_t ISF : 1;              /*!< [24] Interrupt Status Flag */
        uint32_t RESERVED5 : 7;        /*!< [31:25]  */
    } B;
} hw_port_pcrn_t;

/*!
 * @name Constants and macros for entire PORT_PCRn register
 */
/*@{*/
#define HW_PORT_PCRn_COUNT (32U)

#define HW_PORT_PCRn_ADDR(x, n)  ((uint32_t)(x) + 0x0U + (0x4U * (n)))

#define HW_PORT_PCRn(x, n)       (*(__IO hw_port_pcrn_t *) HW_PORT_PCRn_ADDR(x, n))
#define HW_PORT_PCRn_RD(x, n)    (HW_PORT_PCRn(x, n).U)
#define HW_PORT_PCRn_WR(x, n, v) (HW_PORT_PCRn(x, n).U = (v))
#define HW_PORT_PCRn_SET(x, n, v) (BME_OR32(HW_PORT_PCRn_ADDR(x, n), (uint32_t)(v)))
#define HW_PORT_PCRn_CLR(x, n, v) (BME_AND32(HW_PORT_PCRn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_PORT_PCRn_TOG(x, n, v) (BME_XOR32(HW_PORT_PCRn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual PORT_PCRn bitfields
 */

/*!
 * @name Register PORT_PCRn, field PS[0] (RW)
 *
 * This bit is read only for pins that do not support a configurable pull
 * resistor direction. Pull configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Internal pulldown resistor is enabled on the corresponding pin, if the
 *     corresponding PE field is set.
 * - 1 - Internal pullup resistor is enabled on the corresponding pin, if the
 *     corresponding PE field is set.
 */
/*@{*/
#define BP_PORT_PCRn_PS      (0U)          /*!< Bit position for PORT_PCRn_PS. */
#define BM_PORT_PCRn_PS      (0x00000001U) /*!< Bit mask for PORT_PCRn_PS. */
#define BS_PORT_PCRn_PS      (1U)          /*!< Bit field size in bits for PORT_PCRn_PS. */

/*! @brief Read current value of the PORT_PCRn_PS field. */
#define BR_PORT_PCRn_PS(x, n) (BME_UBFX32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_PS, BS_PORT_PCRn_PS))

/*! @brief Format value for bitfield PORT_PCRn_PS. */
#define BF_PORT_PCRn_PS(v)   ((uint32_t)((uint32_t)(v) << BP_PORT_PCRn_PS) & BM_PORT_PCRn_PS)

/*! @brief Set the PS field to a new value. */
#define BW_PORT_PCRn_PS(x, n, v) (BME_BFI32(HW_PORT_PCRn_ADDR(x, n), ((uint32_t)(v) << BP_PORT_PCRn_PS), BP_PORT_PCRn_PS, 1))
/*@}*/

/*!
 * @name Register PORT_PCRn, field PE[1] (RW)
 *
 * This field is read-only for pins that do not support a configurable pull
 * resistor. Refer to the Chapter of Signal Multiplexing and Signal Descriptions for
 * the pins that support a configurable pull resistor. Pull configuration is
 * valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Internal pullup or pulldown resistor is not enabled on the
 *     corresponding pin.
 * - 1 - Internal pullup or pulldown resistor is enabled on the corresponding
 *     pin, if the pin is configured as a digital input.
 */
/*@{*/
#define BP_PORT_PCRn_PE      (1U)          /*!< Bit position for PORT_PCRn_PE. */
#define BM_PORT_PCRn_PE      (0x00000002U) /*!< Bit mask for PORT_PCRn_PE. */
#define BS_PORT_PCRn_PE      (1U)          /*!< Bit field size in bits for PORT_PCRn_PE. */

/*! @brief Read current value of the PORT_PCRn_PE field. */
#define BR_PORT_PCRn_PE(x, n) (BME_UBFX32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_PE, BS_PORT_PCRn_PE))

/*! @brief Format value for bitfield PORT_PCRn_PE. */
#define BF_PORT_PCRn_PE(v)   ((uint32_t)((uint32_t)(v) << BP_PORT_PCRn_PE) & BM_PORT_PCRn_PE)

/*! @brief Set the PE field to a new value. */
#define BW_PORT_PCRn_PE(x, n, v) (BME_BFI32(HW_PORT_PCRn_ADDR(x, n), ((uint32_t)(v) << BP_PORT_PCRn_PE), BP_PORT_PCRn_PE, 1))
/*@}*/

/*!
 * @name Register PORT_PCRn, field SRE[2] (RW)
 *
 * This field is read-only for pins that do not support a configurable slew
 * rate. Slew rate configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Fast slew rate is configured on the corresponding pin, if the pin is
 *     configured as a digital output.
 * - 1 - Slow slew rate is configured on the corresponding pin, if the pin is
 *     configured as a digital output.
 */
/*@{*/
#define BP_PORT_PCRn_SRE     (2U)          /*!< Bit position for PORT_PCRn_SRE. */
#define BM_PORT_PCRn_SRE     (0x00000004U) /*!< Bit mask for PORT_PCRn_SRE. */
#define BS_PORT_PCRn_SRE     (1U)          /*!< Bit field size in bits for PORT_PCRn_SRE. */

/*! @brief Read current value of the PORT_PCRn_SRE field. */
#define BR_PORT_PCRn_SRE(x, n) (BME_UBFX32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_SRE, BS_PORT_PCRn_SRE))

/*! @brief Format value for bitfield PORT_PCRn_SRE. */
#define BF_PORT_PCRn_SRE(v)  ((uint32_t)((uint32_t)(v) << BP_PORT_PCRn_SRE) & BM_PORT_PCRn_SRE)

/*! @brief Set the SRE field to a new value. */
#define BW_PORT_PCRn_SRE(x, n, v) (BME_BFI32(HW_PORT_PCRn_ADDR(x, n), ((uint32_t)(v) << BP_PORT_PCRn_SRE), BP_PORT_PCRn_SRE, 1))
/*@}*/

/*!
 * @name Register PORT_PCRn, field PFE[4] (RW)
 *
 * This field is read-only for pins that do not support a configurable passive
 * input filter. Passive filter configuration is valid in all digital pin muxing
 * modes.
 *
 * Values:
 * - 0 - Passive input filter is disabled on the corresponding pin.
 * - 1 - Passive input filter is enabled on the corresponding pin, if the pin is
 *     configured as a digital input. Refer to the device data sheet for filter
 *     characteristics.
 */
/*@{*/
#define BP_PORT_PCRn_PFE     (4U)          /*!< Bit position for PORT_PCRn_PFE. */
#define BM_PORT_PCRn_PFE     (0x00000010U) /*!< Bit mask for PORT_PCRn_PFE. */
#define BS_PORT_PCRn_PFE     (1U)          /*!< Bit field size in bits for PORT_PCRn_PFE. */

/*! @brief Read current value of the PORT_PCRn_PFE field. */
#define BR_PORT_PCRn_PFE(x, n) (BME_UBFX32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_PFE, BS_PORT_PCRn_PFE))

/*! @brief Format value for bitfield PORT_PCRn_PFE. */
#define BF_PORT_PCRn_PFE(v)  ((uint32_t)((uint32_t)(v) << BP_PORT_PCRn_PFE) & BM_PORT_PCRn_PFE)

/*! @brief Set the PFE field to a new value. */
#define BW_PORT_PCRn_PFE(x, n, v) (BME_BFI32(HW_PORT_PCRn_ADDR(x, n), ((uint32_t)(v) << BP_PORT_PCRn_PFE), BP_PORT_PCRn_PFE, 1))
/*@}*/

/*!
 * @name Register PORT_PCRn, field DSE[6] (RW)
 *
 * This field is read-only for pins that do not support a configurable drive
 * strength. Drive strength configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Low drive strength is configured on the corresponding pin, if pin is
 *     configured as a digital output.
 * - 1 - High drive strength is configured on the corresponding pin, if pin is
 *     configured as a digital output.
 */
/*@{*/
#define BP_PORT_PCRn_DSE     (6U)          /*!< Bit position for PORT_PCRn_DSE. */
#define BM_PORT_PCRn_DSE     (0x00000040U) /*!< Bit mask for PORT_PCRn_DSE. */
#define BS_PORT_PCRn_DSE     (1U)          /*!< Bit field size in bits for PORT_PCRn_DSE. */

/*! @brief Read current value of the PORT_PCRn_DSE field. */
#define BR_PORT_PCRn_DSE(x, n) (BME_UBFX32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_DSE, BS_PORT_PCRn_DSE))

/*! @brief Format value for bitfield PORT_PCRn_DSE. */
#define BF_PORT_PCRn_DSE(v)  ((uint32_t)((uint32_t)(v) << BP_PORT_PCRn_DSE) & BM_PORT_PCRn_DSE)

/*! @brief Set the DSE field to a new value. */
#define BW_PORT_PCRn_DSE(x, n, v) (BME_BFI32(HW_PORT_PCRn_ADDR(x, n), ((uint32_t)(v) << BP_PORT_PCRn_DSE), BP_PORT_PCRn_DSE, 1))
/*@}*/

/*!
 * @name Register PORT_PCRn, field MUX[10:8] (RW)
 *
 * Not all pins support all pin muxing slots. Unimplemented pin muxing slots are
 * reserved and may result in configuring the pin for a different pin muxing
 * slot. The corresponding pin is configured in the following pin muxing slot as
 * follows:
 *
 * Values:
 * - 000 - Pin disabled (analog).
 * - 001 - Alternative 1 (GPIO).
 * - 010 - Alternative 2 (chip-specific).
 * - 011 - Alternative 3 (chip-specific).
 * - 100 - Alternative 4 (chip-specific).
 * - 101 - Alternative 5 (chip-specific).
 * - 110 - Alternative 6 (chip-specific).
 * - 111 - Alternative 7 (chip-specific).
 */
/*@{*/
#define BP_PORT_PCRn_MUX     (8U)          /*!< Bit position for PORT_PCRn_MUX. */
#define BM_PORT_PCRn_MUX     (0x00000700U) /*!< Bit mask for PORT_PCRn_MUX. */
#define BS_PORT_PCRn_MUX     (3U)          /*!< Bit field size in bits for PORT_PCRn_MUX. */

/*! @brief Read current value of the PORT_PCRn_MUX field. */
#define BR_PORT_PCRn_MUX(x, n) (BME_UBFX32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_MUX, BS_PORT_PCRn_MUX))

/*! @brief Format value for bitfield PORT_PCRn_MUX. */
#define BF_PORT_PCRn_MUX(v)  ((uint32_t)((uint32_t)(v) << BP_PORT_PCRn_MUX) & BM_PORT_PCRn_MUX)

/*! @brief Set the MUX field to a new value. */
#define BW_PORT_PCRn_MUX(x, n, v) (BME_BFI32(HW_PORT_PCRn_ADDR(x, n), ((uint32_t)(v) << BP_PORT_PCRn_MUX), BP_PORT_PCRn_MUX, 3))
/*@}*/

/*!
 * @name Register PORT_PCRn, field IRQC[19:16] (RW)
 *
 * This field is read-only for pins that do not support interrupt generation.
 * The pin interrupt configuration is valid in all digital pin muxing modes. The
 * corresponding pin is configured to generate interrupt/DMA request as follows:
 *
 * Values:
 * - 0000 - Interrupt/DMA request disabled.
 * - 0001 - DMA request on rising edge.
 * - 0010 - DMA request on falling edge.
 * - 0011 - DMA request on either edge.
 * - 1000 - Interrupt when logic 0.
 * - 1001 - Interrupt on rising-edge.
 * - 1010 - Interrupt on falling-edge.
 * - 1011 - Interrupt on either edge.
 * - 1100 - Interrupt when logic 1.
 */
/*@{*/
#define BP_PORT_PCRn_IRQC    (16U)         /*!< Bit position for PORT_PCRn_IRQC. */
#define BM_PORT_PCRn_IRQC    (0x000F0000U) /*!< Bit mask for PORT_PCRn_IRQC. */
#define BS_PORT_PCRn_IRQC    (4U)          /*!< Bit field size in bits for PORT_PCRn_IRQC. */

/*! @brief Read current value of the PORT_PCRn_IRQC field. */
#define BR_PORT_PCRn_IRQC(x, n) (BME_UBFX32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_IRQC, BS_PORT_PCRn_IRQC))

/*! @brief Format value for bitfield PORT_PCRn_IRQC. */
#define BF_PORT_PCRn_IRQC(v) ((uint32_t)((uint32_t)(v) << BP_PORT_PCRn_IRQC) & BM_PORT_PCRn_IRQC)

/*! @brief Set the IRQC field to a new value. */
#define BW_PORT_PCRn_IRQC(x, n, v) (BME_BFI32(HW_PORT_PCRn_ADDR(x, n), ((uint32_t)(v) << BP_PORT_PCRn_IRQC), BP_PORT_PCRn_IRQC, 4))
/*@}*/

/*!
 * @name Register PORT_PCRn, field ISF[24] (W1C)
 *
 * This field is read-only for pins that do not support interrupt generation.
 * The pin interrupt configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Configured interrupt is not detected.
 * - 1 - Configured interrupt is detected. If the pin is configured to generate
 *     a DMA request, then the corresponding flag will be cleared automatically
 *     at the completion of the requested DMA transfer. Otherwise, the flag
 *     remains set until a logic 1 is written to the flag. If the pin is configured for
 *     a level sensitive interrupt and the pin remains asserted, then the flag
 *     is set again immediately after it is cleared.
 */
/*@{*/
#define BP_PORT_PCRn_ISF     (24U)         /*!< Bit position for PORT_PCRn_ISF. */
#define BM_PORT_PCRn_ISF     (0x01000000U) /*!< Bit mask for PORT_PCRn_ISF. */
#define BS_PORT_PCRn_ISF     (1U)          /*!< Bit field size in bits for PORT_PCRn_ISF. */

/*! @brief Read current value of the PORT_PCRn_ISF field. */
#define BR_PORT_PCRn_ISF(x, n) (BME_UBFX32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_ISF, BS_PORT_PCRn_ISF))

/*! @brief Format value for bitfield PORT_PCRn_ISF. */
#define BF_PORT_PCRn_ISF(v)  ((uint32_t)((uint32_t)(v) << BP_PORT_PCRn_ISF) & BM_PORT_PCRn_ISF)

/*! @brief Set the ISF field to a new value. */
#define BW_PORT_PCRn_ISF(x, n, v) (BME_BFI32(HW_PORT_PCRn_ADDR(x, n), ((uint32_t)(v) << BP_PORT_PCRn_ISF), BP_PORT_PCRn_ISF, 1))
/*@}*/

/*******************************************************************************
 * HW_PORT_GPCLR - Global Pin Control Low Register
 ******************************************************************************/

/*!
 * @brief HW_PORT_GPCLR - Global Pin Control Low Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
typedef union _hw_port_gpclr
{
    uint32_t U;
    struct _hw_port_gpclr_bitfields
    {
        uint32_t GPWD : 16;            /*!< [15:0] Global Pin Write Data */
        uint32_t GPWE : 16;            /*!< [31:16] Global Pin Write Enable */
    } B;
} hw_port_gpclr_t;

/*!
 * @name Constants and macros for entire PORT_GPCLR register
 */
/*@{*/
#define HW_PORT_GPCLR_ADDR(x)    ((uint32_t)(x) + 0x80U)

#define HW_PORT_GPCLR(x)         (*(__O hw_port_gpclr_t *) HW_PORT_GPCLR_ADDR(x))
#define HW_PORT_GPCLR_RD(x)      (HW_PORT_GPCLR(x).U)
#define HW_PORT_GPCLR_WR(x, v)   (HW_PORT_GPCLR(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual PORT_GPCLR bitfields
 */

/*!
 * @name Register PORT_GPCLR, field GPWD[15:0] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [15:0] that are
 * selected by GPWE.
 */
/*@{*/
#define BP_PORT_GPCLR_GPWD   (0U)          /*!< Bit position for PORT_GPCLR_GPWD. */
#define BM_PORT_GPCLR_GPWD   (0x0000FFFFU) /*!< Bit mask for PORT_GPCLR_GPWD. */
#define BS_PORT_GPCLR_GPWD   (16U)         /*!< Bit field size in bits for PORT_GPCLR_GPWD. */

/*! @brief Format value for bitfield PORT_GPCLR_GPWD. */
#define BF_PORT_GPCLR_GPWD(v) ((uint32_t)((uint32_t)(v) << BP_PORT_GPCLR_GPWD) & BM_PORT_GPCLR_GPWD)

/*! @brief Set the GPWD field to a new value. */
#define BW_PORT_GPCLR_GPWD(x, v) (BME_BFI32(HW_PORT_GPCLR_ADDR(x), ((uint32_t)(v) << BP_PORT_GPCLR_GPWD), BP_PORT_GPCLR_GPWD, 16))
/*@}*/

/*!
 * @name Register PORT_GPCLR, field GPWE[31:16] (WORZ)
 *
 * Selects which Pin Control Registers (15 through 0) bits [15:0] update with
 * the value in GPWD.
 *
 * Values:
 * - 0 - Corresponding Pin Control Register is not updated with the value in
 *     GPWD.
 * - 1 - Corresponding Pin Control Register is updated with the value in GPWD.
 */
/*@{*/
#define BP_PORT_GPCLR_GPWE   (16U)         /*!< Bit position for PORT_GPCLR_GPWE. */
#define BM_PORT_GPCLR_GPWE   (0xFFFF0000U) /*!< Bit mask for PORT_GPCLR_GPWE. */
#define BS_PORT_GPCLR_GPWE   (16U)         /*!< Bit field size in bits for PORT_GPCLR_GPWE. */

/*! @brief Format value for bitfield PORT_GPCLR_GPWE. */
#define BF_PORT_GPCLR_GPWE(v) ((uint32_t)((uint32_t)(v) << BP_PORT_GPCLR_GPWE) & BM_PORT_GPCLR_GPWE)

/*! @brief Set the GPWE field to a new value. */
#define BW_PORT_GPCLR_GPWE(x, v) (BME_BFI32(HW_PORT_GPCLR_ADDR(x), ((uint32_t)(v) << BP_PORT_GPCLR_GPWE), BP_PORT_GPCLR_GPWE, 16))
/*@}*/

/*******************************************************************************
 * HW_PORT_GPCHR - Global Pin Control High Register
 ******************************************************************************/

/*!
 * @brief HW_PORT_GPCHR - Global Pin Control High Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
typedef union _hw_port_gpchr
{
    uint32_t U;
    struct _hw_port_gpchr_bitfields
    {
        uint32_t GPWD : 16;            /*!< [15:0] Global Pin Write Data */
        uint32_t GPWE : 16;            /*!< [31:16] Global Pin Write Enable */
    } B;
} hw_port_gpchr_t;

/*!
 * @name Constants and macros for entire PORT_GPCHR register
 */
/*@{*/
#define HW_PORT_GPCHR_ADDR(x)    ((uint32_t)(x) + 0x84U)

#define HW_PORT_GPCHR(x)         (*(__O hw_port_gpchr_t *) HW_PORT_GPCHR_ADDR(x))
#define HW_PORT_GPCHR_RD(x)      (HW_PORT_GPCHR(x).U)
#define HW_PORT_GPCHR_WR(x, v)   (HW_PORT_GPCHR(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual PORT_GPCHR bitfields
 */

/*!
 * @name Register PORT_GPCHR, field GPWD[15:0] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [15:0] that are
 * selected by GPWE.
 */
/*@{*/
#define BP_PORT_GPCHR_GPWD   (0U)          /*!< Bit position for PORT_GPCHR_GPWD. */
#define BM_PORT_GPCHR_GPWD   (0x0000FFFFU) /*!< Bit mask for PORT_GPCHR_GPWD. */
#define BS_PORT_GPCHR_GPWD   (16U)         /*!< Bit field size in bits for PORT_GPCHR_GPWD. */

/*! @brief Format value for bitfield PORT_GPCHR_GPWD. */
#define BF_PORT_GPCHR_GPWD(v) ((uint32_t)((uint32_t)(v) << BP_PORT_GPCHR_GPWD) & BM_PORT_GPCHR_GPWD)

/*! @brief Set the GPWD field to a new value. */
#define BW_PORT_GPCHR_GPWD(x, v) (BME_BFI32(HW_PORT_GPCHR_ADDR(x), ((uint32_t)(v) << BP_PORT_GPCHR_GPWD), BP_PORT_GPCHR_GPWD, 16))
/*@}*/

/*!
 * @name Register PORT_GPCHR, field GPWE[31:16] (WORZ)
 *
 * Selects which Pin Control Registers (31 through 16) bits [15:0] update with
 * the value in GPWD.
 *
 * Values:
 * - 0 - Corresponding Pin Control Register is not updated with the value in
 *     GPWD.
 * - 1 - Corresponding Pin Control Register is updated with the value in GPWD.
 */
/*@{*/
#define BP_PORT_GPCHR_GPWE   (16U)         /*!< Bit position for PORT_GPCHR_GPWE. */
#define BM_PORT_GPCHR_GPWE   (0xFFFF0000U) /*!< Bit mask for PORT_GPCHR_GPWE. */
#define BS_PORT_GPCHR_GPWE   (16U)         /*!< Bit field size in bits for PORT_GPCHR_GPWE. */

/*! @brief Format value for bitfield PORT_GPCHR_GPWE. */
#define BF_PORT_GPCHR_GPWE(v) ((uint32_t)((uint32_t)(v) << BP_PORT_GPCHR_GPWE) & BM_PORT_GPCHR_GPWE)

/*! @brief Set the GPWE field to a new value. */
#define BW_PORT_GPCHR_GPWE(x, v) (BME_BFI32(HW_PORT_GPCHR_ADDR(x), ((uint32_t)(v) << BP_PORT_GPCHR_GPWE), BP_PORT_GPCHR_GPWE, 16))
/*@}*/

/*******************************************************************************
 * HW_PORT_ISFR - Interrupt Status Flag Register
 ******************************************************************************/

/*!
 * @brief HW_PORT_ISFR - Interrupt Status Flag Register (W1C)
 *
 * Reset value: 0x00000000U
 *
 * The corresponding bit is read only for pins that do not support interrupt
 * generation. The pin interrupt configuration is valid in all digital pin muxing
 * modes. The Interrupt Status Flag for each pin is also visible in the
 * corresponding Pin Control Register, and each flag can be cleared in either location.
 */
typedef union _hw_port_isfr
{
    uint32_t U;
    struct _hw_port_isfr_bitfields
    {
        uint32_t ISF : 32;             /*!< [31:0] Interrupt Status Flag */
    } B;
} hw_port_isfr_t;

/*!
 * @name Constants and macros for entire PORT_ISFR register
 */
/*@{*/
#define HW_PORT_ISFR_ADDR(x)     ((uint32_t)(x) + 0xA0U)

#define HW_PORT_ISFR(x)          (*(__IO hw_port_isfr_t *) HW_PORT_ISFR_ADDR(x))
#define HW_PORT_ISFR_RD(x)       (HW_PORT_ISFR(x).U)
#define HW_PORT_ISFR_WR(x, v)    (HW_PORT_ISFR(x).U = (v))
#define HW_PORT_ISFR_SET(x, v)   (BME_OR32(HW_PORT_ISFR_ADDR(x), (uint32_t)(v)))
#define HW_PORT_ISFR_CLR(x, v)   (BME_AND32(HW_PORT_ISFR_ADDR(x), (uint32_t)(~(v))))
#define HW_PORT_ISFR_TOG(x, v)   (BME_XOR32(HW_PORT_ISFR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual PORT_ISFR bitfields
 */

/*!
 * @name Register PORT_ISFR, field ISF[31:0] (W1C)
 *
 * Each bit in the field indicates the detection of the configured interrupt of
 * the same number as the field.
 *
 * Values:
 * - 0 - Configured interrupt is not detected.
 * - 1 - Configured interrupt is detected. If the pin is configured to generate
 *     a DMA request, then the corresponding flag will be cleared automatically
 *     at the completion of the requested DMA transfer. Otherwise, the flag
 *     remains set until a logic 1 is written to the flag. If the pin is configured for
 *     a level sensitive interrupt and the pin remains asserted, then the flag
 *     is set again immediately after it is cleared.
 */
/*@{*/
#define BP_PORT_ISFR_ISF     (0U)          /*!< Bit position for PORT_ISFR_ISF. */
#define BM_PORT_ISFR_ISF     (0xFFFFFFFFU) /*!< Bit mask for PORT_ISFR_ISF. */
#define BS_PORT_ISFR_ISF     (32U)         /*!< Bit field size in bits for PORT_ISFR_ISF. */

/*! @brief Read current value of the PORT_ISFR_ISF field. */
#define BR_PORT_ISFR_ISF(x)  (HW_PORT_ISFR(x).U)

/*! @brief Format value for bitfield PORT_ISFR_ISF. */
#define BF_PORT_ISFR_ISF(v)  ((uint32_t)((uint32_t)(v) << BP_PORT_ISFR_ISF) & BM_PORT_ISFR_ISF)

/*! @brief Set the ISF field to a new value. */
#define BW_PORT_ISFR_ISF(x, v) (HW_PORT_ISFR_WR(x, v))
/*@}*/

/*******************************************************************************
 * hw_port_t - module struct
 ******************************************************************************/
/*!
 * @brief All PORT module registers.
 */
#pragma pack(1)
typedef struct _hw_port
{
    __IO hw_port_pcrn_t PCRn[32];          /*!< [0x0] Pin Control Register n */
    __O hw_port_gpclr_t GPCLR;             /*!< [0x80] Global Pin Control Low Register */
    __O hw_port_gpchr_t GPCHR;             /*!< [0x84] Global Pin Control High Register */
    uint8_t _reserved0[24];
    __IO hw_port_isfr_t ISFR;              /*!< [0xA0] Interrupt Status Flag Register */
} hw_port_t;
#pragma pack()

/*! @brief Macro to access all PORT registers. */
/*! @param x PORT module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_PORT_REGS(PORTA_BASE)</code>. */
#define HW_PORT_REGS(x) (*(hw_port_t *)(x))

/*
 * MKL43Z4 RCM
 *
 * Reset Control Module
 *
 * Registers defined in this header file:
 * - HW_RCM_SRS0 - System Reset Status Register 0
 * - HW_RCM_SRS1 - System Reset Status Register 1
 * - HW_RCM_RPFC - Reset Pin Filter Control register
 * - HW_RCM_RPFW - Reset Pin Filter Width register
 * - HW_RCM_FM - Force Mode Register
 * - HW_RCM_MR - Mode Register
 * - HW_RCM_SSRS0 - Sticky System Reset Status Register 0
 * - HW_RCM_SSRS1 - Sticky System Reset Status Register 1
 *
 * - hw_rcm_t - Struct containing all module registers.
 */

#define HW_RCM_INSTANCE_COUNT (1U) /*!< Number of instances of the RCM module. */
#define HW_RCM (0U) /*!< Instance number for RCM. */

/*******************************************************************************
 * HW_RCM_SRS0 - System Reset Status Register 0
 ******************************************************************************/

/*!
 * @brief HW_RCM_SRS0 - System Reset Status Register 0 (RO)
 *
 * Reset value: 0x82U
 *
 * This register includes read-only status flags to indicate the source of the
 * most recent reset. The reset state of these bits depends on what caused the MCU
 * to reset. The reset value of this register depends on the reset source: POR
 * (including LVD) - 0x82 LVD (without POR) - 0x02 VLLS mode wakeup due to RESET
 * pin assertion - 0x41 VLLS mode wakeup due to other wakeup sources - 0x01 Other
 * reset - a bit is set if its corresponding reset source caused the reset
 */
typedef union _hw_rcm_srs0
{
    uint8_t U;
    struct _hw_rcm_srs0_bitfields
    {
        uint8_t WAKEUP : 1;            /*!< [0] Low Leakage Wakeup Reset */
        uint8_t LVD : 1;               /*!< [1] Low-Voltage Detect Reset */
        uint8_t RESERVED0 : 3;         /*!< [4:2]  */
        uint8_t WDOG : 1;              /*!< [5] Watchdog */
        uint8_t PIN : 1;               /*!< [6] External Reset Pin */
        uint8_t POR : 1;               /*!< [7] Power-On Reset */
    } B;
} hw_rcm_srs0_t;

/*!
 * @name Constants and macros for entire RCM_SRS0 register
 */
/*@{*/
#define HW_RCM_SRS0_ADDR(x)      ((uint32_t)(x) + 0x0U)

#define HW_RCM_SRS0(x)           (*(__I hw_rcm_srs0_t *) HW_RCM_SRS0_ADDR(x))
#define HW_RCM_SRS0_RD(x)        (HW_RCM_SRS0(x).U)
/*@}*/

/*
 * Constants & macros for individual RCM_SRS0 bitfields
 */

/*!
 * @name Register RCM_SRS0, field WAKEUP[0] (RO)
 *
 * Indicates a reset has been caused by an enabled LLWU module wakeup source
 * while the chip was in a low leakage mode. In LLS mode, the RESET pin is the only
 * wakeup source that can cause this reset. Any enabled wakeup source in a VLLSx
 * mode causes a reset. This bit is cleared by any reset except WAKEUP.
 *
 * Values:
 * - 0 - Reset not caused by LLWU module wakeup source
 * - 1 - Reset caused by LLWU module wakeup source
 */
/*@{*/
#define BP_RCM_SRS0_WAKEUP   (0U)          /*!< Bit position for RCM_SRS0_WAKEUP. */
#define BM_RCM_SRS0_WAKEUP   (0x01U)       /*!< Bit mask for RCM_SRS0_WAKEUP. */
#define BS_RCM_SRS0_WAKEUP   (1U)          /*!< Bit field size in bits for RCM_SRS0_WAKEUP. */

/*! @brief Read current value of the RCM_SRS0_WAKEUP field. */
#define BR_RCM_SRS0_WAKEUP(x) (BME_UBFX8(HW_RCM_SRS0_ADDR(x), BP_RCM_SRS0_WAKEUP, BS_RCM_SRS0_WAKEUP))
/*@}*/

/*!
 * @name Register RCM_SRS0, field LVD[1] (RO)
 *
 * If PMC_LVDSC1[LVDRE] is set and the supply drops below the LVD trip voltage,
 * an LVD reset occurs. This field is also set by POR.
 *
 * Values:
 * - 0 - Reset not caused by LVD trip or POR
 * - 1 - Reset caused by LVD trip or POR
 */
/*@{*/
#define BP_RCM_SRS0_LVD      (1U)          /*!< Bit position for RCM_SRS0_LVD. */
#define BM_RCM_SRS0_LVD      (0x02U)       /*!< Bit mask for RCM_SRS0_LVD. */
#define BS_RCM_SRS0_LVD      (1U)          /*!< Bit field size in bits for RCM_SRS0_LVD. */

/*! @brief Read current value of the RCM_SRS0_LVD field. */
#define BR_RCM_SRS0_LVD(x)   (BME_UBFX8(HW_RCM_SRS0_ADDR(x), BP_RCM_SRS0_LVD, BS_RCM_SRS0_LVD))
/*@}*/

/*!
 * @name Register RCM_SRS0, field WDOG[5] (RO)
 *
 * Indicates a reset has been caused by the watchdog timer timing out. This
 * reset source can be blocked by disabling the watchdog.
 *
 * Values:
 * - 0 - Reset not caused by watchdog timeout
 * - 1 - Reset caused by watchdog timeout
 */
/*@{*/
#define BP_RCM_SRS0_WDOG     (5U)          /*!< Bit position for RCM_SRS0_WDOG. */
#define BM_RCM_SRS0_WDOG     (0x20U)       /*!< Bit mask for RCM_SRS0_WDOG. */
#define BS_RCM_SRS0_WDOG     (1U)          /*!< Bit field size in bits for RCM_SRS0_WDOG. */

/*! @brief Read current value of the RCM_SRS0_WDOG field. */
#define BR_RCM_SRS0_WDOG(x)  (BME_UBFX8(HW_RCM_SRS0_ADDR(x), BP_RCM_SRS0_WDOG, BS_RCM_SRS0_WDOG))
/*@}*/

/*!
 * @name Register RCM_SRS0, field PIN[6] (RO)
 *
 * Indicates a reset has been caused by an active-low level on the external
 * RESET pin.
 *
 * Values:
 * - 0 - Reset not caused by external reset pin
 * - 1 - Reset caused by external reset pin
 */
/*@{*/
#define BP_RCM_SRS0_PIN      (6U)          /*!< Bit position for RCM_SRS0_PIN. */
#define BM_RCM_SRS0_PIN      (0x40U)       /*!< Bit mask for RCM_SRS0_PIN. */
#define BS_RCM_SRS0_PIN      (1U)          /*!< Bit field size in bits for RCM_SRS0_PIN. */

/*! @brief Read current value of the RCM_SRS0_PIN field. */
#define BR_RCM_SRS0_PIN(x)   (BME_UBFX8(HW_RCM_SRS0_ADDR(x), BP_RCM_SRS0_PIN, BS_RCM_SRS0_PIN))
/*@}*/

/*!
 * @name Register RCM_SRS0, field POR[7] (RO)
 *
 * Indicates a reset has been caused by the power-on detection logic. Because
 * the internal supply voltage was ramping up at the time, the low-voltage reset
 * (LVD) status bit is also set to indicate that the reset occurred while the
 * internal supply was below the LVD threshold.
 *
 * Values:
 * - 0 - Reset not caused by POR
 * - 1 - Reset caused by POR
 */
/*@{*/
#define BP_RCM_SRS0_POR      (7U)          /*!< Bit position for RCM_SRS0_POR. */
#define BM_RCM_SRS0_POR      (0x80U)       /*!< Bit mask for RCM_SRS0_POR. */
#define BS_RCM_SRS0_POR      (1U)          /*!< Bit field size in bits for RCM_SRS0_POR. */

/*! @brief Read current value of the RCM_SRS0_POR field. */
#define BR_RCM_SRS0_POR(x)   (BME_UBFX8(HW_RCM_SRS0_ADDR(x), BP_RCM_SRS0_POR, BS_RCM_SRS0_POR))
/*@}*/

/*******************************************************************************
 * HW_RCM_SRS1 - System Reset Status Register 1
 ******************************************************************************/

/*!
 * @brief HW_RCM_SRS1 - System Reset Status Register 1 (RO)
 *
 * Reset value: 0x00U
 *
 * This register includes read-only status flags to indicate the source of the
 * most recent reset. The reset state of these bits depends on what caused the MCU
 * to reset. The reset value of this register depends on the reset source: POR
 * (including LVD) - 0x00 LVD (without POR) - 0x00 VLLS mode wakeup - 0x00 Other
 * reset - a bit is set if its corresponding reset source caused the reset
 */
typedef union _hw_rcm_srs1
{
    uint8_t U;
    struct _hw_rcm_srs1_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t LOCKUP : 1;            /*!< [1] Core Lockup */
        uint8_t SW : 1;                /*!< [2] Software */
        uint8_t MDM_AP : 1;            /*!< [3] MDM-AP System Reset Request */
        uint8_t RESERVED1 : 1;         /*!< [4]  */
        uint8_t SACKERR : 1;           /*!< [5] Stop Mode Acknowledge Error Reset */
        uint8_t RESERVED2 : 2;         /*!< [7:6]  */
    } B;
} hw_rcm_srs1_t;

/*!
 * @name Constants and macros for entire RCM_SRS1 register
 */
/*@{*/
#define HW_RCM_SRS1_ADDR(x)      ((uint32_t)(x) + 0x1U)

#define HW_RCM_SRS1(x)           (*(__I hw_rcm_srs1_t *) HW_RCM_SRS1_ADDR(x))
#define HW_RCM_SRS1_RD(x)        (HW_RCM_SRS1(x).U)
/*@}*/

/*
 * Constants & macros for individual RCM_SRS1 bitfields
 */

/*!
 * @name Register RCM_SRS1, field LOCKUP[1] (RO)
 *
 * Indicates a reset has been caused by the ARM core indication of a LOCKUP
 * event.
 *
 * Values:
 * - 0 - Reset not caused by core LOCKUP event
 * - 1 - Reset caused by core LOCKUP event
 */
/*@{*/
#define BP_RCM_SRS1_LOCKUP   (1U)          /*!< Bit position for RCM_SRS1_LOCKUP. */
#define BM_RCM_SRS1_LOCKUP   (0x02U)       /*!< Bit mask for RCM_SRS1_LOCKUP. */
#define BS_RCM_SRS1_LOCKUP   (1U)          /*!< Bit field size in bits for RCM_SRS1_LOCKUP. */

/*! @brief Read current value of the RCM_SRS1_LOCKUP field. */
#define BR_RCM_SRS1_LOCKUP(x) (BME_UBFX8(HW_RCM_SRS1_ADDR(x), BP_RCM_SRS1_LOCKUP, BS_RCM_SRS1_LOCKUP))
/*@}*/

/*!
 * @name Register RCM_SRS1, field SW[2] (RO)
 *
 * Indicates a reset has been caused by software setting of SYSRESETREQ bit in
 * Application Interrupt and Reset Control Register in the ARM core.
 *
 * Values:
 * - 0 - Reset not caused by software setting of SYSRESETREQ bit
 * - 1 - Reset caused by software setting of SYSRESETREQ bit
 */
/*@{*/
#define BP_RCM_SRS1_SW       (2U)          /*!< Bit position for RCM_SRS1_SW. */
#define BM_RCM_SRS1_SW       (0x04U)       /*!< Bit mask for RCM_SRS1_SW. */
#define BS_RCM_SRS1_SW       (1U)          /*!< Bit field size in bits for RCM_SRS1_SW. */

/*! @brief Read current value of the RCM_SRS1_SW field. */
#define BR_RCM_SRS1_SW(x)    (BME_UBFX8(HW_RCM_SRS1_ADDR(x), BP_RCM_SRS1_SW, BS_RCM_SRS1_SW))
/*@}*/

/*!
 * @name Register RCM_SRS1, field MDM_AP[3] (RO)
 *
 * Indicates a reset has been caused by the host debugger system setting of the
 * System Reset Request bit in the MDM-AP Control Register.
 *
 * Values:
 * - 0 - Reset not caused by host debugger system setting of the System Reset
 *     Request bit
 * - 1 - Reset caused by host debugger system setting of the System Reset
 *     Request bit
 */
/*@{*/
#define BP_RCM_SRS1_MDM_AP   (3U)          /*!< Bit position for RCM_SRS1_MDM_AP. */
#define BM_RCM_SRS1_MDM_AP   (0x08U)       /*!< Bit mask for RCM_SRS1_MDM_AP. */
#define BS_RCM_SRS1_MDM_AP   (1U)          /*!< Bit field size in bits for RCM_SRS1_MDM_AP. */

/*! @brief Read current value of the RCM_SRS1_MDM_AP field. */
#define BR_RCM_SRS1_MDM_AP(x) (BME_UBFX8(HW_RCM_SRS1_ADDR(x), BP_RCM_SRS1_MDM_AP, BS_RCM_SRS1_MDM_AP))
/*@}*/

/*!
 * @name Register RCM_SRS1, field SACKERR[5] (RO)
 *
 * Indicates that after an attempt to enter Stop mode, a reset has been caused
 * by a failure of one or more peripherals to acknowledge within approximately one
 * second to enter stop mode.
 *
 * Values:
 * - 0 - Reset not caused by peripheral failure to acknowledge attempt to enter
 *     stop mode
 * - 1 - Reset caused by peripheral failure to acknowledge attempt to enter stop
 *     mode
 */
/*@{*/
#define BP_RCM_SRS1_SACKERR  (5U)          /*!< Bit position for RCM_SRS1_SACKERR. */
#define BM_RCM_SRS1_SACKERR  (0x20U)       /*!< Bit mask for RCM_SRS1_SACKERR. */
#define BS_RCM_SRS1_SACKERR  (1U)          /*!< Bit field size in bits for RCM_SRS1_SACKERR. */

/*! @brief Read current value of the RCM_SRS1_SACKERR field. */
#define BR_RCM_SRS1_SACKERR(x) (BME_UBFX8(HW_RCM_SRS1_ADDR(x), BP_RCM_SRS1_SACKERR, BS_RCM_SRS1_SACKERR))
/*@}*/

/*******************************************************************************
 * HW_RCM_RPFC - Reset Pin Filter Control register
 ******************************************************************************/

/*!
 * @brief HW_RCM_RPFC - Reset Pin Filter Control register (RW)
 *
 * Reset value: 0x00U
 *
 * The reset values of bits 2-0 are for Chip POR only. They are unaffected by
 * other reset types. The bus clock filter is reset when disabled or when entering
 * stop mode. The LPO filter is reset when disabled .
 */
typedef union _hw_rcm_rpfc
{
    uint8_t U;
    struct _hw_rcm_rpfc_bitfields
    {
        uint8_t RSTFLTSRW : 2;         /*!< [1:0] Reset Pin Filter Select in Run and
                                        * Wait Modes */
        uint8_t RSTFLTSS : 1;          /*!< [2] Reset Pin Filter Select in Stop Mode */
        uint8_t RESERVED0 : 5;         /*!< [7:3]  */
    } B;
} hw_rcm_rpfc_t;

/*!
 * @name Constants and macros for entire RCM_RPFC register
 */
/*@{*/
#define HW_RCM_RPFC_ADDR(x)      ((uint32_t)(x) + 0x4U)

#define HW_RCM_RPFC(x)           (*(__IO hw_rcm_rpfc_t *) HW_RCM_RPFC_ADDR(x))
#define HW_RCM_RPFC_RD(x)        (HW_RCM_RPFC(x).U)
#define HW_RCM_RPFC_WR(x, v)     (HW_RCM_RPFC(x).U = (v))
#define HW_RCM_RPFC_SET(x, v)    (BME_OR8(HW_RCM_RPFC_ADDR(x), (uint8_t)(v)))
#define HW_RCM_RPFC_CLR(x, v)    (BME_AND8(HW_RCM_RPFC_ADDR(x), (uint8_t)(~(v))))
#define HW_RCM_RPFC_TOG(x, v)    (BME_XOR8(HW_RCM_RPFC_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual RCM_RPFC bitfields
 */

/*!
 * @name Register RCM_RPFC, field RSTFLTSRW[1:0] (RW)
 *
 * Selects how the reset pin filter is enabled in run and wait modes.
 *
 * Values:
 * - 00 - All filtering disabled
 * - 01 - Bus clock filter enabled for normal operation
 * - 10 - LPO clock filter enabled for normal operation
 * - 11 - Reserved
 */
/*@{*/
#define BP_RCM_RPFC_RSTFLTSRW (0U)         /*!< Bit position for RCM_RPFC_RSTFLTSRW. */
#define BM_RCM_RPFC_RSTFLTSRW (0x03U)      /*!< Bit mask for RCM_RPFC_RSTFLTSRW. */
#define BS_RCM_RPFC_RSTFLTSRW (2U)         /*!< Bit field size in bits for RCM_RPFC_RSTFLTSRW. */

/*! @brief Read current value of the RCM_RPFC_RSTFLTSRW field. */
#define BR_RCM_RPFC_RSTFLTSRW(x) (BME_UBFX8(HW_RCM_RPFC_ADDR(x), BP_RCM_RPFC_RSTFLTSRW, BS_RCM_RPFC_RSTFLTSRW))

/*! @brief Format value for bitfield RCM_RPFC_RSTFLTSRW. */
#define BF_RCM_RPFC_RSTFLTSRW(v) ((uint8_t)((uint8_t)(v) << BP_RCM_RPFC_RSTFLTSRW) & BM_RCM_RPFC_RSTFLTSRW)

/*! @brief Set the RSTFLTSRW field to a new value. */
#define BW_RCM_RPFC_RSTFLTSRW(x, v) (BME_BFI8(HW_RCM_RPFC_ADDR(x), ((uint8_t)(v) << BP_RCM_RPFC_RSTFLTSRW), BP_RCM_RPFC_RSTFLTSRW, 2))
/*@}*/

/*!
 * @name Register RCM_RPFC, field RSTFLTSS[2] (RW)
 *
 * Selects how the reset pin filter is enabled in Stop and VLPS modes , and also
 * during LLS and VLLS modes. On exit from VLLS mode, this bit should be
 * reconfigured before clearing PMC_REGSC[ACKISO].
 *
 * Values:
 * - 0 - All filtering disabled
 * - 1 - LPO clock filter enabled
 */
/*@{*/
#define BP_RCM_RPFC_RSTFLTSS (2U)          /*!< Bit position for RCM_RPFC_RSTFLTSS. */
#define BM_RCM_RPFC_RSTFLTSS (0x04U)       /*!< Bit mask for RCM_RPFC_RSTFLTSS. */
#define BS_RCM_RPFC_RSTFLTSS (1U)          /*!< Bit field size in bits for RCM_RPFC_RSTFLTSS. */

/*! @brief Read current value of the RCM_RPFC_RSTFLTSS field. */
#define BR_RCM_RPFC_RSTFLTSS(x) (BME_UBFX8(HW_RCM_RPFC_ADDR(x), BP_RCM_RPFC_RSTFLTSS, BS_RCM_RPFC_RSTFLTSS))

/*! @brief Format value for bitfield RCM_RPFC_RSTFLTSS. */
#define BF_RCM_RPFC_RSTFLTSS(v) ((uint8_t)((uint8_t)(v) << BP_RCM_RPFC_RSTFLTSS) & BM_RCM_RPFC_RSTFLTSS)

/*! @brief Set the RSTFLTSS field to a new value. */
#define BW_RCM_RPFC_RSTFLTSS(x, v) (BME_BFI8(HW_RCM_RPFC_ADDR(x), ((uint8_t)(v) << BP_RCM_RPFC_RSTFLTSS), BP_RCM_RPFC_RSTFLTSS, 1))
/*@}*/

/*******************************************************************************
 * HW_RCM_RPFW - Reset Pin Filter Width register
 ******************************************************************************/

/*!
 * @brief HW_RCM_RPFW - Reset Pin Filter Width register (RW)
 *
 * Reset value: 0x00U
 *
 * The reset values of the bits in the RSTFLTSEL field are for Chip POR only.
 * They are unaffected by other reset types.
 */
typedef union _hw_rcm_rpfw
{
    uint8_t U;
    struct _hw_rcm_rpfw_bitfields
    {
        uint8_t RSTFLTSEL : 5;         /*!< [4:0] Reset Pin Filter Bus Clock Select */
        uint8_t RESERVED0 : 3;         /*!< [7:5]  */
    } B;
} hw_rcm_rpfw_t;

/*!
 * @name Constants and macros for entire RCM_RPFW register
 */
/*@{*/
#define HW_RCM_RPFW_ADDR(x)      ((uint32_t)(x) + 0x5U)

#define HW_RCM_RPFW(x)           (*(__IO hw_rcm_rpfw_t *) HW_RCM_RPFW_ADDR(x))
#define HW_RCM_RPFW_RD(x)        (HW_RCM_RPFW(x).U)
#define HW_RCM_RPFW_WR(x, v)     (HW_RCM_RPFW(x).U = (v))
#define HW_RCM_RPFW_SET(x, v)    (BME_OR8(HW_RCM_RPFW_ADDR(x), (uint8_t)(v)))
#define HW_RCM_RPFW_CLR(x, v)    (BME_AND8(HW_RCM_RPFW_ADDR(x), (uint8_t)(~(v))))
#define HW_RCM_RPFW_TOG(x, v)    (BME_XOR8(HW_RCM_RPFW_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual RCM_RPFW bitfields
 */

/*!
 * @name Register RCM_RPFW, field RSTFLTSEL[4:0] (RW)
 *
 * Selects the reset pin bus clock filter width.
 *
 * Values:
 * - 00000 - Bus clock filter count is 1
 * - 00001 - Bus clock filter count is 2
 * - 00010 - Bus clock filter count is 3
 * - 00011 - Bus clock filter count is 4
 * - 00100 - Bus clock filter count is 5
 * - 00101 - Bus clock filter count is 6
 * - 00110 - Bus clock filter count is 7
 * - 00111 - Bus clock filter count is 8
 * - 01000 - Bus clock filter count is 9
 * - 01001 - Bus clock filter count is 10
 * - 01010 - Bus clock filter count is 11
 * - 01011 - Bus clock filter count is 12
 * - 01100 - Bus clock filter count is 13
 * - 01101 - Bus clock filter count is 14
 * - 01110 - Bus clock filter count is 15
 * - 01111 - Bus clock filter count is 16
 * - 10000 - Bus clock filter count is 17
 * - 10001 - Bus clock filter count is 18
 * - 10010 - Bus clock filter count is 19
 * - 10011 - Bus clock filter count is 20
 * - 10100 - Bus clock filter count is 21
 * - 10101 - Bus clock filter count is 22
 * - 10110 - Bus clock filter count is 23
 * - 10111 - Bus clock filter count is 24
 * - 11000 - Bus clock filter count is 25
 * - 11001 - Bus clock filter count is 26
 * - 11010 - Bus clock filter count is 27
 * - 11011 - Bus clock filter count is 28
 * - 11100 - Bus clock filter count is 29
 * - 11101 - Bus clock filter count is 30
 * - 11110 - Bus clock filter count is 31
 * - 11111 - Bus clock filter count is 32
 */
/*@{*/
#define BP_RCM_RPFW_RSTFLTSEL (0U)         /*!< Bit position for RCM_RPFW_RSTFLTSEL. */
#define BM_RCM_RPFW_RSTFLTSEL (0x1FU)      /*!< Bit mask for RCM_RPFW_RSTFLTSEL. */
#define BS_RCM_RPFW_RSTFLTSEL (5U)         /*!< Bit field size in bits for RCM_RPFW_RSTFLTSEL. */

/*! @brief Read current value of the RCM_RPFW_RSTFLTSEL field. */
#define BR_RCM_RPFW_RSTFLTSEL(x) (BME_UBFX8(HW_RCM_RPFW_ADDR(x), BP_RCM_RPFW_RSTFLTSEL, BS_RCM_RPFW_RSTFLTSEL))

/*! @brief Format value for bitfield RCM_RPFW_RSTFLTSEL. */
#define BF_RCM_RPFW_RSTFLTSEL(v) ((uint8_t)((uint8_t)(v) << BP_RCM_RPFW_RSTFLTSEL) & BM_RCM_RPFW_RSTFLTSEL)

/*! @brief Set the RSTFLTSEL field to a new value. */
#define BW_RCM_RPFW_RSTFLTSEL(x, v) (BME_BFI8(HW_RCM_RPFW_ADDR(x), ((uint8_t)(v) << BP_RCM_RPFW_RSTFLTSEL), BP_RCM_RPFW_RSTFLTSEL, 5))
/*@}*/

/*******************************************************************************
 * HW_RCM_FM - Force Mode Register
 ******************************************************************************/

/*!
 * @brief HW_RCM_FM - Force Mode Register (RW)
 *
 * Reset value: 0x00U
 *
 * The reset values of the bits in the FORCEROM field are for Chip POR only.
 * They are unaffected by other reset types.
 */
typedef union _hw_rcm_fm
{
    uint8_t U;
    struct _hw_rcm_fm_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t FORCEROM : 2;          /*!< [2:1] Force ROM Boot */
        uint8_t RESERVED1 : 5;         /*!< [7:3]  */
    } B;
} hw_rcm_fm_t;

/*!
 * @name Constants and macros for entire RCM_FM register
 */
/*@{*/
#define HW_RCM_FM_ADDR(x)        ((uint32_t)(x) + 0x6U)

#define HW_RCM_FM(x)             (*(__IO hw_rcm_fm_t *) HW_RCM_FM_ADDR(x))
#define HW_RCM_FM_RD(x)          (HW_RCM_FM(x).U)
#define HW_RCM_FM_WR(x, v)       (HW_RCM_FM(x).U = (v))
#define HW_RCM_FM_SET(x, v)      (BME_OR8(HW_RCM_FM_ADDR(x), (uint8_t)(v)))
#define HW_RCM_FM_CLR(x, v)      (BME_AND8(HW_RCM_FM_ADDR(x), (uint8_t)(~(v))))
#define HW_RCM_FM_TOG(x, v)      (BME_XOR8(HW_RCM_FM_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual RCM_FM bitfields
 */

/*!
 * @name Register RCM_FM, field FORCEROM[2:1] (RW)
 *
 * When either bit is set, will force boot from ROM during all subsequent system
 * resets.
 *
 * Values:
 * - 00 - No effect
 * - 01 - Force boot from ROM with RCM_MR[1] set.
 * - 10 - Force boot from ROM with RCM_MR[2] set.
 * - 11 - Force boot from ROM with RCM_MR[2:1] set.
 */
/*@{*/
#define BP_RCM_FM_FORCEROM   (1U)          /*!< Bit position for RCM_FM_FORCEROM. */
#define BM_RCM_FM_FORCEROM   (0x06U)       /*!< Bit mask for RCM_FM_FORCEROM. */
#define BS_RCM_FM_FORCEROM   (2U)          /*!< Bit field size in bits for RCM_FM_FORCEROM. */

/*! @brief Read current value of the RCM_FM_FORCEROM field. */
#define BR_RCM_FM_FORCEROM(x) (BME_UBFX8(HW_RCM_FM_ADDR(x), BP_RCM_FM_FORCEROM, BS_RCM_FM_FORCEROM))

/*! @brief Format value for bitfield RCM_FM_FORCEROM. */
#define BF_RCM_FM_FORCEROM(v) ((uint8_t)((uint8_t)(v) << BP_RCM_FM_FORCEROM) & BM_RCM_FM_FORCEROM)

/*! @brief Set the FORCEROM field to a new value. */
#define BW_RCM_FM_FORCEROM(x, v) (BME_BFI8(HW_RCM_FM_ADDR(x), ((uint8_t)(v) << BP_RCM_FM_FORCEROM), BP_RCM_FM_FORCEROM, 2))
/*@}*/

/*******************************************************************************
 * HW_RCM_MR - Mode Register
 ******************************************************************************/

/*!
 * @brief HW_RCM_MR - Mode Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register includes status flags to indicate the state of the mode pins
 * during the last Chip Reset.
 */
typedef union _hw_rcm_mr
{
    uint8_t U;
    struct _hw_rcm_mr_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t BOOTROM : 2;           /*!< [2:1] Boot ROM Configuration */
        uint8_t RESERVED1 : 5;         /*!< [7:3]  */
    } B;
} hw_rcm_mr_t;

/*!
 * @name Constants and macros for entire RCM_MR register
 */
/*@{*/
#define HW_RCM_MR_ADDR(x)        ((uint32_t)(x) + 0x7U)

#define HW_RCM_MR(x)             (*(__IO hw_rcm_mr_t *) HW_RCM_MR_ADDR(x))
#define HW_RCM_MR_RD(x)          (HW_RCM_MR(x).U)
#define HW_RCM_MR_WR(x, v)       (HW_RCM_MR(x).U = (v))
#define HW_RCM_MR_SET(x, v)      (BME_OR8(HW_RCM_MR_ADDR(x), (uint8_t)(v)))
#define HW_RCM_MR_CLR(x, v)      (BME_AND8(HW_RCM_MR_ADDR(x), (uint8_t)(~(v))))
#define HW_RCM_MR_TOG(x, v)      (BME_XOR8(HW_RCM_MR_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual RCM_MR bitfields
 */

/*!
 * @name Register RCM_MR, field BOOTROM[2:1] (W1C)
 *
 * Indicates the boot source, the boot source remains set until the next System
 * Reset or software can write logic one to clear the corresponding mode bit.
 * While either bit is set, the NMI input is disabled and the vector table is
 * relocated to the ROM base address at $1C00_0000. These bits should be cleared by
 * writing logic one before executing any code from either Flash or SRAM.
 *
 * Values:
 * - 00 - Boot from Flash
 * - 01 - Boot from ROM due to BOOTCFG0 pin assertion
 * - 10 - Boot form ROM due to FOPT[7] configuration
 * - 11 - Boot from ROM due to both BOOTCFG0 pin assertion and FOPT[7]
 *     configuration
 */
/*@{*/
#define BP_RCM_MR_BOOTROM    (1U)          /*!< Bit position for RCM_MR_BOOTROM. */
#define BM_RCM_MR_BOOTROM    (0x06U)       /*!< Bit mask for RCM_MR_BOOTROM. */
#define BS_RCM_MR_BOOTROM    (2U)          /*!< Bit field size in bits for RCM_MR_BOOTROM. */

/*! @brief Read current value of the RCM_MR_BOOTROM field. */
#define BR_RCM_MR_BOOTROM(x) (BME_UBFX8(HW_RCM_MR_ADDR(x), BP_RCM_MR_BOOTROM, BS_RCM_MR_BOOTROM))

/*! @brief Format value for bitfield RCM_MR_BOOTROM. */
#define BF_RCM_MR_BOOTROM(v) ((uint8_t)((uint8_t)(v) << BP_RCM_MR_BOOTROM) & BM_RCM_MR_BOOTROM)

/*! @brief Set the BOOTROM field to a new value. */
#define BW_RCM_MR_BOOTROM(x, v) (BME_BFI8(HW_RCM_MR_ADDR(x), ((uint8_t)(v) << BP_RCM_MR_BOOTROM), BP_RCM_MR_BOOTROM, 2))
/*@}*/

/*******************************************************************************
 * HW_RCM_SSRS0 - Sticky System Reset Status Register 0
 ******************************************************************************/

/*!
 * @brief HW_RCM_SSRS0 - Sticky System Reset Status Register 0 (RW)
 *
 * Reset value: 0x82U
 *
 * This register includes status flags to indicate all reset sources since the
 * last POR, LVD or VLLS Wakeup that have not been cleared by software. Software
 * can clear the status flags by writing a logic one to a flag.
 */
typedef union _hw_rcm_ssrs0
{
    uint8_t U;
    struct _hw_rcm_ssrs0_bitfields
    {
        uint8_t SWAKEUP : 1;           /*!< [0] Sticky Low Leakage Wakeup Reset */
        uint8_t SLVD : 1;              /*!< [1] Sticky Low-Voltage Detect Reset */
        uint8_t RESERVED0 : 3;         /*!< [4:2]  */
        uint8_t SWDOG : 1;             /*!< [5] Sticky Watchdog */
        uint8_t SPIN : 1;              /*!< [6] Sticky External Reset Pin */
        uint8_t SPOR : 1;              /*!< [7] Sticky Power-On Reset */
    } B;
} hw_rcm_ssrs0_t;

/*!
 * @name Constants and macros for entire RCM_SSRS0 register
 */
/*@{*/
#define HW_RCM_SSRS0_ADDR(x)     ((uint32_t)(x) + 0x8U)

#define HW_RCM_SSRS0(x)          (*(__IO hw_rcm_ssrs0_t *) HW_RCM_SSRS0_ADDR(x))
#define HW_RCM_SSRS0_RD(x)       (HW_RCM_SSRS0(x).U)
#define HW_RCM_SSRS0_WR(x, v)    (HW_RCM_SSRS0(x).U = (v))
#define HW_RCM_SSRS0_SET(x, v)   (BME_OR8(HW_RCM_SSRS0_ADDR(x), (uint8_t)(v)))
#define HW_RCM_SSRS0_CLR(x, v)   (BME_AND8(HW_RCM_SSRS0_ADDR(x), (uint8_t)(~(v))))
#define HW_RCM_SSRS0_TOG(x, v)   (BME_XOR8(HW_RCM_SSRS0_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual RCM_SSRS0 bitfields
 */

/*!
 * @name Register RCM_SSRS0, field SWAKEUP[0] (W1C)
 *
 * Indicates a reset has been caused by an enabled LLWU modulewakeup source
 * while the chip was in a low leakage mode. In LLS mode, the RESET pin is the only
 * wakeup source that can cause this reset. Any enabled wakeup source in a VLLSx
 * mode causes a reset.
 *
 * Values:
 * - 0 - Reset not caused by LLWU module wakeup source
 * - 1 - Reset caused by LLWU module wakeup source
 */
/*@{*/
#define BP_RCM_SSRS0_SWAKEUP (0U)          /*!< Bit position for RCM_SSRS0_SWAKEUP. */
#define BM_RCM_SSRS0_SWAKEUP (0x01U)       /*!< Bit mask for RCM_SSRS0_SWAKEUP. */
#define BS_RCM_SSRS0_SWAKEUP (1U)          /*!< Bit field size in bits for RCM_SSRS0_SWAKEUP. */

/*! @brief Read current value of the RCM_SSRS0_SWAKEUP field. */
#define BR_RCM_SSRS0_SWAKEUP(x) (BME_UBFX8(HW_RCM_SSRS0_ADDR(x), BP_RCM_SSRS0_SWAKEUP, BS_RCM_SSRS0_SWAKEUP))

/*! @brief Format value for bitfield RCM_SSRS0_SWAKEUP. */
#define BF_RCM_SSRS0_SWAKEUP(v) ((uint8_t)((uint8_t)(v) << BP_RCM_SSRS0_SWAKEUP) & BM_RCM_SSRS0_SWAKEUP)

/*! @brief Set the SWAKEUP field to a new value. */
#define BW_RCM_SSRS0_SWAKEUP(x, v) (BME_BFI8(HW_RCM_SSRS0_ADDR(x), ((uint8_t)(v) << BP_RCM_SSRS0_SWAKEUP), BP_RCM_SSRS0_SWAKEUP, 1))
/*@}*/

/*!
 * @name Register RCM_SSRS0, field SLVD[1] (W1C)
 *
 * If PMC_LVDSC1[LVDRE] is set and the supply drops below the LVD trip voltage,
 * an LVD reset occurs. This field is also set by POR.
 *
 * Values:
 * - 0 - Reset not caused by LVD trip or POR
 * - 1 - Reset caused by LVD trip or POR
 */
/*@{*/
#define BP_RCM_SSRS0_SLVD    (1U)          /*!< Bit position for RCM_SSRS0_SLVD. */
#define BM_RCM_SSRS0_SLVD    (0x02U)       /*!< Bit mask for RCM_SSRS0_SLVD. */
#define BS_RCM_SSRS0_SLVD    (1U)          /*!< Bit field size in bits for RCM_SSRS0_SLVD. */

/*! @brief Read current value of the RCM_SSRS0_SLVD field. */
#define BR_RCM_SSRS0_SLVD(x) (BME_UBFX8(HW_RCM_SSRS0_ADDR(x), BP_RCM_SSRS0_SLVD, BS_RCM_SSRS0_SLVD))

/*! @brief Format value for bitfield RCM_SSRS0_SLVD. */
#define BF_RCM_SSRS0_SLVD(v) ((uint8_t)((uint8_t)(v) << BP_RCM_SSRS0_SLVD) & BM_RCM_SSRS0_SLVD)

/*! @brief Set the SLVD field to a new value. */
#define BW_RCM_SSRS0_SLVD(x, v) (BME_BFI8(HW_RCM_SSRS0_ADDR(x), ((uint8_t)(v) << BP_RCM_SSRS0_SLVD), BP_RCM_SSRS0_SLVD, 1))
/*@}*/

/*!
 * @name Register RCM_SSRS0, field SWDOG[5] (W1C)
 *
 * Indicates a reset has been caused by the watchdog timer timing out. This
 * reset source can be blocked by disabling the watchdog.
 *
 * Values:
 * - 0 - Reset not caused by watchdog timeout
 * - 1 - Reset caused by watchdog timeout
 */
/*@{*/
#define BP_RCM_SSRS0_SWDOG   (5U)          /*!< Bit position for RCM_SSRS0_SWDOG. */
#define BM_RCM_SSRS0_SWDOG   (0x20U)       /*!< Bit mask for RCM_SSRS0_SWDOG. */
#define BS_RCM_SSRS0_SWDOG   (1U)          /*!< Bit field size in bits for RCM_SSRS0_SWDOG. */

/*! @brief Read current value of the RCM_SSRS0_SWDOG field. */
#define BR_RCM_SSRS0_SWDOG(x) (BME_UBFX8(HW_RCM_SSRS0_ADDR(x), BP_RCM_SSRS0_SWDOG, BS_RCM_SSRS0_SWDOG))

/*! @brief Format value for bitfield RCM_SSRS0_SWDOG. */
#define BF_RCM_SSRS0_SWDOG(v) ((uint8_t)((uint8_t)(v) << BP_RCM_SSRS0_SWDOG) & BM_RCM_SSRS0_SWDOG)

/*! @brief Set the SWDOG field to a new value. */
#define BW_RCM_SSRS0_SWDOG(x, v) (BME_BFI8(HW_RCM_SSRS0_ADDR(x), ((uint8_t)(v) << BP_RCM_SSRS0_SWDOG), BP_RCM_SSRS0_SWDOG, 1))
/*@}*/

/*!
 * @name Register RCM_SSRS0, field SPIN[6] (W1C)
 *
 * Indicates a reset has been caused by an active-low level on the external
 * RESET pin.
 *
 * Values:
 * - 0 - Reset not caused by external reset pin
 * - 1 - Reset caused by external reset pin
 */
/*@{*/
#define BP_RCM_SSRS0_SPIN    (6U)          /*!< Bit position for RCM_SSRS0_SPIN. */
#define BM_RCM_SSRS0_SPIN    (0x40U)       /*!< Bit mask for RCM_SSRS0_SPIN. */
#define BS_RCM_SSRS0_SPIN    (1U)          /*!< Bit field size in bits for RCM_SSRS0_SPIN. */

/*! @brief Read current value of the RCM_SSRS0_SPIN field. */
#define BR_RCM_SSRS0_SPIN(x) (BME_UBFX8(HW_RCM_SSRS0_ADDR(x), BP_RCM_SSRS0_SPIN, BS_RCM_SSRS0_SPIN))

/*! @brief Format value for bitfield RCM_SSRS0_SPIN. */
#define BF_RCM_SSRS0_SPIN(v) ((uint8_t)((uint8_t)(v) << BP_RCM_SSRS0_SPIN) & BM_RCM_SSRS0_SPIN)

/*! @brief Set the SPIN field to a new value. */
#define BW_RCM_SSRS0_SPIN(x, v) (BME_BFI8(HW_RCM_SSRS0_ADDR(x), ((uint8_t)(v) << BP_RCM_SSRS0_SPIN), BP_RCM_SSRS0_SPIN, 1))
/*@}*/

/*!
 * @name Register RCM_SSRS0, field SPOR[7] (W1C)
 *
 * Indicates a reset has been caused by the power-on detection logic. Because
 * the internal supply voltage was ramping up at the time, the low-voltage reset
 * (LVD) status bit is also set to indicate that the reset occurred while the
 * internal supply was below the LVD threshold.
 *
 * Values:
 * - 0 - Reset not caused by POR
 * - 1 - Reset caused by POR
 */
/*@{*/
#define BP_RCM_SSRS0_SPOR    (7U)          /*!< Bit position for RCM_SSRS0_SPOR. */
#define BM_RCM_SSRS0_SPOR    (0x80U)       /*!< Bit mask for RCM_SSRS0_SPOR. */
#define BS_RCM_SSRS0_SPOR    (1U)          /*!< Bit field size in bits for RCM_SSRS0_SPOR. */

/*! @brief Read current value of the RCM_SSRS0_SPOR field. */
#define BR_RCM_SSRS0_SPOR(x) (BME_UBFX8(HW_RCM_SSRS0_ADDR(x), BP_RCM_SSRS0_SPOR, BS_RCM_SSRS0_SPOR))

/*! @brief Format value for bitfield RCM_SSRS0_SPOR. */
#define BF_RCM_SSRS0_SPOR(v) ((uint8_t)((uint8_t)(v) << BP_RCM_SSRS0_SPOR) & BM_RCM_SSRS0_SPOR)

/*! @brief Set the SPOR field to a new value. */
#define BW_RCM_SSRS0_SPOR(x, v) (BME_BFI8(HW_RCM_SSRS0_ADDR(x), ((uint8_t)(v) << BP_RCM_SSRS0_SPOR), BP_RCM_SSRS0_SPOR, 1))
/*@}*/

/*******************************************************************************
 * HW_RCM_SSRS1 - Sticky System Reset Status Register 1
 ******************************************************************************/

/*!
 * @brief HW_RCM_SSRS1 - Sticky System Reset Status Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This register includes status flags to indicate all reset sources since the
 * last POR, LVD or VLLS Wakeup that have not been cleared by software. Software
 * can clear the status flags by writing a logic one to a flag.
 */
typedef union _hw_rcm_ssrs1
{
    uint8_t U;
    struct _hw_rcm_ssrs1_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t SLOCKUP : 1;           /*!< [1] Sticky Core Lockup */
        uint8_t SSW : 1;               /*!< [2] Sticky Software */
        uint8_t SMDM_AP : 1;           /*!< [3] Sticky MDM-AP System Reset Request */
        uint8_t RESERVED1 : 1;         /*!< [4]  */
        uint8_t SSACKERR : 1;          /*!< [5] Sticky Stop Mode Acknowledge Error
                                        * Reset */
        uint8_t RESERVED2 : 2;         /*!< [7:6]  */
    } B;
} hw_rcm_ssrs1_t;

/*!
 * @name Constants and macros for entire RCM_SSRS1 register
 */
/*@{*/
#define HW_RCM_SSRS1_ADDR(x)     ((uint32_t)(x) + 0x9U)

#define HW_RCM_SSRS1(x)          (*(__IO hw_rcm_ssrs1_t *) HW_RCM_SSRS1_ADDR(x))
#define HW_RCM_SSRS1_RD(x)       (HW_RCM_SSRS1(x).U)
#define HW_RCM_SSRS1_WR(x, v)    (HW_RCM_SSRS1(x).U = (v))
#define HW_RCM_SSRS1_SET(x, v)   (BME_OR8(HW_RCM_SSRS1_ADDR(x), (uint8_t)(v)))
#define HW_RCM_SSRS1_CLR(x, v)   (BME_AND8(HW_RCM_SSRS1_ADDR(x), (uint8_t)(~(v))))
#define HW_RCM_SSRS1_TOG(x, v)   (BME_XOR8(HW_RCM_SSRS1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual RCM_SSRS1 bitfields
 */

/*!
 * @name Register RCM_SSRS1, field SLOCKUP[1] (W1C)
 *
 * Indicates a reset has been caused by the ARM core indication of a LOCKUP
 * event.
 *
 * Values:
 * - 0 - Reset not caused by core LOCKUP event
 * - 1 - Reset caused by core LOCKUP event
 */
/*@{*/
#define BP_RCM_SSRS1_SLOCKUP (1U)          /*!< Bit position for RCM_SSRS1_SLOCKUP. */
#define BM_RCM_SSRS1_SLOCKUP (0x02U)       /*!< Bit mask for RCM_SSRS1_SLOCKUP. */
#define BS_RCM_SSRS1_SLOCKUP (1U)          /*!< Bit field size in bits for RCM_SSRS1_SLOCKUP. */

/*! @brief Read current value of the RCM_SSRS1_SLOCKUP field. */
#define BR_RCM_SSRS1_SLOCKUP(x) (BME_UBFX8(HW_RCM_SSRS1_ADDR(x), BP_RCM_SSRS1_SLOCKUP, BS_RCM_SSRS1_SLOCKUP))

/*! @brief Format value for bitfield RCM_SSRS1_SLOCKUP. */
#define BF_RCM_SSRS1_SLOCKUP(v) ((uint8_t)((uint8_t)(v) << BP_RCM_SSRS1_SLOCKUP) & BM_RCM_SSRS1_SLOCKUP)

/*! @brief Set the SLOCKUP field to a new value. */
#define BW_RCM_SSRS1_SLOCKUP(x, v) (BME_BFI8(HW_RCM_SSRS1_ADDR(x), ((uint8_t)(v) << BP_RCM_SSRS1_SLOCKUP), BP_RCM_SSRS1_SLOCKUP, 1))
/*@}*/

/*!
 * @name Register RCM_SSRS1, field SSW[2] (W1C)
 *
 * Indicates a reset has been caused by software setting of SYSRESETREQ bit in
 * Application Interrupt and Reset Control Register in the ARM core.
 *
 * Values:
 * - 0 - Reset not caused by software setting of SYSRESETREQ bit
 * - 1 - Reset caused by software setting of SYSRESETREQ bit
 */
/*@{*/
#define BP_RCM_SSRS1_SSW     (2U)          /*!< Bit position for RCM_SSRS1_SSW. */
#define BM_RCM_SSRS1_SSW     (0x04U)       /*!< Bit mask for RCM_SSRS1_SSW. */
#define BS_RCM_SSRS1_SSW     (1U)          /*!< Bit field size in bits for RCM_SSRS1_SSW. */

/*! @brief Read current value of the RCM_SSRS1_SSW field. */
#define BR_RCM_SSRS1_SSW(x)  (BME_UBFX8(HW_RCM_SSRS1_ADDR(x), BP_RCM_SSRS1_SSW, BS_RCM_SSRS1_SSW))

/*! @brief Format value for bitfield RCM_SSRS1_SSW. */
#define BF_RCM_SSRS1_SSW(v)  ((uint8_t)((uint8_t)(v) << BP_RCM_SSRS1_SSW) & BM_RCM_SSRS1_SSW)

/*! @brief Set the SSW field to a new value. */
#define BW_RCM_SSRS1_SSW(x, v) (BME_BFI8(HW_RCM_SSRS1_ADDR(x), ((uint8_t)(v) << BP_RCM_SSRS1_SSW), BP_RCM_SSRS1_SSW, 1))
/*@}*/

/*!
 * @name Register RCM_SSRS1, field SMDM_AP[3] (W1C)
 *
 * Indicates a reset has been caused by the host debugger system setting of the
 * System Reset Request bit in the MDM-AP Control Register.
 *
 * Values:
 * - 0 - Reset not caused by host debugger system setting of the System Reset
 *     Request bit
 * - 1 - Reset caused by host debugger system setting of the System Reset
 *     Request bit
 */
/*@{*/
#define BP_RCM_SSRS1_SMDM_AP (3U)          /*!< Bit position for RCM_SSRS1_SMDM_AP. */
#define BM_RCM_SSRS1_SMDM_AP (0x08U)       /*!< Bit mask for RCM_SSRS1_SMDM_AP. */
#define BS_RCM_SSRS1_SMDM_AP (1U)          /*!< Bit field size in bits for RCM_SSRS1_SMDM_AP. */

/*! @brief Read current value of the RCM_SSRS1_SMDM_AP field. */
#define BR_RCM_SSRS1_SMDM_AP(x) (BME_UBFX8(HW_RCM_SSRS1_ADDR(x), BP_RCM_SSRS1_SMDM_AP, BS_RCM_SSRS1_SMDM_AP))

/*! @brief Format value for bitfield RCM_SSRS1_SMDM_AP. */
#define BF_RCM_SSRS1_SMDM_AP(v) ((uint8_t)((uint8_t)(v) << BP_RCM_SSRS1_SMDM_AP) & BM_RCM_SSRS1_SMDM_AP)

/*! @brief Set the SMDM_AP field to a new value. */
#define BW_RCM_SSRS1_SMDM_AP(x, v) (BME_BFI8(HW_RCM_SSRS1_ADDR(x), ((uint8_t)(v) << BP_RCM_SSRS1_SMDM_AP), BP_RCM_SSRS1_SMDM_AP, 1))
/*@}*/

/*!
 * @name Register RCM_SSRS1, field SSACKERR[5] (W1C)
 *
 * Indicates that after an attempt to enter Stop mode, a reset has been caused
 * by a failure of one or more peripherals to acknowledge within approximately one
 * second to enter stop mode.
 *
 * Values:
 * - 0 - Reset not caused by peripheral failure to acknowledge attempt to enter
 *     stop mode
 * - 1 - Reset caused by peripheral failure to acknowledge attempt to enter stop
 *     mode
 */
/*@{*/
#define BP_RCM_SSRS1_SSACKERR (5U)         /*!< Bit position for RCM_SSRS1_SSACKERR. */
#define BM_RCM_SSRS1_SSACKERR (0x20U)      /*!< Bit mask for RCM_SSRS1_SSACKERR. */
#define BS_RCM_SSRS1_SSACKERR (1U)         /*!< Bit field size in bits for RCM_SSRS1_SSACKERR. */

/*! @brief Read current value of the RCM_SSRS1_SSACKERR field. */
#define BR_RCM_SSRS1_SSACKERR(x) (BME_UBFX8(HW_RCM_SSRS1_ADDR(x), BP_RCM_SSRS1_SSACKERR, BS_RCM_SSRS1_SSACKERR))

/*! @brief Format value for bitfield RCM_SSRS1_SSACKERR. */
#define BF_RCM_SSRS1_SSACKERR(v) ((uint8_t)((uint8_t)(v) << BP_RCM_SSRS1_SSACKERR) & BM_RCM_SSRS1_SSACKERR)

/*! @brief Set the SSACKERR field to a new value. */
#define BW_RCM_SSRS1_SSACKERR(x, v) (BME_BFI8(HW_RCM_SSRS1_ADDR(x), ((uint8_t)(v) << BP_RCM_SSRS1_SSACKERR), BP_RCM_SSRS1_SSACKERR, 1))
/*@}*/

/*******************************************************************************
 * hw_rcm_t - module struct
 ******************************************************************************/
/*!
 * @brief All RCM module registers.
 */
#pragma pack(1)
typedef struct _hw_rcm
{
    __I hw_rcm_srs0_t SRS0;                /*!< [0x0] System Reset Status Register 0 */
    __I hw_rcm_srs1_t SRS1;                /*!< [0x1] System Reset Status Register 1 */
    uint8_t _reserved0[2];
    __IO hw_rcm_rpfc_t RPFC;               /*!< [0x4] Reset Pin Filter Control register */
    __IO hw_rcm_rpfw_t RPFW;               /*!< [0x5] Reset Pin Filter Width register */
    __IO hw_rcm_fm_t FM;                   /*!< [0x6] Force Mode Register */
    __IO hw_rcm_mr_t MR;                   /*!< [0x7] Mode Register */
    __IO hw_rcm_ssrs0_t SSRS0;             /*!< [0x8] Sticky System Reset Status Register 0 */
    __IO hw_rcm_ssrs1_t SSRS1;             /*!< [0x9] Sticky System Reset Status Register 1 */
} hw_rcm_t;
#pragma pack()

/*! @brief Macro to access all RCM registers. */
/*! @param x RCM module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_RCM_REGS(RCM_BASE)</code>. */
#define HW_RCM_REGS(x) (*(hw_rcm_t *)(x))

/*
 * MKL43Z4 RFSYS
 *
 * System register file
 *
 * Registers defined in this header file:
 * - HW_RFSYS_REGn - Register file register
 *
 * - hw_rfsys_t - Struct containing all module registers.
 */

#define HW_RFSYS_INSTANCE_COUNT (1U) /*!< Number of instances of the RFSYS module. */
#define HW_RFSYS (0U) /*!< Instance number for RFSYS. */

/*******************************************************************************
 * HW_RFSYS_REGn - Register file register
 ******************************************************************************/

/*!
 * @brief HW_RFSYS_REGn - Register file register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each register can be accessed as 8-, 16-, or 32-bits.
 */
typedef union _hw_rfsys_regn
{
    uint32_t U;
    struct _hw_rfsys_regn_bitfields
    {
        uint32_t LL : 8;               /*!< [7:0]  */
        uint32_t LH : 8;               /*!< [15:8]  */
        uint32_t HL : 8;               /*!< [23:16]  */
        uint32_t HH : 8;               /*!< [31:24]  */
    } B;
} hw_rfsys_regn_t;

/*!
 * @name Constants and macros for entire RFSYS_REGn register
 */
/*@{*/
#define HW_RFSYS_REGn_COUNT (8U)

#define HW_RFSYS_REGn_ADDR(x, n) ((uint32_t)(x) + 0x0U + (0x4U * (n)))

#define HW_RFSYS_REGn(x, n)      (*(__IO hw_rfsys_regn_t *) HW_RFSYS_REGn_ADDR(x, n))
#define HW_RFSYS_REGn_RD(x, n)   (HW_RFSYS_REGn(x, n).U)
#define HW_RFSYS_REGn_WR(x, n, v) (HW_RFSYS_REGn(x, n).U = (v))
#define HW_RFSYS_REGn_SET(x, n, v) (BME_OR32(HW_RFSYS_REGn_ADDR(x, n), (uint32_t)(v)))
#define HW_RFSYS_REGn_CLR(x, n, v) (BME_AND32(HW_RFSYS_REGn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_RFSYS_REGn_TOG(x, n, v) (BME_XOR32(HW_RFSYS_REGn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual RFSYS_REGn bitfields
 */

/*!
 * @name Register RFSYS_REGn, field LL[7:0] (RW)
 *
 * Low lower byte
 */
/*@{*/
#define BP_RFSYS_REGn_LL     (0U)          /*!< Bit position for RFSYS_REGn_LL. */
#define BM_RFSYS_REGn_LL     (0x000000FFU) /*!< Bit mask for RFSYS_REGn_LL. */
#define BS_RFSYS_REGn_LL     (8U)          /*!< Bit field size in bits for RFSYS_REGn_LL. */

/*! @brief Read current value of the RFSYS_REGn_LL field. */
#define BR_RFSYS_REGn_LL(x, n) (BME_UBFX32(HW_RFSYS_REGn_ADDR(x, n), BP_RFSYS_REGn_LL, BS_RFSYS_REGn_LL))

/*! @brief Format value for bitfield RFSYS_REGn_LL. */
#define BF_RFSYS_REGn_LL(v)  ((uint32_t)((uint32_t)(v) << BP_RFSYS_REGn_LL) & BM_RFSYS_REGn_LL)

/*! @brief Set the LL field to a new value. */
#define BW_RFSYS_REGn_LL(x, n, v) (BME_BFI32(HW_RFSYS_REGn_ADDR(x, n), ((uint32_t)(v) << BP_RFSYS_REGn_LL), BP_RFSYS_REGn_LL, 8))
/*@}*/

/*!
 * @name Register RFSYS_REGn, field LH[15:8] (RW)
 *
 * Low higher byte
 */
/*@{*/
#define BP_RFSYS_REGn_LH     (8U)          /*!< Bit position for RFSYS_REGn_LH. */
#define BM_RFSYS_REGn_LH     (0x0000FF00U) /*!< Bit mask for RFSYS_REGn_LH. */
#define BS_RFSYS_REGn_LH     (8U)          /*!< Bit field size in bits for RFSYS_REGn_LH. */

/*! @brief Read current value of the RFSYS_REGn_LH field. */
#define BR_RFSYS_REGn_LH(x, n) (BME_UBFX32(HW_RFSYS_REGn_ADDR(x, n), BP_RFSYS_REGn_LH, BS_RFSYS_REGn_LH))

/*! @brief Format value for bitfield RFSYS_REGn_LH. */
#define BF_RFSYS_REGn_LH(v)  ((uint32_t)((uint32_t)(v) << BP_RFSYS_REGn_LH) & BM_RFSYS_REGn_LH)

/*! @brief Set the LH field to a new value. */
#define BW_RFSYS_REGn_LH(x, n, v) (BME_BFI32(HW_RFSYS_REGn_ADDR(x, n), ((uint32_t)(v) << BP_RFSYS_REGn_LH), BP_RFSYS_REGn_LH, 8))
/*@}*/

/*!
 * @name Register RFSYS_REGn, field HL[23:16] (RW)
 *
 * High lower byte
 */
/*@{*/
#define BP_RFSYS_REGn_HL     (16U)         /*!< Bit position for RFSYS_REGn_HL. */
#define BM_RFSYS_REGn_HL     (0x00FF0000U) /*!< Bit mask for RFSYS_REGn_HL. */
#define BS_RFSYS_REGn_HL     (8U)          /*!< Bit field size in bits for RFSYS_REGn_HL. */

/*! @brief Read current value of the RFSYS_REGn_HL field. */
#define BR_RFSYS_REGn_HL(x, n) (BME_UBFX32(HW_RFSYS_REGn_ADDR(x, n), BP_RFSYS_REGn_HL, BS_RFSYS_REGn_HL))

/*! @brief Format value for bitfield RFSYS_REGn_HL. */
#define BF_RFSYS_REGn_HL(v)  ((uint32_t)((uint32_t)(v) << BP_RFSYS_REGn_HL) & BM_RFSYS_REGn_HL)

/*! @brief Set the HL field to a new value. */
#define BW_RFSYS_REGn_HL(x, n, v) (BME_BFI32(HW_RFSYS_REGn_ADDR(x, n), ((uint32_t)(v) << BP_RFSYS_REGn_HL), BP_RFSYS_REGn_HL, 8))
/*@}*/

/*!
 * @name Register RFSYS_REGn, field HH[31:24] (RW)
 *
 * High higher byte
 */
/*@{*/
#define BP_RFSYS_REGn_HH     (24U)         /*!< Bit position for RFSYS_REGn_HH. */
#define BM_RFSYS_REGn_HH     (0xFF000000U) /*!< Bit mask for RFSYS_REGn_HH. */
#define BS_RFSYS_REGn_HH     (8U)          /*!< Bit field size in bits for RFSYS_REGn_HH. */

/*! @brief Read current value of the RFSYS_REGn_HH field. */
#define BR_RFSYS_REGn_HH(x, n) (BME_UBFX32(HW_RFSYS_REGn_ADDR(x, n), BP_RFSYS_REGn_HH, BS_RFSYS_REGn_HH))

/*! @brief Format value for bitfield RFSYS_REGn_HH. */
#define BF_RFSYS_REGn_HH(v)  ((uint32_t)((uint32_t)(v) << BP_RFSYS_REGn_HH) & BM_RFSYS_REGn_HH)

/*! @brief Set the HH field to a new value. */
#define BW_RFSYS_REGn_HH(x, n, v) (BME_BFI32(HW_RFSYS_REGn_ADDR(x, n), ((uint32_t)(v) << BP_RFSYS_REGn_HH), BP_RFSYS_REGn_HH, 8))
/*@}*/

/*******************************************************************************
 * hw_rfsys_t - module struct
 ******************************************************************************/
/*!
 * @brief All RFSYS module registers.
 */
#pragma pack(1)
typedef struct _hw_rfsys
{
    __IO hw_rfsys_regn_t REGn[8];          /*!< [0x0] Register file register */
} hw_rfsys_t;
#pragma pack()

/*! @brief Macro to access all RFSYS registers. */
/*! @param x RFSYS module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_RFSYS_REGS(RFSYS_BASE)</code>. */
#define HW_RFSYS_REGS(x) (*(hw_rfsys_t *)(x))

/*
 * MKL43Z4 ROM
 *
 * System ROM
 *
 * Registers defined in this header file:
 * - HW_ROM_ENTRYn - Entry
 * - HW_ROM_TABLEMARK - End of Table Marker Register
 * - HW_ROM_SYSACCESS - System Access Register
 * - HW_ROM_PERIPHID4 - Peripheral ID Register
 * - HW_ROM_PERIPHID5 - Peripheral ID Register
 * - HW_ROM_PERIPHID6 - Peripheral ID Register
 * - HW_ROM_PERIPHID7 - Peripheral ID Register
 * - HW_ROM_PERIPHID0 - Peripheral ID Register
 * - HW_ROM_PERIPHID1 - Peripheral ID Register
 * - HW_ROM_PERIPHID2 - Peripheral ID Register
 * - HW_ROM_PERIPHID3 - Peripheral ID Register
 * - HW_ROM_COMPIDn - Component ID Register
 *
 * - hw_rom_t - Struct containing all module registers.
 */

#define HW_ROM_INSTANCE_COUNT (1U) /*!< Number of instances of the ROM module. */
#define HW_ROM (0U) /*!< Instance number for ROM. */

/*******************************************************************************
 * HW_ROM_ENTRYn - Entry
 ******************************************************************************/

/*!
 * @brief HW_ROM_ENTRYn - Entry (RO)
 *
 * Reset value: 0x00000000U
 *
 * The System ROM Table begins with "n" relative 32-bit addresses, one for each
 * debug component present in the device and terminating with an all-zero value
 * signaling the end of the table at the "n+1"-th value. It is hardwired to
 * specific values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_rom_entryn
{
    uint32_t U;
    struct _hw_rom_entryn_bitfields
    {
        uint32_t ENTRY : 32;           /*!< [31:0] ENTRY */
    } B;
} hw_rom_entryn_t;

/*!
 * @name Constants and macros for entire ROM_ENTRYn register
 */
/*@{*/
#define HW_ROM_ENTRYn_COUNT (3U)

#define HW_ROM_ENTRYn_ADDR(x, n) ((uint32_t)(x) + 0x0U + (0x4U * (n)))

#define HW_ROM_ENTRYn(x, n)      (*(__I hw_rom_entryn_t *) HW_ROM_ENTRYn_ADDR(x, n))
#define HW_ROM_ENTRYn_RD(x, n)   (HW_ROM_ENTRYn(x, n).U)
/*@}*/

/*
 * Constants & macros for individual ROM_ENTRYn bitfields
 */

/*!
 * @name Register ROM_ENTRYn, field ENTRY[31:0] (RO)
 *
 * Entry 0 (MTB) is hardwired to 0xFFFF_E003; Entry 1 (MTBDWT) to 0xFFFF_F003;
 * Entry 2 (CM0+ ROM Table) to 0xF00F_D003.
 */
/*@{*/
#define BP_ROM_ENTRYn_ENTRY  (0U)          /*!< Bit position for ROM_ENTRYn_ENTRY. */
#define BM_ROM_ENTRYn_ENTRY  (0xFFFFFFFFU) /*!< Bit mask for ROM_ENTRYn_ENTRY. */
#define BS_ROM_ENTRYn_ENTRY  (32U)         /*!< Bit field size in bits for ROM_ENTRYn_ENTRY. */

/*! @brief Read current value of the ROM_ENTRYn_ENTRY field. */
#define BR_ROM_ENTRYn_ENTRY(x, n) (HW_ROM_ENTRYn(x, n).U)
/*@}*/

/*******************************************************************************
 * HW_ROM_TABLEMARK - End of Table Marker Register
 ******************************************************************************/

/*!
 * @brief HW_ROM_TABLEMARK - End of Table Marker Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register indicates end of table marker. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_rom_tablemark
{
    uint32_t U;
    struct _hw_rom_tablemark_bitfields
    {
        uint32_t MARK : 32;            /*!< [31:0] MARK */
    } B;
} hw_rom_tablemark_t;

/*!
 * @name Constants and macros for entire ROM_TABLEMARK register
 */
/*@{*/
#define HW_ROM_TABLEMARK_ADDR(x) ((uint32_t)(x) + 0xCU)

#define HW_ROM_TABLEMARK(x)      (*(__I hw_rom_tablemark_t *) HW_ROM_TABLEMARK_ADDR(x))
#define HW_ROM_TABLEMARK_RD(x)   (HW_ROM_TABLEMARK(x).U)
/*@}*/

/*
 * Constants & macros for individual ROM_TABLEMARK bitfields
 */

/*!
 * @name Register ROM_TABLEMARK, field MARK[31:0] (RO)
 *
 * Hardwired to 0x0000_0000
 */
/*@{*/
#define BP_ROM_TABLEMARK_MARK (0U)         /*!< Bit position for ROM_TABLEMARK_MARK. */
#define BM_ROM_TABLEMARK_MARK (0xFFFFFFFFU) /*!< Bit mask for ROM_TABLEMARK_MARK. */
#define BS_ROM_TABLEMARK_MARK (32U)        /*!< Bit field size in bits for ROM_TABLEMARK_MARK. */

/*! @brief Read current value of the ROM_TABLEMARK_MARK field. */
#define BR_ROM_TABLEMARK_MARK(x) (HW_ROM_TABLEMARK(x).U)
/*@}*/

/*******************************************************************************
 * HW_ROM_SYSACCESS - System Access Register
 ******************************************************************************/

/*!
 * @brief HW_ROM_SYSACCESS - System Access Register (RO)
 *
 * Reset value: 0x00000001U
 *
 * This register indicates system access. It is hardwired to specific values
 * used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_rom_sysaccess
{
    uint32_t U;
    struct _hw_rom_sysaccess_bitfields
    {
        uint32_t SYSACCESS : 32;       /*!< [31:0] SYSACCESS */
    } B;
} hw_rom_sysaccess_t;

/*!
 * @name Constants and macros for entire ROM_SYSACCESS register
 */
/*@{*/
#define HW_ROM_SYSACCESS_ADDR(x) ((uint32_t)(x) + 0xFCCU)

#define HW_ROM_SYSACCESS(x)      (*(__I hw_rom_sysaccess_t *) HW_ROM_SYSACCESS_ADDR(x))
#define HW_ROM_SYSACCESS_RD(x)   (HW_ROM_SYSACCESS(x).U)
/*@}*/

/*
 * Constants & macros for individual ROM_SYSACCESS bitfields
 */

/*!
 * @name Register ROM_SYSACCESS, field SYSACCESS[31:0] (RO)
 *
 * Hardwired to 0x0000_0001
 */
/*@{*/
#define BP_ROM_SYSACCESS_SYSACCESS (0U)    /*!< Bit position for ROM_SYSACCESS_SYSACCESS. */
#define BM_ROM_SYSACCESS_SYSACCESS (0xFFFFFFFFU) /*!< Bit mask for ROM_SYSACCESS_SYSACCESS. */
#define BS_ROM_SYSACCESS_SYSACCESS (32U)   /*!< Bit field size in bits for ROM_SYSACCESS_SYSACCESS. */

/*! @brief Read current value of the ROM_SYSACCESS_SYSACCESS field. */
#define BR_ROM_SYSACCESS_SYSACCESS(x) (HW_ROM_SYSACCESS(x).U)
/*@}*/

/*******************************************************************************
 * HW_ROM_PERIPHID4 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_ROM_PERIPHID4 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_rom_periphid4
{
    uint32_t U;
    struct _hw_rom_periphid4_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_rom_periphid4_t;

/*!
 * @name Constants and macros for entire ROM_PERIPHID4 register
 */
/*@{*/
#define HW_ROM_PERIPHID4_ADDR(x) ((uint32_t)(x) + 0xFD0U)

#define HW_ROM_PERIPHID4(x)      (*(__I hw_rom_periphid4_t *) HW_ROM_PERIPHID4_ADDR(x))
#define HW_ROM_PERIPHID4_RD(x)   (HW_ROM_PERIPHID4(x).U)
/*@}*/

/*
 * Constants & macros for individual ROM_PERIPHID4 bitfields
 */

/*!
 * @name Register ROM_PERIPHID4, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID1 is hardwired to 0x0000_00E0; ID2 to 0x0000_0008; and all the
 * others to 0x0000_0000.
 */
/*@{*/
#define BP_ROM_PERIPHID4_PERIPHID (0U)     /*!< Bit position for ROM_PERIPHID4_PERIPHID. */
#define BM_ROM_PERIPHID4_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for ROM_PERIPHID4_PERIPHID. */
#define BS_ROM_PERIPHID4_PERIPHID (32U)    /*!< Bit field size in bits for ROM_PERIPHID4_PERIPHID. */

/*! @brief Read current value of the ROM_PERIPHID4_PERIPHID field. */
#define BR_ROM_PERIPHID4_PERIPHID(x) (HW_ROM_PERIPHID4(x).U)
/*@}*/

/*******************************************************************************
 * HW_ROM_PERIPHID5 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_ROM_PERIPHID5 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_rom_periphid5
{
    uint32_t U;
    struct _hw_rom_periphid5_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_rom_periphid5_t;

/*!
 * @name Constants and macros for entire ROM_PERIPHID5 register
 */
/*@{*/
#define HW_ROM_PERIPHID5_ADDR(x) ((uint32_t)(x) + 0xFD4U)

#define HW_ROM_PERIPHID5(x)      (*(__I hw_rom_periphid5_t *) HW_ROM_PERIPHID5_ADDR(x))
#define HW_ROM_PERIPHID5_RD(x)   (HW_ROM_PERIPHID5(x).U)
/*@}*/

/*
 * Constants & macros for individual ROM_PERIPHID5 bitfields
 */

/*!
 * @name Register ROM_PERIPHID5, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID1 is hardwired to 0x0000_00E0; ID2 to 0x0000_0008; and all the
 * others to 0x0000_0000.
 */
/*@{*/
#define BP_ROM_PERIPHID5_PERIPHID (0U)     /*!< Bit position for ROM_PERIPHID5_PERIPHID. */
#define BM_ROM_PERIPHID5_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for ROM_PERIPHID5_PERIPHID. */
#define BS_ROM_PERIPHID5_PERIPHID (32U)    /*!< Bit field size in bits for ROM_PERIPHID5_PERIPHID. */

/*! @brief Read current value of the ROM_PERIPHID5_PERIPHID field. */
#define BR_ROM_PERIPHID5_PERIPHID(x) (HW_ROM_PERIPHID5(x).U)
/*@}*/

/*******************************************************************************
 * HW_ROM_PERIPHID6 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_ROM_PERIPHID6 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_rom_periphid6
{
    uint32_t U;
    struct _hw_rom_periphid6_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_rom_periphid6_t;

/*!
 * @name Constants and macros for entire ROM_PERIPHID6 register
 */
/*@{*/
#define HW_ROM_PERIPHID6_ADDR(x) ((uint32_t)(x) + 0xFD8U)

#define HW_ROM_PERIPHID6(x)      (*(__I hw_rom_periphid6_t *) HW_ROM_PERIPHID6_ADDR(x))
#define HW_ROM_PERIPHID6_RD(x)   (HW_ROM_PERIPHID6(x).U)
/*@}*/

/*
 * Constants & macros for individual ROM_PERIPHID6 bitfields
 */

/*!
 * @name Register ROM_PERIPHID6, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID1 is hardwired to 0x0000_00E0; ID2 to 0x0000_0008; and all the
 * others to 0x0000_0000.
 */
/*@{*/
#define BP_ROM_PERIPHID6_PERIPHID (0U)     /*!< Bit position for ROM_PERIPHID6_PERIPHID. */
#define BM_ROM_PERIPHID6_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for ROM_PERIPHID6_PERIPHID. */
#define BS_ROM_PERIPHID6_PERIPHID (32U)    /*!< Bit field size in bits for ROM_PERIPHID6_PERIPHID. */

/*! @brief Read current value of the ROM_PERIPHID6_PERIPHID field. */
#define BR_ROM_PERIPHID6_PERIPHID(x) (HW_ROM_PERIPHID6(x).U)
/*@}*/

/*******************************************************************************
 * HW_ROM_PERIPHID7 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_ROM_PERIPHID7 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_rom_periphid7
{
    uint32_t U;
    struct _hw_rom_periphid7_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_rom_periphid7_t;

/*!
 * @name Constants and macros for entire ROM_PERIPHID7 register
 */
/*@{*/
#define HW_ROM_PERIPHID7_ADDR(x) ((uint32_t)(x) + 0xFDCU)

#define HW_ROM_PERIPHID7(x)      (*(__I hw_rom_periphid7_t *) HW_ROM_PERIPHID7_ADDR(x))
#define HW_ROM_PERIPHID7_RD(x)   (HW_ROM_PERIPHID7(x).U)
/*@}*/

/*
 * Constants & macros for individual ROM_PERIPHID7 bitfields
 */

/*!
 * @name Register ROM_PERIPHID7, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID1 is hardwired to 0x0000_00E0; ID2 to 0x0000_0008; and all the
 * others to 0x0000_0000.
 */
/*@{*/
#define BP_ROM_PERIPHID7_PERIPHID (0U)     /*!< Bit position for ROM_PERIPHID7_PERIPHID. */
#define BM_ROM_PERIPHID7_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for ROM_PERIPHID7_PERIPHID. */
#define BS_ROM_PERIPHID7_PERIPHID (32U)    /*!< Bit field size in bits for ROM_PERIPHID7_PERIPHID. */

/*! @brief Read current value of the ROM_PERIPHID7_PERIPHID field. */
#define BR_ROM_PERIPHID7_PERIPHID(x) (HW_ROM_PERIPHID7(x).U)
/*@}*/

/*******************************************************************************
 * HW_ROM_PERIPHID0 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_ROM_PERIPHID0 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_rom_periphid0
{
    uint32_t U;
    struct _hw_rom_periphid0_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_rom_periphid0_t;

/*!
 * @name Constants and macros for entire ROM_PERIPHID0 register
 */
/*@{*/
#define HW_ROM_PERIPHID0_ADDR(x) ((uint32_t)(x) + 0xFE0U)

#define HW_ROM_PERIPHID0(x)      (*(__I hw_rom_periphid0_t *) HW_ROM_PERIPHID0_ADDR(x))
#define HW_ROM_PERIPHID0_RD(x)   (HW_ROM_PERIPHID0(x).U)
/*@}*/

/*
 * Constants & macros for individual ROM_PERIPHID0 bitfields
 */

/*!
 * @name Register ROM_PERIPHID0, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID1 is hardwired to 0x0000_00E0; ID2 to 0x0000_0008; and all the
 * others to 0x0000_0000.
 */
/*@{*/
#define BP_ROM_PERIPHID0_PERIPHID (0U)     /*!< Bit position for ROM_PERIPHID0_PERIPHID. */
#define BM_ROM_PERIPHID0_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for ROM_PERIPHID0_PERIPHID. */
#define BS_ROM_PERIPHID0_PERIPHID (32U)    /*!< Bit field size in bits for ROM_PERIPHID0_PERIPHID. */

/*! @brief Read current value of the ROM_PERIPHID0_PERIPHID field. */
#define BR_ROM_PERIPHID0_PERIPHID(x) (HW_ROM_PERIPHID0(x).U)
/*@}*/

/*******************************************************************************
 * HW_ROM_PERIPHID1 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_ROM_PERIPHID1 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_rom_periphid1
{
    uint32_t U;
    struct _hw_rom_periphid1_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_rom_periphid1_t;

/*!
 * @name Constants and macros for entire ROM_PERIPHID1 register
 */
/*@{*/
#define HW_ROM_PERIPHID1_ADDR(x) ((uint32_t)(x) + 0xFE4U)

#define HW_ROM_PERIPHID1(x)      (*(__I hw_rom_periphid1_t *) HW_ROM_PERIPHID1_ADDR(x))
#define HW_ROM_PERIPHID1_RD(x)   (HW_ROM_PERIPHID1(x).U)
/*@}*/

/*
 * Constants & macros for individual ROM_PERIPHID1 bitfields
 */

/*!
 * @name Register ROM_PERIPHID1, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID1 is hardwired to 0x0000_00E0; ID2 to 0x0000_0008; and all the
 * others to 0x0000_0000.
 */
/*@{*/
#define BP_ROM_PERIPHID1_PERIPHID (0U)     /*!< Bit position for ROM_PERIPHID1_PERIPHID. */
#define BM_ROM_PERIPHID1_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for ROM_PERIPHID1_PERIPHID. */
#define BS_ROM_PERIPHID1_PERIPHID (32U)    /*!< Bit field size in bits for ROM_PERIPHID1_PERIPHID. */

/*! @brief Read current value of the ROM_PERIPHID1_PERIPHID field. */
#define BR_ROM_PERIPHID1_PERIPHID(x) (HW_ROM_PERIPHID1(x).U)
/*@}*/

/*******************************************************************************
 * HW_ROM_PERIPHID2 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_ROM_PERIPHID2 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_rom_periphid2
{
    uint32_t U;
    struct _hw_rom_periphid2_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_rom_periphid2_t;

/*!
 * @name Constants and macros for entire ROM_PERIPHID2 register
 */
/*@{*/
#define HW_ROM_PERIPHID2_ADDR(x) ((uint32_t)(x) + 0xFE8U)

#define HW_ROM_PERIPHID2(x)      (*(__I hw_rom_periphid2_t *) HW_ROM_PERIPHID2_ADDR(x))
#define HW_ROM_PERIPHID2_RD(x)   (HW_ROM_PERIPHID2(x).U)
/*@}*/

/*
 * Constants & macros for individual ROM_PERIPHID2 bitfields
 */

/*!
 * @name Register ROM_PERIPHID2, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID1 is hardwired to 0x0000_00E0; ID2 to 0x0000_0008; and all the
 * others to 0x0000_0000.
 */
/*@{*/
#define BP_ROM_PERIPHID2_PERIPHID (0U)     /*!< Bit position for ROM_PERIPHID2_PERIPHID. */
#define BM_ROM_PERIPHID2_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for ROM_PERIPHID2_PERIPHID. */
#define BS_ROM_PERIPHID2_PERIPHID (32U)    /*!< Bit field size in bits for ROM_PERIPHID2_PERIPHID. */

/*! @brief Read current value of the ROM_PERIPHID2_PERIPHID field. */
#define BR_ROM_PERIPHID2_PERIPHID(x) (HW_ROM_PERIPHID2(x).U)
/*@}*/

/*******************************************************************************
 * HW_ROM_PERIPHID3 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief HW_ROM_PERIPHID3 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_rom_periphid3
{
    uint32_t U;
    struct _hw_rom_periphid3_bitfields
    {
        uint32_t PERIPHID : 32;        /*!< [31:0] PERIPHID */
    } B;
} hw_rom_periphid3_t;

/*!
 * @name Constants and macros for entire ROM_PERIPHID3 register
 */
/*@{*/
#define HW_ROM_PERIPHID3_ADDR(x) ((uint32_t)(x) + 0xFECU)

#define HW_ROM_PERIPHID3(x)      (*(__I hw_rom_periphid3_t *) HW_ROM_PERIPHID3_ADDR(x))
#define HW_ROM_PERIPHID3_RD(x)   (HW_ROM_PERIPHID3(x).U)
/*@}*/

/*
 * Constants & macros for individual ROM_PERIPHID3 bitfields
 */

/*!
 * @name Register ROM_PERIPHID3, field PERIPHID[31:0] (RO)
 *
 * Peripheral ID1 is hardwired to 0x0000_00E0; ID2 to 0x0000_0008; and all the
 * others to 0x0000_0000.
 */
/*@{*/
#define BP_ROM_PERIPHID3_PERIPHID (0U)     /*!< Bit position for ROM_PERIPHID3_PERIPHID. */
#define BM_ROM_PERIPHID3_PERIPHID (0xFFFFFFFFU) /*!< Bit mask for ROM_PERIPHID3_PERIPHID. */
#define BS_ROM_PERIPHID3_PERIPHID (32U)    /*!< Bit field size in bits for ROM_PERIPHID3_PERIPHID. */

/*! @brief Read current value of the ROM_PERIPHID3_PERIPHID field. */
#define BR_ROM_PERIPHID3_PERIPHID(x) (HW_ROM_PERIPHID3(x).U)
/*@}*/

/*******************************************************************************
 * HW_ROM_COMPIDn - Component ID Register
 ******************************************************************************/

/*!
 * @brief HW_ROM_COMPIDn - Component ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the component IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
typedef union _hw_rom_compidn
{
    uint32_t U;
    struct _hw_rom_compidn_bitfields
    {
        uint32_t COMPID : 32;          /*!< [31:0] Component ID */
    } B;
} hw_rom_compidn_t;

/*!
 * @name Constants and macros for entire ROM_COMPIDn register
 */
/*@{*/
#define HW_ROM_COMPIDn_COUNT (4U)

#define HW_ROM_COMPIDn_ADDR(x, n) ((uint32_t)(x) + 0xFF0U + (0x4U * (n)))

#define HW_ROM_COMPIDn(x, n)     (*(__I hw_rom_compidn_t *) HW_ROM_COMPIDn_ADDR(x, n))
#define HW_ROM_COMPIDn_RD(x, n)  (HW_ROM_COMPIDn(x, n).U)
/*@}*/

/*
 * Constants & macros for individual ROM_COMPIDn bitfields
 */

/*!
 * @name Register ROM_COMPIDn, field COMPID[31:0] (RO)
 *
 * Component ID0 is hardwired to 0x0000_000D; ID1 to 0x0000_0010; ID2 to
 * 0x0000_0005; ID3 to 0x0000_00B1.
 */
/*@{*/
#define BP_ROM_COMPIDn_COMPID (0U)         /*!< Bit position for ROM_COMPIDn_COMPID. */
#define BM_ROM_COMPIDn_COMPID (0xFFFFFFFFU) /*!< Bit mask for ROM_COMPIDn_COMPID. */
#define BS_ROM_COMPIDn_COMPID (32U)        /*!< Bit field size in bits for ROM_COMPIDn_COMPID. */

/*! @brief Read current value of the ROM_COMPIDn_COMPID field. */
#define BR_ROM_COMPIDn_COMPID(x, n) (HW_ROM_COMPIDn(x, n).U)
/*@}*/

/*******************************************************************************
 * hw_rom_t - module struct
 ******************************************************************************/
/*!
 * @brief All ROM module registers.
 */
#pragma pack(1)
typedef struct _hw_rom
{
    __I hw_rom_entryn_t ENTRYn[3];         /*!< [0x0] Entry */
    __I hw_rom_tablemark_t TABLEMARK;      /*!< [0xC] End of Table Marker Register */
    uint8_t _reserved0[4028];
    __I hw_rom_sysaccess_t SYSACCESS;      /*!< [0xFCC] System Access Register */
    __I hw_rom_periphid4_t PERIPHID4;      /*!< [0xFD0] Peripheral ID Register */
    __I hw_rom_periphid5_t PERIPHID5;      /*!< [0xFD4] Peripheral ID Register */
    __I hw_rom_periphid6_t PERIPHID6;      /*!< [0xFD8] Peripheral ID Register */
    __I hw_rom_periphid7_t PERIPHID7;      /*!< [0xFDC] Peripheral ID Register */
    __I hw_rom_periphid0_t PERIPHID0;      /*!< [0xFE0] Peripheral ID Register */
    __I hw_rom_periphid1_t PERIPHID1;      /*!< [0xFE4] Peripheral ID Register */
    __I hw_rom_periphid2_t PERIPHID2;      /*!< [0xFE8] Peripheral ID Register */
    __I hw_rom_periphid3_t PERIPHID3;      /*!< [0xFEC] Peripheral ID Register */
    __I hw_rom_compidn_t COMPIDn[4];       /*!< [0xFF0] Component ID Register */
} hw_rom_t;
#pragma pack()

/*! @brief Macro to access all ROM registers. */
/*! @param x ROM module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_ROM_REGS(ROM_BASE)</code>. */
#define HW_ROM_REGS(x) (*(hw_rom_t *)(x))

/*
 * MKL43Z4 RTC
 *
 * Secure Real Time Clock
 *
 * Registers defined in this header file:
 * - HW_RTC_TSR - RTC Time Seconds Register
 * - HW_RTC_TPR - RTC Time Prescaler Register
 * - HW_RTC_TAR - RTC Time Alarm Register
 * - HW_RTC_TCR - RTC Time Compensation Register
 * - HW_RTC_CR - RTC Control Register
 * - HW_RTC_SR - RTC Status Register
 * - HW_RTC_LR - RTC Lock Register
 * - HW_RTC_IER - RTC Interrupt Enable Register
 *
 * - hw_rtc_t - Struct containing all module registers.
 */

#define HW_RTC_INSTANCE_COUNT (1U) /*!< Number of instances of the RTC module. */
#define HW_RTC (0U) /*!< Instance number for RTC. */

/*******************************************************************************
 * HW_RTC_TSR - RTC Time Seconds Register
 ******************************************************************************/

/*!
 * @brief HW_RTC_TSR - RTC Time Seconds Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_rtc_tsr
{
    uint32_t U;
    struct _hw_rtc_tsr_bitfields
    {
        uint32_t TSR : 32;             /*!< [31:0] Time Seconds Register */
    } B;
} hw_rtc_tsr_t;

/*!
 * @name Constants and macros for entire RTC_TSR register
 */
/*@{*/
#define HW_RTC_TSR_ADDR(x)       ((uint32_t)(x) + 0x0U)

#define HW_RTC_TSR(x)            (*(__IO hw_rtc_tsr_t *) HW_RTC_TSR_ADDR(x))
#define HW_RTC_TSR_RD(x)         (HW_RTC_TSR(x).U)
#define HW_RTC_TSR_WR(x, v)      (HW_RTC_TSR(x).U = (v))
#define HW_RTC_TSR_SET(x, v)     (BME_OR32(HW_RTC_TSR_ADDR(x), (uint32_t)(v)))
#define HW_RTC_TSR_CLR(x, v)     (BME_AND32(HW_RTC_TSR_ADDR(x), (uint32_t)(~(v))))
#define HW_RTC_TSR_TOG(x, v)     (BME_XOR32(HW_RTC_TSR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual RTC_TSR bitfields
 */

/*!
 * @name Register RTC_TSR, field TSR[31:0] (RW)
 *
 * When the time counter is enabled, the TSR is read only and increments once a
 * second provided SR[TOF] or SR[TIF] are not set. The time counter will read as
 * zero when SR[TOF] or SR[TIF] are set. When the time counter is disabled, the
 * TSR can be read or written. Writing to the TSR when the time counter is
 * disabled will clear the SR[TOF] and/or the SR[TIF]. Writing to TSR with zero is
 * supported, but not recommended because TSR will read as zero when SR[TIF] or
 * SR[TOF] are set (indicating the time is invalid).
 */
/*@{*/
#define BP_RTC_TSR_TSR       (0U)          /*!< Bit position for RTC_TSR_TSR. */
#define BM_RTC_TSR_TSR       (0xFFFFFFFFU) /*!< Bit mask for RTC_TSR_TSR. */
#define BS_RTC_TSR_TSR       (32U)         /*!< Bit field size in bits for RTC_TSR_TSR. */

/*! @brief Read current value of the RTC_TSR_TSR field. */
#define BR_RTC_TSR_TSR(x)    (HW_RTC_TSR(x).U)

/*! @brief Format value for bitfield RTC_TSR_TSR. */
#define BF_RTC_TSR_TSR(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_TSR_TSR) & BM_RTC_TSR_TSR)

/*! @brief Set the TSR field to a new value. */
#define BW_RTC_TSR_TSR(x, v) (HW_RTC_TSR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_RTC_TPR - RTC Time Prescaler Register
 ******************************************************************************/

/*!
 * @brief HW_RTC_TPR - RTC Time Prescaler Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_rtc_tpr
{
    uint32_t U;
    struct _hw_rtc_tpr_bitfields
    {
        uint32_t TPR : 16;             /*!< [15:0] Time Prescaler Register */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_rtc_tpr_t;

/*!
 * @name Constants and macros for entire RTC_TPR register
 */
/*@{*/
#define HW_RTC_TPR_ADDR(x)       ((uint32_t)(x) + 0x4U)

#define HW_RTC_TPR(x)            (*(__IO hw_rtc_tpr_t *) HW_RTC_TPR_ADDR(x))
#define HW_RTC_TPR_RD(x)         (HW_RTC_TPR(x).U)
#define HW_RTC_TPR_WR(x, v)      (HW_RTC_TPR(x).U = (v))
#define HW_RTC_TPR_SET(x, v)     (BME_OR32(HW_RTC_TPR_ADDR(x), (uint32_t)(v)))
#define HW_RTC_TPR_CLR(x, v)     (BME_AND32(HW_RTC_TPR_ADDR(x), (uint32_t)(~(v))))
#define HW_RTC_TPR_TOG(x, v)     (BME_XOR32(HW_RTC_TPR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual RTC_TPR bitfields
 */

/*!
 * @name Register RTC_TPR, field TPR[15:0] (RW)
 *
 * When the time counter is enabled, the TPR is read only and increments every
 * 32.768 kHz clock cycle. The time counter will read as zero when SR[TOF] or
 * SR[TIF] are set. When the time counter is disabled, the TPR can be read or
 * written. The TSR[TSR] increments when bit 14 of the TPR transitions from a logic one
 * to a logic zero.
 */
/*@{*/
#define BP_RTC_TPR_TPR       (0U)          /*!< Bit position for RTC_TPR_TPR. */
#define BM_RTC_TPR_TPR       (0x0000FFFFU) /*!< Bit mask for RTC_TPR_TPR. */
#define BS_RTC_TPR_TPR       (16U)         /*!< Bit field size in bits for RTC_TPR_TPR. */

/*! @brief Read current value of the RTC_TPR_TPR field. */
#define BR_RTC_TPR_TPR(x)    (BME_UBFX32(HW_RTC_TPR_ADDR(x), BP_RTC_TPR_TPR, BS_RTC_TPR_TPR))

/*! @brief Format value for bitfield RTC_TPR_TPR. */
#define BF_RTC_TPR_TPR(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_TPR_TPR) & BM_RTC_TPR_TPR)

/*! @brief Set the TPR field to a new value. */
#define BW_RTC_TPR_TPR(x, v) (BME_BFI32(HW_RTC_TPR_ADDR(x), ((uint32_t)(v) << BP_RTC_TPR_TPR), BP_RTC_TPR_TPR, 16))
/*@}*/

/*******************************************************************************
 * HW_RTC_TAR - RTC Time Alarm Register
 ******************************************************************************/

/*!
 * @brief HW_RTC_TAR - RTC Time Alarm Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_rtc_tar
{
    uint32_t U;
    struct _hw_rtc_tar_bitfields
    {
        uint32_t TAR : 32;             /*!< [31:0] Time Alarm Register */
    } B;
} hw_rtc_tar_t;

/*!
 * @name Constants and macros for entire RTC_TAR register
 */
/*@{*/
#define HW_RTC_TAR_ADDR(x)       ((uint32_t)(x) + 0x8U)

#define HW_RTC_TAR(x)            (*(__IO hw_rtc_tar_t *) HW_RTC_TAR_ADDR(x))
#define HW_RTC_TAR_RD(x)         (HW_RTC_TAR(x).U)
#define HW_RTC_TAR_WR(x, v)      (HW_RTC_TAR(x).U = (v))
#define HW_RTC_TAR_SET(x, v)     (BME_OR32(HW_RTC_TAR_ADDR(x), (uint32_t)(v)))
#define HW_RTC_TAR_CLR(x, v)     (BME_AND32(HW_RTC_TAR_ADDR(x), (uint32_t)(~(v))))
#define HW_RTC_TAR_TOG(x, v)     (BME_XOR32(HW_RTC_TAR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual RTC_TAR bitfields
 */

/*!
 * @name Register RTC_TAR, field TAR[31:0] (RW)
 *
 * When the time counter is enabled, the SR[TAF] is set whenever the TAR[TAR]
 * equals the TSR[TSR] and the TSR[TSR] increments. Writing to the TAR clears the
 * SR[TAF].
 */
/*@{*/
#define BP_RTC_TAR_TAR       (0U)          /*!< Bit position for RTC_TAR_TAR. */
#define BM_RTC_TAR_TAR       (0xFFFFFFFFU) /*!< Bit mask for RTC_TAR_TAR. */
#define BS_RTC_TAR_TAR       (32U)         /*!< Bit field size in bits for RTC_TAR_TAR. */

/*! @brief Read current value of the RTC_TAR_TAR field. */
#define BR_RTC_TAR_TAR(x)    (HW_RTC_TAR(x).U)

/*! @brief Format value for bitfield RTC_TAR_TAR. */
#define BF_RTC_TAR_TAR(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_TAR_TAR) & BM_RTC_TAR_TAR)

/*! @brief Set the TAR field to a new value. */
#define BW_RTC_TAR_TAR(x, v) (HW_RTC_TAR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_RTC_TCR - RTC Time Compensation Register
 ******************************************************************************/

/*!
 * @brief HW_RTC_TCR - RTC Time Compensation Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_rtc_tcr
{
    uint32_t U;
    struct _hw_rtc_tcr_bitfields
    {
        uint32_t TCR : 8;              /*!< [7:0] Time Compensation Register */
        uint32_t CIR : 8;              /*!< [15:8] Compensation Interval Register */
        uint32_t TCV : 8;              /*!< [23:16] Time Compensation Value */
        uint32_t CIC : 8;              /*!< [31:24] Compensation Interval Counter */
    } B;
} hw_rtc_tcr_t;

/*!
 * @name Constants and macros for entire RTC_TCR register
 */
/*@{*/
#define HW_RTC_TCR_ADDR(x)       ((uint32_t)(x) + 0xCU)

#define HW_RTC_TCR(x)            (*(__IO hw_rtc_tcr_t *) HW_RTC_TCR_ADDR(x))
#define HW_RTC_TCR_RD(x)         (HW_RTC_TCR(x).U)
#define HW_RTC_TCR_WR(x, v)      (HW_RTC_TCR(x).U = (v))
#define HW_RTC_TCR_SET(x, v)     (BME_OR32(HW_RTC_TCR_ADDR(x), (uint32_t)(v)))
#define HW_RTC_TCR_CLR(x, v)     (BME_AND32(HW_RTC_TCR_ADDR(x), (uint32_t)(~(v))))
#define HW_RTC_TCR_TOG(x, v)     (BME_XOR32(HW_RTC_TCR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual RTC_TCR bitfields
 */

/*!
 * @name Register RTC_TCR, field TCR[7:0] (RW)
 *
 * Configures the number of 32.768 kHz clock cycles in each second. This
 * register is double buffered and writes do not take affect until the end of the
 * current compensation interval.
 *
 * Values:
 * - 10000000 - Time Prescaler Register overflows every 32896 clock cycles.
 * - 11111111 - Time Prescaler Register overflows every 32769 clock cycles.
 * - 0 - Time Prescaler Register overflows every 32768 clock cycles.
 * - 1 - Time Prescaler Register overflows every 32767 clock cycles.
 * - 1111111 - Time Prescaler Register overflows every 32641 clock cycles.
 */
/*@{*/
#define BP_RTC_TCR_TCR       (0U)          /*!< Bit position for RTC_TCR_TCR. */
#define BM_RTC_TCR_TCR       (0x000000FFU) /*!< Bit mask for RTC_TCR_TCR. */
#define BS_RTC_TCR_TCR       (8U)          /*!< Bit field size in bits for RTC_TCR_TCR. */

/*! @brief Read current value of the RTC_TCR_TCR field. */
#define BR_RTC_TCR_TCR(x)    (BME_UBFX32(HW_RTC_TCR_ADDR(x), BP_RTC_TCR_TCR, BS_RTC_TCR_TCR))

/*! @brief Format value for bitfield RTC_TCR_TCR. */
#define BF_RTC_TCR_TCR(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_TCR_TCR) & BM_RTC_TCR_TCR)

/*! @brief Set the TCR field to a new value. */
#define BW_RTC_TCR_TCR(x, v) (BME_BFI32(HW_RTC_TCR_ADDR(x), ((uint32_t)(v) << BP_RTC_TCR_TCR), BP_RTC_TCR_TCR, 8))
/*@}*/

/*!
 * @name Register RTC_TCR, field CIR[15:8] (RW)
 *
 * Configures the compensation interval in seconds from 1 to 256 to control how
 * frequently the TCR should adjust the number of 32.768 kHz cycles in each
 * second. The value written should be one less than the number of seconds. For
 * example, write zero to configure for a compensation interval of one second. This
 * register is double buffered and writes do not take affect until the end of the
 * current compensation interval.
 */
/*@{*/
#define BP_RTC_TCR_CIR       (8U)          /*!< Bit position for RTC_TCR_CIR. */
#define BM_RTC_TCR_CIR       (0x0000FF00U) /*!< Bit mask for RTC_TCR_CIR. */
#define BS_RTC_TCR_CIR       (8U)          /*!< Bit field size in bits for RTC_TCR_CIR. */

/*! @brief Read current value of the RTC_TCR_CIR field. */
#define BR_RTC_TCR_CIR(x)    (BME_UBFX32(HW_RTC_TCR_ADDR(x), BP_RTC_TCR_CIR, BS_RTC_TCR_CIR))

/*! @brief Format value for bitfield RTC_TCR_CIR. */
#define BF_RTC_TCR_CIR(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_TCR_CIR) & BM_RTC_TCR_CIR)

/*! @brief Set the CIR field to a new value. */
#define BW_RTC_TCR_CIR(x, v) (BME_BFI32(HW_RTC_TCR_ADDR(x), ((uint32_t)(v) << BP_RTC_TCR_CIR), BP_RTC_TCR_CIR, 8))
/*@}*/

/*!
 * @name Register RTC_TCR, field TCV[23:16] (RO)
 *
 * Current value used by the compensation logic for the present second interval.
 * Updated once a second if the CIC equals 0 with the contents of the TCR field.
 * If the CIC does not equal zero then it is loaded with zero (compensation is
 * not enabled for that second increment).
 */
/*@{*/
#define BP_RTC_TCR_TCV       (16U)         /*!< Bit position for RTC_TCR_TCV. */
#define BM_RTC_TCR_TCV       (0x00FF0000U) /*!< Bit mask for RTC_TCR_TCV. */
#define BS_RTC_TCR_TCV       (8U)          /*!< Bit field size in bits for RTC_TCR_TCV. */

/*! @brief Read current value of the RTC_TCR_TCV field. */
#define BR_RTC_TCR_TCV(x)    (BME_UBFX32(HW_RTC_TCR_ADDR(x), BP_RTC_TCR_TCV, BS_RTC_TCR_TCV))
/*@}*/

/*!
 * @name Register RTC_TCR, field CIC[31:24] (RO)
 *
 * Current value of the compensation interval counter. If the compensation
 * interval counter equals zero then it is loaded with the contents of the CIR. If the
 * CIC does not equal zero then it is decremented once a second.
 */
/*@{*/
#define BP_RTC_TCR_CIC       (24U)         /*!< Bit position for RTC_TCR_CIC. */
#define BM_RTC_TCR_CIC       (0xFF000000U) /*!< Bit mask for RTC_TCR_CIC. */
#define BS_RTC_TCR_CIC       (8U)          /*!< Bit field size in bits for RTC_TCR_CIC. */

/*! @brief Read current value of the RTC_TCR_CIC field. */
#define BR_RTC_TCR_CIC(x)    (BME_UBFX32(HW_RTC_TCR_ADDR(x), BP_RTC_TCR_CIC, BS_RTC_TCR_CIC))
/*@}*/

/*******************************************************************************
 * HW_RTC_CR - RTC Control Register
 ******************************************************************************/

/*!
 * @brief HW_RTC_CR - RTC Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_rtc_cr
{
    uint32_t U;
    struct _hw_rtc_cr_bitfields
    {
        uint32_t SWR : 1;              /*!< [0] Software Reset */
        uint32_t WPE : 1;              /*!< [1] Wakeup Pin Enable */
        uint32_t SUP : 1;              /*!< [2] Supervisor Access */
        uint32_t UM : 1;               /*!< [3] Update Mode */
        uint32_t WPS : 1;              /*!< [4] Wakeup Pin Select */
        uint32_t RESERVED0 : 3;        /*!< [7:5]  */
        uint32_t OSCE : 1;             /*!< [8] Oscillator Enable */
        uint32_t CLKO : 1;             /*!< [9] Clock Output */
        uint32_t SC16P : 1;            /*!< [10] Oscillator 16pF Load Configure */
        uint32_t SC8P : 1;             /*!< [11] Oscillator 8pF Load Configure */
        uint32_t SC4P : 1;             /*!< [12] Oscillator 4pF Load Configure */
        uint32_t SC2P : 1;             /*!< [13] Oscillator 2pF Load Configure */
        uint32_t RESERVED1 : 18;       /*!< [31:14]  */
    } B;
} hw_rtc_cr_t;

/*!
 * @name Constants and macros for entire RTC_CR register
 */
/*@{*/
#define HW_RTC_CR_ADDR(x)        ((uint32_t)(x) + 0x10U)

#define HW_RTC_CR(x)             (*(__IO hw_rtc_cr_t *) HW_RTC_CR_ADDR(x))
#define HW_RTC_CR_RD(x)          (HW_RTC_CR(x).U)
#define HW_RTC_CR_WR(x, v)       (HW_RTC_CR(x).U = (v))
#define HW_RTC_CR_SET(x, v)      (BME_OR32(HW_RTC_CR_ADDR(x), (uint32_t)(v)))
#define HW_RTC_CR_CLR(x, v)      (BME_AND32(HW_RTC_CR_ADDR(x), (uint32_t)(~(v))))
#define HW_RTC_CR_TOG(x, v)      (BME_XOR32(HW_RTC_CR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual RTC_CR bitfields
 */

/*!
 * @name Register RTC_CR, field SWR[0] (RW)
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Resets all RTC registers except for the SWR bit . The SWR bit is
 *     cleared by POR and by software explicitly clearing it.
 */
/*@{*/
#define BP_RTC_CR_SWR        (0U)          /*!< Bit position for RTC_CR_SWR. */
#define BM_RTC_CR_SWR        (0x00000001U) /*!< Bit mask for RTC_CR_SWR. */
#define BS_RTC_CR_SWR        (1U)          /*!< Bit field size in bits for RTC_CR_SWR. */

/*! @brief Read current value of the RTC_CR_SWR field. */
#define BR_RTC_CR_SWR(x)     (BME_UBFX32(HW_RTC_CR_ADDR(x), BP_RTC_CR_SWR, BS_RTC_CR_SWR))

/*! @brief Format value for bitfield RTC_CR_SWR. */
#define BF_RTC_CR_SWR(v)     ((uint32_t)((uint32_t)(v) << BP_RTC_CR_SWR) & BM_RTC_CR_SWR)

/*! @brief Set the SWR field to a new value. */
#define BW_RTC_CR_SWR(x, v)  (BME_BFI32(HW_RTC_CR_ADDR(x), ((uint32_t)(v) << BP_RTC_CR_SWR), BP_RTC_CR_SWR, 1))
/*@}*/

/*!
 * @name Register RTC_CR, field WPE[1] (RW)
 *
 * The wakeup pin is optional and not available on all devices.
 *
 * Values:
 * - 0 - Wakeup pin is disabled.
 * - 1 - Wakeup pin is enabled and wakeup pin asserts if the RTC interrupt
 *     asserts or the wakeup pin is turned on.
 */
/*@{*/
#define BP_RTC_CR_WPE        (1U)          /*!< Bit position for RTC_CR_WPE. */
#define BM_RTC_CR_WPE        (0x00000002U) /*!< Bit mask for RTC_CR_WPE. */
#define BS_RTC_CR_WPE        (1U)          /*!< Bit field size in bits for RTC_CR_WPE. */

/*! @brief Read current value of the RTC_CR_WPE field. */
#define BR_RTC_CR_WPE(x)     (BME_UBFX32(HW_RTC_CR_ADDR(x), BP_RTC_CR_WPE, BS_RTC_CR_WPE))

/*! @brief Format value for bitfield RTC_CR_WPE. */
#define BF_RTC_CR_WPE(v)     ((uint32_t)((uint32_t)(v) << BP_RTC_CR_WPE) & BM_RTC_CR_WPE)

/*! @brief Set the WPE field to a new value. */
#define BW_RTC_CR_WPE(x, v)  (BME_BFI32(HW_RTC_CR_ADDR(x), ((uint32_t)(v) << BP_RTC_CR_WPE), BP_RTC_CR_WPE, 1))
/*@}*/

/*!
 * @name Register RTC_CR, field SUP[2] (RW)
 *
 * Values:
 * - 0 - Non-supervisor mode write accesses are not supported and generate a bus
 *     error.
 * - 1 - Non-supervisor mode write accesses are supported.
 */
/*@{*/
#define BP_RTC_CR_SUP        (2U)          /*!< Bit position for RTC_CR_SUP. */
#define BM_RTC_CR_SUP        (0x00000004U) /*!< Bit mask for RTC_CR_SUP. */
#define BS_RTC_CR_SUP        (1U)          /*!< Bit field size in bits for RTC_CR_SUP. */

/*! @brief Read current value of the RTC_CR_SUP field. */
#define BR_RTC_CR_SUP(x)     (BME_UBFX32(HW_RTC_CR_ADDR(x), BP_RTC_CR_SUP, BS_RTC_CR_SUP))

/*! @brief Format value for bitfield RTC_CR_SUP. */
#define BF_RTC_CR_SUP(v)     ((uint32_t)((uint32_t)(v) << BP_RTC_CR_SUP) & BM_RTC_CR_SUP)

/*! @brief Set the SUP field to a new value. */
#define BW_RTC_CR_SUP(x, v)  (BME_BFI32(HW_RTC_CR_ADDR(x), ((uint32_t)(v) << BP_RTC_CR_SUP), BP_RTC_CR_SUP, 1))
/*@}*/

/*!
 * @name Register RTC_CR, field UM[3] (RW)
 *
 * Allows SR[TCE] to be written even when the Status Register is locked. When
 * set, the SR[TCE] can always be written if the SR[TIF] or SR[TOF] are set or if
 * the SR[TCE] is clear.
 *
 * Values:
 * - 0 - Registers cannot be written when locked.
 * - 1 - Registers can be written when locked under limited conditions.
 */
/*@{*/
#define BP_RTC_CR_UM         (3U)          /*!< Bit position for RTC_CR_UM. */
#define BM_RTC_CR_UM         (0x00000008U) /*!< Bit mask for RTC_CR_UM. */
#define BS_RTC_CR_UM         (1U)          /*!< Bit field size in bits for RTC_CR_UM. */

/*! @brief Read current value of the RTC_CR_UM field. */
#define BR_RTC_CR_UM(x)      (BME_UBFX32(HW_RTC_CR_ADDR(x), BP_RTC_CR_UM, BS_RTC_CR_UM))

/*! @brief Format value for bitfield RTC_CR_UM. */
#define BF_RTC_CR_UM(v)      ((uint32_t)((uint32_t)(v) << BP_RTC_CR_UM) & BM_RTC_CR_UM)

/*! @brief Set the UM field to a new value. */
#define BW_RTC_CR_UM(x, v)   (BME_BFI32(HW_RTC_CR_ADDR(x), ((uint32_t)(v) << BP_RTC_CR_UM), BP_RTC_CR_UM, 1))
/*@}*/

/*!
 * @name Register RTC_CR, field WPS[4] (RW)
 *
 * The wakeup pin is optional and not available on all devices.
 *
 * Values:
 * - 0 - Wakeup pin asserts (active low, open drain) if the RTC interrupt
 *     asserts or the wakeup pin is turned on.
 * - 1 - Wakeup pin instead outputs the RTC 32kHz clock, provided the wakeup pin
 *     is turned on and the 32kHz clock is output to other peripherals.
 */
/*@{*/
#define BP_RTC_CR_WPS        (4U)          /*!< Bit position for RTC_CR_WPS. */
#define BM_RTC_CR_WPS        (0x00000010U) /*!< Bit mask for RTC_CR_WPS. */
#define BS_RTC_CR_WPS        (1U)          /*!< Bit field size in bits for RTC_CR_WPS. */

/*! @brief Read current value of the RTC_CR_WPS field. */
#define BR_RTC_CR_WPS(x)     (BME_UBFX32(HW_RTC_CR_ADDR(x), BP_RTC_CR_WPS, BS_RTC_CR_WPS))

/*! @brief Format value for bitfield RTC_CR_WPS. */
#define BF_RTC_CR_WPS(v)     ((uint32_t)((uint32_t)(v) << BP_RTC_CR_WPS) & BM_RTC_CR_WPS)

/*! @brief Set the WPS field to a new value. */
#define BW_RTC_CR_WPS(x, v)  (BME_BFI32(HW_RTC_CR_ADDR(x), ((uint32_t)(v) << BP_RTC_CR_WPS), BP_RTC_CR_WPS, 1))
/*@}*/

/*!
 * @name Register RTC_CR, field OSCE[8] (RW)
 *
 * Values:
 * - 0 - 32.768 kHz oscillator is disabled.
 * - 1 - 32.768 kHz oscillator is enabled. After setting this bit, wait the
 *     oscillator startup time before enabling the time counter to allow the 32.768
 *     kHz clock time to stabilize.
 */
/*@{*/
#define BP_RTC_CR_OSCE       (8U)          /*!< Bit position for RTC_CR_OSCE. */
#define BM_RTC_CR_OSCE       (0x00000100U) /*!< Bit mask for RTC_CR_OSCE. */
#define BS_RTC_CR_OSCE       (1U)          /*!< Bit field size in bits for RTC_CR_OSCE. */

/*! @brief Read current value of the RTC_CR_OSCE field. */
#define BR_RTC_CR_OSCE(x)    (BME_UBFX32(HW_RTC_CR_ADDR(x), BP_RTC_CR_OSCE, BS_RTC_CR_OSCE))

/*! @brief Format value for bitfield RTC_CR_OSCE. */
#define BF_RTC_CR_OSCE(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_CR_OSCE) & BM_RTC_CR_OSCE)

/*! @brief Set the OSCE field to a new value. */
#define BW_RTC_CR_OSCE(x, v) (BME_BFI32(HW_RTC_CR_ADDR(x), ((uint32_t)(v) << BP_RTC_CR_OSCE), BP_RTC_CR_OSCE, 1))
/*@}*/

/*!
 * @name Register RTC_CR, field CLKO[9] (RW)
 *
 * Values:
 * - 0 - The 32 kHz clock is output to other peripherals.
 * - 1 - The 32 kHz clock is not output to other peripherals.
 */
/*@{*/
#define BP_RTC_CR_CLKO       (9U)          /*!< Bit position for RTC_CR_CLKO. */
#define BM_RTC_CR_CLKO       (0x00000200U) /*!< Bit mask for RTC_CR_CLKO. */
#define BS_RTC_CR_CLKO       (1U)          /*!< Bit field size in bits for RTC_CR_CLKO. */

/*! @brief Read current value of the RTC_CR_CLKO field. */
#define BR_RTC_CR_CLKO(x)    (BME_UBFX32(HW_RTC_CR_ADDR(x), BP_RTC_CR_CLKO, BS_RTC_CR_CLKO))

/*! @brief Format value for bitfield RTC_CR_CLKO. */
#define BF_RTC_CR_CLKO(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_CR_CLKO) & BM_RTC_CR_CLKO)

/*! @brief Set the CLKO field to a new value. */
#define BW_RTC_CR_CLKO(x, v) (BME_BFI32(HW_RTC_CR_ADDR(x), ((uint32_t)(v) << BP_RTC_CR_CLKO), BP_RTC_CR_CLKO, 1))
/*@}*/

/*!
 * @name Register RTC_CR, field SC16P[10] (RW)
 *
 * Values:
 * - 0 - Disable the load.
 * - 1 - Enable the additional load.
 */
/*@{*/
#define BP_RTC_CR_SC16P      (10U)         /*!< Bit position for RTC_CR_SC16P. */
#define BM_RTC_CR_SC16P      (0x00000400U) /*!< Bit mask for RTC_CR_SC16P. */
#define BS_RTC_CR_SC16P      (1U)          /*!< Bit field size in bits for RTC_CR_SC16P. */

/*! @brief Read current value of the RTC_CR_SC16P field. */
#define BR_RTC_CR_SC16P(x)   (BME_UBFX32(HW_RTC_CR_ADDR(x), BP_RTC_CR_SC16P, BS_RTC_CR_SC16P))

/*! @brief Format value for bitfield RTC_CR_SC16P. */
#define BF_RTC_CR_SC16P(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_CR_SC16P) & BM_RTC_CR_SC16P)

/*! @brief Set the SC16P field to a new value. */
#define BW_RTC_CR_SC16P(x, v) (BME_BFI32(HW_RTC_CR_ADDR(x), ((uint32_t)(v) << BP_RTC_CR_SC16P), BP_RTC_CR_SC16P, 1))
/*@}*/

/*!
 * @name Register RTC_CR, field SC8P[11] (RW)
 *
 * Values:
 * - 0 - Disable the load.
 * - 1 - Enable the additional load.
 */
/*@{*/
#define BP_RTC_CR_SC8P       (11U)         /*!< Bit position for RTC_CR_SC8P. */
#define BM_RTC_CR_SC8P       (0x00000800U) /*!< Bit mask for RTC_CR_SC8P. */
#define BS_RTC_CR_SC8P       (1U)          /*!< Bit field size in bits for RTC_CR_SC8P. */

/*! @brief Read current value of the RTC_CR_SC8P field. */
#define BR_RTC_CR_SC8P(x)    (BME_UBFX32(HW_RTC_CR_ADDR(x), BP_RTC_CR_SC8P, BS_RTC_CR_SC8P))

/*! @brief Format value for bitfield RTC_CR_SC8P. */
#define BF_RTC_CR_SC8P(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_CR_SC8P) & BM_RTC_CR_SC8P)

/*! @brief Set the SC8P field to a new value. */
#define BW_RTC_CR_SC8P(x, v) (BME_BFI32(HW_RTC_CR_ADDR(x), ((uint32_t)(v) << BP_RTC_CR_SC8P), BP_RTC_CR_SC8P, 1))
/*@}*/

/*!
 * @name Register RTC_CR, field SC4P[12] (RW)
 *
 * Values:
 * - 0 - Disable the load.
 * - 1 - Enable the additional load.
 */
/*@{*/
#define BP_RTC_CR_SC4P       (12U)         /*!< Bit position for RTC_CR_SC4P. */
#define BM_RTC_CR_SC4P       (0x00001000U) /*!< Bit mask for RTC_CR_SC4P. */
#define BS_RTC_CR_SC4P       (1U)          /*!< Bit field size in bits for RTC_CR_SC4P. */

/*! @brief Read current value of the RTC_CR_SC4P field. */
#define BR_RTC_CR_SC4P(x)    (BME_UBFX32(HW_RTC_CR_ADDR(x), BP_RTC_CR_SC4P, BS_RTC_CR_SC4P))

/*! @brief Format value for bitfield RTC_CR_SC4P. */
#define BF_RTC_CR_SC4P(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_CR_SC4P) & BM_RTC_CR_SC4P)

/*! @brief Set the SC4P field to a new value. */
#define BW_RTC_CR_SC4P(x, v) (BME_BFI32(HW_RTC_CR_ADDR(x), ((uint32_t)(v) << BP_RTC_CR_SC4P), BP_RTC_CR_SC4P, 1))
/*@}*/

/*!
 * @name Register RTC_CR, field SC2P[13] (RW)
 *
 * Values:
 * - 0 - Disable the load.
 * - 1 - Enable the additional load.
 */
/*@{*/
#define BP_RTC_CR_SC2P       (13U)         /*!< Bit position for RTC_CR_SC2P. */
#define BM_RTC_CR_SC2P       (0x00002000U) /*!< Bit mask for RTC_CR_SC2P. */
#define BS_RTC_CR_SC2P       (1U)          /*!< Bit field size in bits for RTC_CR_SC2P. */

/*! @brief Read current value of the RTC_CR_SC2P field. */
#define BR_RTC_CR_SC2P(x)    (BME_UBFX32(HW_RTC_CR_ADDR(x), BP_RTC_CR_SC2P, BS_RTC_CR_SC2P))

/*! @brief Format value for bitfield RTC_CR_SC2P. */
#define BF_RTC_CR_SC2P(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_CR_SC2P) & BM_RTC_CR_SC2P)

/*! @brief Set the SC2P field to a new value. */
#define BW_RTC_CR_SC2P(x, v) (BME_BFI32(HW_RTC_CR_ADDR(x), ((uint32_t)(v) << BP_RTC_CR_SC2P), BP_RTC_CR_SC2P, 1))
/*@}*/

/*******************************************************************************
 * HW_RTC_SR - RTC Status Register
 ******************************************************************************/

/*!
 * @brief HW_RTC_SR - RTC Status Register (RW)
 *
 * Reset value: 0x00000001U
 */
typedef union _hw_rtc_sr
{
    uint32_t U;
    struct _hw_rtc_sr_bitfields
    {
        uint32_t TIF : 1;              /*!< [0] Time Invalid Flag */
        uint32_t TOF : 1;              /*!< [1] Time Overflow Flag */
        uint32_t TAF : 1;              /*!< [2] Time Alarm Flag */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t TCE : 1;              /*!< [4] Time Counter Enable */
        uint32_t RESERVED1 : 27;       /*!< [31:5]  */
    } B;
} hw_rtc_sr_t;

/*!
 * @name Constants and macros for entire RTC_SR register
 */
/*@{*/
#define HW_RTC_SR_ADDR(x)        ((uint32_t)(x) + 0x14U)

#define HW_RTC_SR(x)             (*(__IO hw_rtc_sr_t *) HW_RTC_SR_ADDR(x))
#define HW_RTC_SR_RD(x)          (HW_RTC_SR(x).U)
#define HW_RTC_SR_WR(x, v)       (HW_RTC_SR(x).U = (v))
#define HW_RTC_SR_SET(x, v)      (BME_OR32(HW_RTC_SR_ADDR(x), (uint32_t)(v)))
#define HW_RTC_SR_CLR(x, v)      (BME_AND32(HW_RTC_SR_ADDR(x), (uint32_t)(~(v))))
#define HW_RTC_SR_TOG(x, v)      (BME_XOR32(HW_RTC_SR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual RTC_SR bitfields
 */

/*!
 * @name Register RTC_SR, field TIF[0] (RO)
 *
 * The time invalid flag is set on POR or software reset. The TSR and TPR do not
 * increment and read as zero when this bit is set. This bit is cleared by
 * writing the TSR register when the time counter is disabled.
 *
 * Values:
 * - 0 - Time is valid.
 * - 1 - Time is invalid and time counter is read as zero.
 */
/*@{*/
#define BP_RTC_SR_TIF        (0U)          /*!< Bit position for RTC_SR_TIF. */
#define BM_RTC_SR_TIF        (0x00000001U) /*!< Bit mask for RTC_SR_TIF. */
#define BS_RTC_SR_TIF        (1U)          /*!< Bit field size in bits for RTC_SR_TIF. */

/*! @brief Read current value of the RTC_SR_TIF field. */
#define BR_RTC_SR_TIF(x)     (BME_UBFX32(HW_RTC_SR_ADDR(x), BP_RTC_SR_TIF, BS_RTC_SR_TIF))
/*@}*/

/*!
 * @name Register RTC_SR, field TOF[1] (RO)
 *
 * Time overflow flag is set when the time counter is enabled and overflows. The
 * TSR and TPR do not increment and read as zero when this bit is set. This bit
 * is cleared by writing the TSR register when the time counter is disabled.
 *
 * Values:
 * - 0 - Time overflow has not occurred.
 * - 1 - Time overflow has occurred and time counter is read as zero.
 */
/*@{*/
#define BP_RTC_SR_TOF        (1U)          /*!< Bit position for RTC_SR_TOF. */
#define BM_RTC_SR_TOF        (0x00000002U) /*!< Bit mask for RTC_SR_TOF. */
#define BS_RTC_SR_TOF        (1U)          /*!< Bit field size in bits for RTC_SR_TOF. */

/*! @brief Read current value of the RTC_SR_TOF field. */
#define BR_RTC_SR_TOF(x)     (BME_UBFX32(HW_RTC_SR_ADDR(x), BP_RTC_SR_TOF, BS_RTC_SR_TOF))
/*@}*/

/*!
 * @name Register RTC_SR, field TAF[2] (RO)
 *
 * Time alarm flag is set when the TAR[TAR] equals the TSR[TSR] and the TSR[TSR]
 * increments. This bit is cleared by writing the TAR register.
 *
 * Values:
 * - 0 - Time alarm has not occurred.
 * - 1 - Time alarm has occurred.
 */
/*@{*/
#define BP_RTC_SR_TAF        (2U)          /*!< Bit position for RTC_SR_TAF. */
#define BM_RTC_SR_TAF        (0x00000004U) /*!< Bit mask for RTC_SR_TAF. */
#define BS_RTC_SR_TAF        (1U)          /*!< Bit field size in bits for RTC_SR_TAF. */

/*! @brief Read current value of the RTC_SR_TAF field. */
#define BR_RTC_SR_TAF(x)     (BME_UBFX32(HW_RTC_SR_ADDR(x), BP_RTC_SR_TAF, BS_RTC_SR_TAF))
/*@}*/

/*!
 * @name Register RTC_SR, field TCE[4] (RW)
 *
 * When time counter is disabled the TSR register and TPR register are
 * writeable, but do not increment. When time counter is enabled the TSR register and TPR
 * register are not writeable, but increment.
 *
 * Values:
 * - 0 - Time counter is disabled.
 * - 1 - Time counter is enabled.
 */
/*@{*/
#define BP_RTC_SR_TCE        (4U)          /*!< Bit position for RTC_SR_TCE. */
#define BM_RTC_SR_TCE        (0x00000010U) /*!< Bit mask for RTC_SR_TCE. */
#define BS_RTC_SR_TCE        (1U)          /*!< Bit field size in bits for RTC_SR_TCE. */

/*! @brief Read current value of the RTC_SR_TCE field. */
#define BR_RTC_SR_TCE(x)     (BME_UBFX32(HW_RTC_SR_ADDR(x), BP_RTC_SR_TCE, BS_RTC_SR_TCE))

/*! @brief Format value for bitfield RTC_SR_TCE. */
#define BF_RTC_SR_TCE(v)     ((uint32_t)((uint32_t)(v) << BP_RTC_SR_TCE) & BM_RTC_SR_TCE)

/*! @brief Set the TCE field to a new value. */
#define BW_RTC_SR_TCE(x, v)  (BME_BFI32(HW_RTC_SR_ADDR(x), ((uint32_t)(v) << BP_RTC_SR_TCE), BP_RTC_SR_TCE, 1))
/*@}*/

/*******************************************************************************
 * HW_RTC_LR - RTC Lock Register
 ******************************************************************************/

/*!
 * @brief HW_RTC_LR - RTC Lock Register (RW)
 *
 * Reset value: 0x000000FFU
 */
typedef union _hw_rtc_lr
{
    uint32_t U;
    struct _hw_rtc_lr_bitfields
    {
        uint32_t RESERVED0 : 3;        /*!< [2:0]  */
        uint32_t TCL : 1;              /*!< [3] Time Compensation Lock */
        uint32_t CRL : 1;              /*!< [4] Control Register Lock */
        uint32_t SRL : 1;              /*!< [5] Status Register Lock */
        uint32_t LRL : 1;              /*!< [6] Lock Register Lock */
        uint32_t RESERVED1 : 25;       /*!< [31:7]  */
    } B;
} hw_rtc_lr_t;

/*!
 * @name Constants and macros for entire RTC_LR register
 */
/*@{*/
#define HW_RTC_LR_ADDR(x)        ((uint32_t)(x) + 0x18U)

#define HW_RTC_LR(x)             (*(__IO hw_rtc_lr_t *) HW_RTC_LR_ADDR(x))
#define HW_RTC_LR_RD(x)          (HW_RTC_LR(x).U)
#define HW_RTC_LR_WR(x, v)       (HW_RTC_LR(x).U = (v))
#define HW_RTC_LR_SET(x, v)      (BME_OR32(HW_RTC_LR_ADDR(x), (uint32_t)(v)))
#define HW_RTC_LR_CLR(x, v)      (BME_AND32(HW_RTC_LR_ADDR(x), (uint32_t)(~(v))))
#define HW_RTC_LR_TOG(x, v)      (BME_XOR32(HW_RTC_LR_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual RTC_LR bitfields
 */

/*!
 * @name Register RTC_LR, field TCL[3] (RW)
 *
 * After being cleared, this bit can be set only by POR or software reset.
 *
 * Values:
 * - 0 - Time Compensation Register is locked and writes are ignored.
 * - 1 - Time Compensation Register is not locked and writes complete as normal.
 */
/*@{*/
#define BP_RTC_LR_TCL        (3U)          /*!< Bit position for RTC_LR_TCL. */
#define BM_RTC_LR_TCL        (0x00000008U) /*!< Bit mask for RTC_LR_TCL. */
#define BS_RTC_LR_TCL        (1U)          /*!< Bit field size in bits for RTC_LR_TCL. */

/*! @brief Read current value of the RTC_LR_TCL field. */
#define BR_RTC_LR_TCL(x)     (BME_UBFX32(HW_RTC_LR_ADDR(x), BP_RTC_LR_TCL, BS_RTC_LR_TCL))

/*! @brief Format value for bitfield RTC_LR_TCL. */
#define BF_RTC_LR_TCL(v)     ((uint32_t)((uint32_t)(v) << BP_RTC_LR_TCL) & BM_RTC_LR_TCL)

/*! @brief Set the TCL field to a new value. */
#define BW_RTC_LR_TCL(x, v)  (BME_BFI32(HW_RTC_LR_ADDR(x), ((uint32_t)(v) << BP_RTC_LR_TCL), BP_RTC_LR_TCL, 1))
/*@}*/

/*!
 * @name Register RTC_LR, field CRL[4] (RW)
 *
 * After being cleared, this bit can only be set by POR.
 *
 * Values:
 * - 0 - Control Register is locked and writes are ignored.
 * - 1 - Control Register is not locked and writes complete as normal.
 */
/*@{*/
#define BP_RTC_LR_CRL        (4U)          /*!< Bit position for RTC_LR_CRL. */
#define BM_RTC_LR_CRL        (0x00000010U) /*!< Bit mask for RTC_LR_CRL. */
#define BS_RTC_LR_CRL        (1U)          /*!< Bit field size in bits for RTC_LR_CRL. */

/*! @brief Read current value of the RTC_LR_CRL field. */
#define BR_RTC_LR_CRL(x)     (BME_UBFX32(HW_RTC_LR_ADDR(x), BP_RTC_LR_CRL, BS_RTC_LR_CRL))

/*! @brief Format value for bitfield RTC_LR_CRL. */
#define BF_RTC_LR_CRL(v)     ((uint32_t)((uint32_t)(v) << BP_RTC_LR_CRL) & BM_RTC_LR_CRL)

/*! @brief Set the CRL field to a new value. */
#define BW_RTC_LR_CRL(x, v)  (BME_BFI32(HW_RTC_LR_ADDR(x), ((uint32_t)(v) << BP_RTC_LR_CRL), BP_RTC_LR_CRL, 1))
/*@}*/

/*!
 * @name Register RTC_LR, field SRL[5] (RW)
 *
 * After being cleared, this bit can be set only by POR or software reset.
 *
 * Values:
 * - 0 - Status Register is locked and writes are ignored.
 * - 1 - Status Register is not locked and writes complete as normal.
 */
/*@{*/
#define BP_RTC_LR_SRL        (5U)          /*!< Bit position for RTC_LR_SRL. */
#define BM_RTC_LR_SRL        (0x00000020U) /*!< Bit mask for RTC_LR_SRL. */
#define BS_RTC_LR_SRL        (1U)          /*!< Bit field size in bits for RTC_LR_SRL. */

/*! @brief Read current value of the RTC_LR_SRL field. */
#define BR_RTC_LR_SRL(x)     (BME_UBFX32(HW_RTC_LR_ADDR(x), BP_RTC_LR_SRL, BS_RTC_LR_SRL))

/*! @brief Format value for bitfield RTC_LR_SRL. */
#define BF_RTC_LR_SRL(v)     ((uint32_t)((uint32_t)(v) << BP_RTC_LR_SRL) & BM_RTC_LR_SRL)

/*! @brief Set the SRL field to a new value. */
#define BW_RTC_LR_SRL(x, v)  (BME_BFI32(HW_RTC_LR_ADDR(x), ((uint32_t)(v) << BP_RTC_LR_SRL), BP_RTC_LR_SRL, 1))
/*@}*/

/*!
 * @name Register RTC_LR, field LRL[6] (RW)
 *
 * After being cleared, this bit can be set only by POR or software reset.
 *
 * Values:
 * - 0 - Lock Register is locked and writes are ignored.
 * - 1 - Lock Register is not locked and writes complete as normal.
 */
/*@{*/
#define BP_RTC_LR_LRL        (6U)          /*!< Bit position for RTC_LR_LRL. */
#define BM_RTC_LR_LRL        (0x00000040U) /*!< Bit mask for RTC_LR_LRL. */
#define BS_RTC_LR_LRL        (1U)          /*!< Bit field size in bits for RTC_LR_LRL. */

/*! @brief Read current value of the RTC_LR_LRL field. */
#define BR_RTC_LR_LRL(x)     (BME_UBFX32(HW_RTC_LR_ADDR(x), BP_RTC_LR_LRL, BS_RTC_LR_LRL))

/*! @brief Format value for bitfield RTC_LR_LRL. */
#define BF_RTC_LR_LRL(v)     ((uint32_t)((uint32_t)(v) << BP_RTC_LR_LRL) & BM_RTC_LR_LRL)

/*! @brief Set the LRL field to a new value. */
#define BW_RTC_LR_LRL(x, v)  (BME_BFI32(HW_RTC_LR_ADDR(x), ((uint32_t)(v) << BP_RTC_LR_LRL), BP_RTC_LR_LRL, 1))
/*@}*/

/*******************************************************************************
 * HW_RTC_IER - RTC Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief HW_RTC_IER - RTC Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000007U
 */
typedef union _hw_rtc_ier
{
    uint32_t U;
    struct _hw_rtc_ier_bitfields
    {
        uint32_t TIIE : 1;             /*!< [0] Time Invalid Interrupt Enable */
        uint32_t TOIE : 1;             /*!< [1] Time Overflow Interrupt Enable */
        uint32_t TAIE : 1;             /*!< [2] Time Alarm Interrupt Enable */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t TSIE : 1;             /*!< [4] Time Seconds Interrupt Enable */
        uint32_t RESERVED1 : 2;        /*!< [6:5]  */
        uint32_t WPON : 1;             /*!< [7] Wakeup Pin On */
        uint32_t RESERVED2 : 24;       /*!< [31:8]  */
    } B;
} hw_rtc_ier_t;

/*!
 * @name Constants and macros for entire RTC_IER register
 */
/*@{*/
#define HW_RTC_IER_ADDR(x)       ((uint32_t)(x) + 0x1CU)

#define HW_RTC_IER(x)            (*(__IO hw_rtc_ier_t *) HW_RTC_IER_ADDR(x))
#define HW_RTC_IER_RD(x)         (HW_RTC_IER(x).U)
#define HW_RTC_IER_WR(x, v)      (HW_RTC_IER(x).U = (v))
#define HW_RTC_IER_SET(x, v)     (BME_OR32(HW_RTC_IER_ADDR(x), (uint32_t)(v)))
#define HW_RTC_IER_CLR(x, v)     (BME_AND32(HW_RTC_IER_ADDR(x), (uint32_t)(~(v))))
#define HW_RTC_IER_TOG(x, v)     (BME_XOR32(HW_RTC_IER_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual RTC_IER bitfields
 */

/*!
 * @name Register RTC_IER, field TIIE[0] (RW)
 *
 * Values:
 * - 0 - Time invalid flag does not generate an interrupt.
 * - 1 - Time invalid flag does generate an interrupt.
 */
/*@{*/
#define BP_RTC_IER_TIIE      (0U)          /*!< Bit position for RTC_IER_TIIE. */
#define BM_RTC_IER_TIIE      (0x00000001U) /*!< Bit mask for RTC_IER_TIIE. */
#define BS_RTC_IER_TIIE      (1U)          /*!< Bit field size in bits for RTC_IER_TIIE. */

/*! @brief Read current value of the RTC_IER_TIIE field. */
#define BR_RTC_IER_TIIE(x)   (BME_UBFX32(HW_RTC_IER_ADDR(x), BP_RTC_IER_TIIE, BS_RTC_IER_TIIE))

/*! @brief Format value for bitfield RTC_IER_TIIE. */
#define BF_RTC_IER_TIIE(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_IER_TIIE) & BM_RTC_IER_TIIE)

/*! @brief Set the TIIE field to a new value. */
#define BW_RTC_IER_TIIE(x, v) (BME_BFI32(HW_RTC_IER_ADDR(x), ((uint32_t)(v) << BP_RTC_IER_TIIE), BP_RTC_IER_TIIE, 1))
/*@}*/

/*!
 * @name Register RTC_IER, field TOIE[1] (RW)
 *
 * Values:
 * - 0 - Time overflow flag does not generate an interrupt.
 * - 1 - Time overflow flag does generate an interrupt.
 */
/*@{*/
#define BP_RTC_IER_TOIE      (1U)          /*!< Bit position for RTC_IER_TOIE. */
#define BM_RTC_IER_TOIE      (0x00000002U) /*!< Bit mask for RTC_IER_TOIE. */
#define BS_RTC_IER_TOIE      (1U)          /*!< Bit field size in bits for RTC_IER_TOIE. */

/*! @brief Read current value of the RTC_IER_TOIE field. */
#define BR_RTC_IER_TOIE(x)   (BME_UBFX32(HW_RTC_IER_ADDR(x), BP_RTC_IER_TOIE, BS_RTC_IER_TOIE))

/*! @brief Format value for bitfield RTC_IER_TOIE. */
#define BF_RTC_IER_TOIE(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_IER_TOIE) & BM_RTC_IER_TOIE)

/*! @brief Set the TOIE field to a new value. */
#define BW_RTC_IER_TOIE(x, v) (BME_BFI32(HW_RTC_IER_ADDR(x), ((uint32_t)(v) << BP_RTC_IER_TOIE), BP_RTC_IER_TOIE, 1))
/*@}*/

/*!
 * @name Register RTC_IER, field TAIE[2] (RW)
 *
 * Values:
 * - 0 - Time alarm flag does not generate an interrupt.
 * - 1 - Time alarm flag does generate an interrupt.
 */
/*@{*/
#define BP_RTC_IER_TAIE      (2U)          /*!< Bit position for RTC_IER_TAIE. */
#define BM_RTC_IER_TAIE      (0x00000004U) /*!< Bit mask for RTC_IER_TAIE. */
#define BS_RTC_IER_TAIE      (1U)          /*!< Bit field size in bits for RTC_IER_TAIE. */

/*! @brief Read current value of the RTC_IER_TAIE field. */
#define BR_RTC_IER_TAIE(x)   (BME_UBFX32(HW_RTC_IER_ADDR(x), BP_RTC_IER_TAIE, BS_RTC_IER_TAIE))

/*! @brief Format value for bitfield RTC_IER_TAIE. */
#define BF_RTC_IER_TAIE(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_IER_TAIE) & BM_RTC_IER_TAIE)

/*! @brief Set the TAIE field to a new value. */
#define BW_RTC_IER_TAIE(x, v) (BME_BFI32(HW_RTC_IER_ADDR(x), ((uint32_t)(v) << BP_RTC_IER_TAIE), BP_RTC_IER_TAIE, 1))
/*@}*/

/*!
 * @name Register RTC_IER, field TSIE[4] (RW)
 *
 * The seconds interrupt is an edge-sensitive interrupt with a dedicated
 * interrupt vector. It is generated once a second and requires no software overhead
 * (there is no corresponding status flag to clear).
 *
 * Values:
 * - 0 - Seconds interrupt is disabled.
 * - 1 - Seconds interrupt is enabled.
 */
/*@{*/
#define BP_RTC_IER_TSIE      (4U)          /*!< Bit position for RTC_IER_TSIE. */
#define BM_RTC_IER_TSIE      (0x00000010U) /*!< Bit mask for RTC_IER_TSIE. */
#define BS_RTC_IER_TSIE      (1U)          /*!< Bit field size in bits for RTC_IER_TSIE. */

/*! @brief Read current value of the RTC_IER_TSIE field. */
#define BR_RTC_IER_TSIE(x)   (BME_UBFX32(HW_RTC_IER_ADDR(x), BP_RTC_IER_TSIE, BS_RTC_IER_TSIE))

/*! @brief Format value for bitfield RTC_IER_TSIE. */
#define BF_RTC_IER_TSIE(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_IER_TSIE) & BM_RTC_IER_TSIE)

/*! @brief Set the TSIE field to a new value. */
#define BW_RTC_IER_TSIE(x, v) (BME_BFI32(HW_RTC_IER_ADDR(x), ((uint32_t)(v) << BP_RTC_IER_TSIE), BP_RTC_IER_TSIE, 1))
/*@}*/

/*!
 * @name Register RTC_IER, field WPON[7] (RW)
 *
 * The wakeup pin is optional and not available on all devices. Whenever the
 * wakeup pin is enabled and this bit is set, the wakeup pin will assert.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - If the wakeup pin is enabled, then the wakeup pin will assert.
 */
/*@{*/
#define BP_RTC_IER_WPON      (7U)          /*!< Bit position for RTC_IER_WPON. */
#define BM_RTC_IER_WPON      (0x00000080U) /*!< Bit mask for RTC_IER_WPON. */
#define BS_RTC_IER_WPON      (1U)          /*!< Bit field size in bits for RTC_IER_WPON. */

/*! @brief Read current value of the RTC_IER_WPON field. */
#define BR_RTC_IER_WPON(x)   (BME_UBFX32(HW_RTC_IER_ADDR(x), BP_RTC_IER_WPON, BS_RTC_IER_WPON))

/*! @brief Format value for bitfield RTC_IER_WPON. */
#define BF_RTC_IER_WPON(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_IER_WPON) & BM_RTC_IER_WPON)

/*! @brief Set the WPON field to a new value. */
#define BW_RTC_IER_WPON(x, v) (BME_BFI32(HW_RTC_IER_ADDR(x), ((uint32_t)(v) << BP_RTC_IER_WPON), BP_RTC_IER_WPON, 1))
/*@}*/

/*******************************************************************************
 * hw_rtc_t - module struct
 ******************************************************************************/
/*!
 * @brief All RTC module registers.
 */
#pragma pack(1)
typedef struct _hw_rtc
{
    __IO hw_rtc_tsr_t TSR;                 /*!< [0x0] RTC Time Seconds Register */
    __IO hw_rtc_tpr_t TPR;                 /*!< [0x4] RTC Time Prescaler Register */
    __IO hw_rtc_tar_t TAR;                 /*!< [0x8] RTC Time Alarm Register */
    __IO hw_rtc_tcr_t TCR;                 /*!< [0xC] RTC Time Compensation Register */
    __IO hw_rtc_cr_t CR;                   /*!< [0x10] RTC Control Register */
    __IO hw_rtc_sr_t SR;                   /*!< [0x14] RTC Status Register */
    __IO hw_rtc_lr_t LR;                   /*!< [0x18] RTC Lock Register */
    __IO hw_rtc_ier_t IER;                 /*!< [0x1C] RTC Interrupt Enable Register */
} hw_rtc_t;
#pragma pack()

/*! @brief Macro to access all RTC registers. */
/*! @param x RTC module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_RTC_REGS(RTC_BASE)</code>. */
#define HW_RTC_REGS(x) (*(hw_rtc_t *)(x))

/*
 * MKL43Z4 SIM
 *
 * System Integration Module
 *
 * Registers defined in this header file:
 * - HW_SIM_SOPT1 - System Options Register 1
 * - HW_SIM_SOPT1CFG - SOPT1 Configuration Register
 * - HW_SIM_SOPT2 - System Options Register 2
 * - HW_SIM_SOPT4 - System Options Register 4
 * - HW_SIM_SOPT5 - System Options Register 5
 * - HW_SIM_SOPT7 - System Options Register 7
 * - HW_SIM_SDID - System Device Identification Register
 * - HW_SIM_SCGC4 - System Clock Gating Control Register 4
 * - HW_SIM_SCGC5 - System Clock Gating Control Register 5
 * - HW_SIM_SCGC6 - System Clock Gating Control Register 6
 * - HW_SIM_SCGC7 - System Clock Gating Control Register 7
 * - HW_SIM_CLKDIV1 - System Clock Divider Register 1
 * - HW_SIM_FCFG1 - Flash Configuration Register 1
 * - HW_SIM_FCFG2 - Flash Configuration Register 2
 * - HW_SIM_UIDMH - Unique Identification Register Mid-High
 * - HW_SIM_UIDML - Unique Identification Register Mid Low
 * - HW_SIM_UIDL - Unique Identification Register Low
 * - HW_SIM_COPC - COP Control Register
 * - HW_SIM_SRVCOP - Service COP
 *
 * - hw_sim_t - Struct containing all module registers.
 */

#define HW_SIM_INSTANCE_COUNT (1U) /*!< Number of instances of the SIM module. */
#define HW_SIM (0U) /*!< Instance number for SIM. */

/*******************************************************************************
 * HW_SIM_SOPT1 - System Options Register 1
 ******************************************************************************/

/*!
 * @brief HW_SIM_SOPT1 - System Options Register 1 (RW)
 *
 * Reset value: 0x80000000U
 *
 * The SOPT1 register is only reset on POR or LVD.
 */
typedef union _hw_sim_sopt1
{
    uint32_t U;
    struct _hw_sim_sopt1_bitfields
    {
        uint32_t RESERVED0 : 16;       /*!< [15:0]  */
        uint32_t OSC32KOUT : 2;        /*!< [17:16] 32K oscillator clock output */
        uint32_t OSC32KSEL : 2;        /*!< [19:18] 32K Oscillator Clock Select */
        uint32_t RESERVED1 : 9;        /*!< [28:20]  */
        uint32_t USBVSTBY : 1;         /*!< [29] USB voltage regulator in standby
                                        * mode during VLPR and VLPW modes */
        uint32_t USBSSTBY : 1;         /*!< [30] USB voltage regulator in standby
                                        * mode during Stop, VLPS, LLS and VLLS modes. */
        uint32_t USBREGEN : 1;         /*!< [31] USB voltage regulator enable */
    } B;
} hw_sim_sopt1_t;

/*!
 * @name Constants and macros for entire SIM_SOPT1 register
 */
/*@{*/
#define HW_SIM_SOPT1_ADDR(x)     ((uint32_t)(x) + 0x0U)

#define HW_SIM_SOPT1(x)          (*(__IO hw_sim_sopt1_t *) HW_SIM_SOPT1_ADDR(x))
#define HW_SIM_SOPT1_RD(x)       (HW_SIM_SOPT1(x).U)
#define HW_SIM_SOPT1_WR(x, v)    (HW_SIM_SOPT1(x).U = (v))
#define HW_SIM_SOPT1_SET(x, v)   (BME_OR32(HW_SIM_SOPT1_ADDR(x), (uint32_t)(v)))
#define HW_SIM_SOPT1_CLR(x, v)   (BME_AND32(HW_SIM_SOPT1_ADDR(x), (uint32_t)(~(v))))
#define HW_SIM_SOPT1_TOG(x, v)   (BME_XOR32(HW_SIM_SOPT1_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT1 bitfields
 */

/*!
 * @name Register SIM_SOPT1, field OSC32KOUT[17:16] (RW)
 *
 * Outputs the ERCLK32K on the selected pin in all modes of operation (including
 * LLS/VLLS and System Reset), overriding the existing pin mux configuration for
 * that pin. This field is reset only on POR/LVD.
 *
 * Values:
 * - 00 - ERCLK32K is not output.
 * - 01 - ERCLK32K is output on PTE0.
 * - 10 - ERCLK32K is output on PTE26.
 * - 11 - Reserved.
 */
/*@{*/
#define BP_SIM_SOPT1_OSC32KOUT (16U)       /*!< Bit position for SIM_SOPT1_OSC32KOUT. */
#define BM_SIM_SOPT1_OSC32KOUT (0x00030000U) /*!< Bit mask for SIM_SOPT1_OSC32KOUT. */
#define BS_SIM_SOPT1_OSC32KOUT (2U)        /*!< Bit field size in bits for SIM_SOPT1_OSC32KOUT. */

/*! @brief Read current value of the SIM_SOPT1_OSC32KOUT field. */
#define BR_SIM_SOPT1_OSC32KOUT(x) (BME_UBFX32(HW_SIM_SOPT1_ADDR(x), BP_SIM_SOPT1_OSC32KOUT, BS_SIM_SOPT1_OSC32KOUT))

/*! @brief Format value for bitfield SIM_SOPT1_OSC32KOUT. */
#define BF_SIM_SOPT1_OSC32KOUT(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT1_OSC32KOUT) & BM_SIM_SOPT1_OSC32KOUT)

/*! @brief Set the OSC32KOUT field to a new value. */
#define BW_SIM_SOPT1_OSC32KOUT(x, v) (BME_BFI32(HW_SIM_SOPT1_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT1_OSC32KOUT), BP_SIM_SOPT1_OSC32KOUT, 2))
/*@}*/

/*!
 * @name Register SIM_SOPT1, field OSC32KSEL[19:18] (RW)
 *
 * Selects the 32 kHz clock source (ERCLK32K) for Segment LCD, RTC and LPTMR.
 * This field is reset only on POR/LVD.
 *
 * Values:
 * - 00 - System oscillator (OSC32KCLK)
 * - 01 - Reserved
 * - 10 - RTC_CLKIN
 * - 11 - LPO 1kHz
 */
/*@{*/
#define BP_SIM_SOPT1_OSC32KSEL (18U)       /*!< Bit position for SIM_SOPT1_OSC32KSEL. */
#define BM_SIM_SOPT1_OSC32KSEL (0x000C0000U) /*!< Bit mask for SIM_SOPT1_OSC32KSEL. */
#define BS_SIM_SOPT1_OSC32KSEL (2U)        /*!< Bit field size in bits for SIM_SOPT1_OSC32KSEL. */

/*! @brief Read current value of the SIM_SOPT1_OSC32KSEL field. */
#define BR_SIM_SOPT1_OSC32KSEL(x) (BME_UBFX32(HW_SIM_SOPT1_ADDR(x), BP_SIM_SOPT1_OSC32KSEL, BS_SIM_SOPT1_OSC32KSEL))

/*! @brief Format value for bitfield SIM_SOPT1_OSC32KSEL. */
#define BF_SIM_SOPT1_OSC32KSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT1_OSC32KSEL) & BM_SIM_SOPT1_OSC32KSEL)

/*! @brief Set the OSC32KSEL field to a new value. */
#define BW_SIM_SOPT1_OSC32KSEL(x, v) (BME_BFI32(HW_SIM_SOPT1_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT1_OSC32KSEL), BP_SIM_SOPT1_OSC32KSEL, 2))
/*@}*/

/*!
 * @name Register SIM_SOPT1, field USBVSTBY[29] (RW)
 *
 * Controls whether the USB voltage regulator is placed in standby mode during
 * VLPR and VLPW modes.
 *
 * Values:
 * - 0 - USB voltage regulator not in standby during VLPR and VLPW modes.
 * - 1 - USB voltage regulator in standby during VLPR and VLPW modes.
 */
/*@{*/
#define BP_SIM_SOPT1_USBVSTBY (29U)        /*!< Bit position for SIM_SOPT1_USBVSTBY. */
#define BM_SIM_SOPT1_USBVSTBY (0x20000000U) /*!< Bit mask for SIM_SOPT1_USBVSTBY. */
#define BS_SIM_SOPT1_USBVSTBY (1U)         /*!< Bit field size in bits for SIM_SOPT1_USBVSTBY. */

/*! @brief Read current value of the SIM_SOPT1_USBVSTBY field. */
#define BR_SIM_SOPT1_USBVSTBY(x) (BME_UBFX32(HW_SIM_SOPT1_ADDR(x), BP_SIM_SOPT1_USBVSTBY, BS_SIM_SOPT1_USBVSTBY))

/*! @brief Format value for bitfield SIM_SOPT1_USBVSTBY. */
#define BF_SIM_SOPT1_USBVSTBY(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT1_USBVSTBY) & BM_SIM_SOPT1_USBVSTBY)

/*! @brief Set the USBVSTBY field to a new value. */
#define BW_SIM_SOPT1_USBVSTBY(x, v) (BME_BFI32(HW_SIM_SOPT1_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT1_USBVSTBY), BP_SIM_SOPT1_USBVSTBY, 1))
/*@}*/

/*!
 * @name Register SIM_SOPT1, field USBSSTBY[30] (RW)
 *
 * Controls whether the USB voltage regulator is placed in standby mode during
 * Stop, VLPS, LLS and VLLS modes.
 *
 * Values:
 * - 0 - USB voltage regulator not in standby during Stop, VLPS, LLS and VLLS
 *     modes.
 * - 1 - USB voltage regulator in standby during Stop, VLPS, LLS and VLLS modes.
 */
/*@{*/
#define BP_SIM_SOPT1_USBSSTBY (30U)        /*!< Bit position for SIM_SOPT1_USBSSTBY. */
#define BM_SIM_SOPT1_USBSSTBY (0x40000000U) /*!< Bit mask for SIM_SOPT1_USBSSTBY. */
#define BS_SIM_SOPT1_USBSSTBY (1U)         /*!< Bit field size in bits for SIM_SOPT1_USBSSTBY. */

/*! @brief Read current value of the SIM_SOPT1_USBSSTBY field. */
#define BR_SIM_SOPT1_USBSSTBY(x) (BME_UBFX32(HW_SIM_SOPT1_ADDR(x), BP_SIM_SOPT1_USBSSTBY, BS_SIM_SOPT1_USBSSTBY))

/*! @brief Format value for bitfield SIM_SOPT1_USBSSTBY. */
#define BF_SIM_SOPT1_USBSSTBY(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT1_USBSSTBY) & BM_SIM_SOPT1_USBSSTBY)

/*! @brief Set the USBSSTBY field to a new value. */
#define BW_SIM_SOPT1_USBSSTBY(x, v) (BME_BFI32(HW_SIM_SOPT1_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT1_USBSSTBY), BP_SIM_SOPT1_USBSSTBY, 1))
/*@}*/

/*!
 * @name Register SIM_SOPT1, field USBREGEN[31] (RW)
 *
 * Controls whether the USB voltage regulator is enabled.
 *
 * Values:
 * - 0 - USB voltage regulator is disabled.
 * - 1 - USB voltage regulator is enabled.
 */
/*@{*/
#define BP_SIM_SOPT1_USBREGEN (31U)        /*!< Bit position for SIM_SOPT1_USBREGEN. */
#define BM_SIM_SOPT1_USBREGEN (0x80000000U) /*!< Bit mask for SIM_SOPT1_USBREGEN. */
#define BS_SIM_SOPT1_USBREGEN (1U)         /*!< Bit field size in bits for SIM_SOPT1_USBREGEN. */

/*! @brief Read current value of the SIM_SOPT1_USBREGEN field. */
#define BR_SIM_SOPT1_USBREGEN(x) (BME_UBFX32(HW_SIM_SOPT1_ADDR(x), BP_SIM_SOPT1_USBREGEN, BS_SIM_SOPT1_USBREGEN))

/*! @brief Format value for bitfield SIM_SOPT1_USBREGEN. */
#define BF_SIM_SOPT1_USBREGEN(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT1_USBREGEN) & BM_SIM_SOPT1_USBREGEN)

/*! @brief Set the USBREGEN field to a new value. */
#define BW_SIM_SOPT1_USBREGEN(x, v) (BME_BFI32(HW_SIM_SOPT1_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT1_USBREGEN), BP_SIM_SOPT1_USBREGEN, 1))
/*@}*/

/*******************************************************************************
 * HW_SIM_SOPT1CFG - SOPT1 Configuration Register
 ******************************************************************************/

/*!
 * @brief HW_SIM_SOPT1CFG - SOPT1 Configuration Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The SOPT1CFG register is reset on System Reset not VLLS.
 */
typedef union _hw_sim_sopt1cfg
{
    uint32_t U;
    struct _hw_sim_sopt1cfg_bitfields
    {
        uint32_t RESERVED0 : 24;       /*!< [23:0]  */
        uint32_t URWE : 1;             /*!< [24] USB voltage regulator enable write
                                        * enable */
        uint32_t UVSWE : 1;            /*!< [25] USB voltage regulator VLP standby write
                                        * enable */
        uint32_t USSWE : 1;            /*!< [26] USB voltage regulator stop standby
                                        * write enable */
        uint32_t RESERVED1 : 5;        /*!< [31:27]  */
    } B;
} hw_sim_sopt1cfg_t;

/*!
 * @name Constants and macros for entire SIM_SOPT1CFG register
 */
/*@{*/
#define HW_SIM_SOPT1CFG_ADDR(x)  ((uint32_t)(x) + 0x4U)

#define HW_SIM_SOPT1CFG(x)       (*(__IO hw_sim_sopt1cfg_t *) HW_SIM_SOPT1CFG_ADDR(x))
#define HW_SIM_SOPT1CFG_RD(x)    (HW_SIM_SOPT1CFG(x).U)
#define HW_SIM_SOPT1CFG_WR(x, v) (HW_SIM_SOPT1CFG(x).U = (v))
#define HW_SIM_SOPT1CFG_SET(x, v) (BME_OR32(HW_SIM_SOPT1CFG_ADDR(x), (uint32_t)(v)))
#define HW_SIM_SOPT1CFG_CLR(x, v) (BME_AND32(HW_SIM_SOPT1CFG_ADDR(x), (uint32_t)(~(v))))
#define HW_SIM_SOPT1CFG_TOG(x, v) (BME_XOR32(HW_SIM_SOPT1CFG_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT1CFG bitfields
 */

/*!
 * @name Register SIM_SOPT1CFG, field URWE[24] (RW)
 *
 * Writing one to the URWE bit allows the SOPT1 USBREGEN bit to be written. This
 * register bit clears after a write to USBREGEN.
 *
 * Values:
 * - 0 - SOPT1 USBREGEN cannot be written.
 * - 1 - SOPT1 USBREGEN can be written.
 */
/*@{*/
#define BP_SIM_SOPT1CFG_URWE (24U)         /*!< Bit position for SIM_SOPT1CFG_URWE. */
#define BM_SIM_SOPT1CFG_URWE (0x01000000U) /*!< Bit mask for SIM_SOPT1CFG_URWE. */
#define BS_SIM_SOPT1CFG_URWE (1U)          /*!< Bit field size in bits for SIM_SOPT1CFG_URWE. */

/*! @brief Read current value of the SIM_SOPT1CFG_URWE field. */
#define BR_SIM_SOPT1CFG_URWE(x) (BME_UBFX32(HW_SIM_SOPT1CFG_ADDR(x), BP_SIM_SOPT1CFG_URWE, BS_SIM_SOPT1CFG_URWE))

/*! @brief Format value for bitfield SIM_SOPT1CFG_URWE. */
#define BF_SIM_SOPT1CFG_URWE(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT1CFG_URWE) & BM_SIM_SOPT1CFG_URWE)

/*! @brief Set the URWE field to a new value. */
#define BW_SIM_SOPT1CFG_URWE(x, v) (BME_BFI32(HW_SIM_SOPT1CFG_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT1CFG_URWE), BP_SIM_SOPT1CFG_URWE, 1))
/*@}*/

/*!
 * @name Register SIM_SOPT1CFG, field UVSWE[25] (RW)
 *
 * Writing one to the UVSWE bit allows the SOPT1 USBVSTBY bit to be written.
 * This register bit clears after a write to USBVSTBY.
 *
 * Values:
 * - 0 - SOPT1 USBVSTB cannot be written.
 * - 1 - SOPT1 USBVSTB can be written.
 */
/*@{*/
#define BP_SIM_SOPT1CFG_UVSWE (25U)        /*!< Bit position for SIM_SOPT1CFG_UVSWE. */
#define BM_SIM_SOPT1CFG_UVSWE (0x02000000U) /*!< Bit mask for SIM_SOPT1CFG_UVSWE. */
#define BS_SIM_SOPT1CFG_UVSWE (1U)         /*!< Bit field size in bits for SIM_SOPT1CFG_UVSWE. */

/*! @brief Read current value of the SIM_SOPT1CFG_UVSWE field. */
#define BR_SIM_SOPT1CFG_UVSWE(x) (BME_UBFX32(HW_SIM_SOPT1CFG_ADDR(x), BP_SIM_SOPT1CFG_UVSWE, BS_SIM_SOPT1CFG_UVSWE))

/*! @brief Format value for bitfield SIM_SOPT1CFG_UVSWE. */
#define BF_SIM_SOPT1CFG_UVSWE(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT1CFG_UVSWE) & BM_SIM_SOPT1CFG_UVSWE)

/*! @brief Set the UVSWE field to a new value. */
#define BW_SIM_SOPT1CFG_UVSWE(x, v) (BME_BFI32(HW_SIM_SOPT1CFG_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT1CFG_UVSWE), BP_SIM_SOPT1CFG_UVSWE, 1))
/*@}*/

/*!
 * @name Register SIM_SOPT1CFG, field USSWE[26] (RW)
 *
 * Writing one to the USSWE bit allows the SOPT1 USBSSTBY bit to be written.
 * This register bit clears after a write to USBSSTBY.
 *
 * Values:
 * - 0 - SOPT1 USBSSTB cannot be written.
 * - 1 - SOPT1 USBSSTB can be written.
 */
/*@{*/
#define BP_SIM_SOPT1CFG_USSWE (26U)        /*!< Bit position for SIM_SOPT1CFG_USSWE. */
#define BM_SIM_SOPT1CFG_USSWE (0x04000000U) /*!< Bit mask for SIM_SOPT1CFG_USSWE. */
#define BS_SIM_SOPT1CFG_USSWE (1U)         /*!< Bit field size in bits for SIM_SOPT1CFG_USSWE. */

/*! @brief Read current value of the SIM_SOPT1CFG_USSWE field. */
#define BR_SIM_SOPT1CFG_USSWE(x) (BME_UBFX32(HW_SIM_SOPT1CFG_ADDR(x), BP_SIM_SOPT1CFG_USSWE, BS_SIM_SOPT1CFG_USSWE))

/*! @brief Format value for bitfield SIM_SOPT1CFG_USSWE. */
#define BF_SIM_SOPT1CFG_USSWE(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT1CFG_USSWE) & BM_SIM_SOPT1CFG_USSWE)

/*! @brief Set the USSWE field to a new value. */
#define BW_SIM_SOPT1CFG_USSWE(x, v) (BME_BFI32(HW_SIM_SOPT1CFG_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT1CFG_USSWE), BP_SIM_SOPT1CFG_USSWE, 1))
/*@}*/

/*******************************************************************************
 * HW_SIM_SOPT2 - System Options Register 2
 ******************************************************************************/

/*!
 * @brief HW_SIM_SOPT2 - System Options Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * SOPT2 contains the controls for selecting many of the module clock source
 * options on this device. See the Clock Distribution chapter for more information
 * including clocking diagrams and definitions of device clocks.
 */
typedef union _hw_sim_sopt2
{
    uint32_t U;
    struct _hw_sim_sopt2_bitfields
    {
        uint32_t RESERVED0 : 4;        /*!< [3:0]  */
        uint32_t RTCCLKOUTSEL : 1;     /*!< [4] RTC Clock Out Select */
        uint32_t CLKOUTSEL : 3;        /*!< [7:5] CLKOUT select */
        uint32_t RESERVED1 : 10;       /*!< [17:8]  */
        uint32_t USBSRC : 1;           /*!< [18] USB clock source select */
        uint32_t RESERVED2 : 3;        /*!< [21:19]  */
        uint32_t FLEXIOSRC : 2;        /*!< [23:22] FlexIO Module Clock Source
                                        * Select */
        uint32_t TPMSRC : 2;           /*!< [25:24] TPM Clock Source Select */
        uint32_t LPUART0SRC : 2;       /*!< [27:26] LPUART0 Clock Source Select */
        uint32_t LPUART1SRC : 2;       /*!< [29:28] LPUART1 Clock Source Select */
        uint32_t RESERVED3 : 2;        /*!< [31:30]  */
    } B;
} hw_sim_sopt2_t;

/*!
 * @name Constants and macros for entire SIM_SOPT2 register
 */
/*@{*/
#define HW_SIM_SOPT2_ADDR(x)     ((uint32_t)(x) + 0x1004U)

#define HW_SIM_SOPT2(x)          (*(__IO hw_sim_sopt2_t *) HW_SIM_SOPT2_ADDR(x))
#define HW_SIM_SOPT2_RD(x)       (HW_SIM_SOPT2(x).U)
#define HW_SIM_SOPT2_WR(x, v)    (HW_SIM_SOPT2(x).U = (v))
#define HW_SIM_SOPT2_SET(x, v)   (BME_OR32(HW_SIM_SOPT2_ADDR(x), (uint32_t)(v)))
#define HW_SIM_SOPT2_CLR(x, v)   (BME_AND32(HW_SIM_SOPT2_ADDR(x), (uint32_t)(~(v))))
#define HW_SIM_SOPT2_TOG(x, v)   (BME_XOR32(HW_SIM_SOPT2_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT2 bitfields
 */

/*!
 * @name Register SIM_SOPT2, field RTCCLKOUTSEL[4] (RW)
 *
 * Selects either the RTC 1 Hz clock or the OSC clock to be output on the
 * RTC_CLKOUT pin.
 *
 * Values:
 * - 0 - RTC 1 Hz clock is output on the RTC_CLKOUT pin.
 * - 1 - OSCERCLK clock is output on the RTC_CLKOUT pin.
 */
/*@{*/
#define BP_SIM_SOPT2_RTCCLKOUTSEL (4U)     /*!< Bit position for SIM_SOPT2_RTCCLKOUTSEL. */
#define BM_SIM_SOPT2_RTCCLKOUTSEL (0x00000010U) /*!< Bit mask for SIM_SOPT2_RTCCLKOUTSEL. */
#define BS_SIM_SOPT2_RTCCLKOUTSEL (1U)     /*!< Bit field size in bits for SIM_SOPT2_RTCCLKOUTSEL. */

/*! @brief Read current value of the SIM_SOPT2_RTCCLKOUTSEL field. */
#define BR_SIM_SOPT2_RTCCLKOUTSEL(x) (BME_UBFX32(HW_SIM_SOPT2_ADDR(x), BP_SIM_SOPT2_RTCCLKOUTSEL, BS_SIM_SOPT2_RTCCLKOUTSEL))

/*! @brief Format value for bitfield SIM_SOPT2_RTCCLKOUTSEL. */
#define BF_SIM_SOPT2_RTCCLKOUTSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT2_RTCCLKOUTSEL) & BM_SIM_SOPT2_RTCCLKOUTSEL)

/*! @brief Set the RTCCLKOUTSEL field to a new value. */
#define BW_SIM_SOPT2_RTCCLKOUTSEL(x, v) (BME_BFI32(HW_SIM_SOPT2_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT2_RTCCLKOUTSEL), BP_SIM_SOPT2_RTCCLKOUTSEL, 1))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field CLKOUTSEL[7:5] (RW)
 *
 * Selects the clock to output on the CLKOUT pin.
 *
 * Values:
 * - 000 - Reserved
 * - 001 - Reserved
 * - 010 - Bus clock
 * - 011 - LPO clock (1 kHz)
 * - 100 - LIRC_CLK
 * - 101 - Reserved
 * - 110 - OSCERCLK
 * - 111 - IRC48M clock (IRC48M clock can be output to PAD only when chip VDD is
 *     2.7-3.6 V)
 */
/*@{*/
#define BP_SIM_SOPT2_CLKOUTSEL (5U)        /*!< Bit position for SIM_SOPT2_CLKOUTSEL. */
#define BM_SIM_SOPT2_CLKOUTSEL (0x000000E0U) /*!< Bit mask for SIM_SOPT2_CLKOUTSEL. */
#define BS_SIM_SOPT2_CLKOUTSEL (3U)        /*!< Bit field size in bits for SIM_SOPT2_CLKOUTSEL. */

/*! @brief Read current value of the SIM_SOPT2_CLKOUTSEL field. */
#define BR_SIM_SOPT2_CLKOUTSEL(x) (BME_UBFX32(HW_SIM_SOPT2_ADDR(x), BP_SIM_SOPT2_CLKOUTSEL, BS_SIM_SOPT2_CLKOUTSEL))

/*! @brief Format value for bitfield SIM_SOPT2_CLKOUTSEL. */
#define BF_SIM_SOPT2_CLKOUTSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT2_CLKOUTSEL) & BM_SIM_SOPT2_CLKOUTSEL)

/*! @brief Set the CLKOUTSEL field to a new value. */
#define BW_SIM_SOPT2_CLKOUTSEL(x, v) (BME_BFI32(HW_SIM_SOPT2_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT2_CLKOUTSEL), BP_SIM_SOPT2_CLKOUTSEL, 3))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field USBSRC[18] (RW)
 *
 * Selects the clock source for the USB 48 MHz clock.
 *
 * Values:
 * - 0 - External bypass clock (USB_CLKIN).
 * - 1 - IRC48M clock
 */
/*@{*/
#define BP_SIM_SOPT2_USBSRC  (18U)         /*!< Bit position for SIM_SOPT2_USBSRC. */
#define BM_SIM_SOPT2_USBSRC  (0x00040000U) /*!< Bit mask for SIM_SOPT2_USBSRC. */
#define BS_SIM_SOPT2_USBSRC  (1U)          /*!< Bit field size in bits for SIM_SOPT2_USBSRC. */

/*! @brief Read current value of the SIM_SOPT2_USBSRC field. */
#define BR_SIM_SOPT2_USBSRC(x) (BME_UBFX32(HW_SIM_SOPT2_ADDR(x), BP_SIM_SOPT2_USBSRC, BS_SIM_SOPT2_USBSRC))

/*! @brief Format value for bitfield SIM_SOPT2_USBSRC. */
#define BF_SIM_SOPT2_USBSRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT2_USBSRC) & BM_SIM_SOPT2_USBSRC)

/*! @brief Set the USBSRC field to a new value. */
#define BW_SIM_SOPT2_USBSRC(x, v) (BME_BFI32(HW_SIM_SOPT2_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT2_USBSRC), BP_SIM_SOPT2_USBSRC, 1))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field FLEXIOSRC[23:22] (RW)
 *
 * Selects the clock source for the FlexIO transmit and receive clock.
 *
 * Values:
 * - 00 - Clock disabled
 * - 01 - IRC48M clock
 * - 10 - OSCERCLK clock
 * - 11 - MCGIRCLK clock
 */
/*@{*/
#define BP_SIM_SOPT2_FLEXIOSRC (22U)       /*!< Bit position for SIM_SOPT2_FLEXIOSRC. */
#define BM_SIM_SOPT2_FLEXIOSRC (0x00C00000U) /*!< Bit mask for SIM_SOPT2_FLEXIOSRC. */
#define BS_SIM_SOPT2_FLEXIOSRC (2U)        /*!< Bit field size in bits for SIM_SOPT2_FLEXIOSRC. */

/*! @brief Read current value of the SIM_SOPT2_FLEXIOSRC field. */
#define BR_SIM_SOPT2_FLEXIOSRC(x) (BME_UBFX32(HW_SIM_SOPT2_ADDR(x), BP_SIM_SOPT2_FLEXIOSRC, BS_SIM_SOPT2_FLEXIOSRC))

/*! @brief Format value for bitfield SIM_SOPT2_FLEXIOSRC. */
#define BF_SIM_SOPT2_FLEXIOSRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT2_FLEXIOSRC) & BM_SIM_SOPT2_FLEXIOSRC)

/*! @brief Set the FLEXIOSRC field to a new value. */
#define BW_SIM_SOPT2_FLEXIOSRC(x, v) (BME_BFI32(HW_SIM_SOPT2_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT2_FLEXIOSRC), BP_SIM_SOPT2_FLEXIOSRC, 2))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field TPMSRC[25:24] (RW)
 *
 * Selects the clock source for the TPM counter clock
 *
 * Values:
 * - 00 - Clock disabled
 * - 01 - IRC48M clock
 * - 10 - OSCERCLK clock
 * - 11 - MCGIRCLK clock
 */
/*@{*/
#define BP_SIM_SOPT2_TPMSRC  (24U)         /*!< Bit position for SIM_SOPT2_TPMSRC. */
#define BM_SIM_SOPT2_TPMSRC  (0x03000000U) /*!< Bit mask for SIM_SOPT2_TPMSRC. */
#define BS_SIM_SOPT2_TPMSRC  (2U)          /*!< Bit field size in bits for SIM_SOPT2_TPMSRC. */

/*! @brief Read current value of the SIM_SOPT2_TPMSRC field. */
#define BR_SIM_SOPT2_TPMSRC(x) (BME_UBFX32(HW_SIM_SOPT2_ADDR(x), BP_SIM_SOPT2_TPMSRC, BS_SIM_SOPT2_TPMSRC))

/*! @brief Format value for bitfield SIM_SOPT2_TPMSRC. */
#define BF_SIM_SOPT2_TPMSRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT2_TPMSRC) & BM_SIM_SOPT2_TPMSRC)

/*! @brief Set the TPMSRC field to a new value. */
#define BW_SIM_SOPT2_TPMSRC(x, v) (BME_BFI32(HW_SIM_SOPT2_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT2_TPMSRC), BP_SIM_SOPT2_TPMSRC, 2))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field LPUART0SRC[27:26] (RW)
 *
 * Selects the clock source for the LPUART0 transmit and receive clock.
 *
 * Values:
 * - 00 - Clock disabled
 * - 01 - IRC48M clock
 * - 10 - OSCERCLK clock
 * - 11 - MCGIRCLK clock
 */
/*@{*/
#define BP_SIM_SOPT2_LPUART0SRC (26U)      /*!< Bit position for SIM_SOPT2_LPUART0SRC. */
#define BM_SIM_SOPT2_LPUART0SRC (0x0C000000U) /*!< Bit mask for SIM_SOPT2_LPUART0SRC. */
#define BS_SIM_SOPT2_LPUART0SRC (2U)       /*!< Bit field size in bits for SIM_SOPT2_LPUART0SRC. */

/*! @brief Read current value of the SIM_SOPT2_LPUART0SRC field. */
#define BR_SIM_SOPT2_LPUART0SRC(x) (BME_UBFX32(HW_SIM_SOPT2_ADDR(x), BP_SIM_SOPT2_LPUART0SRC, BS_SIM_SOPT2_LPUART0SRC))

/*! @brief Format value for bitfield SIM_SOPT2_LPUART0SRC. */
#define BF_SIM_SOPT2_LPUART0SRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT2_LPUART0SRC) & BM_SIM_SOPT2_LPUART0SRC)

/*! @brief Set the LPUART0SRC field to a new value. */
#define BW_SIM_SOPT2_LPUART0SRC(x, v) (BME_BFI32(HW_SIM_SOPT2_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT2_LPUART0SRC), BP_SIM_SOPT2_LPUART0SRC, 2))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field LPUART1SRC[29:28] (RW)
 *
 * Selects the clock source for the LPUART1 transmit and receive clock.
 *
 * Values:
 * - 00 - Clock disabled
 * - 01 - IRC48M clock
 * - 10 - OSCERCLK clock
 * - 11 - MCGIRCLK clock
 */
/*@{*/
#define BP_SIM_SOPT2_LPUART1SRC (28U)      /*!< Bit position for SIM_SOPT2_LPUART1SRC. */
#define BM_SIM_SOPT2_LPUART1SRC (0x30000000U) /*!< Bit mask for SIM_SOPT2_LPUART1SRC. */
#define BS_SIM_SOPT2_LPUART1SRC (2U)       /*!< Bit field size in bits for SIM_SOPT2_LPUART1SRC. */

/*! @brief Read current value of the SIM_SOPT2_LPUART1SRC field. */
#define BR_SIM_SOPT2_LPUART1SRC(x) (BME_UBFX32(HW_SIM_SOPT2_ADDR(x), BP_SIM_SOPT2_LPUART1SRC, BS_SIM_SOPT2_LPUART1SRC))

/*! @brief Format value for bitfield SIM_SOPT2_LPUART1SRC. */
#define BF_SIM_SOPT2_LPUART1SRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT2_LPUART1SRC) & BM_SIM_SOPT2_LPUART1SRC)

/*! @brief Set the LPUART1SRC field to a new value. */
#define BW_SIM_SOPT2_LPUART1SRC(x, v) (BME_BFI32(HW_SIM_SOPT2_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT2_LPUART1SRC), BP_SIM_SOPT2_LPUART1SRC, 2))
/*@}*/

/*******************************************************************************
 * HW_SIM_SOPT4 - System Options Register 4
 ******************************************************************************/

/*!
 * @brief HW_SIM_SOPT4 - System Options Register 4 (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_sim_sopt4
{
    uint32_t U;
    struct _hw_sim_sopt4_bitfields
    {
        uint32_t RESERVED0 : 18;       /*!< [17:0]  */
        uint32_t TPM1CH0SRC : 2;       /*!< [19:18] TPM1 channel 0 input capture
                                        * source select */
        uint32_t TPM2CH0SRC : 1;       /*!< [20] TPM2 Channel 0 Input Capture
                                        * Source Select */
        uint32_t RESERVED1 : 3;        /*!< [23:21]  */
        uint32_t TPM0CLKSEL : 1;       /*!< [24] TPM0 External Clock Pin Select */
        uint32_t TPM1CLKSEL : 1;       /*!< [25] TPM1 External Clock Pin Select */
        uint32_t TPM2CLKSEL : 1;       /*!< [26] TPM2 External Clock Pin Select */
        uint32_t RESERVED2 : 5;        /*!< [31:27]  */
    } B;
} hw_sim_sopt4_t;

/*!
 * @name Constants and macros for entire SIM_SOPT4 register
 */
/*@{*/
#define HW_SIM_SOPT4_ADDR(x)     ((uint32_t)(x) + 0x100CU)

#define HW_SIM_SOPT4(x)          (*(__IO hw_sim_sopt4_t *) HW_SIM_SOPT4_ADDR(x))
#define HW_SIM_SOPT4_RD(x)       (HW_SIM_SOPT4(x).U)
#define HW_SIM_SOPT4_WR(x, v)    (HW_SIM_SOPT4(x).U = (v))
#define HW_SIM_SOPT4_SET(x, v)   (BME_OR32(HW_SIM_SOPT4_ADDR(x), (uint32_t)(v)))
#define HW_SIM_SOPT4_CLR(x, v)   (BME_AND32(HW_SIM_SOPT4_ADDR(x), (uint32_t)(~(v))))
#define HW_SIM_SOPT4_TOG(x, v)   (BME_XOR32(HW_SIM_SOPT4_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT4 bitfields
 */

/*!
 * @name Register SIM_SOPT4, field TPM1CH0SRC[19:18] (RW)
 *
 * Selects the source for TPM1 channel 0 input capture. When TPM1 is not in
 * input capture mode, clear this field.
 *
 * Values:
 * - 00 - TPM1_CH0 signal
 * - 01 - CMP0 output
 * - 10 - Reserved
 * - 11 - USB start of frame pulse
 */
/*@{*/
#define BP_SIM_SOPT4_TPM1CH0SRC (18U)      /*!< Bit position for SIM_SOPT4_TPM1CH0SRC. */
#define BM_SIM_SOPT4_TPM1CH0SRC (0x000C0000U) /*!< Bit mask for SIM_SOPT4_TPM1CH0SRC. */
#define BS_SIM_SOPT4_TPM1CH0SRC (2U)       /*!< Bit field size in bits for SIM_SOPT4_TPM1CH0SRC. */

/*! @brief Read current value of the SIM_SOPT4_TPM1CH0SRC field. */
#define BR_SIM_SOPT4_TPM1CH0SRC(x) (BME_UBFX32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_TPM1CH0SRC, BS_SIM_SOPT4_TPM1CH0SRC))

/*! @brief Format value for bitfield SIM_SOPT4_TPM1CH0SRC. */
#define BF_SIM_SOPT4_TPM1CH0SRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT4_TPM1CH0SRC) & BM_SIM_SOPT4_TPM1CH0SRC)

/*! @brief Set the TPM1CH0SRC field to a new value. */
#define BW_SIM_SOPT4_TPM1CH0SRC(x, v) (BME_BFI32(HW_SIM_SOPT4_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT4_TPM1CH0SRC), BP_SIM_SOPT4_TPM1CH0SRC, 2))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field TPM2CH0SRC[20] (RW)
 *
 * Selects the source for TPM2 channel 0 input capture. When TPM2 is not in
 * input capture mode, clear this field.
 *
 * Values:
 * - 0 - TPM2_CH0 signal
 * - 1 - CMP0 output
 */
/*@{*/
#define BP_SIM_SOPT4_TPM2CH0SRC (20U)      /*!< Bit position for SIM_SOPT4_TPM2CH0SRC. */
#define BM_SIM_SOPT4_TPM2CH0SRC (0x00100000U) /*!< Bit mask for SIM_SOPT4_TPM2CH0SRC. */
#define BS_SIM_SOPT4_TPM2CH0SRC (1U)       /*!< Bit field size in bits for SIM_SOPT4_TPM2CH0SRC. */

/*! @brief Read current value of the SIM_SOPT4_TPM2CH0SRC field. */
#define BR_SIM_SOPT4_TPM2CH0SRC(x) (BME_UBFX32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_TPM2CH0SRC, BS_SIM_SOPT4_TPM2CH0SRC))

/*! @brief Format value for bitfield SIM_SOPT4_TPM2CH0SRC. */
#define BF_SIM_SOPT4_TPM2CH0SRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT4_TPM2CH0SRC) & BM_SIM_SOPT4_TPM2CH0SRC)

/*! @brief Set the TPM2CH0SRC field to a new value. */
#define BW_SIM_SOPT4_TPM2CH0SRC(x, v) (BME_BFI32(HW_SIM_SOPT4_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT4_TPM2CH0SRC), BP_SIM_SOPT4_TPM2CH0SRC, 1))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field TPM0CLKSEL[24] (RW)
 *
 * Selects the external pin used to drive the clock to the TPM0 module. The
 * selected pin must also be configured for the TPM external clock function through
 * the appropriate pin control register in the port control module.
 *
 * Values:
 * - 0 - TPM0 external clock driven by TPM_CLKIN0 pin.
 * - 1 - TPM0 external clock driven by TPM_CLKIN1 pin.
 */
/*@{*/
#define BP_SIM_SOPT4_TPM0CLKSEL (24U)      /*!< Bit position for SIM_SOPT4_TPM0CLKSEL. */
#define BM_SIM_SOPT4_TPM0CLKSEL (0x01000000U) /*!< Bit mask for SIM_SOPT4_TPM0CLKSEL. */
#define BS_SIM_SOPT4_TPM0CLKSEL (1U)       /*!< Bit field size in bits for SIM_SOPT4_TPM0CLKSEL. */

/*! @brief Read current value of the SIM_SOPT4_TPM0CLKSEL field. */
#define BR_SIM_SOPT4_TPM0CLKSEL(x) (BME_UBFX32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_TPM0CLKSEL, BS_SIM_SOPT4_TPM0CLKSEL))

/*! @brief Format value for bitfield SIM_SOPT4_TPM0CLKSEL. */
#define BF_SIM_SOPT4_TPM0CLKSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT4_TPM0CLKSEL) & BM_SIM_SOPT4_TPM0CLKSEL)

/*! @brief Set the TPM0CLKSEL field to a new value. */
#define BW_SIM_SOPT4_TPM0CLKSEL(x, v) (BME_BFI32(HW_SIM_SOPT4_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT4_TPM0CLKSEL), BP_SIM_SOPT4_TPM0CLKSEL, 1))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field TPM1CLKSEL[25] (RW)
 *
 * Selects the external pin used to drive the clock to the TPM1 module. The
 * selected pin must also be configured for the TPM external clock function through
 * the appropriate pin control register in the port control module.
 *
 * Values:
 * - 0 - TPM1 external clock driven by TPM_CLKIN0 pin.
 * - 1 - TPM1 external clock driven by TPM_CLKIN1 pin.
 */
/*@{*/
#define BP_SIM_SOPT4_TPM1CLKSEL (25U)      /*!< Bit position for SIM_SOPT4_TPM1CLKSEL. */
#define BM_SIM_SOPT4_TPM1CLKSEL (0x02000000U) /*!< Bit mask for SIM_SOPT4_TPM1CLKSEL. */
#define BS_SIM_SOPT4_TPM1CLKSEL (1U)       /*!< Bit field size in bits for SIM_SOPT4_TPM1CLKSEL. */

/*! @brief Read current value of the SIM_SOPT4_TPM1CLKSEL field. */
#define BR_SIM_SOPT4_TPM1CLKSEL(x) (BME_UBFX32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_TPM1CLKSEL, BS_SIM_SOPT4_TPM1CLKSEL))

/*! @brief Format value for bitfield SIM_SOPT4_TPM1CLKSEL. */
#define BF_SIM_SOPT4_TPM1CLKSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT4_TPM1CLKSEL) & BM_SIM_SOPT4_TPM1CLKSEL)

/*! @brief Set the TPM1CLKSEL field to a new value. */
#define BW_SIM_SOPT4_TPM1CLKSEL(x, v) (BME_BFI32(HW_SIM_SOPT4_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT4_TPM1CLKSEL), BP_SIM_SOPT4_TPM1CLKSEL, 1))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field TPM2CLKSEL[26] (RW)
 *
 * Selects the external pin used to drive the clock to the TPM2 module. The
 * selected pin must also be configured for the TPM external clock function through
 * the appropriate Pin Control Register in the Port Control module.
 *
 * Values:
 * - 0 - TPM2 external clock driven by TPM_CLKIN0 pin.
 * - 1 - TPM2 external clock driven by TPM_CLKIN1 pin.
 */
/*@{*/
#define BP_SIM_SOPT4_TPM2CLKSEL (26U)      /*!< Bit position for SIM_SOPT4_TPM2CLKSEL. */
#define BM_SIM_SOPT4_TPM2CLKSEL (0x04000000U) /*!< Bit mask for SIM_SOPT4_TPM2CLKSEL. */
#define BS_SIM_SOPT4_TPM2CLKSEL (1U)       /*!< Bit field size in bits for SIM_SOPT4_TPM2CLKSEL. */

/*! @brief Read current value of the SIM_SOPT4_TPM2CLKSEL field. */
#define BR_SIM_SOPT4_TPM2CLKSEL(x) (BME_UBFX32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_TPM2CLKSEL, BS_SIM_SOPT4_TPM2CLKSEL))

/*! @brief Format value for bitfield SIM_SOPT4_TPM2CLKSEL. */
#define BF_SIM_SOPT4_TPM2CLKSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT4_TPM2CLKSEL) & BM_SIM_SOPT4_TPM2CLKSEL)

/*! @brief Set the TPM2CLKSEL field to a new value. */
#define BW_SIM_SOPT4_TPM2CLKSEL(x, v) (BME_BFI32(HW_SIM_SOPT4_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT4_TPM2CLKSEL), BP_SIM_SOPT4_TPM2CLKSEL, 1))
/*@}*/

/*******************************************************************************
 * HW_SIM_SOPT5 - System Options Register 5
 ******************************************************************************/

/*!
 * @brief HW_SIM_SOPT5 - System Options Register 5 (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_sim_sopt5
{
    uint32_t U;
    struct _hw_sim_sopt5_bitfields
    {
        uint32_t LPUART0TXSRC : 2;     /*!< [1:0] LPUART0 Transmit Data Source
                                        * Select */
        uint32_t LPUART0RXSRC : 1;     /*!< [2] LPUART0 Receive Data Source
                                        * Select */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t LPUART1TXSRC : 2;     /*!< [5:4] LPUART1 Transmit Data Source
                                        * Select */
        uint32_t LPUART1RXSRC : 1;     /*!< [6] LPUART1 Receive Data Source
                                        * Select */
        uint32_t RESERVED1 : 9;        /*!< [15:7]  */
        uint32_t LPUART0ODE : 1;       /*!< [16] LPUART0 Open Drain Enable */
        uint32_t LPUART1ODE : 1;       /*!< [17] LPUART1 Open Drain Enable */
        uint32_t UART2ODE : 1;         /*!< [18] UART2 Open Drain Enable */
        uint32_t RESERVED2 : 13;       /*!< [31:19]  */
    } B;
} hw_sim_sopt5_t;

/*!
 * @name Constants and macros for entire SIM_SOPT5 register
 */
/*@{*/
#define HW_SIM_SOPT5_ADDR(x)     ((uint32_t)(x) + 0x1010U)

#define HW_SIM_SOPT5(x)          (*(__IO hw_sim_sopt5_t *) HW_SIM_SOPT5_ADDR(x))
#define HW_SIM_SOPT5_RD(x)       (HW_SIM_SOPT5(x).U)
#define HW_SIM_SOPT5_WR(x, v)    (HW_SIM_SOPT5(x).U = (v))
#define HW_SIM_SOPT5_SET(x, v)   (BME_OR32(HW_SIM_SOPT5_ADDR(x), (uint32_t)(v)))
#define HW_SIM_SOPT5_CLR(x, v)   (BME_AND32(HW_SIM_SOPT5_ADDR(x), (uint32_t)(~(v))))
#define HW_SIM_SOPT5_TOG(x, v)   (BME_XOR32(HW_SIM_SOPT5_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT5 bitfields
 */

/*!
 * @name Register SIM_SOPT5, field LPUART0TXSRC[1:0] (RW)
 *
 * Selects the source for the LPUART0 transmit data.
 *
 * Values:
 * - 00 - LPUART0_TX pin
 * - 01 - LPUART0_TX pin modulated with TPM1 channel 0 output
 * - 10 - LPUART0_TX pin modulated with TPM2 channel 0 output
 * - 11 - Reserved
 */
/*@{*/
#define BP_SIM_SOPT5_LPUART0TXSRC (0U)     /*!< Bit position for SIM_SOPT5_LPUART0TXSRC. */
#define BM_SIM_SOPT5_LPUART0TXSRC (0x00000003U) /*!< Bit mask for SIM_SOPT5_LPUART0TXSRC. */
#define BS_SIM_SOPT5_LPUART0TXSRC (2U)     /*!< Bit field size in bits for SIM_SOPT5_LPUART0TXSRC. */

/*! @brief Read current value of the SIM_SOPT5_LPUART0TXSRC field. */
#define BR_SIM_SOPT5_LPUART0TXSRC(x) (BME_UBFX32(HW_SIM_SOPT5_ADDR(x), BP_SIM_SOPT5_LPUART0TXSRC, BS_SIM_SOPT5_LPUART0TXSRC))

/*! @brief Format value for bitfield SIM_SOPT5_LPUART0TXSRC. */
#define BF_SIM_SOPT5_LPUART0TXSRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT5_LPUART0TXSRC) & BM_SIM_SOPT5_LPUART0TXSRC)

/*! @brief Set the LPUART0TXSRC field to a new value. */
#define BW_SIM_SOPT5_LPUART0TXSRC(x, v) (BME_BFI32(HW_SIM_SOPT5_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT5_LPUART0TXSRC), BP_SIM_SOPT5_LPUART0TXSRC, 2))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field LPUART0RXSRC[2] (RW)
 *
 * Selects the source for the LPUART0 receive data.
 *
 * Values:
 * - 0 - LPUART_RX pin
 * - 1 - CMP0 output
 */
/*@{*/
#define BP_SIM_SOPT5_LPUART0RXSRC (2U)     /*!< Bit position for SIM_SOPT5_LPUART0RXSRC. */
#define BM_SIM_SOPT5_LPUART0RXSRC (0x00000004U) /*!< Bit mask for SIM_SOPT5_LPUART0RXSRC. */
#define BS_SIM_SOPT5_LPUART0RXSRC (1U)     /*!< Bit field size in bits for SIM_SOPT5_LPUART0RXSRC. */

/*! @brief Read current value of the SIM_SOPT5_LPUART0RXSRC field. */
#define BR_SIM_SOPT5_LPUART0RXSRC(x) (BME_UBFX32(HW_SIM_SOPT5_ADDR(x), BP_SIM_SOPT5_LPUART0RXSRC, BS_SIM_SOPT5_LPUART0RXSRC))

/*! @brief Format value for bitfield SIM_SOPT5_LPUART0RXSRC. */
#define BF_SIM_SOPT5_LPUART0RXSRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT5_LPUART0RXSRC) & BM_SIM_SOPT5_LPUART0RXSRC)

/*! @brief Set the LPUART0RXSRC field to a new value. */
#define BW_SIM_SOPT5_LPUART0RXSRC(x, v) (BME_BFI32(HW_SIM_SOPT5_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT5_LPUART0RXSRC), BP_SIM_SOPT5_LPUART0RXSRC, 1))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field LPUART1TXSRC[5:4] (RW)
 *
 * Selects the source for the LPUART1 transmit data.
 *
 * Values:
 * - 00 - LPUART1_TX pin
 * - 01 - LPUART1_TX pin modulated with TPM1 channel 0 output
 * - 10 - LPUART1_TX pin modulated with TPM2 channel 0 output
 * - 11 - Reserved
 */
/*@{*/
#define BP_SIM_SOPT5_LPUART1TXSRC (4U)     /*!< Bit position for SIM_SOPT5_LPUART1TXSRC. */
#define BM_SIM_SOPT5_LPUART1TXSRC (0x00000030U) /*!< Bit mask for SIM_SOPT5_LPUART1TXSRC. */
#define BS_SIM_SOPT5_LPUART1TXSRC (2U)     /*!< Bit field size in bits for SIM_SOPT5_LPUART1TXSRC. */

/*! @brief Read current value of the SIM_SOPT5_LPUART1TXSRC field. */
#define BR_SIM_SOPT5_LPUART1TXSRC(x) (BME_UBFX32(HW_SIM_SOPT5_ADDR(x), BP_SIM_SOPT5_LPUART1TXSRC, BS_SIM_SOPT5_LPUART1TXSRC))

/*! @brief Format value for bitfield SIM_SOPT5_LPUART1TXSRC. */
#define BF_SIM_SOPT5_LPUART1TXSRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT5_LPUART1TXSRC) & BM_SIM_SOPT5_LPUART1TXSRC)

/*! @brief Set the LPUART1TXSRC field to a new value. */
#define BW_SIM_SOPT5_LPUART1TXSRC(x, v) (BME_BFI32(HW_SIM_SOPT5_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT5_LPUART1TXSRC), BP_SIM_SOPT5_LPUART1TXSRC, 2))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field LPUART1RXSRC[6] (RW)
 *
 * Selects the source for the LPUART1 receive data.
 *
 * Values:
 * - 0 - LPUART1_RX pin
 * - 1 - CMP0 output
 */
/*@{*/
#define BP_SIM_SOPT5_LPUART1RXSRC (6U)     /*!< Bit position for SIM_SOPT5_LPUART1RXSRC. */
#define BM_SIM_SOPT5_LPUART1RXSRC (0x00000040U) /*!< Bit mask for SIM_SOPT5_LPUART1RXSRC. */
#define BS_SIM_SOPT5_LPUART1RXSRC (1U)     /*!< Bit field size in bits for SIM_SOPT5_LPUART1RXSRC. */

/*! @brief Read current value of the SIM_SOPT5_LPUART1RXSRC field. */
#define BR_SIM_SOPT5_LPUART1RXSRC(x) (BME_UBFX32(HW_SIM_SOPT5_ADDR(x), BP_SIM_SOPT5_LPUART1RXSRC, BS_SIM_SOPT5_LPUART1RXSRC))

/*! @brief Format value for bitfield SIM_SOPT5_LPUART1RXSRC. */
#define BF_SIM_SOPT5_LPUART1RXSRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT5_LPUART1RXSRC) & BM_SIM_SOPT5_LPUART1RXSRC)

/*! @brief Set the LPUART1RXSRC field to a new value. */
#define BW_SIM_SOPT5_LPUART1RXSRC(x, v) (BME_BFI32(HW_SIM_SOPT5_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT5_LPUART1RXSRC), BP_SIM_SOPT5_LPUART1RXSRC, 1))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field LPUART0ODE[16] (RW)
 *
 * Values:
 * - 0 - Open drain is disabled on LPUART0.
 * - 1 - Open drain is enabled on LPUART0.
 */
/*@{*/
#define BP_SIM_SOPT5_LPUART0ODE (16U)      /*!< Bit position for SIM_SOPT5_LPUART0ODE. */
#define BM_SIM_SOPT5_LPUART0ODE (0x00010000U) /*!< Bit mask for SIM_SOPT5_LPUART0ODE. */
#define BS_SIM_SOPT5_LPUART0ODE (1U)       /*!< Bit field size in bits for SIM_SOPT5_LPUART0ODE. */

/*! @brief Read current value of the SIM_SOPT5_LPUART0ODE field. */
#define BR_SIM_SOPT5_LPUART0ODE(x) (BME_UBFX32(HW_SIM_SOPT5_ADDR(x), BP_SIM_SOPT5_LPUART0ODE, BS_SIM_SOPT5_LPUART0ODE))

/*! @brief Format value for bitfield SIM_SOPT5_LPUART0ODE. */
#define BF_SIM_SOPT5_LPUART0ODE(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT5_LPUART0ODE) & BM_SIM_SOPT5_LPUART0ODE)

/*! @brief Set the LPUART0ODE field to a new value. */
#define BW_SIM_SOPT5_LPUART0ODE(x, v) (BME_BFI32(HW_SIM_SOPT5_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT5_LPUART0ODE), BP_SIM_SOPT5_LPUART0ODE, 1))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field LPUART1ODE[17] (RW)
 *
 * Values:
 * - 0 - Open drain is disabled on LPUART1.
 * - 1 - Open drain is enabled on LPUART1
 */
/*@{*/
#define BP_SIM_SOPT5_LPUART1ODE (17U)      /*!< Bit position for SIM_SOPT5_LPUART1ODE. */
#define BM_SIM_SOPT5_LPUART1ODE (0x00020000U) /*!< Bit mask for SIM_SOPT5_LPUART1ODE. */
#define BS_SIM_SOPT5_LPUART1ODE (1U)       /*!< Bit field size in bits for SIM_SOPT5_LPUART1ODE. */

/*! @brief Read current value of the SIM_SOPT5_LPUART1ODE field. */
#define BR_SIM_SOPT5_LPUART1ODE(x) (BME_UBFX32(HW_SIM_SOPT5_ADDR(x), BP_SIM_SOPT5_LPUART1ODE, BS_SIM_SOPT5_LPUART1ODE))

/*! @brief Format value for bitfield SIM_SOPT5_LPUART1ODE. */
#define BF_SIM_SOPT5_LPUART1ODE(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT5_LPUART1ODE) & BM_SIM_SOPT5_LPUART1ODE)

/*! @brief Set the LPUART1ODE field to a new value. */
#define BW_SIM_SOPT5_LPUART1ODE(x, v) (BME_BFI32(HW_SIM_SOPT5_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT5_LPUART1ODE), BP_SIM_SOPT5_LPUART1ODE, 1))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field UART2ODE[18] (RW)
 *
 * Values:
 * - 0 - Open drain is disabled on UART2
 * - 1 - Open drain is enabled on UART2
 */
/*@{*/
#define BP_SIM_SOPT5_UART2ODE (18U)        /*!< Bit position for SIM_SOPT5_UART2ODE. */
#define BM_SIM_SOPT5_UART2ODE (0x00040000U) /*!< Bit mask for SIM_SOPT5_UART2ODE. */
#define BS_SIM_SOPT5_UART2ODE (1U)         /*!< Bit field size in bits for SIM_SOPT5_UART2ODE. */

/*! @brief Read current value of the SIM_SOPT5_UART2ODE field. */
#define BR_SIM_SOPT5_UART2ODE(x) (BME_UBFX32(HW_SIM_SOPT5_ADDR(x), BP_SIM_SOPT5_UART2ODE, BS_SIM_SOPT5_UART2ODE))

/*! @brief Format value for bitfield SIM_SOPT5_UART2ODE. */
#define BF_SIM_SOPT5_UART2ODE(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT5_UART2ODE) & BM_SIM_SOPT5_UART2ODE)

/*! @brief Set the UART2ODE field to a new value. */
#define BW_SIM_SOPT5_UART2ODE(x, v) (BME_BFI32(HW_SIM_SOPT5_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT5_UART2ODE), BP_SIM_SOPT5_UART2ODE, 1))
/*@}*/

/*******************************************************************************
 * HW_SIM_SOPT7 - System Options Register 7
 ******************************************************************************/

/*!
 * @brief HW_SIM_SOPT7 - System Options Register 7 (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_sim_sopt7
{
    uint32_t U;
    struct _hw_sim_sopt7_bitfields
    {
        uint32_t ADC0TRGSEL : 4;       /*!< [3:0] ADC0 Trigger Select */
        uint32_t ADC0PRETRGSEL : 1;    /*!< [4] ADC0 Pretrigger Select */
        uint32_t RESERVED0 : 2;        /*!< [6:5]  */
        uint32_t ADC0ALTTRGEN : 1;     /*!< [7] ADC0 Alternate Trigger Enable */
        uint32_t RESERVED1 : 24;       /*!< [31:8]  */
    } B;
} hw_sim_sopt7_t;

/*!
 * @name Constants and macros for entire SIM_SOPT7 register
 */
/*@{*/
#define HW_SIM_SOPT7_ADDR(x)     ((uint32_t)(x) + 0x1018U)

#define HW_SIM_SOPT7(x)          (*(__IO hw_sim_sopt7_t *) HW_SIM_SOPT7_ADDR(x))
#define HW_SIM_SOPT7_RD(x)       (HW_SIM_SOPT7(x).U)
#define HW_SIM_SOPT7_WR(x, v)    (HW_SIM_SOPT7(x).U = (v))
#define HW_SIM_SOPT7_SET(x, v)   (BME_OR32(HW_SIM_SOPT7_ADDR(x), (uint32_t)(v)))
#define HW_SIM_SOPT7_CLR(x, v)   (BME_AND32(HW_SIM_SOPT7_ADDR(x), (uint32_t)(~(v))))
#define HW_SIM_SOPT7_TOG(x, v)   (BME_XOR32(HW_SIM_SOPT7_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT7 bitfields
 */

/*!
 * @name Register SIM_SOPT7, field ADC0TRGSEL[3:0] (RW)
 *
 * Selects 1 of 16 peripherals to initiate an ADC conversion via the ADHWDT
 * input, when ADC0ALTTRGEN =1, else is ignored by ADC0.
 *
 * Values:
 * - 0000 - External trigger pin input (EXTRG_IN)
 * - 0001 - CMP0 output
 * - 0010 - Reserved
 * - 0011 - Reserved
 * - 0100 - PIT trigger 0
 * - 0101 - PIT trigger 1
 * - 0110 - Reserved
 * - 0111 - Reserved
 * - 1000 - TPM0 overflow
 * - 1001 - TPM1 overflow
 * - 1010 - TPM2 overflow
 * - 1011 - Reserved
 * - 1100 - RTC alarm
 * - 1101 - RTC seconds
 * - 1110 - LPTMR0 trigger
 * - 1111 - Reserved
 */
/*@{*/
#define BP_SIM_SOPT7_ADC0TRGSEL (0U)       /*!< Bit position for SIM_SOPT7_ADC0TRGSEL. */
#define BM_SIM_SOPT7_ADC0TRGSEL (0x0000000FU) /*!< Bit mask for SIM_SOPT7_ADC0TRGSEL. */
#define BS_SIM_SOPT7_ADC0TRGSEL (4U)       /*!< Bit field size in bits for SIM_SOPT7_ADC0TRGSEL. */

/*! @brief Read current value of the SIM_SOPT7_ADC0TRGSEL field. */
#define BR_SIM_SOPT7_ADC0TRGSEL(x) (BME_UBFX32(HW_SIM_SOPT7_ADDR(x), BP_SIM_SOPT7_ADC0TRGSEL, BS_SIM_SOPT7_ADC0TRGSEL))

/*! @brief Format value for bitfield SIM_SOPT7_ADC0TRGSEL. */
#define BF_SIM_SOPT7_ADC0TRGSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT7_ADC0TRGSEL) & BM_SIM_SOPT7_ADC0TRGSEL)

/*! @brief Set the ADC0TRGSEL field to a new value. */
#define BW_SIM_SOPT7_ADC0TRGSEL(x, v) (BME_BFI32(HW_SIM_SOPT7_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT7_ADC0TRGSEL), BP_SIM_SOPT7_ADC0TRGSEL, 4))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field ADC0PRETRGSEL[4] (RW)
 *
 * Selects the ADC0 pre-trigger source when alternative triggers are enabled
 * through ADC0ALTTRGEN.The ADC0PRETRGSEL function is ignored if ADC0ALTTRGEN = 0.
 *
 * Values:
 * - 0 - Pre-trigger ADHDWTSA is selected, thus ADC0 will use ADC0_SC1A
 *     configuration for the next ADC conversion and store the result in ADC0_RA register.
 * - 1 - Pre-trigger ADHDWTSB is selected, thus ADC0 will use ADC0_SC1B
 *     configuration for the next ADC conversion and store the result in ADC0_RB register.
 */
/*@{*/
#define BP_SIM_SOPT7_ADC0PRETRGSEL (4U)    /*!< Bit position for SIM_SOPT7_ADC0PRETRGSEL. */
#define BM_SIM_SOPT7_ADC0PRETRGSEL (0x00000010U) /*!< Bit mask for SIM_SOPT7_ADC0PRETRGSEL. */
#define BS_SIM_SOPT7_ADC0PRETRGSEL (1U)    /*!< Bit field size in bits for SIM_SOPT7_ADC0PRETRGSEL. */

/*! @brief Read current value of the SIM_SOPT7_ADC0PRETRGSEL field. */
#define BR_SIM_SOPT7_ADC0PRETRGSEL(x) (BME_UBFX32(HW_SIM_SOPT7_ADDR(x), BP_SIM_SOPT7_ADC0PRETRGSEL, BS_SIM_SOPT7_ADC0PRETRGSEL))

/*! @brief Format value for bitfield SIM_SOPT7_ADC0PRETRGSEL. */
#define BF_SIM_SOPT7_ADC0PRETRGSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT7_ADC0PRETRGSEL) & BM_SIM_SOPT7_ADC0PRETRGSEL)

/*! @brief Set the ADC0PRETRGSEL field to a new value. */
#define BW_SIM_SOPT7_ADC0PRETRGSEL(x, v) (BME_BFI32(HW_SIM_SOPT7_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT7_ADC0PRETRGSEL), BP_SIM_SOPT7_ADC0PRETRGSEL, 1))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field ADC0ALTTRGEN[7] (RW)
 *
 * Enables alternative conversion triggers for ADC0.
 *
 * Values:
 * - 0 - ADC ADHWT trigger comes from TPM1 channel 0 and channel1. Prior to the
 *     assertion of TPM1 channel 0, a pre-trigger pulse will be sent to ADHWTSA
 *     to initiate an ADC acquisition using ADCx_SC1A configuration and store ADC
 *     conversion in ADCx_RA Register. Prior to the assertion of TPM1 channel 1 a
 *     pre-trigger pulse will be sent to ADHWTSB to initiate an ADC acquisition
 *     using ADCx_SC1Bconfiguration and store ADC conversion in ADCx_RB Register.
 * - 1 - ADC ADHWT trigger comes from a peripheral event selected by ADC0TRGSEL
 *     bits.ADC0PRETRGSEL bit will select the optional ADHWTSA or ADHWTSB select
 *     lines for choosing the ADCx_SC1x config and ADCx_Rx result regsiter to
 *     store the ADC conversion.
 */
/*@{*/
#define BP_SIM_SOPT7_ADC0ALTTRGEN (7U)     /*!< Bit position for SIM_SOPT7_ADC0ALTTRGEN. */
#define BM_SIM_SOPT7_ADC0ALTTRGEN (0x00000080U) /*!< Bit mask for SIM_SOPT7_ADC0ALTTRGEN. */
#define BS_SIM_SOPT7_ADC0ALTTRGEN (1U)     /*!< Bit field size in bits for SIM_SOPT7_ADC0ALTTRGEN. */

/*! @brief Read current value of the SIM_SOPT7_ADC0ALTTRGEN field. */
#define BR_SIM_SOPT7_ADC0ALTTRGEN(x) (BME_UBFX32(HW_SIM_SOPT7_ADDR(x), BP_SIM_SOPT7_ADC0ALTTRGEN, BS_SIM_SOPT7_ADC0ALTTRGEN))

/*! @brief Format value for bitfield SIM_SOPT7_ADC0ALTTRGEN. */
#define BF_SIM_SOPT7_ADC0ALTTRGEN(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT7_ADC0ALTTRGEN) & BM_SIM_SOPT7_ADC0ALTTRGEN)

/*! @brief Set the ADC0ALTTRGEN field to a new value. */
#define BW_SIM_SOPT7_ADC0ALTTRGEN(x, v) (BME_BFI32(HW_SIM_SOPT7_ADDR(x), ((uint32_t)(v) << BP_SIM_SOPT7_ADC0ALTTRGEN), BP_SIM_SOPT7_ADC0ALTTRGEN, 1))
/*@}*/

/*******************************************************************************
 * HW_SIM_SDID - System Device Identification Register
 ******************************************************************************/

/*!
 * @brief HW_SIM_SDID - System Device Identification Register (RO)
 *
 * Reset value: 0x00100D80U
 */
typedef union _hw_sim_sdid
{
    uint32_t U;
    struct _hw_sim_sdid_bitfields
    {
        uint32_t PINID : 4;            /*!< [3:0] Pincount Identification */
        uint32_t RESERVED0 : 8;        /*!< [11:4]  */
        uint32_t REVID : 4;            /*!< [15:12] Device Revision Number */
        uint32_t SRAMSIZE : 4;         /*!< [19:16] System SRAM Size */
        uint32_t SERIESID : 4;         /*!< [23:20] Kinetis Series ID */
        uint32_t SUBFAMID : 4;         /*!< [27:24] Kinetis Sub-Family ID */
        uint32_t FAMID : 4;            /*!< [31:28]  */
    } B;
} hw_sim_sdid_t;

/*!
 * @name Constants and macros for entire SIM_SDID register
 */
/*@{*/
#define HW_SIM_SDID_ADDR(x)      ((uint32_t)(x) + 0x1024U)

#define HW_SIM_SDID(x)           (*(__I hw_sim_sdid_t *) HW_SIM_SDID_ADDR(x))
#define HW_SIM_SDID_RD(x)        (HW_SIM_SDID(x).U)
/*@}*/

/*
 * Constants & macros for individual SIM_SDID bitfields
 */

/*!
 * @name Register SIM_SDID, field PINID[3:0] (RO)
 *
 * Specifies the pincount of the device.
 *
 * Values:
 * - 0010 - 32-pin
 * - 0100 - 48-pin
 * - 0101 - 64-pin
 * - 1011 - Custom pinout (WLCSP)
 */
/*@{*/
#define BP_SIM_SDID_PINID    (0U)          /*!< Bit position for SIM_SDID_PINID. */
#define BM_SIM_SDID_PINID    (0x0000000FU) /*!< Bit mask for SIM_SDID_PINID. */
#define BS_SIM_SDID_PINID    (4U)          /*!< Bit field size in bits for SIM_SDID_PINID. */

/*! @brief Read current value of the SIM_SDID_PINID field. */
#define BR_SIM_SDID_PINID(x) (BME_UBFX32(HW_SIM_SDID_ADDR(x), BP_SIM_SDID_PINID, BS_SIM_SDID_PINID))
/*@}*/

/*!
 * @name Register SIM_SDID, field REVID[15:12] (RO)
 *
 * Specifies the silicon implementation number for the device.
 */
/*@{*/
#define BP_SIM_SDID_REVID    (12U)         /*!< Bit position for SIM_SDID_REVID. */
#define BM_SIM_SDID_REVID    (0x0000F000U) /*!< Bit mask for SIM_SDID_REVID. */
#define BS_SIM_SDID_REVID    (4U)          /*!< Bit field size in bits for SIM_SDID_REVID. */

/*! @brief Read current value of the SIM_SDID_REVID field. */
#define BR_SIM_SDID_REVID(x) (BME_UBFX32(HW_SIM_SDID_ADDR(x), BP_SIM_SDID_REVID, BS_SIM_SDID_REVID))
/*@}*/

/*!
 * @name Register SIM_SDID, field SRAMSIZE[19:16] (RO)
 *
 * Specifies the size of the System SRAM
 *
 * Values:
 * - 0101 - 16 KB
 * - 0110 - 32 KB
 */
/*@{*/
#define BP_SIM_SDID_SRAMSIZE (16U)         /*!< Bit position for SIM_SDID_SRAMSIZE. */
#define BM_SIM_SDID_SRAMSIZE (0x000F0000U) /*!< Bit mask for SIM_SDID_SRAMSIZE. */
#define BS_SIM_SDID_SRAMSIZE (4U)          /*!< Bit field size in bits for SIM_SDID_SRAMSIZE. */

/*! @brief Read current value of the SIM_SDID_SRAMSIZE field. */
#define BR_SIM_SDID_SRAMSIZE(x) (BME_UBFX32(HW_SIM_SDID_ADDR(x), BP_SIM_SDID_SRAMSIZE, BS_SIM_SDID_SRAMSIZE))
/*@}*/

/*!
 * @name Register SIM_SDID, field SERIESID[23:20] (RO)
 *
 * Specifies the Kinetis family of the device.
 *
 * Values:
 * - 0001 - KL family
 */
/*@{*/
#define BP_SIM_SDID_SERIESID (20U)         /*!< Bit position for SIM_SDID_SERIESID. */
#define BM_SIM_SDID_SERIESID (0x00F00000U) /*!< Bit mask for SIM_SDID_SERIESID. */
#define BS_SIM_SDID_SERIESID (4U)          /*!< Bit field size in bits for SIM_SDID_SERIESID. */

/*! @brief Read current value of the SIM_SDID_SERIESID field. */
#define BR_SIM_SDID_SERIESID(x) (BME_UBFX32(HW_SIM_SDID_ADDR(x), BP_SIM_SDID_SERIESID, BS_SIM_SDID_SERIESID))
/*@}*/

/*!
 * @name Register SIM_SDID, field SUBFAMID[27:24] (RO)
 *
 * Specifies the Kinetis sub-family of the device.
 *
 * Values:
 * - 0011 - KLx3 Subfamily
 */
/*@{*/
#define BP_SIM_SDID_SUBFAMID (24U)         /*!< Bit position for SIM_SDID_SUBFAMID. */
#define BM_SIM_SDID_SUBFAMID (0x0F000000U) /*!< Bit mask for SIM_SDID_SUBFAMID. */
#define BS_SIM_SDID_SUBFAMID (4U)          /*!< Bit field size in bits for SIM_SDID_SUBFAMID. */

/*! @brief Read current value of the SIM_SDID_SUBFAMID field. */
#define BR_SIM_SDID_SUBFAMID(x) (BME_UBFX32(HW_SIM_SDID_ADDR(x), BP_SIM_SDID_SUBFAMID, BS_SIM_SDID_SUBFAMID))
/*@}*/

/*!
 * @name Register SIM_SDID, field FAMID[31:28] (RO)
 *
 * Family ID
 *
 * Values:
 * - 0001 - KL17
 * - 0010 - KL27
 * - 0011 - KL33
 * - 0100 - KL43
 */
/*@{*/
#define BP_SIM_SDID_FAMID    (28U)         /*!< Bit position for SIM_SDID_FAMID. */
#define BM_SIM_SDID_FAMID    (0xF0000000U) /*!< Bit mask for SIM_SDID_FAMID. */
#define BS_SIM_SDID_FAMID    (4U)          /*!< Bit field size in bits for SIM_SDID_FAMID. */

/*! @brief Read current value of the SIM_SDID_FAMID field. */
#define BR_SIM_SDID_FAMID(x) (BME_UBFX32(HW_SIM_SDID_ADDR(x), BP_SIM_SDID_FAMID, BS_SIM_SDID_FAMID))
/*@}*/

/*******************************************************************************
 * HW_SIM_SCGC4 - System Clock Gating Control Register 4
 ******************************************************************************/

/*!
 * @brief HW_SIM_SCGC4 - System Clock Gating Control Register 4 (RW)
 *
 * Reset value: 0xF0000030U
 */
typedef union _hw_sim_scgc4
{
    uint32_t U;
    struct _hw_sim_scgc4_bitfields
    {
        uint32_t RESERVED0 : 6;        /*!< [5:0]  */
        uint32_t I2C0b : 1;            /*!< [6] I2C0 Clock Gate Control */
        uint32_t I2C1b : 1;            /*!< [7] I2C1 Clock Gate Control */
        uint32_t RESERVED1 : 4;        /*!< [11:8]  */
        uint32_t UART2b : 1;           /*!< [12] UART2 Clock Gate Control */
        uint32_t RESERVED2 : 5;        /*!< [17:13]  */
        uint32_t USBFS : 1;            /*!< [18] USB Clock Gate Control */
        uint32_t CMP0b : 1;            /*!< [19] Comparator Clock Gate Control */
        uint32_t VREFb : 1;            /*!< [20] VREF Clock Gate Control */
        uint32_t RESERVED3 : 1;        /*!< [21]  */
        uint32_t SPI0b : 1;            /*!< [22] SPI0 Clock Gate Control */
        uint32_t SPI1b : 1;            /*!< [23] SPI1 Clock Gate Control */
        uint32_t RESERVED4 : 8;        /*!< [31:24]  */
    } B;
} hw_sim_scgc4_t;

/*!
 * @name Constants and macros for entire SIM_SCGC4 register
 */
/*@{*/
#define HW_SIM_SCGC4_ADDR(x)     ((uint32_t)(x) + 0x1034U)

/* Unified clock gate bit access macros */
#define HW_SIM_SCGC_BIT_ADDR(x, n) (HW_SIM_SCGC4_ADDR(x) + ((((uint32_t)(n) >> 5) - 3U) * 4U))
#define BP_SIM_SCGC_BIT(n)         ((uint32_t)(n) & ((1U << 5) - 1U))
#define BW_SIM_SCGC_BIT(x, n, v)   (BME_BFI32(HW_SIM_SCGC_BIT_ADDR((x), (n)), ((uint32_t)(v) << BP_SIM_SCGC_BIT(n)), BP_SIM_SCGC_BIT(n), 1))
#define BR_SIM_SCGC_BIT(x, n)      (BME_UBFX32(HW_SIM_SCGC_BIT_ADDR((x), (n)), BP_SIM_SCGC_BIT(n), 1))

#define HW_SIM_SCGC4(x)          (*(__IO hw_sim_scgc4_t *) HW_SIM_SCGC4_ADDR(x))
#define HW_SIM_SCGC4_RD(x)       (HW_SIM_SCGC4(x).U)
#define HW_SIM_SCGC4_WR(x, v)    (HW_SIM_SCGC4(x).U = (v))
#define HW_SIM_SCGC4_SET(x, v)   (BME_OR32(HW_SIM_SCGC4_ADDR(x), (uint32_t)(v)))
#define HW_SIM_SCGC4_CLR(x, v)   (BME_AND32(HW_SIM_SCGC4_ADDR(x), (uint32_t)(~(v))))
#define HW_SIM_SCGC4_TOG(x, v)   (BME_XOR32(HW_SIM_SCGC4_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC4 bitfields
 */

/*!
 * @name Register SIM_SCGC4, field I2C0[6] (RW)
 *
 * Controls the clock gate to the I2C0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC4_I2C0    (6U)          /*!< Bit position for SIM_SCGC4_I2C0. */
#define BM_SIM_SCGC4_I2C0    (0x00000040U) /*!< Bit mask for SIM_SCGC4_I2C0. */
#define BS_SIM_SCGC4_I2C0    (1U)          /*!< Bit field size in bits for SIM_SCGC4_I2C0. */

/*! @brief Read current value of the SIM_SCGC4_I2C0 field. */
#define BR_SIM_SCGC4_I2C0(x) (BME_UBFX32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_I2C0, BS_SIM_SCGC4_I2C0))

/*! @brief Format value for bitfield SIM_SCGC4_I2C0. */
#define BF_SIM_SCGC4_I2C0(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC4_I2C0) & BM_SIM_SCGC4_I2C0)

/*! @brief Set the I2C0 field to a new value. */
#define BW_SIM_SCGC4_I2C0(x, v) (BME_BFI32(HW_SIM_SCGC4_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC4_I2C0), BP_SIM_SCGC4_I2C0, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field I2C1[7] (RW)
 *
 * Controls the clock gate to the I2C1 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC4_I2C1    (7U)          /*!< Bit position for SIM_SCGC4_I2C1. */
#define BM_SIM_SCGC4_I2C1    (0x00000080U) /*!< Bit mask for SIM_SCGC4_I2C1. */
#define BS_SIM_SCGC4_I2C1    (1U)          /*!< Bit field size in bits for SIM_SCGC4_I2C1. */

/*! @brief Read current value of the SIM_SCGC4_I2C1 field. */
#define BR_SIM_SCGC4_I2C1(x) (BME_UBFX32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_I2C1, BS_SIM_SCGC4_I2C1))

/*! @brief Format value for bitfield SIM_SCGC4_I2C1. */
#define BF_SIM_SCGC4_I2C1(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC4_I2C1) & BM_SIM_SCGC4_I2C1)

/*! @brief Set the I2C1 field to a new value. */
#define BW_SIM_SCGC4_I2C1(x, v) (BME_BFI32(HW_SIM_SCGC4_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC4_I2C1), BP_SIM_SCGC4_I2C1, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field UART2[12] (RW)
 *
 * Controls the clock gate to the UART2 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC4_UART2   (12U)         /*!< Bit position for SIM_SCGC4_UART2. */
#define BM_SIM_SCGC4_UART2   (0x00001000U) /*!< Bit mask for SIM_SCGC4_UART2. */
#define BS_SIM_SCGC4_UART2   (1U)          /*!< Bit field size in bits for SIM_SCGC4_UART2. */

/*! @brief Read current value of the SIM_SCGC4_UART2 field. */
#define BR_SIM_SCGC4_UART2(x) (BME_UBFX32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_UART2, BS_SIM_SCGC4_UART2))

/*! @brief Format value for bitfield SIM_SCGC4_UART2. */
#define BF_SIM_SCGC4_UART2(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC4_UART2) & BM_SIM_SCGC4_UART2)

/*! @brief Set the UART2 field to a new value. */
#define BW_SIM_SCGC4_UART2(x, v) (BME_BFI32(HW_SIM_SCGC4_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC4_UART2), BP_SIM_SCGC4_UART2, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field USBFS[18] (RW)
 *
 * This bit controls the clock gate to the USB module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC4_USBFS   (18U)         /*!< Bit position for SIM_SCGC4_USBFS. */
#define BM_SIM_SCGC4_USBFS   (0x00040000U) /*!< Bit mask for SIM_SCGC4_USBFS. */
#define BS_SIM_SCGC4_USBFS   (1U)          /*!< Bit field size in bits for SIM_SCGC4_USBFS. */

/*! @brief Read current value of the SIM_SCGC4_USBFS field. */
#define BR_SIM_SCGC4_USBFS(x) (BME_UBFX32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_USBFS, BS_SIM_SCGC4_USBFS))

/*! @brief Format value for bitfield SIM_SCGC4_USBFS. */
#define BF_SIM_SCGC4_USBFS(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC4_USBFS) & BM_SIM_SCGC4_USBFS)

/*! @brief Set the USBFS field to a new value. */
#define BW_SIM_SCGC4_USBFS(x, v) (BME_BFI32(HW_SIM_SCGC4_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC4_USBFS), BP_SIM_SCGC4_USBFS, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field CMP0[19] (RW)
 *
 * Controls the clock gate to the comparator module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC4_CMP0    (19U)         /*!< Bit position for SIM_SCGC4_CMP0. */
#define BM_SIM_SCGC4_CMP0    (0x00080000U) /*!< Bit mask for SIM_SCGC4_CMP0. */
#define BS_SIM_SCGC4_CMP0    (1U)          /*!< Bit field size in bits for SIM_SCGC4_CMP0. */

/*! @brief Read current value of the SIM_SCGC4_CMP0 field. */
#define BR_SIM_SCGC4_CMP0(x) (BME_UBFX32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_CMP0, BS_SIM_SCGC4_CMP0))

/*! @brief Format value for bitfield SIM_SCGC4_CMP0. */
#define BF_SIM_SCGC4_CMP0(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC4_CMP0) & BM_SIM_SCGC4_CMP0)

/*! @brief Set the CMP0 field to a new value. */
#define BW_SIM_SCGC4_CMP0(x, v) (BME_BFI32(HW_SIM_SCGC4_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC4_CMP0), BP_SIM_SCGC4_CMP0, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field VREF[20] (RW)
 *
 * Controls the clock gate to the VREF module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC4_VREF    (20U)         /*!< Bit position for SIM_SCGC4_VREF. */
#define BM_SIM_SCGC4_VREF    (0x00100000U) /*!< Bit mask for SIM_SCGC4_VREF. */
#define BS_SIM_SCGC4_VREF    (1U)          /*!< Bit field size in bits for SIM_SCGC4_VREF. */

/*! @brief Read current value of the SIM_SCGC4_VREF field. */
#define BR_SIM_SCGC4_VREF(x) (BME_UBFX32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_VREF, BS_SIM_SCGC4_VREF))

/*! @brief Format value for bitfield SIM_SCGC4_VREF. */
#define BF_SIM_SCGC4_VREF(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC4_VREF) & BM_SIM_SCGC4_VREF)

/*! @brief Set the VREF field to a new value. */
#define BW_SIM_SCGC4_VREF(x, v) (BME_BFI32(HW_SIM_SCGC4_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC4_VREF), BP_SIM_SCGC4_VREF, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field SPI0[22] (RW)
 *
 * Controls the clock gate to the SPI0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC4_SPI0    (22U)         /*!< Bit position for SIM_SCGC4_SPI0. */
#define BM_SIM_SCGC4_SPI0    (0x00400000U) /*!< Bit mask for SIM_SCGC4_SPI0. */
#define BS_SIM_SCGC4_SPI0    (1U)          /*!< Bit field size in bits for SIM_SCGC4_SPI0. */

/*! @brief Read current value of the SIM_SCGC4_SPI0 field. */
#define BR_SIM_SCGC4_SPI0(x) (BME_UBFX32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_SPI0, BS_SIM_SCGC4_SPI0))

/*! @brief Format value for bitfield SIM_SCGC4_SPI0. */
#define BF_SIM_SCGC4_SPI0(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC4_SPI0) & BM_SIM_SCGC4_SPI0)

/*! @brief Set the SPI0 field to a new value. */
#define BW_SIM_SCGC4_SPI0(x, v) (BME_BFI32(HW_SIM_SCGC4_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC4_SPI0), BP_SIM_SCGC4_SPI0, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field SPI1[23] (RW)
 *
 * Controls the clock gate to the SPI1 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC4_SPI1    (23U)         /*!< Bit position for SIM_SCGC4_SPI1. */
#define BM_SIM_SCGC4_SPI1    (0x00800000U) /*!< Bit mask for SIM_SCGC4_SPI1. */
#define BS_SIM_SCGC4_SPI1    (1U)          /*!< Bit field size in bits for SIM_SCGC4_SPI1. */

/*! @brief Read current value of the SIM_SCGC4_SPI1 field. */
#define BR_SIM_SCGC4_SPI1(x) (BME_UBFX32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_SPI1, BS_SIM_SCGC4_SPI1))

/*! @brief Format value for bitfield SIM_SCGC4_SPI1. */
#define BF_SIM_SCGC4_SPI1(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC4_SPI1) & BM_SIM_SCGC4_SPI1)

/*! @brief Set the SPI1 field to a new value. */
#define BW_SIM_SCGC4_SPI1(x, v) (BME_BFI32(HW_SIM_SCGC4_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC4_SPI1), BP_SIM_SCGC4_SPI1, 1))
/*@}*/

/*******************************************************************************
 * HW_SIM_SCGC5 - System Clock Gating Control Register 5
 ******************************************************************************/

/*!
 * @brief HW_SIM_SCGC5 - System Clock Gating Control Register 5 (RW)
 *
 * Reset value: 0x00000182U
 */
typedef union _hw_sim_scgc5
{
    uint32_t U;
    struct _hw_sim_scgc5_bitfields
    {
        uint32_t LPTMR : 1;            /*!< [0] Low Power Timer Access Control */
        uint32_t RESERVED0 : 8;        /*!< [8:1]  */
        uint32_t PORTAb : 1;           /*!< [9] Port A Clock Gate Control */
        uint32_t PORTBb : 1;           /*!< [10] Port B Clock Gate Control */
        uint32_t PORTCb : 1;           /*!< [11] Port C Clock Gate Control */
        uint32_t PORTDb : 1;           /*!< [12] Port D Clock Gate Control */
        uint32_t PORTEb : 1;           /*!< [13] Port E Clock Gate Control */
        uint32_t RESERVED1 : 5;        /*!< [18:14]  */
        uint32_t SLCD : 1;             /*!< [19] Segment LCD Clock Gate Control */
        uint32_t LPUART0b : 1;         /*!< [20] LPUART0 Clock Gate Control */
        uint32_t LPUART1b : 1;         /*!< [21] LPUART1 Clock Gate Control */
        uint32_t RESERVED2 : 9;        /*!< [30:22]  */
        uint32_t FLEXIOb : 1;          /*!< [31] FlexIO Module */
    } B;
} hw_sim_scgc5_t;

/*!
 * @name Constants and macros for entire SIM_SCGC5 register
 */
/*@{*/
#define HW_SIM_SCGC5_ADDR(x)     ((uint32_t)(x) + 0x1038U)

#define HW_SIM_SCGC5(x)          (*(__IO hw_sim_scgc5_t *) HW_SIM_SCGC5_ADDR(x))
#define HW_SIM_SCGC5_RD(x)       (HW_SIM_SCGC5(x).U)
#define HW_SIM_SCGC5_WR(x, v)    (HW_SIM_SCGC5(x).U = (v))
#define HW_SIM_SCGC5_SET(x, v)   (BME_OR32(HW_SIM_SCGC5_ADDR(x), (uint32_t)(v)))
#define HW_SIM_SCGC5_CLR(x, v)   (BME_AND32(HW_SIM_SCGC5_ADDR(x), (uint32_t)(~(v))))
#define HW_SIM_SCGC5_TOG(x, v)   (BME_XOR32(HW_SIM_SCGC5_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC5 bitfields
 */

/*!
 * @name Register SIM_SCGC5, field LPTMR[0] (RW)
 *
 * Controls software access to the Low Power Timer module.
 *
 * Values:
 * - 0 - Access disabled
 * - 1 - Access enabled
 */
/*@{*/
#define BP_SIM_SCGC5_LPTMR   (0U)          /*!< Bit position for SIM_SCGC5_LPTMR. */
#define BM_SIM_SCGC5_LPTMR   (0x00000001U) /*!< Bit mask for SIM_SCGC5_LPTMR. */
#define BS_SIM_SCGC5_LPTMR   (1U)          /*!< Bit field size in bits for SIM_SCGC5_LPTMR. */

/*! @brief Read current value of the SIM_SCGC5_LPTMR field. */
#define BR_SIM_SCGC5_LPTMR(x) (BME_UBFX32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_LPTMR, BS_SIM_SCGC5_LPTMR))

/*! @brief Format value for bitfield SIM_SCGC5_LPTMR. */
#define BF_SIM_SCGC5_LPTMR(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC5_LPTMR) & BM_SIM_SCGC5_LPTMR)

/*! @brief Set the LPTMR field to a new value. */
#define BW_SIM_SCGC5_LPTMR(x, v) (BME_BFI32(HW_SIM_SCGC5_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC5_LPTMR), BP_SIM_SCGC5_LPTMR, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTA[9] (RW)
 *
 * Controls the clock gate to the Port A module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC5_PORTA   (9U)          /*!< Bit position for SIM_SCGC5_PORTA. */
#define BM_SIM_SCGC5_PORTA   (0x00000200U) /*!< Bit mask for SIM_SCGC5_PORTA. */
#define BS_SIM_SCGC5_PORTA   (1U)          /*!< Bit field size in bits for SIM_SCGC5_PORTA. */

/*! @brief Read current value of the SIM_SCGC5_PORTA field. */
#define BR_SIM_SCGC5_PORTA(x) (BME_UBFX32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_PORTA, BS_SIM_SCGC5_PORTA))

/*! @brief Format value for bitfield SIM_SCGC5_PORTA. */
#define BF_SIM_SCGC5_PORTA(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC5_PORTA) & BM_SIM_SCGC5_PORTA)

/*! @brief Set the PORTA field to a new value. */
#define BW_SIM_SCGC5_PORTA(x, v) (BME_BFI32(HW_SIM_SCGC5_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC5_PORTA), BP_SIM_SCGC5_PORTA, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTB[10] (RW)
 *
 * Controls the clock gate to the Port B module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC5_PORTB   (10U)         /*!< Bit position for SIM_SCGC5_PORTB. */
#define BM_SIM_SCGC5_PORTB   (0x00000400U) /*!< Bit mask for SIM_SCGC5_PORTB. */
#define BS_SIM_SCGC5_PORTB   (1U)          /*!< Bit field size in bits for SIM_SCGC5_PORTB. */

/*! @brief Read current value of the SIM_SCGC5_PORTB field. */
#define BR_SIM_SCGC5_PORTB(x) (BME_UBFX32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_PORTB, BS_SIM_SCGC5_PORTB))

/*! @brief Format value for bitfield SIM_SCGC5_PORTB. */
#define BF_SIM_SCGC5_PORTB(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC5_PORTB) & BM_SIM_SCGC5_PORTB)

/*! @brief Set the PORTB field to a new value. */
#define BW_SIM_SCGC5_PORTB(x, v) (BME_BFI32(HW_SIM_SCGC5_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC5_PORTB), BP_SIM_SCGC5_PORTB, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTC[11] (RW)
 *
 * Controls the clock gate to the Port C module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC5_PORTC   (11U)         /*!< Bit position for SIM_SCGC5_PORTC. */
#define BM_SIM_SCGC5_PORTC   (0x00000800U) /*!< Bit mask for SIM_SCGC5_PORTC. */
#define BS_SIM_SCGC5_PORTC   (1U)          /*!< Bit field size in bits for SIM_SCGC5_PORTC. */

/*! @brief Read current value of the SIM_SCGC5_PORTC field. */
#define BR_SIM_SCGC5_PORTC(x) (BME_UBFX32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_PORTC, BS_SIM_SCGC5_PORTC))

/*! @brief Format value for bitfield SIM_SCGC5_PORTC. */
#define BF_SIM_SCGC5_PORTC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC5_PORTC) & BM_SIM_SCGC5_PORTC)

/*! @brief Set the PORTC field to a new value. */
#define BW_SIM_SCGC5_PORTC(x, v) (BME_BFI32(HW_SIM_SCGC5_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC5_PORTC), BP_SIM_SCGC5_PORTC, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTD[12] (RW)
 *
 * Controls the clock gate to the Port D module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC5_PORTD   (12U)         /*!< Bit position for SIM_SCGC5_PORTD. */
#define BM_SIM_SCGC5_PORTD   (0x00001000U) /*!< Bit mask for SIM_SCGC5_PORTD. */
#define BS_SIM_SCGC5_PORTD   (1U)          /*!< Bit field size in bits for SIM_SCGC5_PORTD. */

/*! @brief Read current value of the SIM_SCGC5_PORTD field. */
#define BR_SIM_SCGC5_PORTD(x) (BME_UBFX32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_PORTD, BS_SIM_SCGC5_PORTD))

/*! @brief Format value for bitfield SIM_SCGC5_PORTD. */
#define BF_SIM_SCGC5_PORTD(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC5_PORTD) & BM_SIM_SCGC5_PORTD)

/*! @brief Set the PORTD field to a new value. */
#define BW_SIM_SCGC5_PORTD(x, v) (BME_BFI32(HW_SIM_SCGC5_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC5_PORTD), BP_SIM_SCGC5_PORTD, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTE[13] (RW)
 *
 * Controls the clock gate to the Port E module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC5_PORTE   (13U)         /*!< Bit position for SIM_SCGC5_PORTE. */
#define BM_SIM_SCGC5_PORTE   (0x00002000U) /*!< Bit mask for SIM_SCGC5_PORTE. */
#define BS_SIM_SCGC5_PORTE   (1U)          /*!< Bit field size in bits for SIM_SCGC5_PORTE. */

/*! @brief Read current value of the SIM_SCGC5_PORTE field. */
#define BR_SIM_SCGC5_PORTE(x) (BME_UBFX32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_PORTE, BS_SIM_SCGC5_PORTE))

/*! @brief Format value for bitfield SIM_SCGC5_PORTE. */
#define BF_SIM_SCGC5_PORTE(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC5_PORTE) & BM_SIM_SCGC5_PORTE)

/*! @brief Set the PORTE field to a new value. */
#define BW_SIM_SCGC5_PORTE(x, v) (BME_BFI32(HW_SIM_SCGC5_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC5_PORTE), BP_SIM_SCGC5_PORTE, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field SLCD[19] (RW)
 *
 * This bit controls the clock gate to the Segment LCD module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC5_SLCD    (19U)         /*!< Bit position for SIM_SCGC5_SLCD. */
#define BM_SIM_SCGC5_SLCD    (0x00080000U) /*!< Bit mask for SIM_SCGC5_SLCD. */
#define BS_SIM_SCGC5_SLCD    (1U)          /*!< Bit field size in bits for SIM_SCGC5_SLCD. */

/*! @brief Read current value of the SIM_SCGC5_SLCD field. */
#define BR_SIM_SCGC5_SLCD(x) (BME_UBFX32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_SLCD, BS_SIM_SCGC5_SLCD))

/*! @brief Format value for bitfield SIM_SCGC5_SLCD. */
#define BF_SIM_SCGC5_SLCD(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC5_SLCD) & BM_SIM_SCGC5_SLCD)

/*! @brief Set the SLCD field to a new value. */
#define BW_SIM_SCGC5_SLCD(x, v) (BME_BFI32(HW_SIM_SCGC5_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC5_SLCD), BP_SIM_SCGC5_SLCD, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field LPUART0[20] (RW)
 *
 * This bit controls the clock gate to the LPUART0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC5_LPUART0 (20U)         /*!< Bit position for SIM_SCGC5_LPUART0. */
#define BM_SIM_SCGC5_LPUART0 (0x00100000U) /*!< Bit mask for SIM_SCGC5_LPUART0. */
#define BS_SIM_SCGC5_LPUART0 (1U)          /*!< Bit field size in bits for SIM_SCGC5_LPUART0. */

/*! @brief Read current value of the SIM_SCGC5_LPUART0 field. */
#define BR_SIM_SCGC5_LPUART0(x) (BME_UBFX32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_LPUART0, BS_SIM_SCGC5_LPUART0))

/*! @brief Format value for bitfield SIM_SCGC5_LPUART0. */
#define BF_SIM_SCGC5_LPUART0(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC5_LPUART0) & BM_SIM_SCGC5_LPUART0)

/*! @brief Set the LPUART0 field to a new value. */
#define BW_SIM_SCGC5_LPUART0(x, v) (BME_BFI32(HW_SIM_SCGC5_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC5_LPUART0), BP_SIM_SCGC5_LPUART0, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field LPUART1[21] (RW)
 *
 * This bit controls the clock gate to the LPUART1 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC5_LPUART1 (21U)         /*!< Bit position for SIM_SCGC5_LPUART1. */
#define BM_SIM_SCGC5_LPUART1 (0x00200000U) /*!< Bit mask for SIM_SCGC5_LPUART1. */
#define BS_SIM_SCGC5_LPUART1 (1U)          /*!< Bit field size in bits for SIM_SCGC5_LPUART1. */

/*! @brief Read current value of the SIM_SCGC5_LPUART1 field. */
#define BR_SIM_SCGC5_LPUART1(x) (BME_UBFX32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_LPUART1, BS_SIM_SCGC5_LPUART1))

/*! @brief Format value for bitfield SIM_SCGC5_LPUART1. */
#define BF_SIM_SCGC5_LPUART1(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC5_LPUART1) & BM_SIM_SCGC5_LPUART1)

/*! @brief Set the LPUART1 field to a new value. */
#define BW_SIM_SCGC5_LPUART1(x, v) (BME_BFI32(HW_SIM_SCGC5_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC5_LPUART1), BP_SIM_SCGC5_LPUART1, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field FLEXIO[31] (RW)
 *
 * This bit controls the clock gate to the FlexIO Module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC5_FLEXIO  (31U)         /*!< Bit position for SIM_SCGC5_FLEXIO. */
#define BM_SIM_SCGC5_FLEXIO  (0x80000000U) /*!< Bit mask for SIM_SCGC5_FLEXIO. */
#define BS_SIM_SCGC5_FLEXIO  (1U)          /*!< Bit field size in bits for SIM_SCGC5_FLEXIO. */

/*! @brief Read current value of the SIM_SCGC5_FLEXIO field. */
#define BR_SIM_SCGC5_FLEXIO(x) (BME_UBFX32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_FLEXIO, BS_SIM_SCGC5_FLEXIO))

/*! @brief Format value for bitfield SIM_SCGC5_FLEXIO. */
#define BF_SIM_SCGC5_FLEXIO(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC5_FLEXIO) & BM_SIM_SCGC5_FLEXIO)

/*! @brief Set the FLEXIO field to a new value. */
#define BW_SIM_SCGC5_FLEXIO(x, v) (BME_BFI32(HW_SIM_SCGC5_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC5_FLEXIO), BP_SIM_SCGC5_FLEXIO, 1))
/*@}*/

/*******************************************************************************
 * HW_SIM_SCGC6 - System Clock Gating Control Register 6
 ******************************************************************************/

/*!
 * @brief HW_SIM_SCGC6 - System Clock Gating Control Register 6 (RW)
 *
 * Reset value: 0x00000001U
 */
typedef union _hw_sim_scgc6
{
    uint32_t U;
    struct _hw_sim_scgc6_bitfields
    {
        uint32_t FTF : 1;              /*!< [0] Flash Memory Clock Gate Control */
        uint32_t DMAMUX : 1;           /*!< [1] DMA Mux Clock Gate Control */
        uint32_t RESERVED0 : 13;       /*!< [14:2]  */
        uint32_t I2S : 1;              /*!< [15] I2S Clock Gate Control */
        uint32_t RESERVED1 : 7;        /*!< [22:16]  */
        uint32_t PITb : 1;             /*!< [23] PIT Clock Gate Control */
        uint32_t TPM0b : 1;            /*!< [24] TPM0 Clock Gate Control */
        uint32_t TPM1b : 1;            /*!< [25] TPM1 Clock Gate Control */
        uint32_t TPM2b : 1;            /*!< [26] TPM2 Clock Gate Control */
        uint32_t ADC0b : 1;            /*!< [27] ADC0 Clock Gate Control */
        uint32_t RESERVED2 : 1;        /*!< [28]  */
        uint32_t RTCb : 1;             /*!< [29] RTC Access Control */
        uint32_t RESERVED3 : 1;        /*!< [30]  */
        uint32_t DAC0b : 1;            /*!< [31] DAC0 Clock Gate Control */
    } B;
} hw_sim_scgc6_t;

/*!
 * @name Constants and macros for entire SIM_SCGC6 register
 */
/*@{*/
#define HW_SIM_SCGC6_ADDR(x)     ((uint32_t)(x) + 0x103CU)

#define HW_SIM_SCGC6(x)          (*(__IO hw_sim_scgc6_t *) HW_SIM_SCGC6_ADDR(x))
#define HW_SIM_SCGC6_RD(x)       (HW_SIM_SCGC6(x).U)
#define HW_SIM_SCGC6_WR(x, v)    (HW_SIM_SCGC6(x).U = (v))
#define HW_SIM_SCGC6_SET(x, v)   (BME_OR32(HW_SIM_SCGC6_ADDR(x), (uint32_t)(v)))
#define HW_SIM_SCGC6_CLR(x, v)   (BME_AND32(HW_SIM_SCGC6_ADDR(x), (uint32_t)(~(v))))
#define HW_SIM_SCGC6_TOG(x, v)   (BME_XOR32(HW_SIM_SCGC6_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC6 bitfields
 */

/*!
 * @name Register SIM_SCGC6, field FTF[0] (RW)
 *
 * Controls the clock gate to the flash memory. Flash reads are still supported
 * while the flash memory is clock gated, but entry into low power modes is
 * blocked.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_FTF     (0U)          /*!< Bit position for SIM_SCGC6_FTF. */
#define BM_SIM_SCGC6_FTF     (0x00000001U) /*!< Bit mask for SIM_SCGC6_FTF. */
#define BS_SIM_SCGC6_FTF     (1U)          /*!< Bit field size in bits for SIM_SCGC6_FTF. */

/*! @brief Read current value of the SIM_SCGC6_FTF field. */
#define BR_SIM_SCGC6_FTF(x)  (BME_UBFX32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_FTF, BS_SIM_SCGC6_FTF))

/*! @brief Format value for bitfield SIM_SCGC6_FTF. */
#define BF_SIM_SCGC6_FTF(v)  ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_FTF) & BM_SIM_SCGC6_FTF)

/*! @brief Set the FTF field to a new value. */
#define BW_SIM_SCGC6_FTF(x, v) (BME_BFI32(HW_SIM_SCGC6_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC6_FTF), BP_SIM_SCGC6_FTF, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field DMAMUX[1] (RW)
 *
 * Controls the clock gate to the DMA Mux module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_DMAMUX  (1U)          /*!< Bit position for SIM_SCGC6_DMAMUX. */
#define BM_SIM_SCGC6_DMAMUX  (0x00000002U) /*!< Bit mask for SIM_SCGC6_DMAMUX. */
#define BS_SIM_SCGC6_DMAMUX  (1U)          /*!< Bit field size in bits for SIM_SCGC6_DMAMUX. */

/*! @brief Read current value of the SIM_SCGC6_DMAMUX field. */
#define BR_SIM_SCGC6_DMAMUX(x) (BME_UBFX32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_DMAMUX, BS_SIM_SCGC6_DMAMUX))

/*! @brief Format value for bitfield SIM_SCGC6_DMAMUX. */
#define BF_SIM_SCGC6_DMAMUX(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_DMAMUX) & BM_SIM_SCGC6_DMAMUX)

/*! @brief Set the DMAMUX field to a new value. */
#define BW_SIM_SCGC6_DMAMUX(x, v) (BME_BFI32(HW_SIM_SCGC6_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC6_DMAMUX), BP_SIM_SCGC6_DMAMUX, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field I2S[15] (RW)
 *
 * This bit controls the clock gate to the I2S module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_I2S     (15U)         /*!< Bit position for SIM_SCGC6_I2S. */
#define BM_SIM_SCGC6_I2S     (0x00008000U) /*!< Bit mask for SIM_SCGC6_I2S. */
#define BS_SIM_SCGC6_I2S     (1U)          /*!< Bit field size in bits for SIM_SCGC6_I2S. */

/*! @brief Read current value of the SIM_SCGC6_I2S field. */
#define BR_SIM_SCGC6_I2S(x)  (BME_UBFX32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_I2S, BS_SIM_SCGC6_I2S))

/*! @brief Format value for bitfield SIM_SCGC6_I2S. */
#define BF_SIM_SCGC6_I2S(v)  ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_I2S) & BM_SIM_SCGC6_I2S)

/*! @brief Set the I2S field to a new value. */
#define BW_SIM_SCGC6_I2S(x, v) (BME_BFI32(HW_SIM_SCGC6_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC6_I2S), BP_SIM_SCGC6_I2S, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field PIT[23] (RW)
 *
 * This bit controls the clock gate to the PIT module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_PIT     (23U)         /*!< Bit position for SIM_SCGC6_PIT. */
#define BM_SIM_SCGC6_PIT     (0x00800000U) /*!< Bit mask for SIM_SCGC6_PIT. */
#define BS_SIM_SCGC6_PIT     (1U)          /*!< Bit field size in bits for SIM_SCGC6_PIT. */

/*! @brief Read current value of the SIM_SCGC6_PIT field. */
#define BR_SIM_SCGC6_PIT(x)  (BME_UBFX32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_PIT, BS_SIM_SCGC6_PIT))

/*! @brief Format value for bitfield SIM_SCGC6_PIT. */
#define BF_SIM_SCGC6_PIT(v)  ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_PIT) & BM_SIM_SCGC6_PIT)

/*! @brief Set the PIT field to a new value. */
#define BW_SIM_SCGC6_PIT(x, v) (BME_BFI32(HW_SIM_SCGC6_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC6_PIT), BP_SIM_SCGC6_PIT, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field TPM0[24] (RW)
 *
 * Controls the clock gate to the TPM0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_TPM0    (24U)         /*!< Bit position for SIM_SCGC6_TPM0. */
#define BM_SIM_SCGC6_TPM0    (0x01000000U) /*!< Bit mask for SIM_SCGC6_TPM0. */
#define BS_SIM_SCGC6_TPM0    (1U)          /*!< Bit field size in bits for SIM_SCGC6_TPM0. */

/*! @brief Read current value of the SIM_SCGC6_TPM0 field. */
#define BR_SIM_SCGC6_TPM0(x) (BME_UBFX32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_TPM0, BS_SIM_SCGC6_TPM0))

/*! @brief Format value for bitfield SIM_SCGC6_TPM0. */
#define BF_SIM_SCGC6_TPM0(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_TPM0) & BM_SIM_SCGC6_TPM0)

/*! @brief Set the TPM0 field to a new value. */
#define BW_SIM_SCGC6_TPM0(x, v) (BME_BFI32(HW_SIM_SCGC6_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC6_TPM0), BP_SIM_SCGC6_TPM0, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field TPM1[25] (RW)
 *
 * Controls the clock gate to the TPM1 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_TPM1    (25U)         /*!< Bit position for SIM_SCGC6_TPM1. */
#define BM_SIM_SCGC6_TPM1    (0x02000000U) /*!< Bit mask for SIM_SCGC6_TPM1. */
#define BS_SIM_SCGC6_TPM1    (1U)          /*!< Bit field size in bits for SIM_SCGC6_TPM1. */

/*! @brief Read current value of the SIM_SCGC6_TPM1 field. */
#define BR_SIM_SCGC6_TPM1(x) (BME_UBFX32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_TPM1, BS_SIM_SCGC6_TPM1))

/*! @brief Format value for bitfield SIM_SCGC6_TPM1. */
#define BF_SIM_SCGC6_TPM1(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_TPM1) & BM_SIM_SCGC6_TPM1)

/*! @brief Set the TPM1 field to a new value. */
#define BW_SIM_SCGC6_TPM1(x, v) (BME_BFI32(HW_SIM_SCGC6_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC6_TPM1), BP_SIM_SCGC6_TPM1, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field TPM2[26] (RW)
 *
 * Controls the clock gate to the TPM2 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_TPM2    (26U)         /*!< Bit position for SIM_SCGC6_TPM2. */
#define BM_SIM_SCGC6_TPM2    (0x04000000U) /*!< Bit mask for SIM_SCGC6_TPM2. */
#define BS_SIM_SCGC6_TPM2    (1U)          /*!< Bit field size in bits for SIM_SCGC6_TPM2. */

/*! @brief Read current value of the SIM_SCGC6_TPM2 field. */
#define BR_SIM_SCGC6_TPM2(x) (BME_UBFX32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_TPM2, BS_SIM_SCGC6_TPM2))

/*! @brief Format value for bitfield SIM_SCGC6_TPM2. */
#define BF_SIM_SCGC6_TPM2(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_TPM2) & BM_SIM_SCGC6_TPM2)

/*! @brief Set the TPM2 field to a new value. */
#define BW_SIM_SCGC6_TPM2(x, v) (BME_BFI32(HW_SIM_SCGC6_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC6_TPM2), BP_SIM_SCGC6_TPM2, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field ADC0[27] (RW)
 *
 * Controls the clock gate to the ADC0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_ADC0    (27U)         /*!< Bit position for SIM_SCGC6_ADC0. */
#define BM_SIM_SCGC6_ADC0    (0x08000000U) /*!< Bit mask for SIM_SCGC6_ADC0. */
#define BS_SIM_SCGC6_ADC0    (1U)          /*!< Bit field size in bits for SIM_SCGC6_ADC0. */

/*! @brief Read current value of the SIM_SCGC6_ADC0 field. */
#define BR_SIM_SCGC6_ADC0(x) (BME_UBFX32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_ADC0, BS_SIM_SCGC6_ADC0))

/*! @brief Format value for bitfield SIM_SCGC6_ADC0. */
#define BF_SIM_SCGC6_ADC0(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_ADC0) & BM_SIM_SCGC6_ADC0)

/*! @brief Set the ADC0 field to a new value. */
#define BW_SIM_SCGC6_ADC0(x, v) (BME_BFI32(HW_SIM_SCGC6_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC6_ADC0), BP_SIM_SCGC6_ADC0, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field RTC[29] (RW)
 *
 * Controls software access and interrupts to the RTC module.
 *
 * Values:
 * - 0 - Access and interrupts disabled
 * - 1 - Access and interrupts enabled
 */
/*@{*/
#define BP_SIM_SCGC6_RTC     (29U)         /*!< Bit position for SIM_SCGC6_RTC. */
#define BM_SIM_SCGC6_RTC     (0x20000000U) /*!< Bit mask for SIM_SCGC6_RTC. */
#define BS_SIM_SCGC6_RTC     (1U)          /*!< Bit field size in bits for SIM_SCGC6_RTC. */

/*! @brief Read current value of the SIM_SCGC6_RTC field. */
#define BR_SIM_SCGC6_RTC(x)  (BME_UBFX32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_RTC, BS_SIM_SCGC6_RTC))

/*! @brief Format value for bitfield SIM_SCGC6_RTC. */
#define BF_SIM_SCGC6_RTC(v)  ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_RTC) & BM_SIM_SCGC6_RTC)

/*! @brief Set the RTC field to a new value. */
#define BW_SIM_SCGC6_RTC(x, v) (BME_BFI32(HW_SIM_SCGC6_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC6_RTC), BP_SIM_SCGC6_RTC, 1))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field DAC0[31] (RW)
 *
 * This bit controls the clock gate to the DAC0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_DAC0    (31U)         /*!< Bit position for SIM_SCGC6_DAC0. */
#define BM_SIM_SCGC6_DAC0    (0x80000000U) /*!< Bit mask for SIM_SCGC6_DAC0. */
#define BS_SIM_SCGC6_DAC0    (1U)          /*!< Bit field size in bits for SIM_SCGC6_DAC0. */

/*! @brief Read current value of the SIM_SCGC6_DAC0 field. */
#define BR_SIM_SCGC6_DAC0(x) (BME_UBFX32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_DAC0, BS_SIM_SCGC6_DAC0))

/*! @brief Format value for bitfield SIM_SCGC6_DAC0. */
#define BF_SIM_SCGC6_DAC0(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_DAC0) & BM_SIM_SCGC6_DAC0)

/*! @brief Set the DAC0 field to a new value. */
#define BW_SIM_SCGC6_DAC0(x, v) (BME_BFI32(HW_SIM_SCGC6_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC6_DAC0), BP_SIM_SCGC6_DAC0, 1))
/*@}*/

/*******************************************************************************
 * HW_SIM_SCGC7 - System Clock Gating Control Register 7
 ******************************************************************************/

/*!
 * @brief HW_SIM_SCGC7 - System Clock Gating Control Register 7 (RW)
 *
 * Reset value: 0x00000100U
 */
typedef union _hw_sim_scgc7
{
    uint32_t U;
    struct _hw_sim_scgc7_bitfields
    {
        uint32_t RESERVED0 : 8;        /*!< [7:0]  */
        uint32_t DMA : 1;              /*!< [8] DMA Clock Gate Control */
        uint32_t RESERVED1 : 23;       /*!< [31:9]  */
    } B;
} hw_sim_scgc7_t;

/*!
 * @name Constants and macros for entire SIM_SCGC7 register
 */
/*@{*/
#define HW_SIM_SCGC7_ADDR(x)     ((uint32_t)(x) + 0x1040U)

#define HW_SIM_SCGC7(x)          (*(__IO hw_sim_scgc7_t *) HW_SIM_SCGC7_ADDR(x))
#define HW_SIM_SCGC7_RD(x)       (HW_SIM_SCGC7(x).U)
#define HW_SIM_SCGC7_WR(x, v)    (HW_SIM_SCGC7(x).U = (v))
#define HW_SIM_SCGC7_SET(x, v)   (BME_OR32(HW_SIM_SCGC7_ADDR(x), (uint32_t)(v)))
#define HW_SIM_SCGC7_CLR(x, v)   (BME_AND32(HW_SIM_SCGC7_ADDR(x), (uint32_t)(~(v))))
#define HW_SIM_SCGC7_TOG(x, v)   (BME_XOR32(HW_SIM_SCGC7_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC7 bitfields
 */

/*!
 * @name Register SIM_SCGC7, field DMA[8] (RW)
 *
 * Controls the clock gate to the DMA module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC7_DMA     (8U)          /*!< Bit position for SIM_SCGC7_DMA. */
#define BM_SIM_SCGC7_DMA     (0x00000100U) /*!< Bit mask for SIM_SCGC7_DMA. */
#define BS_SIM_SCGC7_DMA     (1U)          /*!< Bit field size in bits for SIM_SCGC7_DMA. */

/*! @brief Read current value of the SIM_SCGC7_DMA field. */
#define BR_SIM_SCGC7_DMA(x)  (BME_UBFX32(HW_SIM_SCGC7_ADDR(x), BP_SIM_SCGC7_DMA, BS_SIM_SCGC7_DMA))

/*! @brief Format value for bitfield SIM_SCGC7_DMA. */
#define BF_SIM_SCGC7_DMA(v)  ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC7_DMA) & BM_SIM_SCGC7_DMA)

/*! @brief Set the DMA field to a new value. */
#define BW_SIM_SCGC7_DMA(x, v) (BME_BFI32(HW_SIM_SCGC7_ADDR(x), ((uint32_t)(v) << BP_SIM_SCGC7_DMA), BP_SIM_SCGC7_DMA, 1))
/*@}*/

/*******************************************************************************
 * HW_SIM_CLKDIV1 - System Clock Divider Register 1
 ******************************************************************************/

/*!
 * @brief HW_SIM_CLKDIV1 - System Clock Divider Register 1 (RW)
 *
 * Reset value: 0x00010000U
 *
 * The CLKDIV1 register cannot be written to when the device is in VLPR mode.
 * Reset value loaded during System Reset from FTFA_FOPT[LPBOOT] (See ).
 */
typedef union _hw_sim_clkdiv1
{
    uint32_t U;
    struct _hw_sim_clkdiv1_bitfields
    {
        uint32_t RESERVED0 : 16;       /*!< [15:0]  */
        uint32_t OUTDIV4 : 3;          /*!< [18:16] Clock 4 Output Divider value */
        uint32_t RESERVED1 : 9;        /*!< [27:19]  */
        uint32_t OUTDIV1 : 4;          /*!< [31:28] Clock 1 Output Divider value */
    } B;
} hw_sim_clkdiv1_t;

/*!
 * @name Constants and macros for entire SIM_CLKDIV1 register
 */
/*@{*/
#define HW_SIM_CLKDIV1_ADDR(x)   ((uint32_t)(x) + 0x1044U)

#define HW_SIM_CLKDIV1(x)        (*(__IO hw_sim_clkdiv1_t *) HW_SIM_CLKDIV1_ADDR(x))
#define HW_SIM_CLKDIV1_RD(x)     (HW_SIM_CLKDIV1(x).U)
#define HW_SIM_CLKDIV1_WR(x, v)  (HW_SIM_CLKDIV1(x).U = (v))
#define HW_SIM_CLKDIV1_SET(x, v) (BME_OR32(HW_SIM_CLKDIV1_ADDR(x), (uint32_t)(v)))
#define HW_SIM_CLKDIV1_CLR(x, v) (BME_AND32(HW_SIM_CLKDIV1_ADDR(x), (uint32_t)(~(v))))
#define HW_SIM_CLKDIV1_TOG(x, v) (BME_XOR32(HW_SIM_CLKDIV1_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SIM_CLKDIV1 bitfields
 */

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV4[18:16] (RW)
 *
 * Sets the divide value for the bus and flash clock and is in addition to the
 * System clock divide ratio. At the end of reset, it is loaded with 0001 (divide
 * by 2).
 *
 * Values:
 * - 000 - Divide-by-1.
 * - 001 - Divide-by-2.
 * - 010 - Divide-by-3.
 * - 011 - Divide-by-4.
 * - 100 - Divide-by-5.
 * - 101 - Divide-by-6.
 * - 110 - Divide-by-7.
 * - 111 - Divide-by-8.
 */
/*@{*/
#define BP_SIM_CLKDIV1_OUTDIV4 (16U)       /*!< Bit position for SIM_CLKDIV1_OUTDIV4. */
#define BM_SIM_CLKDIV1_OUTDIV4 (0x00070000U) /*!< Bit mask for SIM_CLKDIV1_OUTDIV4. */
#define BS_SIM_CLKDIV1_OUTDIV4 (3U)        /*!< Bit field size in bits for SIM_CLKDIV1_OUTDIV4. */

/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV4 field. */
#define BR_SIM_CLKDIV1_OUTDIV4(x) (BME_UBFX32(HW_SIM_CLKDIV1_ADDR(x), BP_SIM_CLKDIV1_OUTDIV4, BS_SIM_CLKDIV1_OUTDIV4))

/*! @brief Format value for bitfield SIM_CLKDIV1_OUTDIV4. */
#define BF_SIM_CLKDIV1_OUTDIV4(v) ((uint32_t)((uint32_t)(v) << BP_SIM_CLKDIV1_OUTDIV4) & BM_SIM_CLKDIV1_OUTDIV4)

/*! @brief Set the OUTDIV4 field to a new value. */
#define BW_SIM_CLKDIV1_OUTDIV4(x, v) (BME_BFI32(HW_SIM_CLKDIV1_ADDR(x), ((uint32_t)(v) << BP_SIM_CLKDIV1_OUTDIV4), BP_SIM_CLKDIV1_OUTDIV4, 3))
/*@}*/

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV1[31:28] (RW)
 *
 * Sets the divide value for the core/system clock, as well as the bus/flash
 * clocks. At the end of reset, it is loaded with 0000 (divide by one), 0001 (divide
 * by two), 0011 (divide by four), or 0111 (divide by eight) depending on the
 * setting of the FTFA_FOPT[LPBOOT] (See ).
 *
 * Values:
 * - 0000 - Divide-by-1.
 * - 0001 - Divide-by-2.
 * - 0010 - Divide-by-3.
 * - 0011 - Divide-by-4.
 * - 0100 - Divide-by-5.
 * - 0101 - Divide-by-6.
 * - 0110 - Divide-by-7.
 * - 0111 - Divide-by-8.
 * - 1000 - Divide-by-9.
 * - 1001 - Divide-by-10.
 * - 1010 - Divide-by-11.
 * - 1011 - Divide-by-12.
 * - 1100 - Divide-by-13.
 * - 1101 - Divide-by-14.
 * - 1110 - Divide-by-15.
 * - 1111 - Divide-by-16.
 */
/*@{*/
#define BP_SIM_CLKDIV1_OUTDIV1 (28U)       /*!< Bit position for SIM_CLKDIV1_OUTDIV1. */
#define BM_SIM_CLKDIV1_OUTDIV1 (0xF0000000U) /*!< Bit mask for SIM_CLKDIV1_OUTDIV1. */
#define BS_SIM_CLKDIV1_OUTDIV1 (4U)        /*!< Bit field size in bits for SIM_CLKDIV1_OUTDIV1. */

/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV1 field. */
#define BR_SIM_CLKDIV1_OUTDIV1(x) (BME_UBFX32(HW_SIM_CLKDIV1_ADDR(x), BP_SIM_CLKDIV1_OUTDIV1, BS_SIM_CLKDIV1_OUTDIV1))

/*! @brief Format value for bitfield SIM_CLKDIV1_OUTDIV1. */
#define BF_SIM_CLKDIV1_OUTDIV1(v) ((uint32_t)((uint32_t)(v) << BP_SIM_CLKDIV1_OUTDIV1) & BM_SIM_CLKDIV1_OUTDIV1)

/*! @brief Set the OUTDIV1 field to a new value. */
#define BW_SIM_CLKDIV1_OUTDIV1(x, v) (BME_BFI32(HW_SIM_CLKDIV1_ADDR(x), ((uint32_t)(v) << BP_SIM_CLKDIV1_OUTDIV1), BP_SIM_CLKDIV1_OUTDIV1, 4))
/*@}*/

/*******************************************************************************
 * HW_SIM_FCFG1 - Flash Configuration Register 1
 ******************************************************************************/

/*!
 * @brief HW_SIM_FCFG1 - Flash Configuration Register 1 (RW)
 *
 * Reset value: 0x0F000000U
 */
typedef union _hw_sim_fcfg1
{
    uint32_t U;
    struct _hw_sim_fcfg1_bitfields
    {
        uint32_t FLASHDIS : 1;         /*!< [0] Flash Disable */
        uint32_t FLASHDOZE : 1;        /*!< [1] Flash Doze */
        uint32_t RESERVED0 : 22;       /*!< [23:2]  */
        uint32_t PFSIZE : 4;           /*!< [27:24] Program Flash Size */
        uint32_t RESERVED1 : 4;        /*!< [31:28]  */
    } B;
} hw_sim_fcfg1_t;

/*!
 * @name Constants and macros for entire SIM_FCFG1 register
 */
/*@{*/
#define HW_SIM_FCFG1_ADDR(x)     ((uint32_t)(x) + 0x104CU)

#define HW_SIM_FCFG1(x)          (*(__IO hw_sim_fcfg1_t *) HW_SIM_FCFG1_ADDR(x))
#define HW_SIM_FCFG1_RD(x)       (HW_SIM_FCFG1(x).U)
#define HW_SIM_FCFG1_WR(x, v)    (HW_SIM_FCFG1(x).U = (v))
#define HW_SIM_FCFG1_SET(x, v)   (BME_OR32(HW_SIM_FCFG1_ADDR(x), (uint32_t)(v)))
#define HW_SIM_FCFG1_CLR(x, v)   (BME_AND32(HW_SIM_FCFG1_ADDR(x), (uint32_t)(~(v))))
#define HW_SIM_FCFG1_TOG(x, v)   (BME_XOR32(HW_SIM_FCFG1_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SIM_FCFG1 bitfields
 */

/*!
 * @name Register SIM_FCFG1, field FLASHDIS[0] (RW)
 *
 * Flash accesses are disabled (and generate a bus error) and the flash memory
 * is placed in a low-power state. This field should not be changed during VLP
 * modes. Relocate the interrupt vectors out of Flash memory before disabling the
 * Flash.
 *
 * Values:
 * - 0 - Flash is enabled.
 * - 1 - Flash is disabled.
 */
/*@{*/
#define BP_SIM_FCFG1_FLASHDIS (0U)         /*!< Bit position for SIM_FCFG1_FLASHDIS. */
#define BM_SIM_FCFG1_FLASHDIS (0x00000001U) /*!< Bit mask for SIM_FCFG1_FLASHDIS. */
#define BS_SIM_FCFG1_FLASHDIS (1U)         /*!< Bit field size in bits for SIM_FCFG1_FLASHDIS. */

/*! @brief Read current value of the SIM_FCFG1_FLASHDIS field. */
#define BR_SIM_FCFG1_FLASHDIS(x) (BME_UBFX32(HW_SIM_FCFG1_ADDR(x), BP_SIM_FCFG1_FLASHDIS, BS_SIM_FCFG1_FLASHDIS))

/*! @brief Format value for bitfield SIM_FCFG1_FLASHDIS. */
#define BF_SIM_FCFG1_FLASHDIS(v) ((uint32_t)((uint32_t)(v) << BP_SIM_FCFG1_FLASHDIS) & BM_SIM_FCFG1_FLASHDIS)

/*! @brief Set the FLASHDIS field to a new value. */
#define BW_SIM_FCFG1_FLASHDIS(x, v) (BME_BFI32(HW_SIM_FCFG1_ADDR(x), ((uint32_t)(v) << BP_SIM_FCFG1_FLASHDIS), BP_SIM_FCFG1_FLASHDIS, 1))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field FLASHDOZE[1] (RW)
 *
 * When set, flash memory is disabled for the duration of Doze mode. This field
 * must be clear during VLP modes. The flash will be automatically enabled again
 * at the end of Doze mode so interrupt vectors do not need to be relocated out
 * of flash memory. The wake-up time from Doze mode is extended when this field is
 * set. An attempt by the DMA or other bus master to access the flash memory
 * when the flash is disabled will result in a bus error.
 *
 * Values:
 * - 0 - Flash remains enabled during Doze mode.
 * - 1 - Flash is disabled for the duration of Doze mode.
 */
/*@{*/
#define BP_SIM_FCFG1_FLASHDOZE (1U)        /*!< Bit position for SIM_FCFG1_FLASHDOZE. */
#define BM_SIM_FCFG1_FLASHDOZE (0x00000002U) /*!< Bit mask for SIM_FCFG1_FLASHDOZE. */
#define BS_SIM_FCFG1_FLASHDOZE (1U)        /*!< Bit field size in bits for SIM_FCFG1_FLASHDOZE. */

/*! @brief Read current value of the SIM_FCFG1_FLASHDOZE field. */
#define BR_SIM_FCFG1_FLASHDOZE(x) (BME_UBFX32(HW_SIM_FCFG1_ADDR(x), BP_SIM_FCFG1_FLASHDOZE, BS_SIM_FCFG1_FLASHDOZE))

/*! @brief Format value for bitfield SIM_FCFG1_FLASHDOZE. */
#define BF_SIM_FCFG1_FLASHDOZE(v) ((uint32_t)((uint32_t)(v) << BP_SIM_FCFG1_FLASHDOZE) & BM_SIM_FCFG1_FLASHDOZE)

/*! @brief Set the FLASHDOZE field to a new value. */
#define BW_SIM_FCFG1_FLASHDOZE(x, v) (BME_BFI32(HW_SIM_FCFG1_ADDR(x), ((uint32_t)(v) << BP_SIM_FCFG1_FLASHDOZE), BP_SIM_FCFG1_FLASHDOZE, 1))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field PFSIZE[27:24] (RO)
 *
 * Specifies the amount of program flash memory available on the device .
 * Undefined values are reserved.
 *
 * Values:
 * - 0000 - 8 KB of program flash memory, 1 KB protection region
 * - 0001 - 16 KB of program flash memory, 1 KB protection region
 * - 0011 - 32 KB of program flash memory, 1 KB protection region
 * - 0101 - 64 KB of program flash memory, 2 KB protection region
 * - 0111 - 128 KB of program flash memory, 4 KB protection region
 * - 1001 - 256 KB of program flash memory, 8 KB protection region
 * - 1111 - 256 KB of program flash memory, 8 KB protection region
 */
/*@{*/
#define BP_SIM_FCFG1_PFSIZE  (24U)         /*!< Bit position for SIM_FCFG1_PFSIZE. */
#define BM_SIM_FCFG1_PFSIZE  (0x0F000000U) /*!< Bit mask for SIM_FCFG1_PFSIZE. */
#define BS_SIM_FCFG1_PFSIZE  (4U)          /*!< Bit field size in bits for SIM_FCFG1_PFSIZE. */

/*! @brief Read current value of the SIM_FCFG1_PFSIZE field. */
#define BR_SIM_FCFG1_PFSIZE(x) (BME_UBFX32(HW_SIM_FCFG1_ADDR(x), BP_SIM_FCFG1_PFSIZE, BS_SIM_FCFG1_PFSIZE))
/*@}*/

/*******************************************************************************
 * HW_SIM_FCFG2 - Flash Configuration Register 2
 ******************************************************************************/

/*!
 * @brief HW_SIM_FCFG2 - Flash Configuration Register 2 (RO)
 *
 * Reset value: 0x7FFF0000U
 *
 * This is read only register, any write to this register will cause transfer
 * error.
 */
typedef union _hw_sim_fcfg2
{
    uint32_t U;
    struct _hw_sim_fcfg2_bitfields
    {
        uint32_t RESERVED0 : 16;       /*!< [15:0]  */
        uint32_t MAXADDR1 : 7;         /*!< [22:16]  */
        uint32_t RESERVED1 : 1;        /*!< [23]  */
        uint32_t MAXADDR0 : 7;         /*!< [30:24] Max Address lock */
        uint32_t RESERVED2 : 1;        /*!< [31]  */
    } B;
} hw_sim_fcfg2_t;

/*!
 * @name Constants and macros for entire SIM_FCFG2 register
 */
/*@{*/
#define HW_SIM_FCFG2_ADDR(x)     ((uint32_t)(x) + 0x1050U)

#define HW_SIM_FCFG2(x)          (*(__I hw_sim_fcfg2_t *) HW_SIM_FCFG2_ADDR(x))
#define HW_SIM_FCFG2_RD(x)       (HW_SIM_FCFG2(x).U)
/*@}*/

/*
 * Constants & macros for individual SIM_FCFG2 bitfields
 */

/*!
 * @name Register SIM_FCFG2, field MAXADDR1[22:16] (RO)
 *
 * This field concatenated with leading zeros plus the value of the MAXADDR0
 * field indicates the first invalid address of the second program flash block
 * (flash block 1). For example, if MAXADDR0 = MAXADDR1 = 0x10 the first invalid
 * address of flash block 1 is 0x2_0000 + 0x2_0000. This would be the MAXADDR1 value
 * for a device with 256 KB program flash memory across two flash blocks.
 */
/*@{*/
#define BP_SIM_FCFG2_MAXADDR1 (16U)        /*!< Bit position for SIM_FCFG2_MAXADDR1. */
#define BM_SIM_FCFG2_MAXADDR1 (0x007F0000U) /*!< Bit mask for SIM_FCFG2_MAXADDR1. */
#define BS_SIM_FCFG2_MAXADDR1 (7U)         /*!< Bit field size in bits for SIM_FCFG2_MAXADDR1. */

/*! @brief Read current value of the SIM_FCFG2_MAXADDR1 field. */
#define BR_SIM_FCFG2_MAXADDR1(x) (BME_UBFX32(HW_SIM_FCFG2_ADDR(x), BP_SIM_FCFG2_MAXADDR1, BS_SIM_FCFG2_MAXADDR1))
/*@}*/

/*!
 * @name Register SIM_FCFG2, field MAXADDR0[30:24] (RO)
 *
 * This field concatenated with 13 trailing zeros indicates the first invalid
 * address of program flash (block 0). For example, if MAXADDR0 = 0x10, the first
 * invalid address of program flash (block 0) is 0x0002_0000. This would be the
 * MAXADDR0 value for a device with 128 KB program flash in flash block 0.
 */
/*@{*/
#define BP_SIM_FCFG2_MAXADDR0 (24U)        /*!< Bit position for SIM_FCFG2_MAXADDR0. */
#define BM_SIM_FCFG2_MAXADDR0 (0x7F000000U) /*!< Bit mask for SIM_FCFG2_MAXADDR0. */
#define BS_SIM_FCFG2_MAXADDR0 (7U)         /*!< Bit field size in bits for SIM_FCFG2_MAXADDR0. */

/*! @brief Read current value of the SIM_FCFG2_MAXADDR0 field. */
#define BR_SIM_FCFG2_MAXADDR0(x) (BME_UBFX32(HW_SIM_FCFG2_ADDR(x), BP_SIM_FCFG2_MAXADDR0, BS_SIM_FCFG2_MAXADDR0))
/*@}*/

/*******************************************************************************
 * HW_SIM_UIDMH - Unique Identification Register Mid-High
 ******************************************************************************/

/*!
 * @brief HW_SIM_UIDMH - Unique Identification Register Mid-High (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_sim_uidmh
{
    uint32_t U;
    struct _hw_sim_uidmh_bitfields
    {
        uint32_t UID : 16;             /*!< [15:0] Unique Identification */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_sim_uidmh_t;

/*!
 * @name Constants and macros for entire SIM_UIDMH register
 */
/*@{*/
#define HW_SIM_UIDMH_ADDR(x)     ((uint32_t)(x) + 0x1058U)

#define HW_SIM_UIDMH(x)          (*(__I hw_sim_uidmh_t *) HW_SIM_UIDMH_ADDR(x))
#define HW_SIM_UIDMH_RD(x)       (HW_SIM_UIDMH(x).U)
/*@}*/

/*
 * Constants & macros for individual SIM_UIDMH bitfields
 */

/*!
 * @name Register SIM_UIDMH, field UID[15:0] (RO)
 *
 * Unique identification for the device.
 */
/*@{*/
#define BP_SIM_UIDMH_UID     (0U)          /*!< Bit position for SIM_UIDMH_UID. */
#define BM_SIM_UIDMH_UID     (0x0000FFFFU) /*!< Bit mask for SIM_UIDMH_UID. */
#define BS_SIM_UIDMH_UID     (16U)         /*!< Bit field size in bits for SIM_UIDMH_UID. */

/*! @brief Read current value of the SIM_UIDMH_UID field. */
#define BR_SIM_UIDMH_UID(x)  (BME_UBFX32(HW_SIM_UIDMH_ADDR(x), BP_SIM_UIDMH_UID, BS_SIM_UIDMH_UID))
/*@}*/

/*******************************************************************************
 * HW_SIM_UIDML - Unique Identification Register Mid Low
 ******************************************************************************/

/*!
 * @brief HW_SIM_UIDML - Unique Identification Register Mid Low (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_sim_uidml
{
    uint32_t U;
    struct _hw_sim_uidml_bitfields
    {
        uint32_t UID : 32;             /*!< [31:0] Unique Identification */
    } B;
} hw_sim_uidml_t;

/*!
 * @name Constants and macros for entire SIM_UIDML register
 */
/*@{*/
#define HW_SIM_UIDML_ADDR(x)     ((uint32_t)(x) + 0x105CU)

#define HW_SIM_UIDML(x)          (*(__I hw_sim_uidml_t *) HW_SIM_UIDML_ADDR(x))
#define HW_SIM_UIDML_RD(x)       (HW_SIM_UIDML(x).U)
/*@}*/

/*
 * Constants & macros for individual SIM_UIDML bitfields
 */

/*!
 * @name Register SIM_UIDML, field UID[31:0] (RO)
 *
 * Unique identification for the device.
 */
/*@{*/
#define BP_SIM_UIDML_UID     (0U)          /*!< Bit position for SIM_UIDML_UID. */
#define BM_SIM_UIDML_UID     (0xFFFFFFFFU) /*!< Bit mask for SIM_UIDML_UID. */
#define BS_SIM_UIDML_UID     (32U)         /*!< Bit field size in bits for SIM_UIDML_UID. */

/*! @brief Read current value of the SIM_UIDML_UID field. */
#define BR_SIM_UIDML_UID(x)  (HW_SIM_UIDML(x).U)
/*@}*/

/*******************************************************************************
 * HW_SIM_UIDL - Unique Identification Register Low
 ******************************************************************************/

/*!
 * @brief HW_SIM_UIDL - Unique Identification Register Low (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_sim_uidl
{
    uint32_t U;
    struct _hw_sim_uidl_bitfields
    {
        uint32_t UID : 32;             /*!< [31:0] Unique Identification */
    } B;
} hw_sim_uidl_t;

/*!
 * @name Constants and macros for entire SIM_UIDL register
 */
/*@{*/
#define HW_SIM_UIDL_ADDR(x)      ((uint32_t)(x) + 0x1060U)

#define HW_SIM_UIDL(x)           (*(__I hw_sim_uidl_t *) HW_SIM_UIDL_ADDR(x))
#define HW_SIM_UIDL_RD(x)        (HW_SIM_UIDL(x).U)
/*@}*/

/*
 * Constants & macros for individual SIM_UIDL bitfields
 */

/*!
 * @name Register SIM_UIDL, field UID[31:0] (RO)
 *
 * Unique identification for the device.
 */
/*@{*/
#define BP_SIM_UIDL_UID      (0U)          /*!< Bit position for SIM_UIDL_UID. */
#define BM_SIM_UIDL_UID      (0xFFFFFFFFU) /*!< Bit mask for SIM_UIDL_UID. */
#define BS_SIM_UIDL_UID      (32U)         /*!< Bit field size in bits for SIM_UIDL_UID. */

/*! @brief Read current value of the SIM_UIDL_UID field. */
#define BR_SIM_UIDL_UID(x)   (HW_SIM_UIDL(x).U)
/*@}*/

/*******************************************************************************
 * HW_SIM_COPC - COP Control Register
 ******************************************************************************/

/*!
 * @brief HW_SIM_COPC - COP Control Register (RW)
 *
 * Reset value: 0x0000000CU
 *
 * All of the bits in this register can be written only once after a reset,
 * writing this register will also reset the COP counter.
 */
typedef union _hw_sim_copc
{
    uint32_t U;
    struct _hw_sim_copc_bitfields
    {
        uint32_t COPW : 1;             /*!< [0] COP Windowed Mode */
        uint32_t COPCLKS : 1;          /*!< [1] COP Clock Select */
        uint32_t COPT : 2;             /*!< [3:2] COP Watchdog Timeout */
        uint32_t COPSTPEN : 1;         /*!< [4] COP Stop Enable */
        uint32_t COPDBGEN : 1;         /*!< [5] COP Debug Enable */
        uint32_t COPCLKSEL : 2;        /*!< [7:6] COP Clock Select */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_sim_copc_t;

/*!
 * @name Constants and macros for entire SIM_COPC register
 */
/*@{*/
#define HW_SIM_COPC_ADDR(x)      ((uint32_t)(x) + 0x1100U)

#define HW_SIM_COPC(x)           (*(__IO hw_sim_copc_t *) HW_SIM_COPC_ADDR(x))
#define HW_SIM_COPC_RD(x)        (HW_SIM_COPC(x).U)
#define HW_SIM_COPC_WR(x, v)     (HW_SIM_COPC(x).U = (v))
#define HW_SIM_COPC_SET(x, v)    (BME_OR32(HW_SIM_COPC_ADDR(x), (uint32_t)(v)))
#define HW_SIM_COPC_CLR(x, v)    (BME_AND32(HW_SIM_COPC_ADDR(x), (uint32_t)(~(v))))
#define HW_SIM_COPC_TOG(x, v)    (BME_XOR32(HW_SIM_COPC_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SIM_COPC bitfields
 */

/*!
 * @name Register SIM_COPC, field COPW[0] (RW)
 *
 * Windowed mode is supported for all COP clock sources, but only when the COP
 * is configured for a long timeout. The COP window is opened three quarters
 * through the timeout period and will generate a system reset if the COP is serviced
 * outside of that time.
 *
 * Values:
 * - 0 - Normal mode
 * - 1 - Windowed mode
 */
/*@{*/
#define BP_SIM_COPC_COPW     (0U)          /*!< Bit position for SIM_COPC_COPW. */
#define BM_SIM_COPC_COPW     (0x00000001U) /*!< Bit mask for SIM_COPC_COPW. */
#define BS_SIM_COPC_COPW     (1U)          /*!< Bit field size in bits for SIM_COPC_COPW. */

/*! @brief Read current value of the SIM_COPC_COPW field. */
#define BR_SIM_COPC_COPW(x)  (BME_UBFX32(HW_SIM_COPC_ADDR(x), BP_SIM_COPC_COPW, BS_SIM_COPC_COPW))

/*! @brief Format value for bitfield SIM_COPC_COPW. */
#define BF_SIM_COPC_COPW(v)  ((uint32_t)((uint32_t)(v) << BP_SIM_COPC_COPW) & BM_SIM_COPC_COPW)

/*! @brief Set the COPW field to a new value. */
#define BW_SIM_COPC_COPW(x, v) (BME_BFI32(HW_SIM_COPC_ADDR(x), ((uint32_t)(v) << BP_SIM_COPC_COPW), BP_SIM_COPC_COPW, 1))
/*@}*/

/*!
 * @name Register SIM_COPC, field COPCLKS[1] (RW)
 *
 * This write-once field selects between a short timeout or a long timeout, the
 * COP clock source is configured by COPCLKSEL.
 *
 * Values:
 * - 0 - COP configured for short timeout
 * - 1 - COP configured for long timeout
 */
/*@{*/
#define BP_SIM_COPC_COPCLKS  (1U)          /*!< Bit position for SIM_COPC_COPCLKS. */
#define BM_SIM_COPC_COPCLKS  (0x00000002U) /*!< Bit mask for SIM_COPC_COPCLKS. */
#define BS_SIM_COPC_COPCLKS  (1U)          /*!< Bit field size in bits for SIM_COPC_COPCLKS. */

/*! @brief Read current value of the SIM_COPC_COPCLKS field. */
#define BR_SIM_COPC_COPCLKS(x) (BME_UBFX32(HW_SIM_COPC_ADDR(x), BP_SIM_COPC_COPCLKS, BS_SIM_COPC_COPCLKS))

/*! @brief Format value for bitfield SIM_COPC_COPCLKS. */
#define BF_SIM_COPC_COPCLKS(v) ((uint32_t)((uint32_t)(v) << BP_SIM_COPC_COPCLKS) & BM_SIM_COPC_COPCLKS)

/*! @brief Set the COPCLKS field to a new value. */
#define BW_SIM_COPC_COPCLKS(x, v) (BME_BFI32(HW_SIM_COPC_ADDR(x), ((uint32_t)(v) << BP_SIM_COPC_COPCLKS), BP_SIM_COPC_COPCLKS, 1))
/*@}*/

/*!
 * @name Register SIM_COPC, field COPT[3:2] (RW)
 *
 * This write-once field selects the timeout period of the COP. COPT along with
 * the COPCLKS field define the COP timeout period.
 *
 * Values:
 * - 00 - COP disabled
 * - 01 - COP timeout after 25 cycles for short timeout or 213 cycles for long
 *     timeout
 * - 10 - COP timeout after 28 cycles for short timeout or 216 cycles for long
 *     timeout
 * - 11 - COP timeout after 210 cycles for short timeout or 218 cycles for long
 *     timeout
 */
/*@{*/
#define BP_SIM_COPC_COPT     (2U)          /*!< Bit position for SIM_COPC_COPT. */
#define BM_SIM_COPC_COPT     (0x0000000CU) /*!< Bit mask for SIM_COPC_COPT. */
#define BS_SIM_COPC_COPT     (2U)          /*!< Bit field size in bits for SIM_COPC_COPT. */

/*! @brief Read current value of the SIM_COPC_COPT field. */
#define BR_SIM_COPC_COPT(x)  (BME_UBFX32(HW_SIM_COPC_ADDR(x), BP_SIM_COPC_COPT, BS_SIM_COPC_COPT))

/*! @brief Format value for bitfield SIM_COPC_COPT. */
#define BF_SIM_COPC_COPT(v)  ((uint32_t)((uint32_t)(v) << BP_SIM_COPC_COPT) & BM_SIM_COPC_COPT)

/*! @brief Set the COPT field to a new value. */
#define BW_SIM_COPC_COPT(x, v) (BME_BFI32(HW_SIM_COPC_ADDR(x), ((uint32_t)(v) << BP_SIM_COPC_COPT), BP_SIM_COPC_COPT, 2))
/*@}*/

/*!
 * @name Register SIM_COPC, field COPSTPEN[4] (RW)
 *
 * Values:
 * - 0 - COP is disabled and the counter is reset in Stop modes
 * - 1 - COP is enabled in Stop modes
 */
/*@{*/
#define BP_SIM_COPC_COPSTPEN (4U)          /*!< Bit position for SIM_COPC_COPSTPEN. */
#define BM_SIM_COPC_COPSTPEN (0x00000010U) /*!< Bit mask for SIM_COPC_COPSTPEN. */
#define BS_SIM_COPC_COPSTPEN (1U)          /*!< Bit field size in bits for SIM_COPC_COPSTPEN. */

/*! @brief Read current value of the SIM_COPC_COPSTPEN field. */
#define BR_SIM_COPC_COPSTPEN(x) (BME_UBFX32(HW_SIM_COPC_ADDR(x), BP_SIM_COPC_COPSTPEN, BS_SIM_COPC_COPSTPEN))

/*! @brief Format value for bitfield SIM_COPC_COPSTPEN. */
#define BF_SIM_COPC_COPSTPEN(v) ((uint32_t)((uint32_t)(v) << BP_SIM_COPC_COPSTPEN) & BM_SIM_COPC_COPSTPEN)

/*! @brief Set the COPSTPEN field to a new value. */
#define BW_SIM_COPC_COPSTPEN(x, v) (BME_BFI32(HW_SIM_COPC_ADDR(x), ((uint32_t)(v) << BP_SIM_COPC_COPSTPEN), BP_SIM_COPC_COPSTPEN, 1))
/*@}*/

/*!
 * @name Register SIM_COPC, field COPDBGEN[5] (RW)
 *
 * Values:
 * - 0 - COP is disabled and the counter is reset in Debug mode
 * - 1 - COP is enabled in Debug mode
 */
/*@{*/
#define BP_SIM_COPC_COPDBGEN (5U)          /*!< Bit position for SIM_COPC_COPDBGEN. */
#define BM_SIM_COPC_COPDBGEN (0x00000020U) /*!< Bit mask for SIM_COPC_COPDBGEN. */
#define BS_SIM_COPC_COPDBGEN (1U)          /*!< Bit field size in bits for SIM_COPC_COPDBGEN. */

/*! @brief Read current value of the SIM_COPC_COPDBGEN field. */
#define BR_SIM_COPC_COPDBGEN(x) (BME_UBFX32(HW_SIM_COPC_ADDR(x), BP_SIM_COPC_COPDBGEN, BS_SIM_COPC_COPDBGEN))

/*! @brief Format value for bitfield SIM_COPC_COPDBGEN. */
#define BF_SIM_COPC_COPDBGEN(v) ((uint32_t)((uint32_t)(v) << BP_SIM_COPC_COPDBGEN) & BM_SIM_COPC_COPDBGEN)

/*! @brief Set the COPDBGEN field to a new value. */
#define BW_SIM_COPC_COPDBGEN(x, v) (BME_BFI32(HW_SIM_COPC_ADDR(x), ((uint32_t)(v) << BP_SIM_COPC_COPDBGEN), BP_SIM_COPC_COPDBGEN, 1))
/*@}*/

/*!
 * @name Register SIM_COPC, field COPCLKSEL[7:6] (RW)
 *
 * This write-once field selects the clock source of the COP watchdog.
 *
 * Values:
 * - 00 - LPO clock (1 kHz)
 * - 01 - MCGIRCLK
 * - 10 - OSCERCLK
 * - 11 - Bus clock
 */
/*@{*/
#define BP_SIM_COPC_COPCLKSEL (6U)         /*!< Bit position for SIM_COPC_COPCLKSEL. */
#define BM_SIM_COPC_COPCLKSEL (0x000000C0U) /*!< Bit mask for SIM_COPC_COPCLKSEL. */
#define BS_SIM_COPC_COPCLKSEL (2U)         /*!< Bit field size in bits for SIM_COPC_COPCLKSEL. */

/*! @brief Read current value of the SIM_COPC_COPCLKSEL field. */
#define BR_SIM_COPC_COPCLKSEL(x) (BME_UBFX32(HW_SIM_COPC_ADDR(x), BP_SIM_COPC_COPCLKSEL, BS_SIM_COPC_COPCLKSEL))

/*! @brief Format value for bitfield SIM_COPC_COPCLKSEL. */
#define BF_SIM_COPC_COPCLKSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_COPC_COPCLKSEL) & BM_SIM_COPC_COPCLKSEL)

/*! @brief Set the COPCLKSEL field to a new value. */
#define BW_SIM_COPC_COPCLKSEL(x, v) (BME_BFI32(HW_SIM_COPC_ADDR(x), ((uint32_t)(v) << BP_SIM_COPC_COPCLKSEL), BP_SIM_COPC_COPCLKSEL, 2))
/*@}*/

/*******************************************************************************
 * HW_SIM_SRVCOP - Service COP
 ******************************************************************************/

/*!
 * @brief HW_SIM_SRVCOP - Service COP (WO)
 *
 * Reset value: 0x00000000U
 *
 * This is write only register, any read to this register will cause transfer
 * error.
 */
typedef union _hw_sim_srvcop
{
    uint32_t U;
    struct _hw_sim_srvcop_bitfields
    {
        uint32_t SRVCOP : 8;           /*!< [7:0] Service COP Register */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_sim_srvcop_t;

/*!
 * @name Constants and macros for entire SIM_SRVCOP register
 */
/*@{*/
#define HW_SIM_SRVCOP_ADDR(x)    ((uint32_t)(x) + 0x1104U)

#define HW_SIM_SRVCOP(x)         (*(__O hw_sim_srvcop_t *) HW_SIM_SRVCOP_ADDR(x))
#define HW_SIM_SRVCOP_WR(x, v)   (HW_SIM_SRVCOP(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual SIM_SRVCOP bitfields
 */

/*!
 * @name Register SIM_SRVCOP, field SRVCOP[7:0] (WO)
 *
 * Write 0x55 and then 0xAA (in that order) to reset the COP timeout counter,
 * writing any other value will generate a system reset.
 */
/*@{*/
#define BP_SIM_SRVCOP_SRVCOP (0U)          /*!< Bit position for SIM_SRVCOP_SRVCOP. */
#define BM_SIM_SRVCOP_SRVCOP (0x000000FFU) /*!< Bit mask for SIM_SRVCOP_SRVCOP. */
#define BS_SIM_SRVCOP_SRVCOP (8U)          /*!< Bit field size in bits for SIM_SRVCOP_SRVCOP. */

/*! @brief Format value for bitfield SIM_SRVCOP_SRVCOP. */
#define BF_SIM_SRVCOP_SRVCOP(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SRVCOP_SRVCOP) & BM_SIM_SRVCOP_SRVCOP)
/*@}*/

/*******************************************************************************
 * hw_sim_t - module struct
 ******************************************************************************/
/*!
 * @brief All SIM module registers.
 */
#pragma pack(1)
typedef struct _hw_sim
{
    __IO hw_sim_sopt1_t SOPT1;             /*!< [0x0] System Options Register 1 */
    __IO hw_sim_sopt1cfg_t SOPT1CFG;       /*!< [0x4] SOPT1 Configuration Register */
    uint8_t _reserved0[4092];
    __IO hw_sim_sopt2_t SOPT2;             /*!< [0x1004] System Options Register 2 */
    uint8_t _reserved1[4];
    __IO hw_sim_sopt4_t SOPT4;             /*!< [0x100C] System Options Register 4 */
    __IO hw_sim_sopt5_t SOPT5;             /*!< [0x1010] System Options Register 5 */
    uint8_t _reserved2[4];
    __IO hw_sim_sopt7_t SOPT7;             /*!< [0x1018] System Options Register 7 */
    uint8_t _reserved3[8];
    __I hw_sim_sdid_t SDID;                /*!< [0x1024] System Device Identification Register */
    uint8_t _reserved4[12];
    __IO hw_sim_scgc4_t SCGC4;             /*!< [0x1034] System Clock Gating Control Register 4 */
    __IO hw_sim_scgc5_t SCGC5;             /*!< [0x1038] System Clock Gating Control Register 5 */
    __IO hw_sim_scgc6_t SCGC6;             /*!< [0x103C] System Clock Gating Control Register 6 */
    __IO hw_sim_scgc7_t SCGC7;             /*!< [0x1040] System Clock Gating Control Register 7 */
    __IO hw_sim_clkdiv1_t CLKDIV1;         /*!< [0x1044] System Clock Divider Register 1 */
    uint8_t _reserved5[4];
    __IO hw_sim_fcfg1_t FCFG1;             /*!< [0x104C] Flash Configuration Register 1 */
    __I hw_sim_fcfg2_t FCFG2;              /*!< [0x1050] Flash Configuration Register 2 */
    uint8_t _reserved6[4];
    __I hw_sim_uidmh_t UIDMH;              /*!< [0x1058] Unique Identification Register Mid-High */
    __I hw_sim_uidml_t UIDML;              /*!< [0x105C] Unique Identification Register Mid Low */
    __I hw_sim_uidl_t UIDL;                /*!< [0x1060] Unique Identification Register Low */
    uint8_t _reserved7[156];
    __IO hw_sim_copc_t COPC;               /*!< [0x1100] COP Control Register */
    __O hw_sim_srvcop_t SRVCOP;            /*!< [0x1104] Service COP */
} hw_sim_t;
#pragma pack()

/*! @brief Macro to access all SIM registers. */
/*! @param x SIM module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_SIM_REGS(SIM_BASE)</code>. */
#define HW_SIM_REGS(x) (*(hw_sim_t *)(x))

/*
 * MKL43Z4 SMC
 *
 * System Mode Controller
 *
 * Registers defined in this header file:
 * - HW_SMC_PMPROT - Power Mode Protection register
 * - HW_SMC_PMCTRL - Power Mode Control register
 * - HW_SMC_STOPCTRL - Stop Control Register
 * - HW_SMC_PMSTAT - Power Mode Status register
 *
 * - hw_smc_t - Struct containing all module registers.
 */

#define HW_SMC_INSTANCE_COUNT (1U) /*!< Number of instances of the SMC module. */
#define HW_SMC (0U) /*!< Instance number for SMC. */

/*******************************************************************************
 * HW_SMC_PMPROT - Power Mode Protection register
 ******************************************************************************/

/*!
 * @brief HW_SMC_PMPROT - Power Mode Protection register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides protection for entry into any low-power run or stop
 * mode. The enabling of the low-power run or stop mode occurs by configuring the
 * Power Mode Control register (PMCTRL). The PMPROT register can be written only
 * once after any system reset. If the MCU is configured for a disallowed or
 * reserved power mode, the MCU remains in its current power mode. For example, if the
 * MCU is in normal RUN mode and AVLP is 0, an attempt to enter VLPR mode using
 * PMCTRL[RUNM] is blocked and PMCTRL[RUNM] remains 00b, indicating the MCU is
 * still in Normal Run mode. This register is reset on Chip Reset not VLLS and by
 * reset types that trigger Chip Reset not VLLS. It is unaffected by reset types
 * that do not trigger Chip Reset not VLLS. See the Reset section details for more
 * information.
 */
typedef union _hw_smc_pmprot
{
    uint8_t U;
    struct _hw_smc_pmprot_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t AVLLS : 1;             /*!< [1] Allow Very-Low-Leakage Stop Mode */
        uint8_t RESERVED1 : 1;         /*!< [2]  */
        uint8_t ALLS : 1;              /*!< [3] Allow Low-Leakage Stop Mode */
        uint8_t RESERVED2 : 1;         /*!< [4]  */
        uint8_t AVLP : 1;              /*!< [5] Allow Very-Low-Power Modes */
        uint8_t RESERVED3 : 2;         /*!< [7:6]  */
    } B;
} hw_smc_pmprot_t;

/*!
 * @name Constants and macros for entire SMC_PMPROT register
 */
/*@{*/
#define HW_SMC_PMPROT_ADDR(x)    ((uint32_t)(x) + 0x0U)

#define HW_SMC_PMPROT(x)         (*(__IO hw_smc_pmprot_t *) HW_SMC_PMPROT_ADDR(x))
#define HW_SMC_PMPROT_RD(x)      (HW_SMC_PMPROT(x).U)
#define HW_SMC_PMPROT_WR(x, v)   (HW_SMC_PMPROT(x).U = (v))
#define HW_SMC_PMPROT_SET(x, v)  (BME_OR8(HW_SMC_PMPROT_ADDR(x), (uint8_t)(v)))
#define HW_SMC_PMPROT_CLR(x, v)  (BME_AND8(HW_SMC_PMPROT_ADDR(x), (uint8_t)(~(v))))
#define HW_SMC_PMPROT_TOG(x, v)  (BME_XOR8(HW_SMC_PMPROT_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SMC_PMPROT bitfields
 */

/*!
 * @name Register SMC_PMPROT, field AVLLS[1] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write once
 * bit allows the MCU to enter any very-low-leakage stop mode (VLLSx).
 *
 * Values:
 * - 0 - Any VLLSx mode is not allowed
 * - 1 - Any VLLSx mode is allowed
 */
/*@{*/
#define BP_SMC_PMPROT_AVLLS  (1U)          /*!< Bit position for SMC_PMPROT_AVLLS. */
#define BM_SMC_PMPROT_AVLLS  (0x02U)       /*!< Bit mask for SMC_PMPROT_AVLLS. */
#define BS_SMC_PMPROT_AVLLS  (1U)          /*!< Bit field size in bits for SMC_PMPROT_AVLLS. */

/*! @brief Read current value of the SMC_PMPROT_AVLLS field. */
#define BR_SMC_PMPROT_AVLLS(x) (BME_UBFX8(HW_SMC_PMPROT_ADDR(x), BP_SMC_PMPROT_AVLLS, BS_SMC_PMPROT_AVLLS))

/*! @brief Format value for bitfield SMC_PMPROT_AVLLS. */
#define BF_SMC_PMPROT_AVLLS(v) ((uint8_t)((uint8_t)(v) << BP_SMC_PMPROT_AVLLS) & BM_SMC_PMPROT_AVLLS)

/*! @brief Set the AVLLS field to a new value. */
#define BW_SMC_PMPROT_AVLLS(x, v) (BME_BFI8(HW_SMC_PMPROT_ADDR(x), ((uint8_t)(v) << BP_SMC_PMPROT_AVLLS), BP_SMC_PMPROT_AVLLS, 1))
/*@}*/

/*!
 * @name Register SMC_PMPROT, field ALLS[3] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write-once
 * field allows the MCU to enter any low-leakage stop mode (LLS).
 *
 * Values:
 * - 0 - LLS is not allowed
 * - 1 - LLS is allowed
 */
/*@{*/
#define BP_SMC_PMPROT_ALLS   (3U)          /*!< Bit position for SMC_PMPROT_ALLS. */
#define BM_SMC_PMPROT_ALLS   (0x08U)       /*!< Bit mask for SMC_PMPROT_ALLS. */
#define BS_SMC_PMPROT_ALLS   (1U)          /*!< Bit field size in bits for SMC_PMPROT_ALLS. */

/*! @brief Read current value of the SMC_PMPROT_ALLS field. */
#define BR_SMC_PMPROT_ALLS(x) (BME_UBFX8(HW_SMC_PMPROT_ADDR(x), BP_SMC_PMPROT_ALLS, BS_SMC_PMPROT_ALLS))

/*! @brief Format value for bitfield SMC_PMPROT_ALLS. */
#define BF_SMC_PMPROT_ALLS(v) ((uint8_t)((uint8_t)(v) << BP_SMC_PMPROT_ALLS) & BM_SMC_PMPROT_ALLS)

/*! @brief Set the ALLS field to a new value. */
#define BW_SMC_PMPROT_ALLS(x, v) (BME_BFI8(HW_SMC_PMPROT_ADDR(x), ((uint8_t)(v) << BP_SMC_PMPROT_ALLS), BP_SMC_PMPROT_ALLS, 1))
/*@}*/

/*!
 * @name Register SMC_PMPROT, field AVLP[5] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write-once
 * field allows the MCU to enter any very-low-power mode (VLPR, VLPW, and VLPS).
 *
 * Values:
 * - 0 - VLPR, VLPW, and VLPS are not allowed.
 * - 1 - VLPR, VLPW, and VLPS are allowed.
 */
/*@{*/
#define BP_SMC_PMPROT_AVLP   (5U)          /*!< Bit position for SMC_PMPROT_AVLP. */
#define BM_SMC_PMPROT_AVLP   (0x20U)       /*!< Bit mask for SMC_PMPROT_AVLP. */
#define BS_SMC_PMPROT_AVLP   (1U)          /*!< Bit field size in bits for SMC_PMPROT_AVLP. */

/*! @brief Read current value of the SMC_PMPROT_AVLP field. */
#define BR_SMC_PMPROT_AVLP(x) (BME_UBFX8(HW_SMC_PMPROT_ADDR(x), BP_SMC_PMPROT_AVLP, BS_SMC_PMPROT_AVLP))

/*! @brief Format value for bitfield SMC_PMPROT_AVLP. */
#define BF_SMC_PMPROT_AVLP(v) ((uint8_t)((uint8_t)(v) << BP_SMC_PMPROT_AVLP) & BM_SMC_PMPROT_AVLP)

/*! @brief Set the AVLP field to a new value. */
#define BW_SMC_PMPROT_AVLP(x, v) (BME_BFI8(HW_SMC_PMPROT_ADDR(x), ((uint8_t)(v) << BP_SMC_PMPROT_AVLP), BP_SMC_PMPROT_AVLP, 1))
/*@}*/

/*******************************************************************************
 * HW_SMC_PMCTRL - Power Mode Control register
 ******************************************************************************/

/*!
 * @brief HW_SMC_PMCTRL - Power Mode Control register (RW)
 *
 * Reset value: 0x00U
 *
 * The PMCTRL register controls entry into low-power Run and Stop modes,
 * provided that the selected power mode is allowed via an appropriate setting of the
 * protection (PMPROT) register. This register is reset on Chip POR not VLLS and by
 * reset types that trigger Chip POR not VLLS. It is unaffected by reset types
 * that do not trigger Chip POR not VLLS. See the Reset section details for more
 * information.
 */
typedef union _hw_smc_pmctrl
{
    uint8_t U;
    struct _hw_smc_pmctrl_bitfields
    {
        uint8_t STOPM : 3;             /*!< [2:0] Stop Mode Control */
        uint8_t STOPA : 1;             /*!< [3] Stop Aborted */
        uint8_t RESERVED0 : 1;         /*!< [4]  */
        uint8_t RUNM : 2;              /*!< [6:5] Run Mode Control */
        uint8_t RESERVED1 : 1;         /*!< [7]  */
    } B;
} hw_smc_pmctrl_t;

/*!
 * @name Constants and macros for entire SMC_PMCTRL register
 */
/*@{*/
#define HW_SMC_PMCTRL_ADDR(x)    ((uint32_t)(x) + 0x1U)

#define HW_SMC_PMCTRL(x)         (*(__IO hw_smc_pmctrl_t *) HW_SMC_PMCTRL_ADDR(x))
#define HW_SMC_PMCTRL_RD(x)      (HW_SMC_PMCTRL(x).U)
#define HW_SMC_PMCTRL_WR(x, v)   (HW_SMC_PMCTRL(x).U = (v))
#define HW_SMC_PMCTRL_SET(x, v)  (BME_OR8(HW_SMC_PMCTRL_ADDR(x), (uint8_t)(v)))
#define HW_SMC_PMCTRL_CLR(x, v)  (BME_AND8(HW_SMC_PMCTRL_ADDR(x), (uint8_t)(~(v))))
#define HW_SMC_PMCTRL_TOG(x, v)  (BME_XOR8(HW_SMC_PMCTRL_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SMC_PMCTRL bitfields
 */

/*!
 * @name Register SMC_PMCTRL, field STOPM[2:0] (RW)
 *
 * When written, controls entry into the selected stop mode when Sleep-Now or
 * Sleep-On-Exit mode is entered with SLEEPDEEP=1 . Writes to this field are
 * blocked if the protection level has not been enabled using the PMPROT register.
 * After any system reset, this field is cleared by hardware on any successful write
 * to the PMPROT register. When set to VLLSx, the VLLSM field in the STOPCTRL
 * register is used to further select the particular VLLS submode which will be
 * entered. When set to STOP, the PSTOPO bits in the STOPCTRL register can be used to
 * select a Partial Stop mode if desired.
 *
 * Values:
 * - 000 - Normal Stop (STOP)
 * - 001 - Reserved
 * - 010 - Very-Low-Power Stop (VLPS)
 * - 011 - Low-Leakage Stop (LLS)
 * - 100 - Very-Low-Leakage Stop (VLLSx)
 * - 101 - Reserved
 * - 110 - Reseved
 * - 111 - Reserved
 */
/*@{*/
#define BP_SMC_PMCTRL_STOPM  (0U)          /*!< Bit position for SMC_PMCTRL_STOPM. */
#define BM_SMC_PMCTRL_STOPM  (0x07U)       /*!< Bit mask for SMC_PMCTRL_STOPM. */
#define BS_SMC_PMCTRL_STOPM  (3U)          /*!< Bit field size in bits for SMC_PMCTRL_STOPM. */

/*! @brief Read current value of the SMC_PMCTRL_STOPM field. */
#define BR_SMC_PMCTRL_STOPM(x) (BME_UBFX8(HW_SMC_PMCTRL_ADDR(x), BP_SMC_PMCTRL_STOPM, BS_SMC_PMCTRL_STOPM))

/*! @brief Format value for bitfield SMC_PMCTRL_STOPM. */
#define BF_SMC_PMCTRL_STOPM(v) ((uint8_t)((uint8_t)(v) << BP_SMC_PMCTRL_STOPM) & BM_SMC_PMCTRL_STOPM)

/*! @brief Set the STOPM field to a new value. */
#define BW_SMC_PMCTRL_STOPM(x, v) (BME_BFI8(HW_SMC_PMCTRL_ADDR(x), ((uint8_t)(v) << BP_SMC_PMCTRL_STOPM), BP_SMC_PMCTRL_STOPM, 3))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field STOPA[3] (RO)
 *
 * When set, this read-only status bit indicates an interrupt occured during the
 * previous stop mode entry sequence, preventing the system from entering that
 * mode. This field is cleared by reset or by hardware at the beginning of any
 * stop mode entry sequence and is set if the sequence was aborted.
 *
 * Values:
 * - 0 - The previous stop mode entry was successsful.
 * - 1 - The previous stop mode entry was aborted.
 */
/*@{*/
#define BP_SMC_PMCTRL_STOPA  (3U)          /*!< Bit position for SMC_PMCTRL_STOPA. */
#define BM_SMC_PMCTRL_STOPA  (0x08U)       /*!< Bit mask for SMC_PMCTRL_STOPA. */
#define BS_SMC_PMCTRL_STOPA  (1U)          /*!< Bit field size in bits for SMC_PMCTRL_STOPA. */

/*! @brief Read current value of the SMC_PMCTRL_STOPA field. */
#define BR_SMC_PMCTRL_STOPA(x) (BME_UBFX8(HW_SMC_PMCTRL_ADDR(x), BP_SMC_PMCTRL_STOPA, BS_SMC_PMCTRL_STOPA))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field RUNM[6:5] (RW)
 *
 * When written, causes entry into the selected run mode. Writes to this field
 * are blocked if the protection level has not been enabled using the PMPROT
 * register. RUNM may be set to VLPR only when PMSTAT=RUN. After being written to
 * VLPR, RUNM should not be written back to RUN until PMSTAT=VLPR.
 *
 * Values:
 * - 00 - Normal Run mode (RUN)
 * - 01 - Reserved
 * - 10 - Very-Low-Power Run mode (VLPR)
 * - 11 - Reserved
 */
/*@{*/
#define BP_SMC_PMCTRL_RUNM   (5U)          /*!< Bit position for SMC_PMCTRL_RUNM. */
#define BM_SMC_PMCTRL_RUNM   (0x60U)       /*!< Bit mask for SMC_PMCTRL_RUNM. */
#define BS_SMC_PMCTRL_RUNM   (2U)          /*!< Bit field size in bits for SMC_PMCTRL_RUNM. */

/*! @brief Read current value of the SMC_PMCTRL_RUNM field. */
#define BR_SMC_PMCTRL_RUNM(x) (BME_UBFX8(HW_SMC_PMCTRL_ADDR(x), BP_SMC_PMCTRL_RUNM, BS_SMC_PMCTRL_RUNM))

/*! @brief Format value for bitfield SMC_PMCTRL_RUNM. */
#define BF_SMC_PMCTRL_RUNM(v) ((uint8_t)((uint8_t)(v) << BP_SMC_PMCTRL_RUNM) & BM_SMC_PMCTRL_RUNM)

/*! @brief Set the RUNM field to a new value. */
#define BW_SMC_PMCTRL_RUNM(x, v) (BME_BFI8(HW_SMC_PMCTRL_ADDR(x), ((uint8_t)(v) << BP_SMC_PMCTRL_RUNM), BP_SMC_PMCTRL_RUNM, 2))
/*@}*/

/*******************************************************************************
 * HW_SMC_STOPCTRL - Stop Control Register
 ******************************************************************************/

/*!
 * @brief HW_SMC_STOPCTRL - Stop Control Register (RW)
 *
 * Reset value: 0x03U
 *
 * The STOPCTRL register provides various control bits allowing the user to fine
 * tune power consumption during the stop mode selected by the STOPM field. This
 * register is reset on Chip POR not VLLS and by reset types that trigger Chip
 * POR not VLLS. It is unaffected by reset types that do not trigger Chip POR not
 * VLLS. See the Reset section details for more information.
 */
typedef union _hw_smc_stopctrl
{
    uint8_t U;
    struct _hw_smc_stopctrl_bitfields
    {
        uint8_t VLLSM : 3;             /*!< [2:0] VLLS Mode Control */
        uint8_t RESERVED0 : 2;         /*!< [4:3]  */
        uint8_t PORPO : 1;             /*!< [5] POR Power Option */
        uint8_t PSTOPO : 2;            /*!< [7:6] Partial Stop Option */
    } B;
} hw_smc_stopctrl_t;

/*!
 * @name Constants and macros for entire SMC_STOPCTRL register
 */
/*@{*/
#define HW_SMC_STOPCTRL_ADDR(x)  ((uint32_t)(x) + 0x2U)

#define HW_SMC_STOPCTRL(x)       (*(__IO hw_smc_stopctrl_t *) HW_SMC_STOPCTRL_ADDR(x))
#define HW_SMC_STOPCTRL_RD(x)    (HW_SMC_STOPCTRL(x).U)
#define HW_SMC_STOPCTRL_WR(x, v) (HW_SMC_STOPCTRL(x).U = (v))
#define HW_SMC_STOPCTRL_SET(x, v) (BME_OR8(HW_SMC_STOPCTRL_ADDR(x), (uint8_t)(v)))
#define HW_SMC_STOPCTRL_CLR(x, v) (BME_AND8(HW_SMC_STOPCTRL_ADDR(x), (uint8_t)(~(v))))
#define HW_SMC_STOPCTRL_TOG(x, v) (BME_XOR8(HW_SMC_STOPCTRL_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SMC_STOPCTRL bitfields
 */

/*!
 * @name Register SMC_STOPCTRL, field VLLSM[2:0] (RW)
 *
 * This field controls which VLLS sub-mode to enter if STOPM = VLLSx.
 *
 * Values:
 * - 000 - VLLS0
 * - 001 - VLLS1
 * - 010 - Reserved
 * - 011 - VLLS3
 * - 100 - Reserved
 * - 101 - Reserved
 * - 110 - Reserved
 * - 111 - Reserved
 */
/*@{*/
#define BP_SMC_STOPCTRL_VLLSM (0U)         /*!< Bit position for SMC_STOPCTRL_VLLSM. */
#define BM_SMC_STOPCTRL_VLLSM (0x07U)      /*!< Bit mask for SMC_STOPCTRL_VLLSM. */
#define BS_SMC_STOPCTRL_VLLSM (3U)         /*!< Bit field size in bits for SMC_STOPCTRL_VLLSM. */

/*! @brief Read current value of the SMC_STOPCTRL_VLLSM field. */
#define BR_SMC_STOPCTRL_VLLSM(x) (BME_UBFX8(HW_SMC_STOPCTRL_ADDR(x), BP_SMC_STOPCTRL_VLLSM, BS_SMC_STOPCTRL_VLLSM))

/*! @brief Format value for bitfield SMC_STOPCTRL_VLLSM. */
#define BF_SMC_STOPCTRL_VLLSM(v) ((uint8_t)((uint8_t)(v) << BP_SMC_STOPCTRL_VLLSM) & BM_SMC_STOPCTRL_VLLSM)

/*! @brief Set the VLLSM field to a new value. */
#define BW_SMC_STOPCTRL_VLLSM(x, v) (BME_BFI8(HW_SMC_STOPCTRL_ADDR(x), ((uint8_t)(v) << BP_SMC_STOPCTRL_VLLSM), BP_SMC_STOPCTRL_VLLSM, 3))
/*@}*/

/*!
 * @name Register SMC_STOPCTRL, field PORPO[5] (RW)
 *
 * This bit controls whether the POR detect circuit is enabled in VLLS0 mode.
 *
 * Values:
 * - 0 - POR detect circuit is enabled in VLLS0
 * - 1 - POR detect circuit is disabled in VLLS0
 */
/*@{*/
#define BP_SMC_STOPCTRL_PORPO (5U)         /*!< Bit position for SMC_STOPCTRL_PORPO. */
#define BM_SMC_STOPCTRL_PORPO (0x20U)      /*!< Bit mask for SMC_STOPCTRL_PORPO. */
#define BS_SMC_STOPCTRL_PORPO (1U)         /*!< Bit field size in bits for SMC_STOPCTRL_PORPO. */

/*! @brief Read current value of the SMC_STOPCTRL_PORPO field. */
#define BR_SMC_STOPCTRL_PORPO(x) (BME_UBFX8(HW_SMC_STOPCTRL_ADDR(x), BP_SMC_STOPCTRL_PORPO, BS_SMC_STOPCTRL_PORPO))

/*! @brief Format value for bitfield SMC_STOPCTRL_PORPO. */
#define BF_SMC_STOPCTRL_PORPO(v) ((uint8_t)((uint8_t)(v) << BP_SMC_STOPCTRL_PORPO) & BM_SMC_STOPCTRL_PORPO)

/*! @brief Set the PORPO field to a new value. */
#define BW_SMC_STOPCTRL_PORPO(x, v) (BME_BFI8(HW_SMC_STOPCTRL_ADDR(x), ((uint8_t)(v) << BP_SMC_STOPCTRL_PORPO), BP_SMC_STOPCTRL_PORPO, 1))
/*@}*/

/*!
 * @name Register SMC_STOPCTRL, field PSTOPO[7:6] (RW)
 *
 * These bits control whether a Partial Stop mode is entered when STOPM=STOP.
 * When entering a Partial Stop mode from RUN mode, the PMC, MCG and flash remain
 * fully powered, allowing the device to wakeup almost instantaneously at the
 * expense of higher power consumption. In PSTOP2, only system clocks are gated
 * allowing peripherals running on bus clock to remain fully functional. In PSTOP1,
 * both system and bus clocks are gated.
 *
 * Values:
 * - 00 - STOP - Normal Stop mode
 * - 01 - PSTOP1 - Partial Stop with both system and bus clocks disabled
 * - 10 - PSTOP2 - Partial Stop with system clock disabled and bus clock enabled
 * - 11 - Reserved
 */
/*@{*/
#define BP_SMC_STOPCTRL_PSTOPO (6U)        /*!< Bit position for SMC_STOPCTRL_PSTOPO. */
#define BM_SMC_STOPCTRL_PSTOPO (0xC0U)     /*!< Bit mask for SMC_STOPCTRL_PSTOPO. */
#define BS_SMC_STOPCTRL_PSTOPO (2U)        /*!< Bit field size in bits for SMC_STOPCTRL_PSTOPO. */

/*! @brief Read current value of the SMC_STOPCTRL_PSTOPO field. */
#define BR_SMC_STOPCTRL_PSTOPO(x) (BME_UBFX8(HW_SMC_STOPCTRL_ADDR(x), BP_SMC_STOPCTRL_PSTOPO, BS_SMC_STOPCTRL_PSTOPO))

/*! @brief Format value for bitfield SMC_STOPCTRL_PSTOPO. */
#define BF_SMC_STOPCTRL_PSTOPO(v) ((uint8_t)((uint8_t)(v) << BP_SMC_STOPCTRL_PSTOPO) & BM_SMC_STOPCTRL_PSTOPO)

/*! @brief Set the PSTOPO field to a new value. */
#define BW_SMC_STOPCTRL_PSTOPO(x, v) (BME_BFI8(HW_SMC_STOPCTRL_ADDR(x), ((uint8_t)(v) << BP_SMC_STOPCTRL_PSTOPO), BP_SMC_STOPCTRL_PSTOPO, 2))
/*@}*/

/*******************************************************************************
 * HW_SMC_PMSTAT - Power Mode Status register
 ******************************************************************************/

/*!
 * @brief HW_SMC_PMSTAT - Power Mode Status register (RO)
 *
 * Reset value: 0x01U
 *
 * PMSTAT is a read-only, one-hot register which indicates the current power
 * mode of the system. This register is reset on Chip POR not VLLS and by reset
 * types that trigger Chip POR not VLLS. It is unaffected by reset types that do not
 * trigger Chip POR not VLLS. See the Reset section details for more information.
 */
typedef union _hw_smc_pmstat
{
    uint8_t U;
    struct _hw_smc_pmstat_bitfields
    {
        uint8_t PMSTAT : 8;            /*!< [7:0] Power Mode Status */
    } B;
} hw_smc_pmstat_t;

/*!
 * @name Constants and macros for entire SMC_PMSTAT register
 */
/*@{*/
#define HW_SMC_PMSTAT_ADDR(x)    ((uint32_t)(x) + 0x3U)

#define HW_SMC_PMSTAT(x)         (*(__I hw_smc_pmstat_t *) HW_SMC_PMSTAT_ADDR(x))
#define HW_SMC_PMSTAT_RD(x)      (HW_SMC_PMSTAT(x).U)
/*@}*/

/*
 * Constants & macros for individual SMC_PMSTAT bitfields
 */

/*!
 * @name Register SMC_PMSTAT, field PMSTAT[7:0] (RO)
 *
 * When debug is enabled, the PMSTAT will not update to STOP or VLPS When a
 * PSTOP mode is enabled, the PMSTAT will not update to STOP or VLPS
 */
/*@{*/
#define BP_SMC_PMSTAT_PMSTAT (0U)          /*!< Bit position for SMC_PMSTAT_PMSTAT. */
#define BM_SMC_PMSTAT_PMSTAT (0xFFU)       /*!< Bit mask for SMC_PMSTAT_PMSTAT. */
#define BS_SMC_PMSTAT_PMSTAT (8U)          /*!< Bit field size in bits for SMC_PMSTAT_PMSTAT. */

/*! @brief Read current value of the SMC_PMSTAT_PMSTAT field. */
#define BR_SMC_PMSTAT_PMSTAT(x) (HW_SMC_PMSTAT(x).U)
/*@}*/

/*******************************************************************************
 * hw_smc_t - module struct
 ******************************************************************************/
/*!
 * @brief All SMC module registers.
 */
#pragma pack(1)
typedef struct _hw_smc
{
    __IO hw_smc_pmprot_t PMPROT;           /*!< [0x0] Power Mode Protection register */
    __IO hw_smc_pmctrl_t PMCTRL;           /*!< [0x1] Power Mode Control register */
    __IO hw_smc_stopctrl_t STOPCTRL;       /*!< [0x2] Stop Control Register */
    __I hw_smc_pmstat_t PMSTAT;            /*!< [0x3] Power Mode Status register */
} hw_smc_t;
#pragma pack()

/*! @brief Macro to access all SMC registers. */
/*! @param x SMC module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_SMC_REGS(SMC_BASE)</code>. */
#define HW_SMC_REGS(x) (*(hw_smc_t *)(x))

/*
 * MKL43Z4 SPI
 *
 * Serial Peripheral Interface
 *
 * Registers defined in this header file:
 * - HW_SPI_S - SPI Status Register
 * - HW_SPI_BR - SPI Baud Rate Register
 * - HW_SPI_C2 - SPI Control Register 2
 * - HW_SPI_C1 - SPI Control Register 1
 * - HW_SPI_ML - SPI Match Register low
 * - HW_SPI_MH - SPI match register high
 * - HW_SPI_DL - SPI Data Register low
 * - HW_SPI_DH - SPI data register high
 * - HW_SPI_CI - SPI clear interrupt register
 * - HW_SPI_C3 - SPI control register 3
 *
 * - hw_spi_t - Struct containing all module registers.
 */

#define HW_SPI_INSTANCE_COUNT (2U) /*!< Number of instances of the SPI module. */
#define HW_SPI0 (0U) /*!< Instance number for SPI0. */
#define HW_SPI1 (1U) /*!< Instance number for SPI1. */

/*******************************************************************************
 * HW_SPI_S - SPI Status Register
 ******************************************************************************/

/*!
 * @brief HW_SPI_S - SPI Status Register (RO)
 *
 * Reset value: 0x20U
 *
 * This register contains read-only status bits. Writes have no meaning or
 * effect. When the FIFO is not supported or not enabled (FIFOMODE is not present or
 * is 0): Bits 3 through 0 are not implemented and always read 0. When the FIFO is
 * supported and enabled (FIFOMODE is 1): This register has four flags that
 * provide mechanisms to support an 8-byte FIFO mode: RNFULLF, TNEARF, TXFULLF, and
 * RFIFOEF. When the SPI is in 8-byte FIFO mode, the function of SPRF and SPTEF
 * differs slightly from their function in the normal buffered modes, mainly
 * regarding how these flags are cleared by the amount available in the transmit and
 * receive FIFOs. The RNFULLF and TNEAREF help improve the efficiency of FIFO
 * operation when transfering large amounts of data. These flags provide a "watermark"
 * feature of the FIFOs to allow continuous transmissions of data when running
 * at high speed. The RNFULLF can generate an interrupt if the RNFULLIEN bit in
 * the C3 register is set, which allows the CPU to start emptying the receive FIFO
 * without delaying the reception of subsequent bytes. The user can also
 * determine if all data in the receive FIFO has been read by monitoring the RFIFOEF. The
 * TNEAREF can generate an interrupt if the TNEARIEN bit in the C3 register is
 * set, which allows the CPU to start filling the transmit FIFO before it is empty
 * and thus to prevent breaks in SPI transmission. At an initial POR, the values
 * of TNEAREF and RFIFOEF are 0. However, the status (S) register and both TX
 * and RX FIFOs are reset due to a change of SPIMODE, FIFOMODE or SPE. If this type
 * of reset occurs and FIFOMODE is 0, TNEAREF and RFIFOEF continue to reset to
 * 0. If this type of reset occurs and FIFOMODE is 1, TNEAREF and RFIFOEF reset to
 * 1.
 */
typedef union _hw_spi_s
{
    uint8_t U;
    struct _hw_spi_s_bitfields
    {
        uint8_t RFIFOEF : 1;           /*!< [0] SPI read FIFO empty flag */
        uint8_t TXFULLF : 1;           /*!< [1] Transmit FIFO full flag */
        uint8_t TNEAREF : 1;           /*!< [2] Transmit FIFO nearly empty flag */
        uint8_t RNFULLF : 1;           /*!< [3] Receive FIFO nearly full flag */
        uint8_t MODF : 1;              /*!< [4] Master Mode Fault Flag */
        uint8_t SPTEF : 1;             /*!< [5] SPI Transmit Buffer Empty Flag (when FIFO
                                        * is not supported or not enabled) or SPI transmit FIFO empty flag (when
                                        * FIFO is supported and enabled) */
        uint8_t SPMF : 1;              /*!< [6] SPI Match Flag */
        uint8_t SPRF : 1;              /*!< [7] SPI Read Buffer Full Flag (when FIFO is
                                        * not supported or not enabled) or SPI read FIFO FULL flag (when FIFO is
                                        * supported and enabled) */
    } B;
} hw_spi_s_t;

/*!
 * @name Constants and macros for entire SPI_S register
 */
/*@{*/
#define HW_SPI_S_ADDR(x)         ((uint32_t)(x) + 0x0U)

#define HW_SPI_S(x)              (*(__I hw_spi_s_t *) HW_SPI_S_ADDR(x))
#define HW_SPI_S_RD(x)           (HW_SPI_S(x).U)
/*@}*/

/*
 * Constants & macros for individual SPI_S bitfields
 */

/*!
 * @name Register SPI_S, field RFIFOEF[0] (RO)
 *
 * This bit indicates the status of the read FIFO when FIFOMODE is enabled. If
 * FIFOMODE is not enabled, ignore this bit. When FIFOMODE and DMA are both
 * enabled, the inverted RXIFOEF is used to trigger a DMA transfer. So when the receive
 * FIFO is not empty, the DMA request is active, and remains active until the
 * FIFO is empty. At an initial POR, the values of TNEAREF and RFIFOEF are 0.
 * However, the status (S) register and both TX and RX FIFOs are reset due to a change
 * of SPIMODE, FIFOMODE or SPE. If this type of reset occurs and FIFOMODE is 0,
 * TNEAREF and RFIFOEF continue to reset to 0. If this type of reset occurs and
 * FIFOMODE is 1, TNEAREF and RFIFOEF reset to 1.
 *
 * Values:
 * - 0 - Read FIFO has data. Reads of the DH:DL registers in 16-bit mode or the
 *     DL register in 8-bit mode will empty the read FIFO.
 * - 1 - Read FIFO is empty.
 */
/*@{*/
#define BP_SPI_S_RFIFOEF     (0U)          /*!< Bit position for SPI_S_RFIFOEF. */
#define BM_SPI_S_RFIFOEF     (0x01U)       /*!< Bit mask for SPI_S_RFIFOEF. */
#define BS_SPI_S_RFIFOEF     (1U)          /*!< Bit field size in bits for SPI_S_RFIFOEF. */

/*! @brief Read current value of the SPI_S_RFIFOEF field. */
#define BR_SPI_S_RFIFOEF(x)  (BME_UBFX8(HW_SPI_S_ADDR(x), BP_SPI_S_RFIFOEF, BS_SPI_S_RFIFOEF))
/*@}*/

/*!
 * @name Register SPI_S, field TXFULLF[1] (RO)
 *
 * This bit indicates the status of the transmit FIFO when FIFOMODE is enabled.
 * This flag is set when there are 8 bytes in the transmit FIFO. If FIFOMODE is
 * not enabled, ignore this bit. When FIFOMODE and DMA are both enabled, the
 * inverted TXFULLF is used to trigger a DMA transfer. So when the transmit FIFO is
 * not full, the DMA request is active, and remains active until the FIFO is full.
 *
 * Values:
 * - 0 - Transmit FIFO has less than 8 bytes
 * - 1 - Transmit FIFO has 8 bytes of data
 */
/*@{*/
#define BP_SPI_S_TXFULLF     (1U)          /*!< Bit position for SPI_S_TXFULLF. */
#define BM_SPI_S_TXFULLF     (0x02U)       /*!< Bit mask for SPI_S_TXFULLF. */
#define BS_SPI_S_TXFULLF     (1U)          /*!< Bit field size in bits for SPI_S_TXFULLF. */

/*! @brief Read current value of the SPI_S_TXFULLF field. */
#define BR_SPI_S_TXFULLF(x)  (BME_UBFX8(HW_SPI_S_ADDR(x), BP_SPI_S_TXFULLF, BS_SPI_S_TXFULLF))
/*@}*/

/*!
 * @name Register SPI_S, field TNEAREF[2] (RO)
 *
 * This flag is set when only one 16-bit word or two 8-bit bytes of data remain
 * in the transmit FIFO, provided C3[TNEAREF_MARK] is 0, or when only two 16-bit
 * words or four 8-bit bytes of data remain in the transmit FIFO, provided
 * C3[TNEAREF_MARK] is 1. If FIFOMODE is not enabled, ignore this bit. At an initial
 * POR, the values of TNEAREF and RFIFOEF are 0. However, the status (S) register
 * and both TX and RX FIFOs are reset due to a change of SPIMODE, FIFOMODE or SPE.
 * If this type of reset occurs and FIFOMODE is 0, TNEAREF and RFIFOEF continue
 * to reset to 0. If this type of reset occurs and FIFOMODE is 1, TNEAREF and
 * RFIFOEF reset to 1.
 *
 * Values:
 * - 0 - Transmit FIFO has more than 16 bits (when C3[TNEAREF_MARK] is 0) or
 *     more than 32 bits (when C3[TNEAREF_MARK] is 1) remaining to transmit
 * - 1 - Transmit FIFO has an amount of data equal to or less than 16 bits (when
 *     C3[TNEAREF_MARK] is 0) or 32 bits (when C3[TNEAREF_MARK] is 1) remaining
 *     to transmit
 */
/*@{*/
#define BP_SPI_S_TNEAREF     (2U)          /*!< Bit position for SPI_S_TNEAREF. */
#define BM_SPI_S_TNEAREF     (0x04U)       /*!< Bit mask for SPI_S_TNEAREF. */
#define BS_SPI_S_TNEAREF     (1U)          /*!< Bit field size in bits for SPI_S_TNEAREF. */

/*! @brief Read current value of the SPI_S_TNEAREF field. */
#define BR_SPI_S_TNEAREF(x)  (BME_UBFX8(HW_SPI_S_ADDR(x), BP_SPI_S_TNEAREF, BS_SPI_S_TNEAREF))
/*@}*/

/*!
 * @name Register SPI_S, field RNFULLF[3] (RO)
 *
 * This flag is set when more than three 16-bit words or six 8-bit bytes of data
 * remain in the receive FIFO, provided C3[RNFULLF_MARK] is 0, or when more than
 * two 16-bit words or four 8-bit bytes of data remain in the receive FIFO,
 * provided C3[RNFULLF_MARK] is 1. It has no function if FIFOMODE is not present or
 * is 0.
 *
 * Values:
 * - 0 - Receive FIFO has received less than 48 bits (when C3[RNFULLF_MARK] is
 *     0) or less than 32 bits (when C3[RNFULLF_MARK] is 1)
 * - 1 - Receive FIFO has received data of an amount equal to or greater than 48
 *     bits (when C3[RNFULLF_MARK] is 0) or 32 bits (when C3[RNFULLF_MARK] is 1)
 */
/*@{*/
#define BP_SPI_S_RNFULLF     (3U)          /*!< Bit position for SPI_S_RNFULLF. */
#define BM_SPI_S_RNFULLF     (0x08U)       /*!< Bit mask for SPI_S_RNFULLF. */
#define BS_SPI_S_RNFULLF     (1U)          /*!< Bit field size in bits for SPI_S_RNFULLF. */

/*! @brief Read current value of the SPI_S_RNFULLF field. */
#define BR_SPI_S_RNFULLF(x)  (BME_UBFX8(HW_SPI_S_ADDR(x), BP_SPI_S_RNFULLF, BS_SPI_S_RNFULLF))
/*@}*/

/*!
 * @name Register SPI_S, field MODF[4] (RO)
 *
 * MODF is set if the SPI is configured as a master and the slave select input
 * goes low, indicating some other SPI device is also configured as a master. The
 * SS pin acts as a mode fault error input only when C1[MSTR] is 1, C2[MODFEN] is
 * 1, and C1[SSOE] is 0; otherwise, MODF will never be set. MODF is cleared by
 * reading MODF while it is 1 and then writing to the SPI Control Register 1 (C1).
 *
 * Values:
 * - 0 - No mode fault error
 * - 1 - Mode fault error detected
 */
/*@{*/
#define BP_SPI_S_MODF        (4U)          /*!< Bit position for SPI_S_MODF. */
#define BM_SPI_S_MODF        (0x10U)       /*!< Bit mask for SPI_S_MODF. */
#define BS_SPI_S_MODF        (1U)          /*!< Bit field size in bits for SPI_S_MODF. */

/*! @brief Read current value of the SPI_S_MODF field. */
#define BR_SPI_S_MODF(x)     (BME_UBFX8(HW_SPI_S_ADDR(x), BP_SPI_S_MODF, BS_SPI_S_MODF))
/*@}*/

/*!
 * @name Register SPI_S, field SPTEF[5] (RO)
 *
 * When the FIFO is not supported or not enabled (FIFOMODE is not present or is
 * 0): This bit is set when the transmit data buffer is empty. When the transmit
 * DMA request is disabled (TXDMAE is 0), SPTEF is cleared by reading the S
 * register with SPTEF set and then writing a data value to the transmit buffer at
 * DH:DL. The S register must be read with SPTEF set to 1 before writing data to the
 * DH:DL register; otherwise, the DH:DL write is ignored. When the transmit DMA
 * request is enabled (TXDMAE is 1), SPTEF is automatically cleared when the DMA
 * transfer for the transmit DMA request is completed (TX DMA Done is asserted).
 * SPTEF is automatically set when all data from the transmit buffer transfers
 * into the transmit shift register. For an idle SPI, data written to DH:DL is
 * transferred to the shifter almost immediately so that SPTEF is set within two bus
 * cycles, allowing a second set of data to be queued into the transmit buffer.
 * After completion of the transfer of the data in the shift register, the queued
 * data from the transmit buffer automatically moves to the shifter, and SPTEF is
 * set to indicate that room exists for new data in the transmit buffer. If no
 * new data is waiting in the transmit buffer, SPTEF simply remains set and no
 * data moves from the buffer to the shifter. When the FIFO is not supported or not
 * enabled (FIFOMODE is not present or is 0): If a transfer does not stop, the
 * last data that was transmitted is sent out again. When the FIFO is supported and
 * enabled (FIFOMODE is 1): This bit provides the status of the FIFO rather than
 * an 8-bit or a 16-bit buffer. This bit is set when the transmit FIFO is empty.
 * When the transmit DMA request is disabled (TXDMAE is 0), SPTEF is cleared by
 * writing a data value to the transmit FIFO at DH:DL. When the transmit DMA
 * request is enabled (TXDMAE is 1), SPTEF is automatically cleared when the DMA
 * transfer for the transmit DMA request is completed (TX DMA Done is asserted).
 * SPTEF is automatically set when all data from the transmit FIFO transfers into the
 * transmit shift register. For an idle SPI, data written to the DH:DL register
 * is transferred to the shifter almost immediately, so that SPTEF is set within
 * two bus cycles. A second write of data to the DH:DL register clears this SPTEF
 * flag. After completion of the transfer of the data in the shift register, the
 * queued data from the transmit FIFO automatically moves to the shifter, and
 * SPTEF will be set only when all data written to the transmit FIFO has been
 * transfered to the shifter. If no new data is waiting in the transmit FIFO, SPTEF
 * simply remains set and no data moves from the buffer to the shifter.
 *
 * Values:
 * - 0 - SPI transmit buffer not empty (when FIFOMODE is not present or is 0) or
 *     SPI FIFO not empty (when FIFOMODE is 1)
 * - 1 - SPI transmit buffer empty (when FIFOMODE is not present or is 0) or SPI
 *     FIFO empty (when FIFOMODE is 1)
 */
/*@{*/
#define BP_SPI_S_SPTEF       (5U)          /*!< Bit position for SPI_S_SPTEF. */
#define BM_SPI_S_SPTEF       (0x20U)       /*!< Bit mask for SPI_S_SPTEF. */
#define BS_SPI_S_SPTEF       (1U)          /*!< Bit field size in bits for SPI_S_SPTEF. */

/*! @brief Read current value of the SPI_S_SPTEF field. */
#define BR_SPI_S_SPTEF(x)    (BME_UBFX8(HW_SPI_S_ADDR(x), BP_SPI_S_SPTEF, BS_SPI_S_SPTEF))
/*@}*/

/*!
 * @name Register SPI_S, field SPMF[6] (RO)
 *
 * SPMF is set after SPRF is 1 when the value in the receive data buffer matches
 * the value in the MH:ML registers. To clear the flag, read SPMF when it is set
 * and then write a 1 to it.
 *
 * Values:
 * - 0 - Value in the receive data buffer does not match the value in the MH:ML
 *     registers
 * - 1 - Value in the receive data buffer matches the value in the MH:ML
 *     registers
 */
/*@{*/
#define BP_SPI_S_SPMF        (6U)          /*!< Bit position for SPI_S_SPMF. */
#define BM_SPI_S_SPMF        (0x40U)       /*!< Bit mask for SPI_S_SPMF. */
#define BS_SPI_S_SPMF        (1U)          /*!< Bit field size in bits for SPI_S_SPMF. */

/*! @brief Read current value of the SPI_S_SPMF field. */
#define BR_SPI_S_SPMF(x)     (BME_UBFX8(HW_SPI_S_ADDR(x), BP_SPI_S_SPMF, BS_SPI_S_SPMF))
/*@}*/

/*!
 * @name Register SPI_S, field SPRF[7] (RO)
 *
 * When the FIFO is not supported or not enabled (FIFOMODE is not present or is
 * 0): SPRF is set at the completion of an SPI transfer to indicate that received
 * data may be read from the SPI data (DH:DL) register. When the receive DMA
 * request is disabled (RXDMAE is 0), SPRF is cleared by reading SPRF while it is
 * set and then reading the SPI data register. When the receive DMA request is
 * enabled (RXDMAE is 1), SPRF is automatically cleared when the DMA transfer for the
 * receive DMA request is completed (RX DMA Done is asserted). When FIFOMODE is
 * 1: This bit indicates the status of the read FIFO when FIFOMODE is enabled.
 * The SPRF is set when the read FIFO has received 64 bits (4 words or 8 bytes) of
 * data from the shifter and there have been no CPU reads of the SPI data (DH:DL)
 * register. When the receive DMA request is disabled (RXDMAE is 0), SPRF is
 * cleared by reading the SPI data register, resulting in the FIFO no longer being
 * full, assuming another SPI message is not received. When the receive DMA
 * request is enabled (RXDMAE is 1), SPRF is automatically cleared when the first DMA
 * transfer for the receive DMA request is completed (RX DMA Done is asserted).
 *
 * Values:
 * - 0 - No data available in the receive data buffer (when FIFOMODE is not
 *     present or is 0) or Read FIFO is not full (when FIFOMODE is 1)
 * - 1 - Data available in the receive data buffer (when FIFOMODE is not present
 *     or is 0) or Read FIFO is full (when FIFOMODE is 1)
 */
/*@{*/
#define BP_SPI_S_SPRF        (7U)          /*!< Bit position for SPI_S_SPRF. */
#define BM_SPI_S_SPRF        (0x80U)       /*!< Bit mask for SPI_S_SPRF. */
#define BS_SPI_S_SPRF        (1U)          /*!< Bit field size in bits for SPI_S_SPRF. */

/*! @brief Read current value of the SPI_S_SPRF field. */
#define BR_SPI_S_SPRF(x)     (BME_UBFX8(HW_SPI_S_ADDR(x), BP_SPI_S_SPRF, BS_SPI_S_SPRF))
/*@}*/

/*******************************************************************************
 * HW_SPI_BR - SPI Baud Rate Register
 ******************************************************************************/

/*!
 * @brief HW_SPI_BR - SPI Baud Rate Register (RW)
 *
 * Reset value: 0x00U
 *
 * Use this register to set the prescaler and bit rate divisor for an SPI
 * master. This register may be read or written at any time.
 */
typedef union _hw_spi_br
{
    uint8_t U;
    struct _hw_spi_br_bitfields
    {
        uint8_t SPR : 4;               /*!< [3:0] SPI Baud Rate Divisor */
        uint8_t SPPR : 3;              /*!< [6:4] SPI Baud Rate Prescale Divisor */
        uint8_t RESERVED0 : 1;         /*!< [7]  */
    } B;
} hw_spi_br_t;

/*!
 * @name Constants and macros for entire SPI_BR register
 */
/*@{*/
#define HW_SPI_BR_ADDR(x)        ((uint32_t)(x) + 0x1U)

#define HW_SPI_BR(x)             (*(__IO hw_spi_br_t *) HW_SPI_BR_ADDR(x))
#define HW_SPI_BR_RD(x)          (HW_SPI_BR(x).U)
#define HW_SPI_BR_WR(x, v)       (HW_SPI_BR(x).U = (v))
#define HW_SPI_BR_SET(x, v)      (BME_OR8(HW_SPI_BR_ADDR(x), (uint8_t)(v)))
#define HW_SPI_BR_CLR(x, v)      (BME_AND8(HW_SPI_BR_ADDR(x), (uint8_t)(~(v))))
#define HW_SPI_BR_TOG(x, v)      (BME_XOR8(HW_SPI_BR_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SPI_BR bitfields
 */

/*!
 * @name Register SPI_BR, field SPR[3:0] (RW)
 *
 * This 4-bit field selects one of nine divisors for the SPI baud rate divider.
 * The input to this divider comes from the SPI baud rate prescaler. Refer to the
 * description of "SPI Baud Rate Generation" for details.
 *
 * Values:
 * - 0000 - Baud rate divisor is 2.
 * - 0001 - Baud rate divisor is 4.
 * - 0010 - Baud rate divisor is 8.
 * - 0011 - Baud rate divisor is 16.
 * - 0100 - Baud rate divisor is 32.
 * - 0101 - Baud rate divisor is 64.
 * - 0110 - Baud rate divisor is 128.
 * - 0111 - Baud rate divisor is 256.
 * - 1000 - Baud rate divisor is 512.
 */
/*@{*/
#define BP_SPI_BR_SPR        (0U)          /*!< Bit position for SPI_BR_SPR. */
#define BM_SPI_BR_SPR        (0x0FU)       /*!< Bit mask for SPI_BR_SPR. */
#define BS_SPI_BR_SPR        (4U)          /*!< Bit field size in bits for SPI_BR_SPR. */

/*! @brief Read current value of the SPI_BR_SPR field. */
#define BR_SPI_BR_SPR(x)     (BME_UBFX8(HW_SPI_BR_ADDR(x), BP_SPI_BR_SPR, BS_SPI_BR_SPR))

/*! @brief Format value for bitfield SPI_BR_SPR. */
#define BF_SPI_BR_SPR(v)     ((uint8_t)((uint8_t)(v) << BP_SPI_BR_SPR) & BM_SPI_BR_SPR)

/*! @brief Set the SPR field to a new value. */
#define BW_SPI_BR_SPR(x, v)  (BME_BFI8(HW_SPI_BR_ADDR(x), ((uint8_t)(v) << BP_SPI_BR_SPR), BP_SPI_BR_SPR, 4))
/*@}*/

/*!
 * @name Register SPI_BR, field SPPR[6:4] (RW)
 *
 * This 3-bit field selects one of eight divisors for the SPI baud rate
 * prescaler. The input to this prescaler is the SPI module clock. The output of this
 * prescaler drives the input of the SPI baud rate divider. Refer to the description
 * of "SPI Baud Rate Generation" for details.
 *
 * Values:
 * - 000 - Baud rate prescaler divisor is 1.
 * - 001 - Baud rate prescaler divisor is 2.
 * - 010 - Baud rate prescaler divisor is 3.
 * - 011 - Baud rate prescaler divisor is 4.
 * - 100 - Baud rate prescaler divisor is 5.
 * - 101 - Baud rate prescaler divisor is 6.
 * - 110 - Baud rate prescaler divisor is 7.
 * - 111 - Baud rate prescaler divisor is 8.
 */
/*@{*/
#define BP_SPI_BR_SPPR       (4U)          /*!< Bit position for SPI_BR_SPPR. */
#define BM_SPI_BR_SPPR       (0x70U)       /*!< Bit mask for SPI_BR_SPPR. */
#define BS_SPI_BR_SPPR       (3U)          /*!< Bit field size in bits for SPI_BR_SPPR. */

/*! @brief Read current value of the SPI_BR_SPPR field. */
#define BR_SPI_BR_SPPR(x)    (BME_UBFX8(HW_SPI_BR_ADDR(x), BP_SPI_BR_SPPR, BS_SPI_BR_SPPR))

/*! @brief Format value for bitfield SPI_BR_SPPR. */
#define BF_SPI_BR_SPPR(v)    ((uint8_t)((uint8_t)(v) << BP_SPI_BR_SPPR) & BM_SPI_BR_SPPR)

/*! @brief Set the SPPR field to a new value. */
#define BW_SPI_BR_SPPR(x, v) (BME_BFI8(HW_SPI_BR_ADDR(x), ((uint8_t)(v) << BP_SPI_BR_SPPR), BP_SPI_BR_SPPR, 3))
/*@}*/

/*******************************************************************************
 * HW_SPI_C2 - SPI Control Register 2
 ******************************************************************************/

/*!
 * @brief HW_SPI_C2 - SPI Control Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This read/write register is used to control optional features of the SPI
 * system.
 */
typedef union _hw_spi_c2
{
    uint8_t U;
    struct _hw_spi_c2_bitfields
    {
        uint8_t SPC0 : 1;              /*!< [0] SPI Pin Control 0 */
        uint8_t SPISWAI : 1;           /*!< [1] SPI Stop in Wait Mode */
        uint8_t RXDMAE : 1;            /*!< [2] Receive DMA enable */
        uint8_t BIDIROE : 1;           /*!< [3] Bidirectional Mode Output Enable */
        uint8_t MODFEN : 1;            /*!< [4] Master Mode-Fault Function Enable */
        uint8_t TXDMAE : 1;            /*!< [5] Transmit DMA enable */
        uint8_t SPIMODE : 1;           /*!< [6] SPI 8-bit or 16-bit mode */
        uint8_t SPMIE : 1;             /*!< [7] SPI Match Interrupt Enable */
    } B;
} hw_spi_c2_t;

/*!
 * @name Constants and macros for entire SPI_C2 register
 */
/*@{*/
#define HW_SPI_C2_ADDR(x)        ((uint32_t)(x) + 0x2U)

#define HW_SPI_C2(x)             (*(__IO hw_spi_c2_t *) HW_SPI_C2_ADDR(x))
#define HW_SPI_C2_RD(x)          (HW_SPI_C2(x).U)
#define HW_SPI_C2_WR(x, v)       (HW_SPI_C2(x).U = (v))
#define HW_SPI_C2_SET(x, v)      (BME_OR8(HW_SPI_C2_ADDR(x), (uint8_t)(v)))
#define HW_SPI_C2_CLR(x, v)      (BME_AND8(HW_SPI_C2_ADDR(x), (uint8_t)(~(v))))
#define HW_SPI_C2_TOG(x, v)      (BME_XOR8(HW_SPI_C2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SPI_C2 bitfields
 */

/*!
 * @name Register SPI_C2, field SPC0[0] (RW)
 *
 * Enables bidirectional pin configurations.
 *
 * Values:
 * - 0 - SPI uses separate pins for data input and data output (pin mode is
 *     normal). In master mode of operation: MISO is master in and MOSI is master
 *     out. In slave mode of operation: MISO is slave out and MOSI is slave in.
 * - 1 - SPI configured for single-wire bidirectional operation (pin mode is
 *     bidirectional). In master mode of operation: MISO is not used by SPI; MOSI is
 *     master in when BIDIROE is 0 or master I/O when BIDIROE is 1. In slave
 *     mode of operation: MISO is slave in when BIDIROE is 0 or slave I/O when
 *     BIDIROE is 1; MOSI is not used by SPI.
 */
/*@{*/
#define BP_SPI_C2_SPC0       (0U)          /*!< Bit position for SPI_C2_SPC0. */
#define BM_SPI_C2_SPC0       (0x01U)       /*!< Bit mask for SPI_C2_SPC0. */
#define BS_SPI_C2_SPC0       (1U)          /*!< Bit field size in bits for SPI_C2_SPC0. */

/*! @brief Read current value of the SPI_C2_SPC0 field. */
#define BR_SPI_C2_SPC0(x)    (BME_UBFX8(HW_SPI_C2_ADDR(x), BP_SPI_C2_SPC0, BS_SPI_C2_SPC0))

/*! @brief Format value for bitfield SPI_C2_SPC0. */
#define BF_SPI_C2_SPC0(v)    ((uint8_t)((uint8_t)(v) << BP_SPI_C2_SPC0) & BM_SPI_C2_SPC0)

/*! @brief Set the SPC0 field to a new value. */
#define BW_SPI_C2_SPC0(x, v) (BME_BFI8(HW_SPI_C2_ADDR(x), ((uint8_t)(v) << BP_SPI_C2_SPC0), BP_SPI_C2_SPC0, 1))
/*@}*/

/*!
 * @name Register SPI_C2, field SPISWAI[1] (RW)
 *
 * This bit is used for power conservation while the device is in Wait mode.
 *
 * Values:
 * - 0 - SPI clocks continue to operate in Wait mode.
 * - 1 - SPI clocks stop when the MCU enters Wait mode.
 */
/*@{*/
#define BP_SPI_C2_SPISWAI    (1U)          /*!< Bit position for SPI_C2_SPISWAI. */
#define BM_SPI_C2_SPISWAI    (0x02U)       /*!< Bit mask for SPI_C2_SPISWAI. */
#define BS_SPI_C2_SPISWAI    (1U)          /*!< Bit field size in bits for SPI_C2_SPISWAI. */

/*! @brief Read current value of the SPI_C2_SPISWAI field. */
#define BR_SPI_C2_SPISWAI(x) (BME_UBFX8(HW_SPI_C2_ADDR(x), BP_SPI_C2_SPISWAI, BS_SPI_C2_SPISWAI))

/*! @brief Format value for bitfield SPI_C2_SPISWAI. */
#define BF_SPI_C2_SPISWAI(v) ((uint8_t)((uint8_t)(v) << BP_SPI_C2_SPISWAI) & BM_SPI_C2_SPISWAI)

/*! @brief Set the SPISWAI field to a new value. */
#define BW_SPI_C2_SPISWAI(x, v) (BME_BFI8(HW_SPI_C2_ADDR(x), ((uint8_t)(v) << BP_SPI_C2_SPISWAI), BP_SPI_C2_SPISWAI, 1))
/*@}*/

/*!
 * @name Register SPI_C2, field RXDMAE[2] (RW)
 *
 * This is the enable bit for a receive DMA request. When this bit is set to 1,
 * a receive DMA request is asserted when both SPRF and SPE are set, and the
 * interrupt from SPRF is disabled.
 *
 * Values:
 * - 0 - DMA request for receive is disabled and interrupt from SPRF is allowed
 * - 1 - DMA request for receive is enabled and interrupt from SPRF is disabled
 */
/*@{*/
#define BP_SPI_C2_RXDMAE     (2U)          /*!< Bit position for SPI_C2_RXDMAE. */
#define BM_SPI_C2_RXDMAE     (0x04U)       /*!< Bit mask for SPI_C2_RXDMAE. */
#define BS_SPI_C2_RXDMAE     (1U)          /*!< Bit field size in bits for SPI_C2_RXDMAE. */

/*! @brief Read current value of the SPI_C2_RXDMAE field. */
#define BR_SPI_C2_RXDMAE(x)  (BME_UBFX8(HW_SPI_C2_ADDR(x), BP_SPI_C2_RXDMAE, BS_SPI_C2_RXDMAE))

/*! @brief Format value for bitfield SPI_C2_RXDMAE. */
#define BF_SPI_C2_RXDMAE(v)  ((uint8_t)((uint8_t)(v) << BP_SPI_C2_RXDMAE) & BM_SPI_C2_RXDMAE)

/*! @brief Set the RXDMAE field to a new value. */
#define BW_SPI_C2_RXDMAE(x, v) (BME_BFI8(HW_SPI_C2_ADDR(x), ((uint8_t)(v) << BP_SPI_C2_RXDMAE), BP_SPI_C2_RXDMAE, 1))
/*@}*/

/*!
 * @name Register SPI_C2, field BIDIROE[3] (RW)
 *
 * When bidirectional mode is enabled because SPI pin control 0 (SPC0) is set to
 * 1, BIDIROE determines whether the SPI data output driver is enabled to the
 * single bidirectional SPI I/O pin. Depending on whether the SPI is configured as
 * a master or a slave, it uses the MOSI (MOMI) or MISO (SISO) pin, respectively,
 * as the single SPI data I/O pin. When SPC0 is 0, BIDIROE has no meaning or
 * effect.
 *
 * Values:
 * - 0 - Output driver disabled so SPI data I/O pin acts as an input
 * - 1 - SPI I/O pin enabled as an output
 */
/*@{*/
#define BP_SPI_C2_BIDIROE    (3U)          /*!< Bit position for SPI_C2_BIDIROE. */
#define BM_SPI_C2_BIDIROE    (0x08U)       /*!< Bit mask for SPI_C2_BIDIROE. */
#define BS_SPI_C2_BIDIROE    (1U)          /*!< Bit field size in bits for SPI_C2_BIDIROE. */

/*! @brief Read current value of the SPI_C2_BIDIROE field. */
#define BR_SPI_C2_BIDIROE(x) (BME_UBFX8(HW_SPI_C2_ADDR(x), BP_SPI_C2_BIDIROE, BS_SPI_C2_BIDIROE))

/*! @brief Format value for bitfield SPI_C2_BIDIROE. */
#define BF_SPI_C2_BIDIROE(v) ((uint8_t)((uint8_t)(v) << BP_SPI_C2_BIDIROE) & BM_SPI_C2_BIDIROE)

/*! @brief Set the BIDIROE field to a new value. */
#define BW_SPI_C2_BIDIROE(x, v) (BME_BFI8(HW_SPI_C2_ADDR(x), ((uint8_t)(v) << BP_SPI_C2_BIDIROE), BP_SPI_C2_BIDIROE, 1))
/*@}*/

/*!
 * @name Register SPI_C2, field MODFEN[4] (RW)
 *
 * When the SPI is configured for slave mode, this bit has no meaning or effect.
 * (The SS pin is the slave select input.) In master mode, this bit determines
 * how the SS pin is used. For details, refer to the description of the SSOE bit
 * in the C1 register.
 *
 * Values:
 * - 0 - Mode fault function disabled, master SS pin reverts to general-purpose
 *     I/O not controlled by SPI
 * - 1 - Mode fault function enabled, master SS pin acts as the mode fault input
 *     or the slave select output
 */
/*@{*/
#define BP_SPI_C2_MODFEN     (4U)          /*!< Bit position for SPI_C2_MODFEN. */
#define BM_SPI_C2_MODFEN     (0x10U)       /*!< Bit mask for SPI_C2_MODFEN. */
#define BS_SPI_C2_MODFEN     (1U)          /*!< Bit field size in bits for SPI_C2_MODFEN. */

/*! @brief Read current value of the SPI_C2_MODFEN field. */
#define BR_SPI_C2_MODFEN(x)  (BME_UBFX8(HW_SPI_C2_ADDR(x), BP_SPI_C2_MODFEN, BS_SPI_C2_MODFEN))

/*! @brief Format value for bitfield SPI_C2_MODFEN. */
#define BF_SPI_C2_MODFEN(v)  ((uint8_t)((uint8_t)(v) << BP_SPI_C2_MODFEN) & BM_SPI_C2_MODFEN)

/*! @brief Set the MODFEN field to a new value. */
#define BW_SPI_C2_MODFEN(x, v) (BME_BFI8(HW_SPI_C2_ADDR(x), ((uint8_t)(v) << BP_SPI_C2_MODFEN), BP_SPI_C2_MODFEN, 1))
/*@}*/

/*!
 * @name Register SPI_C2, field TXDMAE[5] (RW)
 *
 * This bit enables a transmit DMA request. When this bit is set to 1, a
 * transmit DMA request is asserted when both SPTEF and SPE are set, and the interrupt
 * from SPTEF is disabled.
 *
 * Values:
 * - 0 - DMA request for transmit is disabled and interrupt from SPTEF is allowed
 * - 1 - DMA request for transmit is enabled and interrupt from SPTEF is disabled
 */
/*@{*/
#define BP_SPI_C2_TXDMAE     (5U)          /*!< Bit position for SPI_C2_TXDMAE. */
#define BM_SPI_C2_TXDMAE     (0x20U)       /*!< Bit mask for SPI_C2_TXDMAE. */
#define BS_SPI_C2_TXDMAE     (1U)          /*!< Bit field size in bits for SPI_C2_TXDMAE. */

/*! @brief Read current value of the SPI_C2_TXDMAE field. */
#define BR_SPI_C2_TXDMAE(x)  (BME_UBFX8(HW_SPI_C2_ADDR(x), BP_SPI_C2_TXDMAE, BS_SPI_C2_TXDMAE))

/*! @brief Format value for bitfield SPI_C2_TXDMAE. */
#define BF_SPI_C2_TXDMAE(v)  ((uint8_t)((uint8_t)(v) << BP_SPI_C2_TXDMAE) & BM_SPI_C2_TXDMAE)

/*! @brief Set the TXDMAE field to a new value. */
#define BW_SPI_C2_TXDMAE(x, v) (BME_BFI8(HW_SPI_C2_ADDR(x), ((uint8_t)(v) << BP_SPI_C2_TXDMAE), BP_SPI_C2_TXDMAE, 1))
/*@}*/

/*!
 * @name Register SPI_C2, field SPIMODE[6] (RW)
 *
 * This bit allows the user to select either an 8-bit or 16-bit SPI data
 * transmission length. In master mode, a change of this bit aborts a transmission in
 * progress, forces the SPI system into an idle state, and resets all status bits
 * in the S register. Refer to the description of "Data Transmission Length" for
 * details.
 *
 * Values:
 * - 0 - 8-bit SPI shift register, match register, and buffers
 * - 1 - 16-bit SPI shift register, match register, and buffers
 */
/*@{*/
#define BP_SPI_C2_SPIMODE    (6U)          /*!< Bit position for SPI_C2_SPIMODE. */
#define BM_SPI_C2_SPIMODE    (0x40U)       /*!< Bit mask for SPI_C2_SPIMODE. */
#define BS_SPI_C2_SPIMODE    (1U)          /*!< Bit field size in bits for SPI_C2_SPIMODE. */

/*! @brief Read current value of the SPI_C2_SPIMODE field. */
#define BR_SPI_C2_SPIMODE(x) (BME_UBFX8(HW_SPI_C2_ADDR(x), BP_SPI_C2_SPIMODE, BS_SPI_C2_SPIMODE))

/*! @brief Format value for bitfield SPI_C2_SPIMODE. */
#define BF_SPI_C2_SPIMODE(v) ((uint8_t)((uint8_t)(v) << BP_SPI_C2_SPIMODE) & BM_SPI_C2_SPIMODE)

/*! @brief Set the SPIMODE field to a new value. */
#define BW_SPI_C2_SPIMODE(x, v) (BME_BFI8(HW_SPI_C2_ADDR(x), ((uint8_t)(v) << BP_SPI_C2_SPIMODE), BP_SPI_C2_SPIMODE, 1))
/*@}*/

/*!
 * @name Register SPI_C2, field SPMIE[7] (RW)
 *
 * This is the interrupt enable bit for the SPI receive data buffer hardware
 * match (SPMF) function.
 *
 * Values:
 * - 0 - Interrupts from SPMF inhibited (use polling)
 * - 1 - When SPMF is 1, requests a hardware interrupt
 */
/*@{*/
#define BP_SPI_C2_SPMIE      (7U)          /*!< Bit position for SPI_C2_SPMIE. */
#define BM_SPI_C2_SPMIE      (0x80U)       /*!< Bit mask for SPI_C2_SPMIE. */
#define BS_SPI_C2_SPMIE      (1U)          /*!< Bit field size in bits for SPI_C2_SPMIE. */

/*! @brief Read current value of the SPI_C2_SPMIE field. */
#define BR_SPI_C2_SPMIE(x)   (BME_UBFX8(HW_SPI_C2_ADDR(x), BP_SPI_C2_SPMIE, BS_SPI_C2_SPMIE))

/*! @brief Format value for bitfield SPI_C2_SPMIE. */
#define BF_SPI_C2_SPMIE(v)   ((uint8_t)((uint8_t)(v) << BP_SPI_C2_SPMIE) & BM_SPI_C2_SPMIE)

/*! @brief Set the SPMIE field to a new value. */
#define BW_SPI_C2_SPMIE(x, v) (BME_BFI8(HW_SPI_C2_ADDR(x), ((uint8_t)(v) << BP_SPI_C2_SPMIE), BP_SPI_C2_SPMIE, 1))
/*@}*/

/*******************************************************************************
 * HW_SPI_C1 - SPI Control Register 1
 ******************************************************************************/

/*!
 * @brief HW_SPI_C1 - SPI Control Register 1 (RW)
 *
 * Reset value: 0x04U
 *
 * This read/write register includes the SPI enable control, interrupt enables,
 * and configuration options.
 */
typedef union _hw_spi_c1
{
    uint8_t U;
    struct _hw_spi_c1_bitfields
    {
        uint8_t LSBFE : 1;             /*!< [0] LSB First (shifter direction) */
        uint8_t SSOE : 1;              /*!< [1] Slave Select Output Enable */
        uint8_t CPHA : 1;              /*!< [2] Clock Phase */
        uint8_t CPOL : 1;              /*!< [3] Clock Polarity */
        uint8_t MSTR : 1;              /*!< [4] Master/Slave Mode Select */
        uint8_t SPTIE : 1;             /*!< [5] SPI Transmit Interrupt Enable */
        uint8_t SPE : 1;               /*!< [6] SPI System Enable */
        uint8_t SPIE : 1;              /*!< [7] SPI Interrupt Enable: for SPRF and MODF
                                        * (when FIFO is not supported or not enabled) or for read FIFO (when FIFO is
                                        * supported and enabled) */
    } B;
} hw_spi_c1_t;

/*!
 * @name Constants and macros for entire SPI_C1 register
 */
/*@{*/
#define HW_SPI_C1_ADDR(x)        ((uint32_t)(x) + 0x3U)

#define HW_SPI_C1(x)             (*(__IO hw_spi_c1_t *) HW_SPI_C1_ADDR(x))
#define HW_SPI_C1_RD(x)          (HW_SPI_C1(x).U)
#define HW_SPI_C1_WR(x, v)       (HW_SPI_C1(x).U = (v))
#define HW_SPI_C1_SET(x, v)      (BME_OR8(HW_SPI_C1_ADDR(x), (uint8_t)(v)))
#define HW_SPI_C1_CLR(x, v)      (BME_AND8(HW_SPI_C1_ADDR(x), (uint8_t)(~(v))))
#define HW_SPI_C1_TOG(x, v)      (BME_XOR8(HW_SPI_C1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SPI_C1 bitfields
 */

/*!
 * @name Register SPI_C1, field LSBFE[0] (RW)
 *
 * This bit does not affect the position of the MSB and LSB in the data
 * register. Reads and writes of the data register always have the MSB in bit 7 (or bit
 * 15 in 16-bit mode).
 *
 * Values:
 * - 0 - SPI serial data transfers start with the most significant bit.
 * - 1 - SPI serial data transfers start with the least significant bit.
 */
/*@{*/
#define BP_SPI_C1_LSBFE      (0U)          /*!< Bit position for SPI_C1_LSBFE. */
#define BM_SPI_C1_LSBFE      (0x01U)       /*!< Bit mask for SPI_C1_LSBFE. */
#define BS_SPI_C1_LSBFE      (1U)          /*!< Bit field size in bits for SPI_C1_LSBFE. */

/*! @brief Read current value of the SPI_C1_LSBFE field. */
#define BR_SPI_C1_LSBFE(x)   (BME_UBFX8(HW_SPI_C1_ADDR(x), BP_SPI_C1_LSBFE, BS_SPI_C1_LSBFE))

/*! @brief Format value for bitfield SPI_C1_LSBFE. */
#define BF_SPI_C1_LSBFE(v)   ((uint8_t)((uint8_t)(v) << BP_SPI_C1_LSBFE) & BM_SPI_C1_LSBFE)

/*! @brief Set the LSBFE field to a new value. */
#define BW_SPI_C1_LSBFE(x, v) (BME_BFI8(HW_SPI_C1_ADDR(x), ((uint8_t)(v) << BP_SPI_C1_LSBFE), BP_SPI_C1_LSBFE, 1))
/*@}*/

/*!
 * @name Register SPI_C1, field SSOE[1] (RW)
 *
 * This bit is used in combination with the Mode Fault Enable (MODFEN) field in
 * the C2 register and the Master/Slave (MSTR) control bit to determine the
 * function of the SS pin.
 *
 * Values:
 * - 0 - When C2[MODFEN] is 0: In master mode, SS pin function is
 *     general-purpose I/O (not SPI). In slave mode, SS pin function is slave select input.
 *     When C2[MODFEN] is 1: In master mode, SS pin function is SS input for mode
 *     fault. In slave mode, SS pin function is slave select input.
 * - 1 - When C2[MODFEN] is 0: In master mode, SS pin function is
 *     general-purpose I/O (not SPI). In slave mode, SS pin function is slave select input.
 *     When C2[MODFEN] is 1: In master mode, SS pin function is automatic SS output.
 *     In slave mode: SS pin function is slave select input.
 */
/*@{*/
#define BP_SPI_C1_SSOE       (1U)          /*!< Bit position for SPI_C1_SSOE. */
#define BM_SPI_C1_SSOE       (0x02U)       /*!< Bit mask for SPI_C1_SSOE. */
#define BS_SPI_C1_SSOE       (1U)          /*!< Bit field size in bits for SPI_C1_SSOE. */

/*! @brief Read current value of the SPI_C1_SSOE field. */
#define BR_SPI_C1_SSOE(x)    (BME_UBFX8(HW_SPI_C1_ADDR(x), BP_SPI_C1_SSOE, BS_SPI_C1_SSOE))

/*! @brief Format value for bitfield SPI_C1_SSOE. */
#define BF_SPI_C1_SSOE(v)    ((uint8_t)((uint8_t)(v) << BP_SPI_C1_SSOE) & BM_SPI_C1_SSOE)

/*! @brief Set the SSOE field to a new value. */
#define BW_SPI_C1_SSOE(x, v) (BME_BFI8(HW_SPI_C1_ADDR(x), ((uint8_t)(v) << BP_SPI_C1_SSOE), BP_SPI_C1_SSOE, 1))
/*@}*/

/*!
 * @name Register SPI_C1, field CPHA[2] (RW)
 *
 * Selects one of two clock formats for different kinds of synchronous serial
 * peripheral devices. Refer to the description of "SPI Clock Formats" for details.
 *
 * Values:
 * - 0 - First edge on SPSCK occurs at the middle of the first cycle of a data
 *     transfer.
 * - 1 - First edge on SPSCK occurs at the start of the first cycle of a data
 *     transfer.
 */
/*@{*/
#define BP_SPI_C1_CPHA       (2U)          /*!< Bit position for SPI_C1_CPHA. */
#define BM_SPI_C1_CPHA       (0x04U)       /*!< Bit mask for SPI_C1_CPHA. */
#define BS_SPI_C1_CPHA       (1U)          /*!< Bit field size in bits for SPI_C1_CPHA. */

/*! @brief Read current value of the SPI_C1_CPHA field. */
#define BR_SPI_C1_CPHA(x)    (BME_UBFX8(HW_SPI_C1_ADDR(x), BP_SPI_C1_CPHA, BS_SPI_C1_CPHA))

/*! @brief Format value for bitfield SPI_C1_CPHA. */
#define BF_SPI_C1_CPHA(v)    ((uint8_t)((uint8_t)(v) << BP_SPI_C1_CPHA) & BM_SPI_C1_CPHA)

/*! @brief Set the CPHA field to a new value. */
#define BW_SPI_C1_CPHA(x, v) (BME_BFI8(HW_SPI_C1_ADDR(x), ((uint8_t)(v) << BP_SPI_C1_CPHA), BP_SPI_C1_CPHA, 1))
/*@}*/

/*!
 * @name Register SPI_C1, field CPOL[3] (RW)
 *
 * Selects an inverted or non-inverted SPI clock. To transmit data between SPI
 * modules, the SPI modules must have identical CPOL values. This bit effectively
 * places an inverter in series with the clock signal either from a master SPI
 * device or to a slave SPI device. Refer to the description of "SPI Clock Formats"
 * for details.
 *
 * Values:
 * - 0 - Active-high SPI clock (idles low)
 * - 1 - Active-low SPI clock (idles high)
 */
/*@{*/
#define BP_SPI_C1_CPOL       (3U)          /*!< Bit position for SPI_C1_CPOL. */
#define BM_SPI_C1_CPOL       (0x08U)       /*!< Bit mask for SPI_C1_CPOL. */
#define BS_SPI_C1_CPOL       (1U)          /*!< Bit field size in bits for SPI_C1_CPOL. */

/*! @brief Read current value of the SPI_C1_CPOL field. */
#define BR_SPI_C1_CPOL(x)    (BME_UBFX8(HW_SPI_C1_ADDR(x), BP_SPI_C1_CPOL, BS_SPI_C1_CPOL))

/*! @brief Format value for bitfield SPI_C1_CPOL. */
#define BF_SPI_C1_CPOL(v)    ((uint8_t)((uint8_t)(v) << BP_SPI_C1_CPOL) & BM_SPI_C1_CPOL)

/*! @brief Set the CPOL field to a new value. */
#define BW_SPI_C1_CPOL(x, v) (BME_BFI8(HW_SPI_C1_ADDR(x), ((uint8_t)(v) << BP_SPI_C1_CPOL), BP_SPI_C1_CPOL, 1))
/*@}*/

/*!
 * @name Register SPI_C1, field MSTR[4] (RW)
 *
 * Selects master or slave mode operation.
 *
 * Values:
 * - 0 - SPI module configured as a slave SPI device
 * - 1 - SPI module configured as a master SPI device
 */
/*@{*/
#define BP_SPI_C1_MSTR       (4U)          /*!< Bit position for SPI_C1_MSTR. */
#define BM_SPI_C1_MSTR       (0x10U)       /*!< Bit mask for SPI_C1_MSTR. */
#define BS_SPI_C1_MSTR       (1U)          /*!< Bit field size in bits for SPI_C1_MSTR. */

/*! @brief Read current value of the SPI_C1_MSTR field. */
#define BR_SPI_C1_MSTR(x)    (BME_UBFX8(HW_SPI_C1_ADDR(x), BP_SPI_C1_MSTR, BS_SPI_C1_MSTR))

/*! @brief Format value for bitfield SPI_C1_MSTR. */
#define BF_SPI_C1_MSTR(v)    ((uint8_t)((uint8_t)(v) << BP_SPI_C1_MSTR) & BM_SPI_C1_MSTR)

/*! @brief Set the MSTR field to a new value. */
#define BW_SPI_C1_MSTR(x, v) (BME_BFI8(HW_SPI_C1_ADDR(x), ((uint8_t)(v) << BP_SPI_C1_MSTR), BP_SPI_C1_MSTR, 1))
/*@}*/

/*!
 * @name Register SPI_C1, field SPTIE[5] (RW)
 *
 * When the FIFO is not supported or not enabled (FIFOMODE is not present or is
 * 0): This is the interrupt enable bit for SPI transmit buffer empty (SPTEF). An
 * interrupt occurs when the SPI transmit buffer is empty (SPTEF is set). When
 * the FIFO is supported and enabled (FIFOMODE is 1): This is the interrupt enable
 * bit for SPI transmit FIFO empty (SPTEF). An interrupt occurs when the SPI
 * transmit FIFO is empty (SPTEF is set).
 *
 * Values:
 * - 0 - Interrupts from SPTEF inhibited (use polling)
 * - 1 - When SPTEF is 1, hardware interrupt requested
 */
/*@{*/
#define BP_SPI_C1_SPTIE      (5U)          /*!< Bit position for SPI_C1_SPTIE. */
#define BM_SPI_C1_SPTIE      (0x20U)       /*!< Bit mask for SPI_C1_SPTIE. */
#define BS_SPI_C1_SPTIE      (1U)          /*!< Bit field size in bits for SPI_C1_SPTIE. */

/*! @brief Read current value of the SPI_C1_SPTIE field. */
#define BR_SPI_C1_SPTIE(x)   (BME_UBFX8(HW_SPI_C1_ADDR(x), BP_SPI_C1_SPTIE, BS_SPI_C1_SPTIE))

/*! @brief Format value for bitfield SPI_C1_SPTIE. */
#define BF_SPI_C1_SPTIE(v)   ((uint8_t)((uint8_t)(v) << BP_SPI_C1_SPTIE) & BM_SPI_C1_SPTIE)

/*! @brief Set the SPTIE field to a new value. */
#define BW_SPI_C1_SPTIE(x, v) (BME_BFI8(HW_SPI_C1_ADDR(x), ((uint8_t)(v) << BP_SPI_C1_SPTIE), BP_SPI_C1_SPTIE, 1))
/*@}*/

/*!
 * @name Register SPI_C1, field SPE[6] (RW)
 *
 * Enables the SPI system and dedicates the SPI port pins to SPI system
 * functions. If SPE is cleared, the SPI is disabled and forced into an idle state, and
 * all status bits in the S register are reset.
 *
 * Values:
 * - 0 - SPI system inactive
 * - 1 - SPI system enabled
 */
/*@{*/
#define BP_SPI_C1_SPE        (6U)          /*!< Bit position for SPI_C1_SPE. */
#define BM_SPI_C1_SPE        (0x40U)       /*!< Bit mask for SPI_C1_SPE. */
#define BS_SPI_C1_SPE        (1U)          /*!< Bit field size in bits for SPI_C1_SPE. */

/*! @brief Read current value of the SPI_C1_SPE field. */
#define BR_SPI_C1_SPE(x)     (BME_UBFX8(HW_SPI_C1_ADDR(x), BP_SPI_C1_SPE, BS_SPI_C1_SPE))

/*! @brief Format value for bitfield SPI_C1_SPE. */
#define BF_SPI_C1_SPE(v)     ((uint8_t)((uint8_t)(v) << BP_SPI_C1_SPE) & BM_SPI_C1_SPE)

/*! @brief Set the SPE field to a new value. */
#define BW_SPI_C1_SPE(x, v)  (BME_BFI8(HW_SPI_C1_ADDR(x), ((uint8_t)(v) << BP_SPI_C1_SPE), BP_SPI_C1_SPE, 1))
/*@}*/

/*!
 * @name Register SPI_C1, field SPIE[7] (RW)
 *
 * When the FIFO is not supported or not enabled (FIFOMODE is not present or is
 * 0): Enables the interrupt for SPI receive buffer full (SPRF) and mode fault
 * (MODF) events. When the FIFO is supported and enabled (FIFOMODE is 1): This bit
 * enables the SPI to interrupt the CPU when the receive FIFO is full. An
 * interrupt occurs when the SPRF bit is set or the MODF bit is set.
 *
 * Values:
 * - 0 - Interrupts from SPRF and MODF are inhibited-use polling (when FIFOMODE
 *     is not present or is 0) or Read FIFO Full Interrupts are disabled (when
 *     FIFOMODE is 1)
 * - 1 - Request a hardware interrupt when SPRF or MODF is 1 (when FIFOMODE is
 *     not present or is 0) or Read FIFO Full Interrupts are enabled (when
 *     FIFOMODE is 1)
 */
/*@{*/
#define BP_SPI_C1_SPIE       (7U)          /*!< Bit position for SPI_C1_SPIE. */
#define BM_SPI_C1_SPIE       (0x80U)       /*!< Bit mask for SPI_C1_SPIE. */
#define BS_SPI_C1_SPIE       (1U)          /*!< Bit field size in bits for SPI_C1_SPIE. */

/*! @brief Read current value of the SPI_C1_SPIE field. */
#define BR_SPI_C1_SPIE(x)    (BME_UBFX8(HW_SPI_C1_ADDR(x), BP_SPI_C1_SPIE, BS_SPI_C1_SPIE))

/*! @brief Format value for bitfield SPI_C1_SPIE. */
#define BF_SPI_C1_SPIE(v)    ((uint8_t)((uint8_t)(v) << BP_SPI_C1_SPIE) & BM_SPI_C1_SPIE)

/*! @brief Set the SPIE field to a new value. */
#define BW_SPI_C1_SPIE(x, v) (BME_BFI8(HW_SPI_C1_ADDR(x), ((uint8_t)(v) << BP_SPI_C1_SPIE), BP_SPI_C1_SPIE, 1))
/*@}*/

/*******************************************************************************
 * HW_SPI_ML - SPI Match Register low
 ******************************************************************************/

/*!
 * @brief HW_SPI_ML - SPI Match Register low (RW)
 *
 * Reset value: 0x00U
 *
 * This register, together with the MH register, contains the hardware compare
 * value. When the value received in the SPI receive data buffer equals this
 * hardware compare value, the SPI Match Flag in the S register (S[SPMF]) sets. In
 * 8-bit mode, only the ML register is available. Reads of the MH register return
 * all zeros. Writes to the MH register are ignored. In 16-bit mode, reading either
 * byte (the MH or ML register) latches the contents of both bytes into a buffer
 * where they remain latched until the other byte is read. Writing to either
 * byte (the MH or ML register) latches the value into a buffer. When both bytes
 * have been written, they are transferred as a coherent value into the SPI match
 * registers.
 */
typedef union _hw_spi_ml
{
    uint8_t U;
    struct _hw_spi_ml_bitfields
    {
        uint8_t Bits : 8;              /*!< [7:0] Hardware compare value (low byte) */
    } B;
} hw_spi_ml_t;

/*!
 * @name Constants and macros for entire SPI_ML register
 */
/*@{*/
#define HW_SPI_ML_ADDR(x)        ((uint32_t)(x) + 0x4U)

#define HW_SPI_ML(x)             (*(__IO hw_spi_ml_t *) HW_SPI_ML_ADDR(x))
#define HW_SPI_ML_RD(x)          (HW_SPI_ML(x).U)
#define HW_SPI_ML_WR(x, v)       (HW_SPI_ML(x).U = (v))
#define HW_SPI_ML_SET(x, v)      (BME_OR8(HW_SPI_ML_ADDR(x), (uint8_t)(v)))
#define HW_SPI_ML_CLR(x, v)      (BME_AND8(HW_SPI_ML_ADDR(x), (uint8_t)(~(v))))
#define HW_SPI_ML_TOG(x, v)      (BME_XOR8(HW_SPI_ML_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SPI_ML bitfields
 */

/*!
 * @name Register SPI_ML, field Bits[7:0] (RW)
 */
/*@{*/
#define BP_SPI_ML_Bits       (0U)          /*!< Bit position for SPI_ML_Bits. */
#define BM_SPI_ML_Bits       (0xFFU)       /*!< Bit mask for SPI_ML_Bits. */
#define BS_SPI_ML_Bits       (8U)          /*!< Bit field size in bits for SPI_ML_Bits. */

/*! @brief Read current value of the SPI_ML_Bits field. */
#define BR_SPI_ML_Bits(x)    (HW_SPI_ML(x).U)

/*! @brief Format value for bitfield SPI_ML_Bits. */
#define BF_SPI_ML_Bits(v)    ((uint8_t)((uint8_t)(v) << BP_SPI_ML_Bits) & BM_SPI_ML_Bits)

/*! @brief Set the Bits field to a new value. */
#define BW_SPI_ML_Bits(x, v) (HW_SPI_ML_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_SPI_MH - SPI match register high
 ******************************************************************************/

/*!
 * @brief HW_SPI_MH - SPI match register high (RW)
 *
 * Reset value: 0x00U
 *
 * Refer to the description of the ML register.
 */
typedef union _hw_spi_mh
{
    uint8_t U;
    struct _hw_spi_mh_bitfields
    {
        uint8_t Bits : 8;              /*!< [7:0] Hardware compare value (high byte) */
    } B;
} hw_spi_mh_t;

/*!
 * @name Constants and macros for entire SPI_MH register
 */
/*@{*/
#define HW_SPI_MH_ADDR(x)        ((uint32_t)(x) + 0x5U)

#define HW_SPI_MH(x)             (*(__IO hw_spi_mh_t *) HW_SPI_MH_ADDR(x))
#define HW_SPI_MH_RD(x)          (HW_SPI_MH(x).U)
#define HW_SPI_MH_WR(x, v)       (HW_SPI_MH(x).U = (v))
#define HW_SPI_MH_SET(x, v)      (BME_OR8(HW_SPI_MH_ADDR(x), (uint8_t)(v)))
#define HW_SPI_MH_CLR(x, v)      (BME_AND8(HW_SPI_MH_ADDR(x), (uint8_t)(~(v))))
#define HW_SPI_MH_TOG(x, v)      (BME_XOR8(HW_SPI_MH_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SPI_MH bitfields
 */

/*!
 * @name Register SPI_MH, field Bits[7:0] (RW)
 */
/*@{*/
#define BP_SPI_MH_Bits       (0U)          /*!< Bit position for SPI_MH_Bits. */
#define BM_SPI_MH_Bits       (0xFFU)       /*!< Bit mask for SPI_MH_Bits. */
#define BS_SPI_MH_Bits       (8U)          /*!< Bit field size in bits for SPI_MH_Bits. */

/*! @brief Read current value of the SPI_MH_Bits field. */
#define BR_SPI_MH_Bits(x)    (HW_SPI_MH(x).U)

/*! @brief Format value for bitfield SPI_MH_Bits. */
#define BF_SPI_MH_Bits(v)    ((uint8_t)((uint8_t)(v) << BP_SPI_MH_Bits) & BM_SPI_MH_Bits)

/*! @brief Set the Bits field to a new value. */
#define BW_SPI_MH_Bits(x, v) (HW_SPI_MH_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_SPI_DL - SPI Data Register low
 ******************************************************************************/

/*!
 * @brief HW_SPI_DL - SPI Data Register low (RW)
 *
 * Reset value: 0x00U
 *
 * This register, together with the DH register, is both the input and output
 * register for SPI data. A write to the registers writes to the transmit data
 * buffer, allowing data to be queued and transmitted. When the SPI is configured as
 * a master, data queued in the transmit data buffer is transmitted immediately
 * after the previous transmission has completed. The SPTEF bit in the S register
 * indicates when the transmit data buffer is ready to accept new data. When the
 * transmit DMA request is disabled (TXDMAE is 0): The S register must be read
 * when S[SPTEF] is set before writing to the SPI data registers; otherwise, the
 * write is ignored. When the transmit DMA request is enabled (TXDMAE is 1) when
 * S[SPTEF] is set, the SPI data registers can be written automatically by DMA
 * without reading the S register first. Data may be read from the SPI data registers
 * any time after S[SPRF] is set and before another transfer is finished.
 * Failure to read the data out of the receive data buffer before a new transfer ends
 * causes a receive overrun condition, and the data from the new transfer is lost.
 * The new data is lost because the receive buffer still held the previous
 * character and was not ready to accept the new data. There is no indication for a
 * receive overrun condition, so the application system designer must ensure that
 * previous data has been read from the receive buffer before a new transfer is
 * initiated. In 8-bit mode, only the DL register is available. Reads of the DH
 * register return all zeros. Writes to the DH register are ignored. In 16-bit mode,
 * reading either byte (the DH or DL register) latches the contents of both
 * bytes into a buffer where they remain latched until the other byte is read.
 * Writing to either byte (the DH or DL register) latches the value into a buffer. When
 * both bytes have been written, they are transferred as a coherent 16-bit value
 * into the transmit data buffer.
 */
typedef union _hw_spi_dl
{
    uint8_t U;
    struct _hw_spi_dl_bitfields
    {
        uint8_t Bits : 8;              /*!< [7:0] Data (low byte) */
    } B;
} hw_spi_dl_t;

/*!
 * @name Constants and macros for entire SPI_DL register
 */
/*@{*/
#define HW_SPI_DL_ADDR(x)        ((uint32_t)(x) + 0x6U)

#define HW_SPI_DL(x)             (*(__IO hw_spi_dl_t *) HW_SPI_DL_ADDR(x))
#define HW_SPI_DL_RD(x)          (HW_SPI_DL(x).U)
#define HW_SPI_DL_WR(x, v)       (HW_SPI_DL(x).U = (v))
#define HW_SPI_DL_SET(x, v)      (BME_OR8(HW_SPI_DL_ADDR(x), (uint8_t)(v)))
#define HW_SPI_DL_CLR(x, v)      (BME_AND8(HW_SPI_DL_ADDR(x), (uint8_t)(~(v))))
#define HW_SPI_DL_TOG(x, v)      (BME_XOR8(HW_SPI_DL_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SPI_DL bitfields
 */

/*!
 * @name Register SPI_DL, field Bits[7:0] (RW)
 */
/*@{*/
#define BP_SPI_DL_Bits       (0U)          /*!< Bit position for SPI_DL_Bits. */
#define BM_SPI_DL_Bits       (0xFFU)       /*!< Bit mask for SPI_DL_Bits. */
#define BS_SPI_DL_Bits       (8U)          /*!< Bit field size in bits for SPI_DL_Bits. */

/*! @brief Read current value of the SPI_DL_Bits field. */
#define BR_SPI_DL_Bits(x)    (HW_SPI_DL(x).U)

/*! @brief Format value for bitfield SPI_DL_Bits. */
#define BF_SPI_DL_Bits(v)    ((uint8_t)((uint8_t)(v) << BP_SPI_DL_Bits) & BM_SPI_DL_Bits)

/*! @brief Set the Bits field to a new value. */
#define BW_SPI_DL_Bits(x, v) (HW_SPI_DL_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_SPI_DH - SPI data register high
 ******************************************************************************/

/*!
 * @brief HW_SPI_DH - SPI data register high (RW)
 *
 * Reset value: 0x00U
 *
 * Refer to the description of the DL register.
 */
typedef union _hw_spi_dh
{
    uint8_t U;
    struct _hw_spi_dh_bitfields
    {
        uint8_t Bits : 8;              /*!< [7:0] Data (high byte) */
    } B;
} hw_spi_dh_t;

/*!
 * @name Constants and macros for entire SPI_DH register
 */
/*@{*/
#define HW_SPI_DH_ADDR(x)        ((uint32_t)(x) + 0x7U)

#define HW_SPI_DH(x)             (*(__IO hw_spi_dh_t *) HW_SPI_DH_ADDR(x))
#define HW_SPI_DH_RD(x)          (HW_SPI_DH(x).U)
#define HW_SPI_DH_WR(x, v)       (HW_SPI_DH(x).U = (v))
#define HW_SPI_DH_SET(x, v)      (BME_OR8(HW_SPI_DH_ADDR(x), (uint8_t)(v)))
#define HW_SPI_DH_CLR(x, v)      (BME_AND8(HW_SPI_DH_ADDR(x), (uint8_t)(~(v))))
#define HW_SPI_DH_TOG(x, v)      (BME_XOR8(HW_SPI_DH_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SPI_DH bitfields
 */

/*!
 * @name Register SPI_DH, field Bits[7:0] (RW)
 */
/*@{*/
#define BP_SPI_DH_Bits       (0U)          /*!< Bit position for SPI_DH_Bits. */
#define BM_SPI_DH_Bits       (0xFFU)       /*!< Bit mask for SPI_DH_Bits. */
#define BS_SPI_DH_Bits       (8U)          /*!< Bit field size in bits for SPI_DH_Bits. */

/*! @brief Read current value of the SPI_DH_Bits field. */
#define BR_SPI_DH_Bits(x)    (HW_SPI_DH(x).U)

/*! @brief Format value for bitfield SPI_DH_Bits. */
#define BF_SPI_DH_Bits(v)    ((uint8_t)((uint8_t)(v) << BP_SPI_DH_Bits) & BM_SPI_DH_Bits)

/*! @brief Set the Bits field to a new value. */
#define BW_SPI_DH_Bits(x, v) (HW_SPI_DH_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_SPI_CI - SPI clear interrupt register
 ******************************************************************************/

/*!
 * @brief HW_SPI_CI - SPI clear interrupt register (RW)
 *
 * Reset value: 0x00U
 *
 * This register applies only for an instance of the SPI module that supports
 * the FIFO feature. The register has four bits dedicated to clearing the
 * interrupts. Writing 1 to these bits clears the corresponding interrupts if the INTCLR
 * bit in the C3 register is 1. Reading these bits always returns 0. This register
 * also has two read-only bits to indicate the transmit FIFO and receive FIFO
 * overrun conditions. When the receive FIFO is full and data is received, RXFOF is
 * set. Similarily, when the transmit FIFO is full and a write to the data
 * register occurs, TXFOF is set. These flags are cleared when the CI register is read
 * while the flags are set. The register has two more read-only bits to indicate
 * the error flags. These flags are set when, due to some spurious reason,
 * entries in the FIFO total more than 64 bits of data. At this point, all the flags
 * in the status register are reset, and entries in the FIFO are flushed with the
 * corresponding error flags set. These flags are cleared when the CI register is
 * read while the flags are set.
 */
typedef union _hw_spi_ci
{
    uint8_t U;
    struct _hw_spi_ci_bitfields
    {
        uint8_t SPRFCI : 1;            /*!< [0] Receive FIFO full flag clear interrupt */
        uint8_t SPTEFCI : 1;           /*!< [1] Transmit FIFO empty flag clear
                                        * interrupt */
        uint8_t RNFULLFCI : 1;         /*!< [2] Receive FIFO nearly full flag clear
                                        * interrupt */
        uint8_t TNEAREFCI : 1;         /*!< [3] Transmit FIFO nearly empty flag clear
                                        * interrupt */
        uint8_t RXFOF : 1;             /*!< [4] Receive FIFO overflow flag */
        uint8_t TXFOF : 1;             /*!< [5] Transmit FIFO overflow flag */
        uint8_t RXFERR : 1;            /*!< [6] Receive FIFO error flag */
        uint8_t TXFERR : 1;            /*!< [7] Transmit FIFO error flag */
    } B;
} hw_spi_ci_t;

/*!
 * @name Constants and macros for entire SPI_CI register
 */
/*@{*/
#define HW_SPI_CI_ADDR(x)        ((uint32_t)(x) + 0xAU)

#define HW_SPI_CI(x)             (*(__IO hw_spi_ci_t *) HW_SPI_CI_ADDR(x))
#define HW_SPI_CI_RD(x)          (HW_SPI_CI(x).U)
#define HW_SPI_CI_WR(x, v)       (HW_SPI_CI(x).U = (v))
#define HW_SPI_CI_SET(x, v)      (BME_OR8(HW_SPI_CI_ADDR(x), (uint8_t)(v)))
#define HW_SPI_CI_CLR(x, v)      (BME_AND8(HW_SPI_CI_ADDR(x), (uint8_t)(~(v))))
#define HW_SPI_CI_TOG(x, v)      (BME_XOR8(HW_SPI_CI_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SPI_CI bitfields
 */

/*!
 * @name Register SPI_CI, field SPRFCI[0] (WORZ)
 *
 * Writing 1 to this bit clears the SPRF interrupt provided that C3[3] is set.
 */
/*@{*/
#define BP_SPI_CI_SPRFCI     (0U)          /*!< Bit position for SPI_CI_SPRFCI. */
#define BM_SPI_CI_SPRFCI     (0x01U)       /*!< Bit mask for SPI_CI_SPRFCI. */
#define BS_SPI_CI_SPRFCI     (1U)          /*!< Bit field size in bits for SPI_CI_SPRFCI. */

/*! @brief Format value for bitfield SPI_CI_SPRFCI. */
#define BF_SPI_CI_SPRFCI(v)  ((uint8_t)((uint8_t)(v) << BP_SPI_CI_SPRFCI) & BM_SPI_CI_SPRFCI)

/*! @brief Set the SPRFCI field to a new value. */
#define BW_SPI_CI_SPRFCI(x, v) (BME_BFI8(HW_SPI_CI_ADDR(x), ((uint8_t)(v) << BP_SPI_CI_SPRFCI), BP_SPI_CI_SPRFCI, 1))
/*@}*/

/*!
 * @name Register SPI_CI, field SPTEFCI[1] (WORZ)
 *
 * Writing 1 to this bit clears the SPTEF interrupt provided that C3[3] is set.
 */
/*@{*/
#define BP_SPI_CI_SPTEFCI    (1U)          /*!< Bit position for SPI_CI_SPTEFCI. */
#define BM_SPI_CI_SPTEFCI    (0x02U)       /*!< Bit mask for SPI_CI_SPTEFCI. */
#define BS_SPI_CI_SPTEFCI    (1U)          /*!< Bit field size in bits for SPI_CI_SPTEFCI. */

/*! @brief Format value for bitfield SPI_CI_SPTEFCI. */
#define BF_SPI_CI_SPTEFCI(v) ((uint8_t)((uint8_t)(v) << BP_SPI_CI_SPTEFCI) & BM_SPI_CI_SPTEFCI)

/*! @brief Set the SPTEFCI field to a new value. */
#define BW_SPI_CI_SPTEFCI(x, v) (BME_BFI8(HW_SPI_CI_ADDR(x), ((uint8_t)(v) << BP_SPI_CI_SPTEFCI), BP_SPI_CI_SPTEFCI, 1))
/*@}*/

/*!
 * @name Register SPI_CI, field RNFULLFCI[2] (WORZ)
 *
 * Writing 1 to this bit clears the RNFULLF interrupt provided that C3[3] is set.
 */
/*@{*/
#define BP_SPI_CI_RNFULLFCI  (2U)          /*!< Bit position for SPI_CI_RNFULLFCI. */
#define BM_SPI_CI_RNFULLFCI  (0x04U)       /*!< Bit mask for SPI_CI_RNFULLFCI. */
#define BS_SPI_CI_RNFULLFCI  (1U)          /*!< Bit field size in bits for SPI_CI_RNFULLFCI. */

/*! @brief Format value for bitfield SPI_CI_RNFULLFCI. */
#define BF_SPI_CI_RNFULLFCI(v) ((uint8_t)((uint8_t)(v) << BP_SPI_CI_RNFULLFCI) & BM_SPI_CI_RNFULLFCI)

/*! @brief Set the RNFULLFCI field to a new value. */
#define BW_SPI_CI_RNFULLFCI(x, v) (BME_BFI8(HW_SPI_CI_ADDR(x), ((uint8_t)(v) << BP_SPI_CI_RNFULLFCI), BP_SPI_CI_RNFULLFCI, 1))
/*@}*/

/*!
 * @name Register SPI_CI, field TNEAREFCI[3] (WORZ)
 *
 * Writing 1 to this bit clears the TNEAREF interrupt provided that C3[3] is set.
 */
/*@{*/
#define BP_SPI_CI_TNEAREFCI  (3U)          /*!< Bit position for SPI_CI_TNEAREFCI. */
#define BM_SPI_CI_TNEAREFCI  (0x08U)       /*!< Bit mask for SPI_CI_TNEAREFCI. */
#define BS_SPI_CI_TNEAREFCI  (1U)          /*!< Bit field size in bits for SPI_CI_TNEAREFCI. */

/*! @brief Format value for bitfield SPI_CI_TNEAREFCI. */
#define BF_SPI_CI_TNEAREFCI(v) ((uint8_t)((uint8_t)(v) << BP_SPI_CI_TNEAREFCI) & BM_SPI_CI_TNEAREFCI)

/*! @brief Set the TNEAREFCI field to a new value. */
#define BW_SPI_CI_TNEAREFCI(x, v) (BME_BFI8(HW_SPI_CI_ADDR(x), ((uint8_t)(v) << BP_SPI_CI_TNEAREFCI), BP_SPI_CI_TNEAREFCI, 1))
/*@}*/

/*!
 * @name Register SPI_CI, field RXFOF[4] (RO)
 *
 * This flag indicates that a receive FIFO overflow condition has occurred.
 *
 * Values:
 * - 0 - Receive FIFO overflow condition has not occurred
 * - 1 - Receive FIFO overflow condition occurred
 */
/*@{*/
#define BP_SPI_CI_RXFOF      (4U)          /*!< Bit position for SPI_CI_RXFOF. */
#define BM_SPI_CI_RXFOF      (0x10U)       /*!< Bit mask for SPI_CI_RXFOF. */
#define BS_SPI_CI_RXFOF      (1U)          /*!< Bit field size in bits for SPI_CI_RXFOF. */

/*! @brief Read current value of the SPI_CI_RXFOF field. */
#define BR_SPI_CI_RXFOF(x)   (BME_UBFX8(HW_SPI_CI_ADDR(x), BP_SPI_CI_RXFOF, BS_SPI_CI_RXFOF))
/*@}*/

/*!
 * @name Register SPI_CI, field TXFOF[5] (RO)
 *
 * This flag indicates that a transmit FIFO overflow condition has occurred.
 *
 * Values:
 * - 0 - Transmit FIFO overflow condition has not occurred
 * - 1 - Transmit FIFO overflow condition occurred
 */
/*@{*/
#define BP_SPI_CI_TXFOF      (5U)          /*!< Bit position for SPI_CI_TXFOF. */
#define BM_SPI_CI_TXFOF      (0x20U)       /*!< Bit mask for SPI_CI_TXFOF. */
#define BS_SPI_CI_TXFOF      (1U)          /*!< Bit field size in bits for SPI_CI_TXFOF. */

/*! @brief Read current value of the SPI_CI_TXFOF field. */
#define BR_SPI_CI_TXFOF(x)   (BME_UBFX8(HW_SPI_CI_ADDR(x), BP_SPI_CI_TXFOF, BS_SPI_CI_TXFOF))
/*@}*/

/*!
 * @name Register SPI_CI, field RXFERR[6] (RO)
 *
 * This flag indicates that a receive FIFO error occurred because entries in the
 * FIFO total more than 64 bits of data.
 *
 * Values:
 * - 0 - No receive FIFO error occurred
 * - 1 - A receive FIFO error occurred
 */
/*@{*/
#define BP_SPI_CI_RXFERR     (6U)          /*!< Bit position for SPI_CI_RXFERR. */
#define BM_SPI_CI_RXFERR     (0x40U)       /*!< Bit mask for SPI_CI_RXFERR. */
#define BS_SPI_CI_RXFERR     (1U)          /*!< Bit field size in bits for SPI_CI_RXFERR. */

/*! @brief Read current value of the SPI_CI_RXFERR field. */
#define BR_SPI_CI_RXFERR(x)  (BME_UBFX8(HW_SPI_CI_ADDR(x), BP_SPI_CI_RXFERR, BS_SPI_CI_RXFERR))
/*@}*/

/*!
 * @name Register SPI_CI, field TXFERR[7] (RO)
 *
 * This flag indicates that a transmit FIFO error occurred because entries in
 * the FIFO total more than 64 bits of data.
 *
 * Values:
 * - 0 - No transmit FIFO error occurred
 * - 1 - A transmit FIFO error occurred
 */
/*@{*/
#define BP_SPI_CI_TXFERR     (7U)          /*!< Bit position for SPI_CI_TXFERR. */
#define BM_SPI_CI_TXFERR     (0x80U)       /*!< Bit mask for SPI_CI_TXFERR. */
#define BS_SPI_CI_TXFERR     (1U)          /*!< Bit field size in bits for SPI_CI_TXFERR. */

/*! @brief Read current value of the SPI_CI_TXFERR field. */
#define BR_SPI_CI_TXFERR(x)  (BME_UBFX8(HW_SPI_CI_ADDR(x), BP_SPI_CI_TXFERR, BS_SPI_CI_TXFERR))
/*@}*/

/*******************************************************************************
 * HW_SPI_C3 - SPI control register 3
 ******************************************************************************/

/*!
 * @brief HW_SPI_C3 - SPI control register 3 (RW)
 *
 * Reset value: 0x00U
 *
 * This register introduces a 64-bit FIFO function on both transmit and receive
 * buffers. It applies only for an instance of the SPI module that supports the
 * FIFO feature. FIFO mode is enabled by setting the FIFOMODE bit to 1. A write to
 * this register occurs only when it sets the FIFOMODE bit to 1. Using this FIFO
 * feature allows the SPI to provide high speed transfers of large amounts of
 * data without consuming large amounts of the CPU bandwidth. Enabling this FIFO
 * function affects the behavior of some of the read/write buffer flags in the S
 * register as follows: When the receive FIFO has data in it, S[RFIFOEF] is 0. As a
 * result: If C2[RXDMAE] is 1, RFIFOEF_b generates a receive DMA request. The
 * DMA request remains active until RFIFOEF is set to 1, indicating the receive
 * buffer is empty. If C2[RXDMAE] is 0 and C1[SPIE] is 1, SPRF interrupts the CPU.
 * When the transmit FIFO is not full, S[TXFULLF] is 0. As a result: If C2[TXDMAE]
 * is 1, TXFULLF_b generates a transmit DMA request. The DMA request remains
 * active until TXFULLF is set to 1, indicating the transmit FIFO is full. If
 * C2[TXDMAE] is 0 and C1[SPTIE] is 1, SPTEF interrupts the CPU. Two interrupt enable
 * bits, TNEARIEN and RNFULLIEN, provide CPU interrupts based on the "watermark"
 * feature of the TNEARF and RNFULLF flags of the S register.
 */
typedef union _hw_spi_c3
{
    uint8_t U;
    struct _hw_spi_c3_bitfields
    {
        uint8_t FIFOMODE : 1;          /*!< [0] FIFO mode enable */
        uint8_t RNFULLIEN : 1;         /*!< [1] Receive FIFO nearly full interrupt
                                        * enable */
        uint8_t TNEARIEN : 1;          /*!< [2] Transmit FIFO nearly empty interrupt
                                        * enable */
        uint8_t INTCLR : 1;            /*!< [3] Interrupt clearing mechanism select */
        uint8_t RNFULLF_MARK : 1;      /*!< [4] Receive FIFO nearly full watermark
                                        * */
        uint8_t TNEAREF_MARK : 1;      /*!< [5] Transmit FIFO nearly empty
                                        * watermark */
        uint8_t RESERVED0 : 2;         /*!< [7:6]  */
    } B;
} hw_spi_c3_t;

/*!
 * @name Constants and macros for entire SPI_C3 register
 */
/*@{*/
#define HW_SPI_C3_ADDR(x)        ((uint32_t)(x) + 0xBU)

#define HW_SPI_C3(x)             (*(__IO hw_spi_c3_t *) HW_SPI_C3_ADDR(x))
#define HW_SPI_C3_RD(x)          (HW_SPI_C3(x).U)
#define HW_SPI_C3_WR(x, v)       (HW_SPI_C3(x).U = (v))
#define HW_SPI_C3_SET(x, v)      (BME_OR8(HW_SPI_C3_ADDR(x), (uint8_t)(v)))
#define HW_SPI_C3_CLR(x, v)      (BME_AND8(HW_SPI_C3_ADDR(x), (uint8_t)(~(v))))
#define HW_SPI_C3_TOG(x, v)      (BME_XOR8(HW_SPI_C3_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual SPI_C3 bitfields
 */

/*!
 * @name Register SPI_C3, field FIFOMODE[0] (RW)
 *
 * This bit enables the SPI to use a 64-bit FIFO (8 bytes or four 16-bit words)
 * for both transmit and receive buffers.
 *
 * Values:
 * - 0 - Buffer mode disabled
 * - 1 - Data available in the receive data buffer
 */
/*@{*/
#define BP_SPI_C3_FIFOMODE   (0U)          /*!< Bit position for SPI_C3_FIFOMODE. */
#define BM_SPI_C3_FIFOMODE   (0x01U)       /*!< Bit mask for SPI_C3_FIFOMODE. */
#define BS_SPI_C3_FIFOMODE   (1U)          /*!< Bit field size in bits for SPI_C3_FIFOMODE. */

/*! @brief Read current value of the SPI_C3_FIFOMODE field. */
#define BR_SPI_C3_FIFOMODE(x) (BME_UBFX8(HW_SPI_C3_ADDR(x), BP_SPI_C3_FIFOMODE, BS_SPI_C3_FIFOMODE))

/*! @brief Format value for bitfield SPI_C3_FIFOMODE. */
#define BF_SPI_C3_FIFOMODE(v) ((uint8_t)((uint8_t)(v) << BP_SPI_C3_FIFOMODE) & BM_SPI_C3_FIFOMODE)

/*! @brief Set the FIFOMODE field to a new value. */
#define BW_SPI_C3_FIFOMODE(x, v) (BME_BFI8(HW_SPI_C3_ADDR(x), ((uint8_t)(v) << BP_SPI_C3_FIFOMODE), BP_SPI_C3_FIFOMODE, 1))
/*@}*/

/*!
 * @name Register SPI_C3, field RNFULLIEN[1] (RW)
 *
 * Writing 1 to this bit enables the SPI to interrupt the CPU when the RNFULLF
 * flag is set. This bit is ignored and has no function if the FIFOMODE bit is 0.
 *
 * Values:
 * - 0 - No interrupt upon RNFULLF being set
 * - 1 - Enable interrupts upon RNFULLF being set
 */
/*@{*/
#define BP_SPI_C3_RNFULLIEN  (1U)          /*!< Bit position for SPI_C3_RNFULLIEN. */
#define BM_SPI_C3_RNFULLIEN  (0x02U)       /*!< Bit mask for SPI_C3_RNFULLIEN. */
#define BS_SPI_C3_RNFULLIEN  (1U)          /*!< Bit field size in bits for SPI_C3_RNFULLIEN. */

/*! @brief Read current value of the SPI_C3_RNFULLIEN field. */
#define BR_SPI_C3_RNFULLIEN(x) (BME_UBFX8(HW_SPI_C3_ADDR(x), BP_SPI_C3_RNFULLIEN, BS_SPI_C3_RNFULLIEN))

/*! @brief Format value for bitfield SPI_C3_RNFULLIEN. */
#define BF_SPI_C3_RNFULLIEN(v) ((uint8_t)((uint8_t)(v) << BP_SPI_C3_RNFULLIEN) & BM_SPI_C3_RNFULLIEN)

/*! @brief Set the RNFULLIEN field to a new value. */
#define BW_SPI_C3_RNFULLIEN(x, v) (BME_BFI8(HW_SPI_C3_ADDR(x), ((uint8_t)(v) << BP_SPI_C3_RNFULLIEN), BP_SPI_C3_RNFULLIEN, 1))
/*@}*/

/*!
 * @name Register SPI_C3, field TNEARIEN[2] (RW)
 *
 * Writing 1 to this bit enables the SPI to interrupt the CPU when the TNEAREF
 * flag is set. This bit is ignored and has no function if the FIFOMODE bit is 0.
 *
 * Values:
 * - 0 - No interrupt upon TNEAREF being set
 * - 1 - Enable interrupts upon TNEAREF being set
 */
/*@{*/
#define BP_SPI_C3_TNEARIEN   (2U)          /*!< Bit position for SPI_C3_TNEARIEN. */
#define BM_SPI_C3_TNEARIEN   (0x04U)       /*!< Bit mask for SPI_C3_TNEARIEN. */
#define BS_SPI_C3_TNEARIEN   (1U)          /*!< Bit field size in bits for SPI_C3_TNEARIEN. */

/*! @brief Read current value of the SPI_C3_TNEARIEN field. */
#define BR_SPI_C3_TNEARIEN(x) (BME_UBFX8(HW_SPI_C3_ADDR(x), BP_SPI_C3_TNEARIEN, BS_SPI_C3_TNEARIEN))

/*! @brief Format value for bitfield SPI_C3_TNEARIEN. */
#define BF_SPI_C3_TNEARIEN(v) ((uint8_t)((uint8_t)(v) << BP_SPI_C3_TNEARIEN) & BM_SPI_C3_TNEARIEN)

/*! @brief Set the TNEARIEN field to a new value. */
#define BW_SPI_C3_TNEARIEN(x, v) (BME_BFI8(HW_SPI_C3_ADDR(x), ((uint8_t)(v) << BP_SPI_C3_TNEARIEN), BP_SPI_C3_TNEARIEN, 1))
/*@}*/

/*!
 * @name Register SPI_C3, field INTCLR[3] (RW)
 *
 * This bit selects the mechanism by which the SPRF, SPTEF, TNEAREF, and RNFULLF
 * interrupts are cleared.
 *
 * Values:
 * - 0 - These interrupts are cleared when the corresponding flags are cleared
 *     depending on the state of the FIFOs
 * - 1 - These interrupts are cleared by writing the corresponding bits in the
 *     CI register
 */
/*@{*/
#define BP_SPI_C3_INTCLR     (3U)          /*!< Bit position for SPI_C3_INTCLR. */
#define BM_SPI_C3_INTCLR     (0x08U)       /*!< Bit mask for SPI_C3_INTCLR. */
#define BS_SPI_C3_INTCLR     (1U)          /*!< Bit field size in bits for SPI_C3_INTCLR. */

/*! @brief Read current value of the SPI_C3_INTCLR field. */
#define BR_SPI_C3_INTCLR(x)  (BME_UBFX8(HW_SPI_C3_ADDR(x), BP_SPI_C3_INTCLR, BS_SPI_C3_INTCLR))

/*! @brief Format value for bitfield SPI_C3_INTCLR. */
#define BF_SPI_C3_INTCLR(v)  ((uint8_t)((uint8_t)(v) << BP_SPI_C3_INTCLR) & BM_SPI_C3_INTCLR)

/*! @brief Set the INTCLR field to a new value. */
#define BW_SPI_C3_INTCLR(x, v) (BME_BFI8(HW_SPI_C3_ADDR(x), ((uint8_t)(v) << BP_SPI_C3_INTCLR), BP_SPI_C3_INTCLR, 1))
/*@}*/

/*!
 * @name Register SPI_C3, field RNFULLF_MARK[4] (RW)
 *
 * This bit selects the mark after which the RNFULLF flag is asserted.
 *
 * Values:
 * - 0 - RNFULLF is set when the receive FIFO has 48 bits or more
 * - 1 - RNFULLF is set when the receive FIFO has 32 bits or more
 */
/*@{*/
#define BP_SPI_C3_RNFULLF_MARK (4U)        /*!< Bit position for SPI_C3_RNFULLF_MARK. */
#define BM_SPI_C3_RNFULLF_MARK (0x10U)     /*!< Bit mask for SPI_C3_RNFULLF_MARK. */
#define BS_SPI_C3_RNFULLF_MARK (1U)        /*!< Bit field size in bits for SPI_C3_RNFULLF_MARK. */

/*! @brief Read current value of the SPI_C3_RNFULLF_MARK field. */
#define BR_SPI_C3_RNFULLF_MARK(x) (BME_UBFX8(HW_SPI_C3_ADDR(x), BP_SPI_C3_RNFULLF_MARK, BS_SPI_C3_RNFULLF_MARK))

/*! @brief Format value for bitfield SPI_C3_RNFULLF_MARK. */
#define BF_SPI_C3_RNFULLF_MARK(v) ((uint8_t)((uint8_t)(v) << BP_SPI_C3_RNFULLF_MARK) & BM_SPI_C3_RNFULLF_MARK)

/*! @brief Set the RNFULLF_MARK field to a new value. */
#define BW_SPI_C3_RNFULLF_MARK(x, v) (BME_BFI8(HW_SPI_C3_ADDR(x), ((uint8_t)(v) << BP_SPI_C3_RNFULLF_MARK), BP_SPI_C3_RNFULLF_MARK, 1))
/*@}*/

/*!
 * @name Register SPI_C3, field TNEAREF_MARK[5] (RW)
 *
 * This bit selects the mark after which the TNEAREF flag is asserted.
 *
 * Values:
 * - 0 - TNEAREF is set when the transmit FIFO has 16 bits or less
 * - 1 - TNEAREF is set when the transmit FIFO has 32 bits or less
 */
/*@{*/
#define BP_SPI_C3_TNEAREF_MARK (5U)        /*!< Bit position for SPI_C3_TNEAREF_MARK. */
#define BM_SPI_C3_TNEAREF_MARK (0x20U)     /*!< Bit mask for SPI_C3_TNEAREF_MARK. */
#define BS_SPI_C3_TNEAREF_MARK (1U)        /*!< Bit field size in bits for SPI_C3_TNEAREF_MARK. */

/*! @brief Read current value of the SPI_C3_TNEAREF_MARK field. */
#define BR_SPI_C3_TNEAREF_MARK(x) (BME_UBFX8(HW_SPI_C3_ADDR(x), BP_SPI_C3_TNEAREF_MARK, BS_SPI_C3_TNEAREF_MARK))

/*! @brief Format value for bitfield SPI_C3_TNEAREF_MARK. */
#define BF_SPI_C3_TNEAREF_MARK(v) ((uint8_t)((uint8_t)(v) << BP_SPI_C3_TNEAREF_MARK) & BM_SPI_C3_TNEAREF_MARK)

/*! @brief Set the TNEAREF_MARK field to a new value. */
#define BW_SPI_C3_TNEAREF_MARK(x, v) (BME_BFI8(HW_SPI_C3_ADDR(x), ((uint8_t)(v) << BP_SPI_C3_TNEAREF_MARK), BP_SPI_C3_TNEAREF_MARK, 1))
/*@}*/

/*******************************************************************************
 * hw_spi_t - module struct
 ******************************************************************************/
/*!
 * @brief All SPI module registers.
 */
#pragma pack(1)
typedef struct _hw_spi
{
    __I hw_spi_s_t S;                      /*!< [0x0] SPI Status Register */
    __IO hw_spi_br_t BR;                   /*!< [0x1] SPI Baud Rate Register */
    __IO hw_spi_c2_t C2;                   /*!< [0x2] SPI Control Register 2 */
    __IO hw_spi_c1_t C1;                   /*!< [0x3] SPI Control Register 1 */
    __IO hw_spi_ml_t ML;                   /*!< [0x4] SPI Match Register low */
    __IO hw_spi_mh_t MH;                   /*!< [0x5] SPI match register high */
    __IO hw_spi_dl_t DL;                   /*!< [0x6] SPI Data Register low */
    __IO hw_spi_dh_t DH;                   /*!< [0x7] SPI data register high */
    uint8_t _reserved0[2];
    __IO hw_spi_ci_t CI;                   /*!< [0xA] SPI clear interrupt register */
    __IO hw_spi_c3_t C3;                   /*!< [0xB] SPI control register 3 */
} hw_spi_t;
#pragma pack()

/*! @brief Macro to access all SPI registers. */
/*! @param x SPI module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_SPI_REGS(SPI0_BASE)</code>. */
#define HW_SPI_REGS(x) (*(hw_spi_t *)(x))

/*
 * MKL43Z4 TPM
 *
 * Timer/PWM Module
 *
 * Registers defined in this header file:
 * - HW_TPM_SC - Status and Control
 * - HW_TPM_CNT - Counter
 * - HW_TPM_MOD - Modulo
 * - HW_TPM_CnSC - Channel (n) Status and Control
 * - HW_TPM_CnV - Channel (n) Value
 * - HW_TPM_STATUS - Capture and Compare Status
 * - HW_TPM_POL - Channel Polarity
 * - HW_TPM_CONF - Configuration
 *
 * - hw_tpm_t - Struct containing all module registers.
 */

#define HW_TPM_INSTANCE_COUNT (3U) /*!< Number of instances of the TPM module. */
#define HW_TPM0 (0U) /*!< Instance number for TPM0. */
#define HW_TPM1 (1U) /*!< Instance number for TPM1. */
#define HW_TPM2 (2U) /*!< Instance number for TPM2. */

/*******************************************************************************
 * HW_TPM_SC - Status and Control
 ******************************************************************************/

/*!
 * @brief HW_TPM_SC - Status and Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * SC contains the overflow status flag and control bits used to configure the
 * interrupt enable, module configuration and prescaler factor. These controls
 * relate to all channels within this module.
 */
typedef union _hw_tpm_sc
{
    uint32_t U;
    struct _hw_tpm_sc_bitfields
    {
        uint32_t PS : 3;               /*!< [2:0] Prescale Factor Selection */
        uint32_t CMOD : 2;             /*!< [4:3] Clock Mode Selection */
        uint32_t CPWMS : 1;            /*!< [5] Center-Aligned PWM Select */
        uint32_t TOIE : 1;             /*!< [6] Timer Overflow Interrupt Enable */
        uint32_t TOF : 1;              /*!< [7] Timer Overflow Flag */
        uint32_t DMA : 1;              /*!< [8] DMA Enable */
        uint32_t RESERVED0 : 23;       /*!< [31:9]  */
    } B;
} hw_tpm_sc_t;

/*!
 * @name Constants and macros for entire TPM_SC register
 */
/*@{*/
#define HW_TPM_SC_ADDR(x)        ((uint32_t)(x) + 0x0U)

#define HW_TPM_SC(x)             (*(__IO hw_tpm_sc_t *) HW_TPM_SC_ADDR(x))
#define HW_TPM_SC_RD(x)          (HW_TPM_SC(x).U)
#define HW_TPM_SC_WR(x, v)       (HW_TPM_SC(x).U = (v))
#define HW_TPM_SC_SET(x, v)      (BME_OR32(HW_TPM_SC_ADDR(x), (uint32_t)(v)))
#define HW_TPM_SC_CLR(x, v)      (BME_AND32(HW_TPM_SC_ADDR(x), (uint32_t)(~(v))))
#define HW_TPM_SC_TOG(x, v)      (BME_XOR32(HW_TPM_SC_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual TPM_SC bitfields
 */

/*!
 * @name Register TPM_SC, field PS[2:0] (RW)
 *
 * Selects one of 8 division factors for the clock mode selected by CMOD. This
 * field is write protected. It can be written only when the counter is disabled.
 *
 * Values:
 * - 000 - Divide by 1
 * - 001 - Divide by 2
 * - 010 - Divide by 4
 * - 011 - Divide by 8
 * - 100 - Divide by 16
 * - 101 - Divide by 32
 * - 110 - Divide by 64
 * - 111 - Divide by 128
 */
/*@{*/
#define BP_TPM_SC_PS         (0U)          /*!< Bit position for TPM_SC_PS. */
#define BM_TPM_SC_PS         (0x00000007U) /*!< Bit mask for TPM_SC_PS. */
#define BS_TPM_SC_PS         (3U)          /*!< Bit field size in bits for TPM_SC_PS. */

/*! @brief Read current value of the TPM_SC_PS field. */
#define BR_TPM_SC_PS(x)      (BME_UBFX32(HW_TPM_SC_ADDR(x), BP_TPM_SC_PS, BS_TPM_SC_PS))

/*! @brief Format value for bitfield TPM_SC_PS. */
#define BF_TPM_SC_PS(v)      ((uint32_t)((uint32_t)(v) << BP_TPM_SC_PS) & BM_TPM_SC_PS)

/*! @brief Set the PS field to a new value. */
#define BW_TPM_SC_PS(x, v)   (BME_BFI32(HW_TPM_SC_ADDR(x), ((uint32_t)(v) << BP_TPM_SC_PS), BP_TPM_SC_PS, 3))
/*@}*/

/*!
 * @name Register TPM_SC, field CMOD[4:3] (RW)
 *
 * Selects the TPM counter clock modes. When disabling the counter, this field
 * remain set until acknolwedged in the TPM clock domain.
 *
 * Values:
 * - 00 - TPM counter is disabled
 * - 01 - TPM counter increments on every TPM counter clock
 * - 10 - TPM counter increments on rising edge of TPM_EXTCLK synchronized to
 *     the TPM counter clock
 * - 11 - Reserved
 */
/*@{*/
#define BP_TPM_SC_CMOD       (3U)          /*!< Bit position for TPM_SC_CMOD. */
#define BM_TPM_SC_CMOD       (0x00000018U) /*!< Bit mask for TPM_SC_CMOD. */
#define BS_TPM_SC_CMOD       (2U)          /*!< Bit field size in bits for TPM_SC_CMOD. */

/*! @brief Read current value of the TPM_SC_CMOD field. */
#define BR_TPM_SC_CMOD(x)    (BME_UBFX32(HW_TPM_SC_ADDR(x), BP_TPM_SC_CMOD, BS_TPM_SC_CMOD))

/*! @brief Format value for bitfield TPM_SC_CMOD. */
#define BF_TPM_SC_CMOD(v)    ((uint32_t)((uint32_t)(v) << BP_TPM_SC_CMOD) & BM_TPM_SC_CMOD)

/*! @brief Set the CMOD field to a new value. */
#define BW_TPM_SC_CMOD(x, v) (BME_BFI32(HW_TPM_SC_ADDR(x), ((uint32_t)(v) << BP_TPM_SC_CMOD), BP_TPM_SC_CMOD, 2))
/*@}*/

/*!
 * @name Register TPM_SC, field CPWMS[5] (RW)
 *
 * Selects CPWM mode. This mode configures the TPM to operate in up-down
 * counting mode. This field is write protected. It can be written only when the counter
 * is disabled.
 *
 * Values:
 * - 0 - TPM counter operates in up counting mode.
 * - 1 - TPM counter operates in up-down counting mode.
 */
/*@{*/
#define BP_TPM_SC_CPWMS      (5U)          /*!< Bit position for TPM_SC_CPWMS. */
#define BM_TPM_SC_CPWMS      (0x00000020U) /*!< Bit mask for TPM_SC_CPWMS. */
#define BS_TPM_SC_CPWMS      (1U)          /*!< Bit field size in bits for TPM_SC_CPWMS. */

/*! @brief Read current value of the TPM_SC_CPWMS field. */
#define BR_TPM_SC_CPWMS(x)   (BME_UBFX32(HW_TPM_SC_ADDR(x), BP_TPM_SC_CPWMS, BS_TPM_SC_CPWMS))

/*! @brief Format value for bitfield TPM_SC_CPWMS. */
#define BF_TPM_SC_CPWMS(v)   ((uint32_t)((uint32_t)(v) << BP_TPM_SC_CPWMS) & BM_TPM_SC_CPWMS)

/*! @brief Set the CPWMS field to a new value. */
#define BW_TPM_SC_CPWMS(x, v) (BME_BFI32(HW_TPM_SC_ADDR(x), ((uint32_t)(v) << BP_TPM_SC_CPWMS), BP_TPM_SC_CPWMS, 1))
/*@}*/

/*!
 * @name Register TPM_SC, field TOIE[6] (RW)
 *
 * Enables TPM overflow interrupts.
 *
 * Values:
 * - 0 - Disable TOF interrupts. Use software polling or DMA request.
 * - 1 - Enable TOF interrupts. An interrupt is generated when TOF equals one.
 */
/*@{*/
#define BP_TPM_SC_TOIE       (6U)          /*!< Bit position for TPM_SC_TOIE. */
#define BM_TPM_SC_TOIE       (0x00000040U) /*!< Bit mask for TPM_SC_TOIE. */
#define BS_TPM_SC_TOIE       (1U)          /*!< Bit field size in bits for TPM_SC_TOIE. */

/*! @brief Read current value of the TPM_SC_TOIE field. */
#define BR_TPM_SC_TOIE(x)    (BME_UBFX32(HW_TPM_SC_ADDR(x), BP_TPM_SC_TOIE, BS_TPM_SC_TOIE))

/*! @brief Format value for bitfield TPM_SC_TOIE. */
#define BF_TPM_SC_TOIE(v)    ((uint32_t)((uint32_t)(v) << BP_TPM_SC_TOIE) & BM_TPM_SC_TOIE)

/*! @brief Set the TOIE field to a new value. */
#define BW_TPM_SC_TOIE(x, v) (BME_BFI32(HW_TPM_SC_ADDR(x), ((uint32_t)(v) << BP_TPM_SC_TOIE), BP_TPM_SC_TOIE, 1))
/*@}*/

/*!
 * @name Register TPM_SC, field TOF[7] (W1C)
 *
 * Set by hardware when the TPM counter equals the value in the MOD register and
 * increments. Writing a 1 to TOF clears it. Writing a 0 to TOF has no effect.
 * If another TPM overflow occurs between the flag setting and the flag clearing,
 * the write operation has no effect; therefore, TOF remains set indicating
 * another overflow has occurred. In this case a TOF interrupt request is not lost due
 * to a delay in clearing the previous TOF.
 *
 * Values:
 * - 0 - TPM counter has not overflowed.
 * - 1 - TPM counter has overflowed.
 */
/*@{*/
#define BP_TPM_SC_TOF        (7U)          /*!< Bit position for TPM_SC_TOF. */
#define BM_TPM_SC_TOF        (0x00000080U) /*!< Bit mask for TPM_SC_TOF. */
#define BS_TPM_SC_TOF        (1U)          /*!< Bit field size in bits for TPM_SC_TOF. */

/*! @brief Read current value of the TPM_SC_TOF field. */
#define BR_TPM_SC_TOF(x)     (BME_UBFX32(HW_TPM_SC_ADDR(x), BP_TPM_SC_TOF, BS_TPM_SC_TOF))

/*! @brief Format value for bitfield TPM_SC_TOF. */
#define BF_TPM_SC_TOF(v)     ((uint32_t)((uint32_t)(v) << BP_TPM_SC_TOF) & BM_TPM_SC_TOF)

/*! @brief Set the TOF field to a new value. */
#define BW_TPM_SC_TOF(x, v)  (BME_BFI32(HW_TPM_SC_ADDR(x), ((uint32_t)(v) << BP_TPM_SC_TOF), BP_TPM_SC_TOF, 1))
/*@}*/

/*!
 * @name Register TPM_SC, field DMA[8] (RW)
 *
 * Enables DMA transfers for the overflow flag.
 *
 * Values:
 * - 0 - Disables DMA transfers.
 * - 1 - Enables DMA transfers.
 */
/*@{*/
#define BP_TPM_SC_DMA        (8U)          /*!< Bit position for TPM_SC_DMA. */
#define BM_TPM_SC_DMA        (0x00000100U) /*!< Bit mask for TPM_SC_DMA. */
#define BS_TPM_SC_DMA        (1U)          /*!< Bit field size in bits for TPM_SC_DMA. */

/*! @brief Read current value of the TPM_SC_DMA field. */
#define BR_TPM_SC_DMA(x)     (BME_UBFX32(HW_TPM_SC_ADDR(x), BP_TPM_SC_DMA, BS_TPM_SC_DMA))

/*! @brief Format value for bitfield TPM_SC_DMA. */
#define BF_TPM_SC_DMA(v)     ((uint32_t)((uint32_t)(v) << BP_TPM_SC_DMA) & BM_TPM_SC_DMA)

/*! @brief Set the DMA field to a new value. */
#define BW_TPM_SC_DMA(x, v)  (BME_BFI32(HW_TPM_SC_ADDR(x), ((uint32_t)(v) << BP_TPM_SC_DMA), BP_TPM_SC_DMA, 1))
/*@}*/

/*******************************************************************************
 * HW_TPM_CNT - Counter
 ******************************************************************************/

/*!
 * @brief HW_TPM_CNT - Counter (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CNT register contains the TPM counter value. Reset clears the CNT
 * register. Writing any value to COUNT also clears the counter. When debug is active,
 * the TPM counter does not increment unless configured otherwise. Reading the CNT
 * register adds two wait states to the register access due to synchronization
 * delays.
 */
typedef union _hw_tpm_cnt
{
    uint32_t U;
    struct _hw_tpm_cnt_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Counter value */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_tpm_cnt_t;

/*!
 * @name Constants and macros for entire TPM_CNT register
 */
/*@{*/
#define HW_TPM_CNT_ADDR(x)       ((uint32_t)(x) + 0x4U)

#define HW_TPM_CNT(x)            (*(__IO hw_tpm_cnt_t *) HW_TPM_CNT_ADDR(x))
#define HW_TPM_CNT_RD(x)         (HW_TPM_CNT(x).U)
#define HW_TPM_CNT_WR(x, v)      (HW_TPM_CNT(x).U = (v))
#define HW_TPM_CNT_SET(x, v)     (BME_OR32(HW_TPM_CNT_ADDR(x), (uint32_t)(v)))
#define HW_TPM_CNT_CLR(x, v)     (BME_AND32(HW_TPM_CNT_ADDR(x), (uint32_t)(~(v))))
#define HW_TPM_CNT_TOG(x, v)     (BME_XOR32(HW_TPM_CNT_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual TPM_CNT bitfields
 */

/*!
 * @name Register TPM_CNT, field COUNT[15:0] (RW)
 */
/*@{*/
#define BP_TPM_CNT_COUNT     (0U)          /*!< Bit position for TPM_CNT_COUNT. */
#define BM_TPM_CNT_COUNT     (0x0000FFFFU) /*!< Bit mask for TPM_CNT_COUNT. */
#define BS_TPM_CNT_COUNT     (16U)         /*!< Bit field size in bits for TPM_CNT_COUNT. */

/*! @brief Read current value of the TPM_CNT_COUNT field. */
#define BR_TPM_CNT_COUNT(x)  (BME_UBFX32(HW_TPM_CNT_ADDR(x), BP_TPM_CNT_COUNT, BS_TPM_CNT_COUNT))

/*! @brief Format value for bitfield TPM_CNT_COUNT. */
#define BF_TPM_CNT_COUNT(v)  ((uint32_t)((uint32_t)(v) << BP_TPM_CNT_COUNT) & BM_TPM_CNT_COUNT)

/*! @brief Set the COUNT field to a new value. */
#define BW_TPM_CNT_COUNT(x, v) (BME_BFI32(HW_TPM_CNT_ADDR(x), ((uint32_t)(v) << BP_TPM_CNT_COUNT), BP_TPM_CNT_COUNT, 16))
/*@}*/

/*******************************************************************************
 * HW_TPM_MOD - Modulo
 ******************************************************************************/

/*!
 * @brief HW_TPM_MOD - Modulo (RW)
 *
 * Reset value: 0x0000FFFFU
 *
 * The Modulo register contains the modulo value for the TPM counter. When the
 * TPM counter reaches the modulo value and increments, the overflow flag (TOF) is
 * set and the next value of TPM counter depends on the selected counting method
 * (see CounterThe TPM has a 16-bit counter that is used by the channels either
 * for input or output modes. ). Writing to the MOD register latches the value
 * into a buffer. The MOD register is updated with the value of its write buffer
 * according to MOD Register Update . Additional writes to the MOD write buffer are
 * ignored until the register has been updated. It is recommended to initialize
 * the TPM counter (write to CNT) before writing to the MOD register to avoid
 * confusion about when the first counter overflow will occur.
 */
typedef union _hw_tpm_mod
{
    uint32_t U;
    struct _hw_tpm_mod_bitfields
    {
        uint32_t MOD : 16;             /*!< [15:0] Modulo value */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_tpm_mod_t;

/*!
 * @name Constants and macros for entire TPM_MOD register
 */
/*@{*/
#define HW_TPM_MOD_ADDR(x)       ((uint32_t)(x) + 0x8U)

#define HW_TPM_MOD(x)            (*(__IO hw_tpm_mod_t *) HW_TPM_MOD_ADDR(x))
#define HW_TPM_MOD_RD(x)         (HW_TPM_MOD(x).U)
#define HW_TPM_MOD_WR(x, v)      (HW_TPM_MOD(x).U = (v))
#define HW_TPM_MOD_SET(x, v)     (BME_OR32(HW_TPM_MOD_ADDR(x), (uint32_t)(v)))
#define HW_TPM_MOD_CLR(x, v)     (BME_AND32(HW_TPM_MOD_ADDR(x), (uint32_t)(~(v))))
#define HW_TPM_MOD_TOG(x, v)     (BME_XOR32(HW_TPM_MOD_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual TPM_MOD bitfields
 */

/*!
 * @name Register TPM_MOD, field MOD[15:0] (RW)
 *
 * When writing this field, all bytes must be written at the same time.
 */
/*@{*/
#define BP_TPM_MOD_MOD       (0U)          /*!< Bit position for TPM_MOD_MOD. */
#define BM_TPM_MOD_MOD       (0x0000FFFFU) /*!< Bit mask for TPM_MOD_MOD. */
#define BS_TPM_MOD_MOD       (16U)         /*!< Bit field size in bits for TPM_MOD_MOD. */

/*! @brief Read current value of the TPM_MOD_MOD field. */
#define BR_TPM_MOD_MOD(x)    (BME_UBFX32(HW_TPM_MOD_ADDR(x), BP_TPM_MOD_MOD, BS_TPM_MOD_MOD))

/*! @brief Format value for bitfield TPM_MOD_MOD. */
#define BF_TPM_MOD_MOD(v)    ((uint32_t)((uint32_t)(v) << BP_TPM_MOD_MOD) & BM_TPM_MOD_MOD)

/*! @brief Set the MOD field to a new value. */
#define BW_TPM_MOD_MOD(x, v) (BME_BFI32(HW_TPM_MOD_ADDR(x), ((uint32_t)(v) << BP_TPM_MOD_MOD), BP_TPM_MOD_MOD, 16))
/*@}*/

/*******************************************************************************
 * HW_TPM_CnSC - Channel (n) Status and Control
 ******************************************************************************/

/*!
 * @brief HW_TPM_CnSC - Channel (n) Status and Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * CnSC contains the channel-interrupt-status flag and control bits used to
 * configure the interrupt enable, channel configuration, and pin function. When
 * switching from one channel mode to a different channel mode, the channel must
 * first be disabled and this must be acknowledged in the TPM counter clock domain.
 * Mode, Edge, and Level Selection CPWMS MSnB:MSnA ELSnB:ELSnA Mode Configuration
 * X 00 00 None Channel disabled X 01 00 Software compare Pin not used for TPM 0
 * 00 01 Input capture Capture on Rising Edge Only 10 Capture on Falling Edge
 * Only 11 Capture on Rising or Falling Edge 01 01 Output compare Toggle Output on
 * match 10 Clear Output on match 11 Set Output on match 10 10 Edge-aligned PWM
 * High-true pulses (clear Output on match, set Output on reload) X1 Low-true
 * pulses (set Output on match, clear Output on reload) 11 10 Output compare Pulse
 * Output low on match 01 Pulse Output high on match 1 10 10 Center-aligned PWM
 * High-true pulses (clear Output on match-up, set Output on match-down) 01 Low-true
 * pulses (set Output on match-up, clear Output on match-down)
 */
typedef union _hw_tpm_cnsc
{
    uint32_t U;
    struct _hw_tpm_cnsc_bitfields
    {
        uint32_t DMA : 1;              /*!< [0] DMA Enable */
        uint32_t RESERVED0 : 1;        /*!< [1]  */
        uint32_t ELSA : 1;             /*!< [2] Edge or Level Select */
        uint32_t ELSB : 1;             /*!< [3] Edge or Level Select */
        uint32_t MSA : 1;              /*!< [4] Channel Mode Select */
        uint32_t MSB : 1;              /*!< [5] Channel Mode Select */
        uint32_t CHIE : 1;             /*!< [6] Channel Interrupt Enable */
        uint32_t CHF : 1;              /*!< [7] Channel Flag */
        uint32_t RESERVED1 : 24;       /*!< [31:8]  */
    } B;
} hw_tpm_cnsc_t;

/*!
 * @name Constants and macros for entire TPM_CnSC register
 */
/*@{*/
#define HW_TPM_CnSC_COUNT (6U)

#define HW_TPM_CnSC_ADDR(x, n)   ((uint32_t)(x) + 0xCU + (0x8U * (n)))

#define HW_TPM_CnSC(x, n)        (*(__IO hw_tpm_cnsc_t *) HW_TPM_CnSC_ADDR(x, n))
#define HW_TPM_CnSC_RD(x, n)     (HW_TPM_CnSC(x, n).U)
#define HW_TPM_CnSC_WR(x, n, v)  (HW_TPM_CnSC(x, n).U = (v))
#define HW_TPM_CnSC_SET(x, n, v) (BME_OR32(HW_TPM_CnSC_ADDR(x, n), (uint32_t)(v)))
#define HW_TPM_CnSC_CLR(x, n, v) (BME_AND32(HW_TPM_CnSC_ADDR(x, n), (uint32_t)(~(v))))
#define HW_TPM_CnSC_TOG(x, n, v) (BME_XOR32(HW_TPM_CnSC_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual TPM_CnSC bitfields
 */

/*!
 * @name Register TPM_CnSC, field DMA[0] (RW)
 *
 * Enables DMA transfers for the channel.
 *
 * Values:
 * - 0 - Disable DMA transfers.
 * - 1 - Enable DMA transfers.
 */
/*@{*/
#define BP_TPM_CnSC_DMA      (0U)          /*!< Bit position for TPM_CnSC_DMA. */
#define BM_TPM_CnSC_DMA      (0x00000001U) /*!< Bit mask for TPM_CnSC_DMA. */
#define BS_TPM_CnSC_DMA      (1U)          /*!< Bit field size in bits for TPM_CnSC_DMA. */

/*! @brief Read current value of the TPM_CnSC_DMA field. */
#define BR_TPM_CnSC_DMA(x, n) (BME_UBFX32(HW_TPM_CnSC_ADDR(x, n), BP_TPM_CnSC_DMA, BS_TPM_CnSC_DMA))

/*! @brief Format value for bitfield TPM_CnSC_DMA. */
#define BF_TPM_CnSC_DMA(v)   ((uint32_t)((uint32_t)(v) << BP_TPM_CnSC_DMA) & BM_TPM_CnSC_DMA)

/*! @brief Set the DMA field to a new value. */
#define BW_TPM_CnSC_DMA(x, n, v) (BME_BFI32(HW_TPM_CnSC_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnSC_DMA), BP_TPM_CnSC_DMA, 1))
/*@}*/

/*!
 * @name Register TPM_CnSC, field ELSA[2] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. When a
 * channel is disabled, this field will not change state until acknowledged in the TPM
 * counter clock domain.
 */
/*@{*/
#define BP_TPM_CnSC_ELSA     (2U)          /*!< Bit position for TPM_CnSC_ELSA. */
#define BM_TPM_CnSC_ELSA     (0x00000004U) /*!< Bit mask for TPM_CnSC_ELSA. */
#define BS_TPM_CnSC_ELSA     (1U)          /*!< Bit field size in bits for TPM_CnSC_ELSA. */

/*! @brief Read current value of the TPM_CnSC_ELSA field. */
#define BR_TPM_CnSC_ELSA(x, n) (BME_UBFX32(HW_TPM_CnSC_ADDR(x, n), BP_TPM_CnSC_ELSA, BS_TPM_CnSC_ELSA))

/*! @brief Format value for bitfield TPM_CnSC_ELSA. */
#define BF_TPM_CnSC_ELSA(v)  ((uint32_t)((uint32_t)(v) << BP_TPM_CnSC_ELSA) & BM_TPM_CnSC_ELSA)

/*! @brief Set the ELSA field to a new value. */
#define BW_TPM_CnSC_ELSA(x, n, v) (BME_BFI32(HW_TPM_CnSC_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnSC_ELSA), BP_TPM_CnSC_ELSA, 1))
/*@}*/

/*!
 * @name Register TPM_CnSC, field ELSB[3] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. When a
 * channel is disabled, this field will not change state until acknowledged in the TPM
 * counter clock domain.
 */
/*@{*/
#define BP_TPM_CnSC_ELSB     (3U)          /*!< Bit position for TPM_CnSC_ELSB. */
#define BM_TPM_CnSC_ELSB     (0x00000008U) /*!< Bit mask for TPM_CnSC_ELSB. */
#define BS_TPM_CnSC_ELSB     (1U)          /*!< Bit field size in bits for TPM_CnSC_ELSB. */

/*! @brief Read current value of the TPM_CnSC_ELSB field. */
#define BR_TPM_CnSC_ELSB(x, n) (BME_UBFX32(HW_TPM_CnSC_ADDR(x, n), BP_TPM_CnSC_ELSB, BS_TPM_CnSC_ELSB))

/*! @brief Format value for bitfield TPM_CnSC_ELSB. */
#define BF_TPM_CnSC_ELSB(v)  ((uint32_t)((uint32_t)(v) << BP_TPM_CnSC_ELSB) & BM_TPM_CnSC_ELSB)

/*! @brief Set the ELSB field to a new value. */
#define BW_TPM_CnSC_ELSB(x, n, v) (BME_BFI32(HW_TPM_CnSC_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnSC_ELSB), BP_TPM_CnSC_ELSB, 1))
/*@}*/

/*!
 * @name Register TPM_CnSC, field MSA[4] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. When a channel is disabled, this field will not
 * change state until acknowledged in the TPM counter clock domain.
 */
/*@{*/
#define BP_TPM_CnSC_MSA      (4U)          /*!< Bit position for TPM_CnSC_MSA. */
#define BM_TPM_CnSC_MSA      (0x00000010U) /*!< Bit mask for TPM_CnSC_MSA. */
#define BS_TPM_CnSC_MSA      (1U)          /*!< Bit field size in bits for TPM_CnSC_MSA. */

/*! @brief Read current value of the TPM_CnSC_MSA field. */
#define BR_TPM_CnSC_MSA(x, n) (BME_UBFX32(HW_TPM_CnSC_ADDR(x, n), BP_TPM_CnSC_MSA, BS_TPM_CnSC_MSA))

/*! @brief Format value for bitfield TPM_CnSC_MSA. */
#define BF_TPM_CnSC_MSA(v)   ((uint32_t)((uint32_t)(v) << BP_TPM_CnSC_MSA) & BM_TPM_CnSC_MSA)

/*! @brief Set the MSA field to a new value. */
#define BW_TPM_CnSC_MSA(x, n, v) (BME_BFI32(HW_TPM_CnSC_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnSC_MSA), BP_TPM_CnSC_MSA, 1))
/*@}*/

/*!
 * @name Register TPM_CnSC, field MSB[5] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. When a channel is disabled, this field will not
 * change state until acknowledged in the TPM counter clock domain.
 */
/*@{*/
#define BP_TPM_CnSC_MSB      (5U)          /*!< Bit position for TPM_CnSC_MSB. */
#define BM_TPM_CnSC_MSB      (0x00000020U) /*!< Bit mask for TPM_CnSC_MSB. */
#define BS_TPM_CnSC_MSB      (1U)          /*!< Bit field size in bits for TPM_CnSC_MSB. */

/*! @brief Read current value of the TPM_CnSC_MSB field. */
#define BR_TPM_CnSC_MSB(x, n) (BME_UBFX32(HW_TPM_CnSC_ADDR(x, n), BP_TPM_CnSC_MSB, BS_TPM_CnSC_MSB))

/*! @brief Format value for bitfield TPM_CnSC_MSB. */
#define BF_TPM_CnSC_MSB(v)   ((uint32_t)((uint32_t)(v) << BP_TPM_CnSC_MSB) & BM_TPM_CnSC_MSB)

/*! @brief Set the MSB field to a new value. */
#define BW_TPM_CnSC_MSB(x, n, v) (BME_BFI32(HW_TPM_CnSC_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnSC_MSB), BP_TPM_CnSC_MSB, 1))
/*@}*/

/*!
 * @name Register TPM_CnSC, field CHIE[6] (RW)
 *
 * Enables channel interrupts.
 *
 * Values:
 * - 0 - Disable channel interrupts.
 * - 1 - Enable channel interrupts.
 */
/*@{*/
#define BP_TPM_CnSC_CHIE     (6U)          /*!< Bit position for TPM_CnSC_CHIE. */
#define BM_TPM_CnSC_CHIE     (0x00000040U) /*!< Bit mask for TPM_CnSC_CHIE. */
#define BS_TPM_CnSC_CHIE     (1U)          /*!< Bit field size in bits for TPM_CnSC_CHIE. */

/*! @brief Read current value of the TPM_CnSC_CHIE field. */
#define BR_TPM_CnSC_CHIE(x, n) (BME_UBFX32(HW_TPM_CnSC_ADDR(x, n), BP_TPM_CnSC_CHIE, BS_TPM_CnSC_CHIE))

/*! @brief Format value for bitfield TPM_CnSC_CHIE. */
#define BF_TPM_CnSC_CHIE(v)  ((uint32_t)((uint32_t)(v) << BP_TPM_CnSC_CHIE) & BM_TPM_CnSC_CHIE)

/*! @brief Set the CHIE field to a new value. */
#define BW_TPM_CnSC_CHIE(x, n, v) (BME_BFI32(HW_TPM_CnSC_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnSC_CHIE), BP_TPM_CnSC_CHIE, 1))
/*@}*/

/*!
 * @name Register TPM_CnSC, field CHF[7] (W1C)
 *
 * Set by hardware when an event occurs on the channel. CHF is cleared by
 * writing a 1 to the CHF bit. Writing a 0 to CHF has no effect. If another event
 * occurs between the CHF sets and the write operation, the write operation has no
 * effect; therefore, CHF remains set indicating another event has occurred. In this
 * case a CHF interrupt request is not lost due to the delay in clearing the
 * previous CHF.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_TPM_CnSC_CHF      (7U)          /*!< Bit position for TPM_CnSC_CHF. */
#define BM_TPM_CnSC_CHF      (0x00000080U) /*!< Bit mask for TPM_CnSC_CHF. */
#define BS_TPM_CnSC_CHF      (1U)          /*!< Bit field size in bits for TPM_CnSC_CHF. */

/*! @brief Read current value of the TPM_CnSC_CHF field. */
#define BR_TPM_CnSC_CHF(x, n) (BME_UBFX32(HW_TPM_CnSC_ADDR(x, n), BP_TPM_CnSC_CHF, BS_TPM_CnSC_CHF))

/*! @brief Format value for bitfield TPM_CnSC_CHF. */
#define BF_TPM_CnSC_CHF(v)   ((uint32_t)((uint32_t)(v) << BP_TPM_CnSC_CHF) & BM_TPM_CnSC_CHF)

/*! @brief Set the CHF field to a new value. */
#define BW_TPM_CnSC_CHF(x, n, v) (BME_BFI32(HW_TPM_CnSC_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnSC_CHF), BP_TPM_CnSC_CHF, 1))
/*@}*/
/*******************************************************************************
 * HW_TPM_CnV - Channel (n) Value
 ******************************************************************************/

/*!
 * @brief HW_TPM_CnV - Channel (n) Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the captured TPM counter value for the input modes or
 * the match value for the output modes. In input capture mode, any write to a
 * CnV register is ignored. In compare modes, writing to a CnV register latches
 * the value into a buffer. A CnV register is updated with the value of its write
 * buffer according to CnV Register Update . Additional writes to the CnV write
 * buffer are ignored until the register has been updated.
 */
typedef union _hw_tpm_cnv
{
    uint32_t U;
    struct _hw_tpm_cnv_bitfields
    {
        uint32_t VAL : 16;             /*!< [15:0] Channel Value */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_tpm_cnv_t;

/*!
 * @name Constants and macros for entire TPM_CnV register
 */
/*@{*/
#define HW_TPM_CnV_COUNT (6U)

#define HW_TPM_CnV_ADDR(x, n)    ((uint32_t)(x) + 0x10U + (0x8U * (n)))

#define HW_TPM_CnV(x, n)         (*(__IO hw_tpm_cnv_t *) HW_TPM_CnV_ADDR(x, n))
#define HW_TPM_CnV_RD(x, n)      (HW_TPM_CnV(x, n).U)
#define HW_TPM_CnV_WR(x, n, v)   (HW_TPM_CnV(x, n).U = (v))
#define HW_TPM_CnV_SET(x, n, v)  (BME_OR32(HW_TPM_CnV_ADDR(x, n), (uint32_t)(v)))
#define HW_TPM_CnV_CLR(x, n, v)  (BME_AND32(HW_TPM_CnV_ADDR(x, n), (uint32_t)(~(v))))
#define HW_TPM_CnV_TOG(x, n, v)  (BME_XOR32(HW_TPM_CnV_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual TPM_CnV bitfields
 */

/*!
 * @name Register TPM_CnV, field VAL[15:0] (RW)
 *
 * Captured TPM counter value of the input modes or the match value for the
 * output modes. When writing this field, all bytes must be written at the same time.
 */
/*@{*/
#define BP_TPM_CnV_VAL       (0U)          /*!< Bit position for TPM_CnV_VAL. */
#define BM_TPM_CnV_VAL       (0x0000FFFFU) /*!< Bit mask for TPM_CnV_VAL. */
#define BS_TPM_CnV_VAL       (16U)         /*!< Bit field size in bits for TPM_CnV_VAL. */

/*! @brief Read current value of the TPM_CnV_VAL field. */
#define BR_TPM_CnV_VAL(x, n) (BME_UBFX32(HW_TPM_CnV_ADDR(x, n), BP_TPM_CnV_VAL, BS_TPM_CnV_VAL))

/*! @brief Format value for bitfield TPM_CnV_VAL. */
#define BF_TPM_CnV_VAL(v)    ((uint32_t)((uint32_t)(v) << BP_TPM_CnV_VAL) & BM_TPM_CnV_VAL)

/*! @brief Set the VAL field to a new value. */
#define BW_TPM_CnV_VAL(x, n, v) (BME_BFI32(HW_TPM_CnV_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnV_VAL), BP_TPM_CnV_VAL, 16))
/*@}*/

/*******************************************************************************
 * HW_TPM_STATUS - Capture and Compare Status
 ******************************************************************************/

/*!
 * @brief HW_TPM_STATUS - Capture and Compare Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * The STATUS register contains a copy of the status flag, CnSC[CHnF] for each
 * TPM channel, as well as SC[TOF], for software convenience. Each CHnF bit in
 * STATUS is a mirror of CHnF bit in CnSC. All CHnF bits can be checked using only
 * one read of STATUS. All CHnF bits can be cleared by writing all ones to STATUS.
 * Hardware sets the individual channel flags when an event occurs on the
 * channel. Writing a 1 to CHF clears it. Writing a 0 to CHF has no effect. If another
 * event occurs between the flag setting and the write operation, the write
 * operation has no effect; therefore, CHF remains set indicating another event has
 * occurred. In this case a CHF interrupt request is not lost due to the clearing
 * sequence for a previous CHF.
 */
typedef union _hw_tpm_status
{
    uint32_t U;
    struct _hw_tpm_status_bitfields
    {
        uint32_t CH0F : 1;             /*!< [0] Channel 0 Flag */
        uint32_t CH1F : 1;             /*!< [1] Channel 1 Flag */
        uint32_t CH2F : 1;             /*!< [2] Channel 2 Flag */
        uint32_t CH3F : 1;             /*!< [3] Channel 3 Flag */
        uint32_t CH4F : 1;             /*!< [4] Channel 4 Flag */
        uint32_t CH5F : 1;             /*!< [5] Channel 5 Flag */
        uint32_t RESERVED0 : 2;        /*!< [7:6]  */
        uint32_t TOF : 1;              /*!< [8] Timer Overflow Flag */
        uint32_t RESERVED1 : 23;       /*!< [31:9]  */
    } B;
} hw_tpm_status_t;

/*!
 * @name Constants and macros for entire TPM_STATUS register
 */
/*@{*/
#define HW_TPM_STATUS_ADDR(x)    ((uint32_t)(x) + 0x50U)

#define HW_TPM_STATUS(x)         (*(__IO hw_tpm_status_t *) HW_TPM_STATUS_ADDR(x))
#define HW_TPM_STATUS_RD(x)      (HW_TPM_STATUS(x).U)
#define HW_TPM_STATUS_WR(x, v)   (HW_TPM_STATUS(x).U = (v))
#define HW_TPM_STATUS_SET(x, v)  (BME_OR32(HW_TPM_STATUS_ADDR(x), (uint32_t)(v)))
#define HW_TPM_STATUS_CLR(x, v)  (BME_AND32(HW_TPM_STATUS_ADDR(x), (uint32_t)(~(v))))
#define HW_TPM_STATUS_TOG(x, v)  (BME_XOR32(HW_TPM_STATUS_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual TPM_STATUS bitfields
 */

/*!
 * @name Register TPM_STATUS, field CH0F[0] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_TPM_STATUS_CH0F   (0U)          /*!< Bit position for TPM_STATUS_CH0F. */
#define BM_TPM_STATUS_CH0F   (0x00000001U) /*!< Bit mask for TPM_STATUS_CH0F. */
#define BS_TPM_STATUS_CH0F   (1U)          /*!< Bit field size in bits for TPM_STATUS_CH0F. */

/*! @brief Read current value of the TPM_STATUS_CH0F field. */
#define BR_TPM_STATUS_CH0F(x) (BME_UBFX32(HW_TPM_STATUS_ADDR(x), BP_TPM_STATUS_CH0F, BS_TPM_STATUS_CH0F))

/*! @brief Format value for bitfield TPM_STATUS_CH0F. */
#define BF_TPM_STATUS_CH0F(v) ((uint32_t)((uint32_t)(v) << BP_TPM_STATUS_CH0F) & BM_TPM_STATUS_CH0F)

/*! @brief Set the CH0F field to a new value. */
#define BW_TPM_STATUS_CH0F(x, v) (BME_BFI32(HW_TPM_STATUS_ADDR(x), ((uint32_t)(v) << BP_TPM_STATUS_CH0F), BP_TPM_STATUS_CH0F, 1))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH1F[1] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_TPM_STATUS_CH1F   (1U)          /*!< Bit position for TPM_STATUS_CH1F. */
#define BM_TPM_STATUS_CH1F   (0x00000002U) /*!< Bit mask for TPM_STATUS_CH1F. */
#define BS_TPM_STATUS_CH1F   (1U)          /*!< Bit field size in bits for TPM_STATUS_CH1F. */

/*! @brief Read current value of the TPM_STATUS_CH1F field. */
#define BR_TPM_STATUS_CH1F(x) (BME_UBFX32(HW_TPM_STATUS_ADDR(x), BP_TPM_STATUS_CH1F, BS_TPM_STATUS_CH1F))

/*! @brief Format value for bitfield TPM_STATUS_CH1F. */
#define BF_TPM_STATUS_CH1F(v) ((uint32_t)((uint32_t)(v) << BP_TPM_STATUS_CH1F) & BM_TPM_STATUS_CH1F)

/*! @brief Set the CH1F field to a new value. */
#define BW_TPM_STATUS_CH1F(x, v) (BME_BFI32(HW_TPM_STATUS_ADDR(x), ((uint32_t)(v) << BP_TPM_STATUS_CH1F), BP_TPM_STATUS_CH1F, 1))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH2F[2] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_TPM_STATUS_CH2F   (2U)          /*!< Bit position for TPM_STATUS_CH2F. */
#define BM_TPM_STATUS_CH2F   (0x00000004U) /*!< Bit mask for TPM_STATUS_CH2F. */
#define BS_TPM_STATUS_CH2F   (1U)          /*!< Bit field size in bits for TPM_STATUS_CH2F. */

/*! @brief Read current value of the TPM_STATUS_CH2F field. */
#define BR_TPM_STATUS_CH2F(x) (BME_UBFX32(HW_TPM_STATUS_ADDR(x), BP_TPM_STATUS_CH2F, BS_TPM_STATUS_CH2F))

/*! @brief Format value for bitfield TPM_STATUS_CH2F. */
#define BF_TPM_STATUS_CH2F(v) ((uint32_t)((uint32_t)(v) << BP_TPM_STATUS_CH2F) & BM_TPM_STATUS_CH2F)

/*! @brief Set the CH2F field to a new value. */
#define BW_TPM_STATUS_CH2F(x, v) (BME_BFI32(HW_TPM_STATUS_ADDR(x), ((uint32_t)(v) << BP_TPM_STATUS_CH2F), BP_TPM_STATUS_CH2F, 1))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH3F[3] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_TPM_STATUS_CH3F   (3U)          /*!< Bit position for TPM_STATUS_CH3F. */
#define BM_TPM_STATUS_CH3F   (0x00000008U) /*!< Bit mask for TPM_STATUS_CH3F. */
#define BS_TPM_STATUS_CH3F   (1U)          /*!< Bit field size in bits for TPM_STATUS_CH3F. */

/*! @brief Read current value of the TPM_STATUS_CH3F field. */
#define BR_TPM_STATUS_CH3F(x) (BME_UBFX32(HW_TPM_STATUS_ADDR(x), BP_TPM_STATUS_CH3F, BS_TPM_STATUS_CH3F))

/*! @brief Format value for bitfield TPM_STATUS_CH3F. */
#define BF_TPM_STATUS_CH3F(v) ((uint32_t)((uint32_t)(v) << BP_TPM_STATUS_CH3F) & BM_TPM_STATUS_CH3F)

/*! @brief Set the CH3F field to a new value. */
#define BW_TPM_STATUS_CH3F(x, v) (BME_BFI32(HW_TPM_STATUS_ADDR(x), ((uint32_t)(v) << BP_TPM_STATUS_CH3F), BP_TPM_STATUS_CH3F, 1))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH4F[4] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_TPM_STATUS_CH4F   (4U)          /*!< Bit position for TPM_STATUS_CH4F. */
#define BM_TPM_STATUS_CH4F   (0x00000010U) /*!< Bit mask for TPM_STATUS_CH4F. */
#define BS_TPM_STATUS_CH4F   (1U)          /*!< Bit field size in bits for TPM_STATUS_CH4F. */

/*! @brief Read current value of the TPM_STATUS_CH4F field. */
#define BR_TPM_STATUS_CH4F(x) (BME_UBFX32(HW_TPM_STATUS_ADDR(x), BP_TPM_STATUS_CH4F, BS_TPM_STATUS_CH4F))

/*! @brief Format value for bitfield TPM_STATUS_CH4F. */
#define BF_TPM_STATUS_CH4F(v) ((uint32_t)((uint32_t)(v) << BP_TPM_STATUS_CH4F) & BM_TPM_STATUS_CH4F)

/*! @brief Set the CH4F field to a new value. */
#define BW_TPM_STATUS_CH4F(x, v) (BME_BFI32(HW_TPM_STATUS_ADDR(x), ((uint32_t)(v) << BP_TPM_STATUS_CH4F), BP_TPM_STATUS_CH4F, 1))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH5F[5] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_TPM_STATUS_CH5F   (5U)          /*!< Bit position for TPM_STATUS_CH5F. */
#define BM_TPM_STATUS_CH5F   (0x00000020U) /*!< Bit mask for TPM_STATUS_CH5F. */
#define BS_TPM_STATUS_CH5F   (1U)          /*!< Bit field size in bits for TPM_STATUS_CH5F. */

/*! @brief Read current value of the TPM_STATUS_CH5F field. */
#define BR_TPM_STATUS_CH5F(x) (BME_UBFX32(HW_TPM_STATUS_ADDR(x), BP_TPM_STATUS_CH5F, BS_TPM_STATUS_CH5F))

/*! @brief Format value for bitfield TPM_STATUS_CH5F. */
#define BF_TPM_STATUS_CH5F(v) ((uint32_t)((uint32_t)(v) << BP_TPM_STATUS_CH5F) & BM_TPM_STATUS_CH5F)

/*! @brief Set the CH5F field to a new value. */
#define BW_TPM_STATUS_CH5F(x, v) (BME_BFI32(HW_TPM_STATUS_ADDR(x), ((uint32_t)(v) << BP_TPM_STATUS_CH5F), BP_TPM_STATUS_CH5F, 1))
/*@}*/

/*!
 * @name Register TPM_STATUS, field TOF[8] (W1C)
 *
 * See register description
 *
 * Values:
 * - 0 - TPM counter has not overflowed.
 * - 1 - TPM counter has overflowed.
 */
/*@{*/
#define BP_TPM_STATUS_TOF    (8U)          /*!< Bit position for TPM_STATUS_TOF. */
#define BM_TPM_STATUS_TOF    (0x00000100U) /*!< Bit mask for TPM_STATUS_TOF. */
#define BS_TPM_STATUS_TOF    (1U)          /*!< Bit field size in bits for TPM_STATUS_TOF. */

/*! @brief Read current value of the TPM_STATUS_TOF field. */
#define BR_TPM_STATUS_TOF(x) (BME_UBFX32(HW_TPM_STATUS_ADDR(x), BP_TPM_STATUS_TOF, BS_TPM_STATUS_TOF))

/*! @brief Format value for bitfield TPM_STATUS_TOF. */
#define BF_TPM_STATUS_TOF(v) ((uint32_t)((uint32_t)(v) << BP_TPM_STATUS_TOF) & BM_TPM_STATUS_TOF)

/*! @brief Set the TOF field to a new value. */
#define BW_TPM_STATUS_TOF(x, v) (BME_BFI32(HW_TPM_STATUS_ADDR(x), ((uint32_t)(v) << BP_TPM_STATUS_TOF), BP_TPM_STATUS_TOF, 1))
/*@}*/

/*******************************************************************************
 * HW_TPM_POL - Channel Polarity
 ******************************************************************************/

/*!
 * @brief HW_TPM_POL - Channel Polarity (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the input and output polarity of each of the channels.
 */
typedef union _hw_tpm_pol
{
    uint32_t U;
    struct _hw_tpm_pol_bitfields
    {
        uint32_t POL0 : 1;             /*!< [0] Channel 0 Polarity */
        uint32_t POL1 : 1;             /*!< [1] Channel 1 Polarity */
        uint32_t POL2 : 1;             /*!< [2] Channel 2 Polarity */
        uint32_t POL3 : 1;             /*!< [3] Channel 3 Polarity */
        uint32_t POL4 : 1;             /*!< [4] Channel Polarity 4 */
        uint32_t POL5 : 1;             /*!< [5] Channel 5 Polarity */
        uint32_t RESERVED0 : 26;       /*!< [31:6]  */
    } B;
} hw_tpm_pol_t;

/*!
 * @name Constants and macros for entire TPM_POL register
 */
/*@{*/
#define HW_TPM_POL_ADDR(x)       ((uint32_t)(x) + 0x70U)

#define HW_TPM_POL(x)            (*(__IO hw_tpm_pol_t *) HW_TPM_POL_ADDR(x))
#define HW_TPM_POL_RD(x)         (HW_TPM_POL(x).U)
#define HW_TPM_POL_WR(x, v)      (HW_TPM_POL(x).U = (v))
#define HW_TPM_POL_SET(x, v)     (BME_OR32(HW_TPM_POL_ADDR(x), (uint32_t)(v)))
#define HW_TPM_POL_CLR(x, v)     (BME_AND32(HW_TPM_POL_ADDR(x), (uint32_t)(~(v))))
#define HW_TPM_POL_TOG(x, v)     (BME_XOR32(HW_TPM_POL_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual TPM_POL bitfields
 */

/*!
 * @name Register TPM_POL, field POL0[0] (RW)
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
#define BP_TPM_POL_POL0      (0U)          /*!< Bit position for TPM_POL_POL0. */
#define BM_TPM_POL_POL0      (0x00000001U) /*!< Bit mask for TPM_POL_POL0. */
#define BS_TPM_POL_POL0      (1U)          /*!< Bit field size in bits for TPM_POL_POL0. */

/*! @brief Read current value of the TPM_POL_POL0 field. */
#define BR_TPM_POL_POL0(x)   (BME_UBFX32(HW_TPM_POL_ADDR(x), BP_TPM_POL_POL0, BS_TPM_POL_POL0))

/*! @brief Format value for bitfield TPM_POL_POL0. */
#define BF_TPM_POL_POL0(v)   ((uint32_t)((uint32_t)(v) << BP_TPM_POL_POL0) & BM_TPM_POL_POL0)

/*! @brief Set the POL0 field to a new value. */
#define BW_TPM_POL_POL0(x, v) (BME_BFI32(HW_TPM_POL_ADDR(x), ((uint32_t)(v) << BP_TPM_POL_POL0), BP_TPM_POL_POL0, 1))
/*@}*/

/*!
 * @name Register TPM_POL, field POL1[1] (RW)
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
#define BP_TPM_POL_POL1      (1U)          /*!< Bit position for TPM_POL_POL1. */
#define BM_TPM_POL_POL1      (0x00000002U) /*!< Bit mask for TPM_POL_POL1. */
#define BS_TPM_POL_POL1      (1U)          /*!< Bit field size in bits for TPM_POL_POL1. */

/*! @brief Read current value of the TPM_POL_POL1 field. */
#define BR_TPM_POL_POL1(x)   (BME_UBFX32(HW_TPM_POL_ADDR(x), BP_TPM_POL_POL1, BS_TPM_POL_POL1))

/*! @brief Format value for bitfield TPM_POL_POL1. */
#define BF_TPM_POL_POL1(v)   ((uint32_t)((uint32_t)(v) << BP_TPM_POL_POL1) & BM_TPM_POL_POL1)

/*! @brief Set the POL1 field to a new value. */
#define BW_TPM_POL_POL1(x, v) (BME_BFI32(HW_TPM_POL_ADDR(x), ((uint32_t)(v) << BP_TPM_POL_POL1), BP_TPM_POL_POL1, 1))
/*@}*/

/*!
 * @name Register TPM_POL, field POL2[2] (RW)
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
#define BP_TPM_POL_POL2      (2U)          /*!< Bit position for TPM_POL_POL2. */
#define BM_TPM_POL_POL2      (0x00000004U) /*!< Bit mask for TPM_POL_POL2. */
#define BS_TPM_POL_POL2      (1U)          /*!< Bit field size in bits for TPM_POL_POL2. */

/*! @brief Read current value of the TPM_POL_POL2 field. */
#define BR_TPM_POL_POL2(x)   (BME_UBFX32(HW_TPM_POL_ADDR(x), BP_TPM_POL_POL2, BS_TPM_POL_POL2))

/*! @brief Format value for bitfield TPM_POL_POL2. */
#define BF_TPM_POL_POL2(v)   ((uint32_t)((uint32_t)(v) << BP_TPM_POL_POL2) & BM_TPM_POL_POL2)

/*! @brief Set the POL2 field to a new value. */
#define BW_TPM_POL_POL2(x, v) (BME_BFI32(HW_TPM_POL_ADDR(x), ((uint32_t)(v) << BP_TPM_POL_POL2), BP_TPM_POL_POL2, 1))
/*@}*/

/*!
 * @name Register TPM_POL, field POL3[3] (RW)
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
#define BP_TPM_POL_POL3      (3U)          /*!< Bit position for TPM_POL_POL3. */
#define BM_TPM_POL_POL3      (0x00000008U) /*!< Bit mask for TPM_POL_POL3. */
#define BS_TPM_POL_POL3      (1U)          /*!< Bit field size in bits for TPM_POL_POL3. */

/*! @brief Read current value of the TPM_POL_POL3 field. */
#define BR_TPM_POL_POL3(x)   (BME_UBFX32(HW_TPM_POL_ADDR(x), BP_TPM_POL_POL3, BS_TPM_POL_POL3))

/*! @brief Format value for bitfield TPM_POL_POL3. */
#define BF_TPM_POL_POL3(v)   ((uint32_t)((uint32_t)(v) << BP_TPM_POL_POL3) & BM_TPM_POL_POL3)

/*! @brief Set the POL3 field to a new value. */
#define BW_TPM_POL_POL3(x, v) (BME_BFI32(HW_TPM_POL_ADDR(x), ((uint32_t)(v) << BP_TPM_POL_POL3), BP_TPM_POL_POL3, 1))
/*@}*/

/*!
 * @name Register TPM_POL, field POL4[4] (RW)
 *
 * Values:
 * - 0 - The channel polarity is active high
 * - 1 - The channel polarity is active low.
 */
/*@{*/
#define BP_TPM_POL_POL4      (4U)          /*!< Bit position for TPM_POL_POL4. */
#define BM_TPM_POL_POL4      (0x00000010U) /*!< Bit mask for TPM_POL_POL4. */
#define BS_TPM_POL_POL4      (1U)          /*!< Bit field size in bits for TPM_POL_POL4. */

/*! @brief Read current value of the TPM_POL_POL4 field. */
#define BR_TPM_POL_POL4(x)   (BME_UBFX32(HW_TPM_POL_ADDR(x), BP_TPM_POL_POL4, BS_TPM_POL_POL4))

/*! @brief Format value for bitfield TPM_POL_POL4. */
#define BF_TPM_POL_POL4(v)   ((uint32_t)((uint32_t)(v) << BP_TPM_POL_POL4) & BM_TPM_POL_POL4)

/*! @brief Set the POL4 field to a new value. */
#define BW_TPM_POL_POL4(x, v) (BME_BFI32(HW_TPM_POL_ADDR(x), ((uint32_t)(v) << BP_TPM_POL_POL4), BP_TPM_POL_POL4, 1))
/*@}*/

/*!
 * @name Register TPM_POL, field POL5[5] (RW)
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
#define BP_TPM_POL_POL5      (5U)          /*!< Bit position for TPM_POL_POL5. */
#define BM_TPM_POL_POL5      (0x00000020U) /*!< Bit mask for TPM_POL_POL5. */
#define BS_TPM_POL_POL5      (1U)          /*!< Bit field size in bits for TPM_POL_POL5. */

/*! @brief Read current value of the TPM_POL_POL5 field. */
#define BR_TPM_POL_POL5(x)   (BME_UBFX32(HW_TPM_POL_ADDR(x), BP_TPM_POL_POL5, BS_TPM_POL_POL5))

/*! @brief Format value for bitfield TPM_POL_POL5. */
#define BF_TPM_POL_POL5(v)   ((uint32_t)((uint32_t)(v) << BP_TPM_POL_POL5) & BM_TPM_POL_POL5)

/*! @brief Set the POL5 field to a new value. */
#define BW_TPM_POL_POL5(x, v) (BME_BFI32(HW_TPM_POL_ADDR(x), ((uint32_t)(v) << BP_TPM_POL_POL5), BP_TPM_POL_POL5, 1))
/*@}*/

/*******************************************************************************
 * HW_TPM_CONF - Configuration
 ******************************************************************************/

/*!
 * @brief HW_TPM_CONF - Configuration (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the behavior in debug and wait modes and the use of an
 * external global time base.
 */
typedef union _hw_tpm_conf
{
    uint32_t U;
    struct _hw_tpm_conf_bitfields
    {
        uint32_t RESERVED0 : 5;        /*!< [4:0]  */
        uint32_t DOZEEN : 1;           /*!< [5] Doze Enable */
        uint32_t DBGMODE : 2;          /*!< [7:6] Debug Mode */
        uint32_t GTBSYNC : 1;          /*!< [8] Global Time Base Synchronization */
        uint32_t GTBEEN : 1;           /*!< [9] Global time base enable */
        uint32_t RESERVED1 : 6;        /*!< [15:10]  */
        uint32_t CSOT : 1;             /*!< [16] Counter Start on Trigger */
        uint32_t CSOO : 1;             /*!< [17] Counter Stop On Overflow */
        uint32_t CROT : 1;             /*!< [18] Counter Reload On Trigger */
        uint32_t CPOT : 1;             /*!< [19] Counter Pause On Trigger */
        uint32_t RESERVED2 : 2;        /*!< [21:20]  */
        uint32_t TRGPOL : 1;           /*!< [22] Trigger Polarity */
        uint32_t TRGSRC : 1;           /*!< [23] Trigger Source */
        uint32_t TRGSEL : 4;           /*!< [27:24] Trigger Select */
        uint32_t RESERVED3 : 4;        /*!< [31:28]  */
    } B;
} hw_tpm_conf_t;

/*!
 * @name Constants and macros for entire TPM_CONF register
 */
/*@{*/
#define HW_TPM_CONF_ADDR(x)      ((uint32_t)(x) + 0x84U)

#define HW_TPM_CONF(x)           (*(__IO hw_tpm_conf_t *) HW_TPM_CONF_ADDR(x))
#define HW_TPM_CONF_RD(x)        (HW_TPM_CONF(x).U)
#define HW_TPM_CONF_WR(x, v)     (HW_TPM_CONF(x).U = (v))
#define HW_TPM_CONF_SET(x, v)    (BME_OR32(HW_TPM_CONF_ADDR(x), (uint32_t)(v)))
#define HW_TPM_CONF_CLR(x, v)    (BME_AND32(HW_TPM_CONF_ADDR(x), (uint32_t)(~(v))))
#define HW_TPM_CONF_TOG(x, v)    (BME_XOR32(HW_TPM_CONF_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual TPM_CONF bitfields
 */

/*!
 * @name Register TPM_CONF, field DOZEEN[5] (RW)
 *
 * Configures the TPM behavior in wait mode.
 *
 * Values:
 * - 0 - Internal TPM counter continues in Doze mode.
 * - 1 - Internal TPM counter is paused and does not increment during Doze mode.
 *     Trigger inputs and input capture events are also ignored.
 */
/*@{*/
#define BP_TPM_CONF_DOZEEN   (5U)          /*!< Bit position for TPM_CONF_DOZEEN. */
#define BM_TPM_CONF_DOZEEN   (0x00000020U) /*!< Bit mask for TPM_CONF_DOZEEN. */
#define BS_TPM_CONF_DOZEEN   (1U)          /*!< Bit field size in bits for TPM_CONF_DOZEEN. */

/*! @brief Read current value of the TPM_CONF_DOZEEN field. */
#define BR_TPM_CONF_DOZEEN(x) (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_DOZEEN, BS_TPM_CONF_DOZEEN))

/*! @brief Format value for bitfield TPM_CONF_DOZEEN. */
#define BF_TPM_CONF_DOZEEN(v) ((uint32_t)((uint32_t)(v) << BP_TPM_CONF_DOZEEN) & BM_TPM_CONF_DOZEEN)

/*! @brief Set the DOZEEN field to a new value. */
#define BW_TPM_CONF_DOZEEN(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_DOZEEN), BP_TPM_CONF_DOZEEN, 1))
/*@}*/

/*!
 * @name Register TPM_CONF, field DBGMODE[7:6] (RW)
 *
 * Configures the TPM behavior in debug mode. All other configurations are
 * reserved.
 *
 * Values:
 * - 00 - TPM counter is paused and does not increment during debug mode.
 *     Trigger inputs and input capture events are also ignored.
 * - 11 - TPM counter continues in debug mode.
 */
/*@{*/
#define BP_TPM_CONF_DBGMODE  (6U)          /*!< Bit position for TPM_CONF_DBGMODE. */
#define BM_TPM_CONF_DBGMODE  (0x000000C0U) /*!< Bit mask for TPM_CONF_DBGMODE. */
#define BS_TPM_CONF_DBGMODE  (2U)          /*!< Bit field size in bits for TPM_CONF_DBGMODE. */

/*! @brief Read current value of the TPM_CONF_DBGMODE field. */
#define BR_TPM_CONF_DBGMODE(x) (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_DBGMODE, BS_TPM_CONF_DBGMODE))

/*! @brief Format value for bitfield TPM_CONF_DBGMODE. */
#define BF_TPM_CONF_DBGMODE(v) ((uint32_t)((uint32_t)(v) << BP_TPM_CONF_DBGMODE) & BM_TPM_CONF_DBGMODE)

/*! @brief Set the DBGMODE field to a new value. */
#define BW_TPM_CONF_DBGMODE(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_DBGMODE), BP_TPM_CONF_DBGMODE, 2))
/*@}*/

/*!
 * @name Register TPM_CONF, field GTBSYNC[8] (RW)
 *
 * When enabled, the TPM counter is synchronized to the global time base. It
 * uses the global timebase enable, trigger and overflow to ensure the TPM counter
 * starts incrementing at the same time as the global timebase, stops incrementing
 * at the same time as the global timebase and is reset at the same time as the
 * global timebase. This field should only be changed when the TPM counter is
 * disabled.
 *
 * Values:
 * - 0 - Global timebase synchronization disabled.
 * - 1 - Global timebase synchronization enabled.
 */
/*@{*/
#define BP_TPM_CONF_GTBSYNC  (8U)          /*!< Bit position for TPM_CONF_GTBSYNC. */
#define BM_TPM_CONF_GTBSYNC  (0x00000100U) /*!< Bit mask for TPM_CONF_GTBSYNC. */
#define BS_TPM_CONF_GTBSYNC  (1U)          /*!< Bit field size in bits for TPM_CONF_GTBSYNC. */

/*! @brief Read current value of the TPM_CONF_GTBSYNC field. */
#define BR_TPM_CONF_GTBSYNC(x) (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_GTBSYNC, BS_TPM_CONF_GTBSYNC))

/*! @brief Format value for bitfield TPM_CONF_GTBSYNC. */
#define BF_TPM_CONF_GTBSYNC(v) ((uint32_t)((uint32_t)(v) << BP_TPM_CONF_GTBSYNC) & BM_TPM_CONF_GTBSYNC)

/*! @brief Set the GTBSYNC field to a new value. */
#define BW_TPM_CONF_GTBSYNC(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_GTBSYNC), BP_TPM_CONF_GTBSYNC, 1))
/*@}*/

/*!
 * @name Register TPM_CONF, field GTBEEN[9] (RW)
 *
 * Configures the TPM to use an externally generated global time base counter.
 * When an externally generated timebase is used, the internal TPM counter is not
 * used by the channels but can be used to generate a periodic interruptor DMA
 * request using the Modulo register and timer overflow flag.
 *
 * Values:
 * - 0 - All channels use the internally generated TPM counter as their timebase
 * - 1 - All channels use an externally generated global timebase as their
 *     timebase
 */
/*@{*/
#define BP_TPM_CONF_GTBEEN   (9U)          /*!< Bit position for TPM_CONF_GTBEEN. */
#define BM_TPM_CONF_GTBEEN   (0x00000200U) /*!< Bit mask for TPM_CONF_GTBEEN. */
#define BS_TPM_CONF_GTBEEN   (1U)          /*!< Bit field size in bits for TPM_CONF_GTBEEN. */

/*! @brief Read current value of the TPM_CONF_GTBEEN field. */
#define BR_TPM_CONF_GTBEEN(x) (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_GTBEEN, BS_TPM_CONF_GTBEEN))

/*! @brief Format value for bitfield TPM_CONF_GTBEEN. */
#define BF_TPM_CONF_GTBEEN(v) ((uint32_t)((uint32_t)(v) << BP_TPM_CONF_GTBEEN) & BM_TPM_CONF_GTBEEN)

/*! @brief Set the GTBEEN field to a new value. */
#define BW_TPM_CONF_GTBEEN(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_GTBEEN), BP_TPM_CONF_GTBEEN, 1))
/*@}*/

/*!
 * @name Register TPM_CONF, field CSOT[16] (RW)
 *
 * When set, the TPM counter will not start incrementing after it is enabled
 * until a rising edge on the selected trigger input is detected. If the TPM counter
 * is stopped due to an overflow, a rising edge on the selected trigger input
 * will also cause the TPM counter to start incrementing again. The trigger input
 * is ignored if the TPM counter is paused during debug mode or doze mode. This
 * field should only be changed when the TPM counter is disabled.
 *
 * Values:
 * - 0 - TPM counter starts to increment immediately, once it is enabled.
 * - 1 - TPM counter only starts to increment when it a rising edge on the
 *     selected input trigger is detected, after it has been enabled or after it has
 *     stopped due to overflow.
 */
/*@{*/
#define BP_TPM_CONF_CSOT     (16U)         /*!< Bit position for TPM_CONF_CSOT. */
#define BM_TPM_CONF_CSOT     (0x00010000U) /*!< Bit mask for TPM_CONF_CSOT. */
#define BS_TPM_CONF_CSOT     (1U)          /*!< Bit field size in bits for TPM_CONF_CSOT. */

/*! @brief Read current value of the TPM_CONF_CSOT field. */
#define BR_TPM_CONF_CSOT(x)  (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_CSOT, BS_TPM_CONF_CSOT))

/*! @brief Format value for bitfield TPM_CONF_CSOT. */
#define BF_TPM_CONF_CSOT(v)  ((uint32_t)((uint32_t)(v) << BP_TPM_CONF_CSOT) & BM_TPM_CONF_CSOT)

/*! @brief Set the CSOT field to a new value. */
#define BW_TPM_CONF_CSOT(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_CSOT), BP_TPM_CONF_CSOT, 1))
/*@}*/

/*!
 * @name Register TPM_CONF, field CSOO[17] (RW)
 *
 * When set, the TPM counter will stop incrementing once the counter equals the
 * MOD value and incremented (this also sets the TOF). Reloading the counter with
 * 0 due to writing to the counter register or due to a trigger input does not
 * cause the counter to stop incrementing. Once the counter has stopped
 * incrementing, the counter will not start incrementing unless it is disabled and then
 * enabled again, or a rising edge on the selected trigger input is detected when
 * CSOT set. This field should only be changed when the TPM counter is disabled.
 *
 * Values:
 * - 0 - TPM counter continues incrementing or decrementing after overflow
 * - 1 - TPM counter stops incrementing or decrementing after overflow.
 */
/*@{*/
#define BP_TPM_CONF_CSOO     (17U)         /*!< Bit position for TPM_CONF_CSOO. */
#define BM_TPM_CONF_CSOO     (0x00020000U) /*!< Bit mask for TPM_CONF_CSOO. */
#define BS_TPM_CONF_CSOO     (1U)          /*!< Bit field size in bits for TPM_CONF_CSOO. */

/*! @brief Read current value of the TPM_CONF_CSOO field. */
#define BR_TPM_CONF_CSOO(x)  (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_CSOO, BS_TPM_CONF_CSOO))

/*! @brief Format value for bitfield TPM_CONF_CSOO. */
#define BF_TPM_CONF_CSOO(v)  ((uint32_t)((uint32_t)(v) << BP_TPM_CONF_CSOO) & BM_TPM_CONF_CSOO)

/*! @brief Set the CSOO field to a new value. */
#define BW_TPM_CONF_CSOO(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_CSOO), BP_TPM_CONF_CSOO, 1))
/*@}*/

/*!
 * @name Register TPM_CONF, field CROT[18] (RW)
 *
 * When set, the TPM counter will reload with 0 (and initialize PWM outputs to
 * their default value) when a rising edge is detected on the selected trigger
 * input. The trigger input is ignored if the TPM counter is paused during debug
 * mode or doze mode. This field should only be changed when the TPM counter is
 * disabled.
 *
 * Values:
 * - 0 - Counter is not reloaded due to a rising edge on the selected input
 *     trigger
 * - 1 - Counter is reloaded when a rising edge is detected on the selected
 *     input trigger
 */
/*@{*/
#define BP_TPM_CONF_CROT     (18U)         /*!< Bit position for TPM_CONF_CROT. */
#define BM_TPM_CONF_CROT     (0x00040000U) /*!< Bit mask for TPM_CONF_CROT. */
#define BS_TPM_CONF_CROT     (1U)          /*!< Bit field size in bits for TPM_CONF_CROT. */

/*! @brief Read current value of the TPM_CONF_CROT field. */
#define BR_TPM_CONF_CROT(x)  (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_CROT, BS_TPM_CONF_CROT))

/*! @brief Format value for bitfield TPM_CONF_CROT. */
#define BF_TPM_CONF_CROT(v)  ((uint32_t)((uint32_t)(v) << BP_TPM_CONF_CROT) & BM_TPM_CONF_CROT)

/*! @brief Set the CROT field to a new value. */
#define BW_TPM_CONF_CROT(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_CROT), BP_TPM_CONF_CROT, 1))
/*@}*/

/*!
 * @name Register TPM_CONF, field CPOT[19] (RW)
 *
 * When enabled, the counter will pause incrementing while the trigger remains
 * asserted (level sensitive). This field should only be changed when the TPM
 * counter is disabled.
 */
/*@{*/
#define BP_TPM_CONF_CPOT     (19U)         /*!< Bit position for TPM_CONF_CPOT. */
#define BM_TPM_CONF_CPOT     (0x00080000U) /*!< Bit mask for TPM_CONF_CPOT. */
#define BS_TPM_CONF_CPOT     (1U)          /*!< Bit field size in bits for TPM_CONF_CPOT. */

/*! @brief Read current value of the TPM_CONF_CPOT field. */
#define BR_TPM_CONF_CPOT(x)  (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_CPOT, BS_TPM_CONF_CPOT))

/*! @brief Format value for bitfield TPM_CONF_CPOT. */
#define BF_TPM_CONF_CPOT(v)  ((uint32_t)((uint32_t)(v) << BP_TPM_CONF_CPOT) & BM_TPM_CONF_CPOT)

/*! @brief Set the CPOT field to a new value. */
#define BW_TPM_CONF_CPOT(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_CPOT), BP_TPM_CONF_CPOT, 1))
/*@}*/

/*!
 * @name Register TPM_CONF, field TRGPOL[22] (RW)
 *
 * Selects the polarity of the external trigger source. This field should only
 * be changed when the TPM counter is disabled.
 *
 * Values:
 * - 0 - Trigger is active high.
 * - 1 - Trigger is active low.
 */
/*@{*/
#define BP_TPM_CONF_TRGPOL   (22U)         /*!< Bit position for TPM_CONF_TRGPOL. */
#define BM_TPM_CONF_TRGPOL   (0x00400000U) /*!< Bit mask for TPM_CONF_TRGPOL. */
#define BS_TPM_CONF_TRGPOL   (1U)          /*!< Bit field size in bits for TPM_CONF_TRGPOL. */

/*! @brief Read current value of the TPM_CONF_TRGPOL field. */
#define BR_TPM_CONF_TRGPOL(x) (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_TRGPOL, BS_TPM_CONF_TRGPOL))

/*! @brief Format value for bitfield TPM_CONF_TRGPOL. */
#define BF_TPM_CONF_TRGPOL(v) ((uint32_t)((uint32_t)(v) << BP_TPM_CONF_TRGPOL) & BM_TPM_CONF_TRGPOL)

/*! @brief Set the TRGPOL field to a new value. */
#define BW_TPM_CONF_TRGPOL(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_TRGPOL), BP_TPM_CONF_TRGPOL, 1))
/*@}*/

/*!
 * @name Register TPM_CONF, field TRGSRC[23] (RW)
 *
 * Selects between internal (channel pin input capture) or external trigger
 * sources. When selecting an internal trigger, the channel selected should be
 * configured for input capture. Only a rising edge input capture can be used to
 * initially start the counter using the CSOT configuration; either rising edge or
 * falling edge input capture can be used to reload the counter using the CROT
 * configuration; and the state of the channel input pin is used to pause the counter
 * using the CPOT configuration. The channel polarity register can be used to
 * invert the polarity of the channel input pins. This field should only be changed
 * when the TPM counter is disabled.
 *
 * Values:
 * - 0 - Trigger source selected by TRGSEL is external.
 * - 1 - Trigger source selected by TRGSEL is internal (channel pin input
 *     capture).
 */
/*@{*/
#define BP_TPM_CONF_TRGSRC   (23U)         /*!< Bit position for TPM_CONF_TRGSRC. */
#define BM_TPM_CONF_TRGSRC   (0x00800000U) /*!< Bit mask for TPM_CONF_TRGSRC. */
#define BS_TPM_CONF_TRGSRC   (1U)          /*!< Bit field size in bits for TPM_CONF_TRGSRC. */

/*! @brief Read current value of the TPM_CONF_TRGSRC field. */
#define BR_TPM_CONF_TRGSRC(x) (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_TRGSRC, BS_TPM_CONF_TRGSRC))

/*! @brief Format value for bitfield TPM_CONF_TRGSRC. */
#define BF_TPM_CONF_TRGSRC(v) ((uint32_t)((uint32_t)(v) << BP_TPM_CONF_TRGSRC) & BM_TPM_CONF_TRGSRC)

/*! @brief Set the TRGSRC field to a new value. */
#define BW_TPM_CONF_TRGSRC(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_TRGSRC), BP_TPM_CONF_TRGSRC, 1))
/*@}*/

/*!
 * @name Register TPM_CONF, field TRGSEL[27:24] (RW)
 *
 * Selects the input trigger to use for starting, reloading and/or pausing the
 * counter. The source of the trigger (external or internal to the TPM) is
 * configured by the TRGSRC field. This field should only be changed when the TPM
 * counter is disabled. Refer to the chip configuration section for available external
 * trigger options. The available internal trigger sources are listed below.
 *
 * Values:
 * - 0001 - Channel 0 pin input capture
 * - 0010 - Channel 1 pin input capture
 * - 0011 - Channel 0 or Channel 1 pin input capture
 * - 0100 - Channel 2 pin input capture
 * - 0101 - Channel 0 or Channel 2 pin input capture
 * - 0110 - Channel 1 or Channel 2 pin input capture
 * - 0111 - Channel 0 or Channel 1 or Channel 2 pin input capture
 * - 1000 - Channel 3 pin input capture
 * - 1001 - Channel 0 or Channel 3 pin input capture
 * - 1010 - Channel 1 or Channel 3 pin input capture
 * - 1011 - Channel 0 or Channel 1 or Channel 3 pin input capture
 * - 1100 - Channel 2 or Channel 3 pin input capture
 * - 1101 - Channel 0 or Channel 2 or Channel 3 pin input capture
 * - 1110 - Channel 1 or Channel 2 or Channel 3 pin input capture
 * - 1111 - Channel 0 or Channel 1 or Channel 2 or Channel 3 pin input capture
 */
/*@{*/
#define BP_TPM_CONF_TRGSEL   (24U)         /*!< Bit position for TPM_CONF_TRGSEL. */
#define BM_TPM_CONF_TRGSEL   (0x0F000000U) /*!< Bit mask for TPM_CONF_TRGSEL. */
#define BS_TPM_CONF_TRGSEL   (4U)          /*!< Bit field size in bits for TPM_CONF_TRGSEL. */

/*! @brief Read current value of the TPM_CONF_TRGSEL field. */
#define BR_TPM_CONF_TRGSEL(x) (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_TRGSEL, BS_TPM_CONF_TRGSEL))

/*! @brief Format value for bitfield TPM_CONF_TRGSEL. */
#define BF_TPM_CONF_TRGSEL(v) ((uint32_t)((uint32_t)(v) << BP_TPM_CONF_TRGSEL) & BM_TPM_CONF_TRGSEL)

/*! @brief Set the TRGSEL field to a new value. */
#define BW_TPM_CONF_TRGSEL(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_TRGSEL), BP_TPM_CONF_TRGSEL, 4))
/*@}*/

/*******************************************************************************
 * hw_tpm_t - module struct
 ******************************************************************************/
/*!
 * @brief All TPM module registers.
 */
#pragma pack(1)
typedef struct _hw_tpm
{
    __IO hw_tpm_sc_t SC;                   /*!< [0x0] Status and Control */
    __IO hw_tpm_cnt_t CNT;                 /*!< [0x4] Counter */
    __IO hw_tpm_mod_t MOD;                 /*!< [0x8] Modulo */
    struct {
        __IO hw_tpm_cnsc_t CnSC;           /*!< [0xC] Channel (n) Status and Control */
        __IO hw_tpm_cnv_t CnV;             /*!< [0x10] Channel (n) Value */
    } CONTROLS[6];
    uint8_t _reserved0[20];
    __IO hw_tpm_status_t STATUS;           /*!< [0x50] Capture and Compare Status */
    uint8_t _reserved1[28];
    __IO hw_tpm_pol_t POL;                 /*!< [0x70] Channel Polarity */
    uint8_t _reserved2[16];
    __IO hw_tpm_conf_t CONF;               /*!< [0x84] Configuration */
} hw_tpm_t;
#pragma pack()

/*! @brief Macro to access all TPM registers. */
/*! @param x TPM module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_TPM_REGS(TPM0_BASE)</code>. */
#define HW_TPM_REGS(x) (*(hw_tpm_t *)(x))

/*
 * MKL43Z4 UART
 *
 * Serial Communication Interface
 *
 * Registers defined in this header file:
 * - HW_UART_BDH - UART Baud Rate Registers: High
 * - HW_UART_BDL - UART Baud Rate Registers: Low
 * - HW_UART_C1 - UART Control Register 1
 * - HW_UART_C2 - UART Control Register 2
 * - HW_UART_S1 - UART Status Register 1
 * - HW_UART_S2 - UART Status Register 2
 * - HW_UART_C3 - UART Control Register 3
 * - HW_UART_D - UART Data Register
 * - HW_UART_MA1 - UART Match Address Registers 1
 * - HW_UART_MA2 - UART Match Address Registers 2
 * - HW_UART_C4 - UART Control Register 4
 * - HW_UART_C5 - UART Control Register 5
 * - HW_UART_C7816 - UART 7816 Control Register
 * - HW_UART_IE7816 - UART 7816 Interrupt Enable Register
 * - HW_UART_IS7816 - UART 7816 Interrupt Status Register
 * - HW_UART_WP7816 - UART 7816 Wait Parameter Register
 * - HW_UART_WN7816 - UART 7816 Wait N Register
 * - HW_UART_WF7816 - UART 7816 Wait FD Register
 * - HW_UART_ET7816 - UART 7816 Error Threshold Register
 * - HW_UART_TL7816 - UART 7816 Transmit Length Register
 * - HW_UART_AP7816A_T0 - UART 7816 ATR Duration Timer Register A
 * - HW_UART_AP7816B_T0 - UART 7816 ATR Duration Timer Register B
 * - HW_UART_WP7816A_T0 - UART 7816 Wait Parameter Register A
 * - HW_UART_WP7816B_T0 - UART 7816 Wait Parameter Register B
 * - HW_UART_WP7816A_T1 - UART 7816 Wait Parameter Register A
 * - HW_UART_WP7816B_T1 - UART 7816 Wait Parameter Register B
 * - HW_UART_WGP7816_T1 - UART 7816 Wait and Guard Parameter Register
 * - HW_UART_WP7816C_T1 - UART 7816 Wait Parameter Register C
 *
 * - hw_uart_t - Struct containing all module registers.
 */

#define HW_UART_INSTANCE_COUNT (1U) /*!< Number of instances of the UART module. */
#define HW_UART2 (0U) /*!< Instance number for UART2. */

/*******************************************************************************
 * HW_UART_BDH - UART Baud Rate Registers: High
 ******************************************************************************/

/*!
 * @brief HW_UART_BDH - UART Baud Rate Registers: High (RW)
 *
 * Reset value: 0x00U
 *
 * This register, along with the BDL register, controls the prescale divisor for
 * UART baud rate generation. To update the 13-bit baud rate setting
 * (SBR[12:0]), first write to BDH to buffer the high half of the new value and then write
 * to BDL. The working value in BDH does not change until BDL is written. BDL is
 * reset to a nonzero value, but after reset, the baud rate generator remains
 * disabled until the first time the receiver or transmitter is enabled, that is,
 * when C2[RE] or C2[TE] is set.
 */
typedef union _hw_uart_bdh
{
    uint8_t U;
    struct _hw_uart_bdh_bitfields
    {
        uint8_t SBR : 5;               /*!< [4:0] UART Baud Rate Bits */
        uint8_t RESERVED0 : 1;         /*!< [5]  */
        uint8_t RXEDGIE : 1;           /*!< [6] RxD Input Active Edge Interrupt Enable
                                        * */
        uint8_t RESERVED1 : 1;         /*!< [7] Reserved. */
    } B;
} hw_uart_bdh_t;

/*!
 * @name Constants and macros for entire UART_BDH register
 */
/*@{*/
#define HW_UART_BDH_ADDR(x)      ((uint32_t)(x) + 0x0U)

#define HW_UART_BDH(x)           (*(__IO hw_uart_bdh_t *) HW_UART_BDH_ADDR(x))
#define HW_UART_BDH_RD(x)        (HW_UART_BDH(x).U)
#define HW_UART_BDH_WR(x, v)     (HW_UART_BDH(x).U = (v))
#define HW_UART_BDH_SET(x, v)    (BME_OR8(HW_UART_BDH_ADDR(x), (uint8_t)(v)))
#define HW_UART_BDH_CLR(x, v)    (BME_AND8(HW_UART_BDH_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_BDH_TOG(x, v)    (BME_XOR8(HW_UART_BDH_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_BDH bitfields
 */

/*!
 * @name Register UART_BDH, field SBR[4:0] (RW)
 *
 * The baud rate for the UART is determined by the 13 SBR fields. See Baud rate
 * generation for details. The baud rate generator is disabled until C2[TE] or
 * C2[RE] is set for the first time after reset.The baud rate generator is disabled
 * when SBR = 0. Writing to BDH has no effect without writing to BDL, because
 * writing to BDH puts the data in a temporary location until BDL is written.
 */
/*@{*/
#define BP_UART_BDH_SBR      (0U)          /*!< Bit position for UART_BDH_SBR. */
#define BM_UART_BDH_SBR      (0x1FU)       /*!< Bit mask for UART_BDH_SBR. */
#define BS_UART_BDH_SBR      (5U)          /*!< Bit field size in bits for UART_BDH_SBR. */

/*! @brief Read current value of the UART_BDH_SBR field. */
#define BR_UART_BDH_SBR(x)   (BME_UBFX8(HW_UART_BDH_ADDR(x), BP_UART_BDH_SBR, BS_UART_BDH_SBR))

/*! @brief Format value for bitfield UART_BDH_SBR. */
#define BF_UART_BDH_SBR(v)   ((uint8_t)((uint8_t)(v) << BP_UART_BDH_SBR) & BM_UART_BDH_SBR)

/*! @brief Set the SBR field to a new value. */
#define BW_UART_BDH_SBR(x, v) (BME_BFI8(HW_UART_BDH_ADDR(x), ((uint8_t)(v) << BP_UART_BDH_SBR), BP_UART_BDH_SBR, 5))
/*@}*/

/*!
 * @name Register UART_BDH, field RXEDGIE[6] (RW)
 *
 * Enables the receive input active edge, RXEDGIF, to generate interrupt
 * requests.
 *
 * Values:
 * - 0 - Hardware interrupts from RXEDGIF disabled using polling.
 * - 1 - RXEDGIF interrupt request enabled.
 */
/*@{*/
#define BP_UART_BDH_RXEDGIE  (6U)          /*!< Bit position for UART_BDH_RXEDGIE. */
#define BM_UART_BDH_RXEDGIE  (0x40U)       /*!< Bit mask for UART_BDH_RXEDGIE. */
#define BS_UART_BDH_RXEDGIE  (1U)          /*!< Bit field size in bits for UART_BDH_RXEDGIE. */

/*! @brief Read current value of the UART_BDH_RXEDGIE field. */
#define BR_UART_BDH_RXEDGIE(x) (BME_UBFX8(HW_UART_BDH_ADDR(x), BP_UART_BDH_RXEDGIE, BS_UART_BDH_RXEDGIE))

/*! @brief Format value for bitfield UART_BDH_RXEDGIE. */
#define BF_UART_BDH_RXEDGIE(v) ((uint8_t)((uint8_t)(v) << BP_UART_BDH_RXEDGIE) & BM_UART_BDH_RXEDGIE)

/*! @brief Set the RXEDGIE field to a new value. */
#define BW_UART_BDH_RXEDGIE(x, v) (BME_BFI8(HW_UART_BDH_ADDR(x), ((uint8_t)(v) << BP_UART_BDH_RXEDGIE), BP_UART_BDH_RXEDGIE, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_BDL - UART Baud Rate Registers: Low
 ******************************************************************************/

/*!
 * @brief HW_UART_BDL - UART Baud Rate Registers: Low (RW)
 *
 * Reset value: 0x04U
 *
 * This register, along with the BDH register, controls the prescale divisor for
 * UART baud rate generation. To update the 13-bit baud rate setting, SBR[12:0],
 * first write to BDH to buffer the high half of the new value and then write to
 * BDL. The working value in BDH does not change until BDL is written. BDL is
 * reset to a nonzero value, but after reset, the baud rate generator remains
 * disabled until the first time the receiver or transmitter is enabled, that is, when
 * C2[RE] or C2[TE] is set.
 */
typedef union _hw_uart_bdl
{
    uint8_t U;
    struct _hw_uart_bdl_bitfields
    {
        uint8_t SBR : 8;               /*!< [7:0] UART Baud Rate Bits */
    } B;
} hw_uart_bdl_t;

/*!
 * @name Constants and macros for entire UART_BDL register
 */
/*@{*/
#define HW_UART_BDL_ADDR(x)      ((uint32_t)(x) + 0x1U)

#define HW_UART_BDL(x)           (*(__IO hw_uart_bdl_t *) HW_UART_BDL_ADDR(x))
#define HW_UART_BDL_RD(x)        (HW_UART_BDL(x).U)
#define HW_UART_BDL_WR(x, v)     (HW_UART_BDL(x).U = (v))
#define HW_UART_BDL_SET(x, v)    (BME_OR8(HW_UART_BDL_ADDR(x), (uint8_t)(v)))
#define HW_UART_BDL_CLR(x, v)    (BME_AND8(HW_UART_BDL_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_BDL_TOG(x, v)    (BME_XOR8(HW_UART_BDL_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_BDL bitfields
 */

/*!
 * @name Register UART_BDL, field SBR[7:0] (RW)
 *
 * The baud rate for the UART is determined by the 13 SBR fields. See Baud rate
 * generation for details. The baud rate generator is disabled until C2[TE] or
 * C2[RE] is set for the first time after reset.The baud rate generator is disabled
 * when SBR = 0. Writing to BDH has no effect without writing to BDL, because
 * writing to BDH puts the data in a temporary location until BDL is written.
 */
/*@{*/
#define BP_UART_BDL_SBR      (0U)          /*!< Bit position for UART_BDL_SBR. */
#define BM_UART_BDL_SBR      (0xFFU)       /*!< Bit mask for UART_BDL_SBR. */
#define BS_UART_BDL_SBR      (8U)          /*!< Bit field size in bits for UART_BDL_SBR. */

/*! @brief Read current value of the UART_BDL_SBR field. */
#define BR_UART_BDL_SBR(x)   (HW_UART_BDL(x).U)

/*! @brief Format value for bitfield UART_BDL_SBR. */
#define BF_UART_BDL_SBR(v)   ((uint8_t)((uint8_t)(v) << BP_UART_BDL_SBR) & BM_UART_BDL_SBR)

/*! @brief Set the SBR field to a new value. */
#define BW_UART_BDL_SBR(x, v) (HW_UART_BDL_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_C1 - UART Control Register 1
 ******************************************************************************/

/*!
 * @brief HW_UART_C1 - UART Control Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This read/write register controls various optional features of the UART
 * system.
 */
typedef union _hw_uart_c1
{
    uint8_t U;
    struct _hw_uart_c1_bitfields
    {
        uint8_t PT : 1;                /*!< [0] Parity Type */
        uint8_t PE : 1;                /*!< [1] Parity Enable */
        uint8_t ILT : 1;               /*!< [2] Idle Line Type Select */
        uint8_t WAKE : 1;              /*!< [3] Receiver Wakeup Method Select */
        uint8_t M : 1;                 /*!< [4] 9-bit or 8-bit Mode Select */
        uint8_t RSRC : 1;              /*!< [5] Receiver Source Select */
        uint8_t RESERVED0 : 1;         /*!< [6] Reserved. */
        uint8_t LOOPS : 1;             /*!< [7] Loop Mode Select */
    } B;
} hw_uart_c1_t;

/*!
 * @name Constants and macros for entire UART_C1 register
 */
/*@{*/
#define HW_UART_C1_ADDR(x)       ((uint32_t)(x) + 0x2U)

#define HW_UART_C1(x)            (*(__IO hw_uart_c1_t *) HW_UART_C1_ADDR(x))
#define HW_UART_C1_RD(x)         (HW_UART_C1(x).U)
#define HW_UART_C1_WR(x, v)      (HW_UART_C1(x).U = (v))
#define HW_UART_C1_SET(x, v)     (BME_OR8(HW_UART_C1_ADDR(x), (uint8_t)(v)))
#define HW_UART_C1_CLR(x, v)     (BME_AND8(HW_UART_C1_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_C1_TOG(x, v)     (BME_XOR8(HW_UART_C1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_C1 bitfields
 */

/*!
 * @name Register UART_C1, field PT[0] (RW)
 *
 * Determines whether the UART generates and checks for even parity or odd
 * parity. With even parity, an even number of 1s clears the parity bit and an odd
 * number of 1s sets the parity bit. With odd parity, an odd number of 1s clears the
 * parity bit and an even number of 1s sets the parity bit. This field must be
 * cleared when C7816[ISO_7816E] is set/enabled.
 *
 * Values:
 * - 0 - Even parity.
 * - 1 - Odd parity.
 */
/*@{*/
#define BP_UART_C1_PT        (0U)          /*!< Bit position for UART_C1_PT. */
#define BM_UART_C1_PT        (0x01U)       /*!< Bit mask for UART_C1_PT. */
#define BS_UART_C1_PT        (1U)          /*!< Bit field size in bits for UART_C1_PT. */

/*! @brief Read current value of the UART_C1_PT field. */
#define BR_UART_C1_PT(x)     (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_PT, BS_UART_C1_PT))

/*! @brief Format value for bitfield UART_C1_PT. */
#define BF_UART_C1_PT(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C1_PT) & BM_UART_C1_PT)

/*! @brief Set the PT field to a new value. */
#define BW_UART_C1_PT(x, v)  (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_PT), BP_UART_C1_PT, 1))
/*@}*/

/*!
 * @name Register UART_C1, field PE[1] (RW)
 *
 * Enables the parity function. When parity is enabled, parity function inserts
 * a parity bit in the bit position immediately preceding the stop bit. This
 * field must be set when C7816[ISO_7816E] is set/enabled.
 *
 * Values:
 * - 0 - Parity function disabled.
 * - 1 - Parity function enabled.
 */
/*@{*/
#define BP_UART_C1_PE        (1U)          /*!< Bit position for UART_C1_PE. */
#define BM_UART_C1_PE        (0x02U)       /*!< Bit mask for UART_C1_PE. */
#define BS_UART_C1_PE        (1U)          /*!< Bit field size in bits for UART_C1_PE. */

/*! @brief Read current value of the UART_C1_PE field. */
#define BR_UART_C1_PE(x)     (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_PE, BS_UART_C1_PE))

/*! @brief Format value for bitfield UART_C1_PE. */
#define BF_UART_C1_PE(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C1_PE) & BM_UART_C1_PE)

/*! @brief Set the PE field to a new value. */
#define BW_UART_C1_PE(x, v)  (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_PE), BP_UART_C1_PE, 1))
/*@}*/

/*!
 * @name Register UART_C1, field ILT[2] (RW)
 *
 * Determines when the receiver starts counting logic 1s as idle character bits.
 * The count begins either after a valid start bit or after the stop bit. If the
 * count begins after the start bit, then a string of logic 1s preceding the
 * stop bit can cause false recognition of an idle character. Beginning the count
 * after the stop bit avoids false idle character recognition, but requires
 * properly synchronized transmissions. In case the UART is programmed with ILT = 1, a
 * logic of 1'b0 is automatically shifted after a received stop bit, therefore
 * resetting the idle count. In case the UART is programmed for IDLE line wakeup
 * (RWU = 1 and WAKE = 0), ILT has no effect on when the receiver starts counting
 * logic 1s as idle character bits. In idle line wakeup, an idle character is
 * recognized at anytime the receiver sees 10, 11, or 12 1s depending on the M, PE,
 * and C4[M10] fields.
 *
 * Values:
 * - 0 - Idle character bit count starts after start bit.
 * - 1 - Idle character bit count starts after stop bit.
 */
/*@{*/
#define BP_UART_C1_ILT       (2U)          /*!< Bit position for UART_C1_ILT. */
#define BM_UART_C1_ILT       (0x04U)       /*!< Bit mask for UART_C1_ILT. */
#define BS_UART_C1_ILT       (1U)          /*!< Bit field size in bits for UART_C1_ILT. */

/*! @brief Read current value of the UART_C1_ILT field. */
#define BR_UART_C1_ILT(x)    (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_ILT, BS_UART_C1_ILT))

/*! @brief Format value for bitfield UART_C1_ILT. */
#define BF_UART_C1_ILT(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C1_ILT) & BM_UART_C1_ILT)

/*! @brief Set the ILT field to a new value. */
#define BW_UART_C1_ILT(x, v) (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_ILT), BP_UART_C1_ILT, 1))
/*@}*/

/*!
 * @name Register UART_C1, field WAKE[3] (RW)
 *
 * Determines which condition wakes the UART: Address mark in the most
 * significant bit position of a received data character, or An idle condition on the
 * receive pin input signal.
 *
 * Values:
 * - 0 - Idle line wakeup.
 * - 1 - Address mark wakeup.
 */
/*@{*/
#define BP_UART_C1_WAKE      (3U)          /*!< Bit position for UART_C1_WAKE. */
#define BM_UART_C1_WAKE      (0x08U)       /*!< Bit mask for UART_C1_WAKE. */
#define BS_UART_C1_WAKE      (1U)          /*!< Bit field size in bits for UART_C1_WAKE. */

/*! @brief Read current value of the UART_C1_WAKE field. */
#define BR_UART_C1_WAKE(x)   (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_WAKE, BS_UART_C1_WAKE))

/*! @brief Format value for bitfield UART_C1_WAKE. */
#define BF_UART_C1_WAKE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C1_WAKE) & BM_UART_C1_WAKE)

/*! @brief Set the WAKE field to a new value. */
#define BW_UART_C1_WAKE(x, v) (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_WAKE), BP_UART_C1_WAKE, 1))
/*@}*/

/*!
 * @name Register UART_C1, field M[4] (RW)
 *
 * This field must be set when C7816[ISO_7816E] is set/enabled.
 *
 * Values:
 * - 0 - Normal-start + 8 data bits (MSB/LSB first as determined by MSBF) + stop.
 * - 1 - Use-start + 9 data bits (MSB/LSB first as determined by MSBF) + stop.
 */
/*@{*/
#define BP_UART_C1_M         (4U)          /*!< Bit position for UART_C1_M. */
#define BM_UART_C1_M         (0x10U)       /*!< Bit mask for UART_C1_M. */
#define BS_UART_C1_M         (1U)          /*!< Bit field size in bits for UART_C1_M. */

/*! @brief Read current value of the UART_C1_M field. */
#define BR_UART_C1_M(x)      (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_M, BS_UART_C1_M))

/*! @brief Format value for bitfield UART_C1_M. */
#define BF_UART_C1_M(v)      ((uint8_t)((uint8_t)(v) << BP_UART_C1_M) & BM_UART_C1_M)

/*! @brief Set the M field to a new value. */
#define BW_UART_C1_M(x, v)   (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_M), BP_UART_C1_M, 1))
/*@}*/

/*!
 * @name Register UART_C1, field RSRC[5] (RW)
 *
 * This field has no meaning or effect unless the LOOPS field is set. When LOOPS
 * is set, the RSRC field determines the source for the receiver shift register
 * input.
 *
 * Values:
 * - 0 - Selects internal loop back mode. The receiver input is internally
 *     connected to transmitter output.
 * - 1 - Single wire UART mode where the receiver input is connected to the
 *     transmit pin input signal.
 */
/*@{*/
#define BP_UART_C1_RSRC      (5U)          /*!< Bit position for UART_C1_RSRC. */
#define BM_UART_C1_RSRC      (0x20U)       /*!< Bit mask for UART_C1_RSRC. */
#define BS_UART_C1_RSRC      (1U)          /*!< Bit field size in bits for UART_C1_RSRC. */

/*! @brief Read current value of the UART_C1_RSRC field. */
#define BR_UART_C1_RSRC(x)   (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_RSRC, BS_UART_C1_RSRC))

/*! @brief Format value for bitfield UART_C1_RSRC. */
#define BF_UART_C1_RSRC(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C1_RSRC) & BM_UART_C1_RSRC)

/*! @brief Set the RSRC field to a new value. */
#define BW_UART_C1_RSRC(x, v) (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_RSRC), BP_UART_C1_RSRC, 1))
/*@}*/

/*!
 * @name Register UART_C1, field LOOPS[7] (RW)
 *
 * When LOOPS is set, the RxD pin is disconnected from the UART and the
 * transmitter output is internally connected to the receiver input. The transmitter and
 * the receiver must be enabled to use the loop function.
 *
 * Values:
 * - 0 - Normal operation.
 * - 1 - Loop mode where transmitter output is internally connected to receiver
 *     input. The receiver input is determined by RSRC.
 */
/*@{*/
#define BP_UART_C1_LOOPS     (7U)          /*!< Bit position for UART_C1_LOOPS. */
#define BM_UART_C1_LOOPS     (0x80U)       /*!< Bit mask for UART_C1_LOOPS. */
#define BS_UART_C1_LOOPS     (1U)          /*!< Bit field size in bits for UART_C1_LOOPS. */

/*! @brief Read current value of the UART_C1_LOOPS field. */
#define BR_UART_C1_LOOPS(x)  (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_LOOPS, BS_UART_C1_LOOPS))

/*! @brief Format value for bitfield UART_C1_LOOPS. */
#define BF_UART_C1_LOOPS(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C1_LOOPS) & BM_UART_C1_LOOPS)

/*! @brief Set the LOOPS field to a new value. */
#define BW_UART_C1_LOOPS(x, v) (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_LOOPS), BP_UART_C1_LOOPS, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_C2 - UART Control Register 2
 ******************************************************************************/

/*!
 * @brief HW_UART_C2 - UART Control Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This register can be read or written at any time.
 */
typedef union _hw_uart_c2
{
    uint8_t U;
    struct _hw_uart_c2_bitfields
    {
        uint8_t SBK : 1;               /*!< [0] Send Break */
        uint8_t RWU : 1;               /*!< [1] Receiver Wakeup Control */
        uint8_t RE : 1;                /*!< [2] Receiver Enable */
        uint8_t TE : 1;                /*!< [3] Transmitter Enable */
        uint8_t ILIE : 1;              /*!< [4] Idle Line Interrupt Enable */
        uint8_t RIE : 1;               /*!< [5] Receiver Full Interrupt or DMA Transfer
                                        * Enable */
        uint8_t TCIE : 1;              /*!< [6] Transmission Complete Interrupt Enable */
        uint8_t TIE : 1;               /*!< [7] Transmitter Interrupt or DMA Transfer
                                        * Enable. */
    } B;
} hw_uart_c2_t;

/*!
 * @name Constants and macros for entire UART_C2 register
 */
/*@{*/
#define HW_UART_C2_ADDR(x)       ((uint32_t)(x) + 0x3U)

#define HW_UART_C2(x)            (*(__IO hw_uart_c2_t *) HW_UART_C2_ADDR(x))
#define HW_UART_C2_RD(x)         (HW_UART_C2(x).U)
#define HW_UART_C2_WR(x, v)      (HW_UART_C2(x).U = (v))
#define HW_UART_C2_SET(x, v)     (BME_OR8(HW_UART_C2_ADDR(x), (uint8_t)(v)))
#define HW_UART_C2_CLR(x, v)     (BME_AND8(HW_UART_C2_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_C2_TOG(x, v)     (BME_XOR8(HW_UART_C2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_C2 bitfields
 */

/*!
 * @name Register UART_C2, field SBK[0] (RW)
 *
 * Toggling SBK sends one break character from the following: See Transmitting
 * break characters for the number of logic 0s for the different configurations.
 * Toggling implies clearing the SBK field before the break character has finished
 * transmitting. As long as SBK is set, the transmitter continues to send
 * complete break characters (10, 11, or 12 bits, or 13 or 14 bits). Ensure that C2[TE]
 * is asserted atleast 1 clock before assertion of this bit. 10, 11, or 12 logic
 * 0s if S2[BRK13] is cleared 13 or 14 logic 0s if S2[BRK13] is set. This field
 * must be cleared when C7816[ISO_7816E] is set.
 *
 * Values:
 * - 0 - Normal transmitter operation.
 * - 1 - Queue break characters to be sent.
 */
/*@{*/
#define BP_UART_C2_SBK       (0U)          /*!< Bit position for UART_C2_SBK. */
#define BM_UART_C2_SBK       (0x01U)       /*!< Bit mask for UART_C2_SBK. */
#define BS_UART_C2_SBK       (1U)          /*!< Bit field size in bits for UART_C2_SBK. */

/*! @brief Read current value of the UART_C2_SBK field. */
#define BR_UART_C2_SBK(x)    (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_SBK, BS_UART_C2_SBK))

/*! @brief Format value for bitfield UART_C2_SBK. */
#define BF_UART_C2_SBK(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C2_SBK) & BM_UART_C2_SBK)

/*! @brief Set the SBK field to a new value. */
#define BW_UART_C2_SBK(x, v) (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_SBK), BP_UART_C2_SBK, 1))
/*@}*/

/*!
 * @name Register UART_C2, field RWU[1] (RW)
 *
 * This field can be set to place the UART receiver in a standby state. RWU
 * automatically clears when an RWU event occurs, that is, an IDLE event when
 * C1[WAKE] is clear or an address match when C1[WAKE] is set. This field must be
 * cleared when C7816[ISO_7816E] is set. RWU must be set only with C1[WAKE] = 0 (wakeup
 * on idle) if the channel is currently not idle. This can be determined by
 * S2[RAF]. If the flag is set to wake up an IDLE event and the channel is already
 * idle, it is possible that the UART will discard data. This is because the data
 * must be received after an IDLE is detected before IDLE is allowed to reasserted.
 *
 * Values:
 * - 0 - Normal operation.
 * - 1 - RWU enables the wakeup function and inhibits further receiver interrupt
 *     requests. Normally, hardware wakes the receiver by automatically clearing
 *     RWU.
 */
/*@{*/
#define BP_UART_C2_RWU       (1U)          /*!< Bit position for UART_C2_RWU. */
#define BM_UART_C2_RWU       (0x02U)       /*!< Bit mask for UART_C2_RWU. */
#define BS_UART_C2_RWU       (1U)          /*!< Bit field size in bits for UART_C2_RWU. */

/*! @brief Read current value of the UART_C2_RWU field. */
#define BR_UART_C2_RWU(x)    (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_RWU, BS_UART_C2_RWU))

/*! @brief Format value for bitfield UART_C2_RWU. */
#define BF_UART_C2_RWU(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C2_RWU) & BM_UART_C2_RWU)

/*! @brief Set the RWU field to a new value. */
#define BW_UART_C2_RWU(x, v) (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_RWU), BP_UART_C2_RWU, 1))
/*@}*/

/*!
 * @name Register UART_C2, field RE[2] (RW)
 *
 * Enables the UART receiver.
 *
 * Values:
 * - 0 - Receiver off.
 * - 1 - Receiver on.
 */
/*@{*/
#define BP_UART_C2_RE        (2U)          /*!< Bit position for UART_C2_RE. */
#define BM_UART_C2_RE        (0x04U)       /*!< Bit mask for UART_C2_RE. */
#define BS_UART_C2_RE        (1U)          /*!< Bit field size in bits for UART_C2_RE. */

/*! @brief Read current value of the UART_C2_RE field. */
#define BR_UART_C2_RE(x)     (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_RE, BS_UART_C2_RE))

/*! @brief Format value for bitfield UART_C2_RE. */
#define BF_UART_C2_RE(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C2_RE) & BM_UART_C2_RE)

/*! @brief Set the RE field to a new value. */
#define BW_UART_C2_RE(x, v)  (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_RE), BP_UART_C2_RE, 1))
/*@}*/

/*!
 * @name Register UART_C2, field TE[3] (RW)
 *
 * Enables the UART transmitter. TE can be used to queue an idle preamble by
 * clearing and then setting TE. When C7816[ISO_7816E] is set/enabled and
 * C7816[TTYPE] = 1, this field is automatically cleared after the requested block has been
 * transmitted. This condition is detected when TL7816[TLEN] = 0 and four
 * additional characters are transmitted.
 *
 * Values:
 * - 0 - Transmitter off.
 * - 1 - Transmitter on.
 */
/*@{*/
#define BP_UART_C2_TE        (3U)          /*!< Bit position for UART_C2_TE. */
#define BM_UART_C2_TE        (0x08U)       /*!< Bit mask for UART_C2_TE. */
#define BS_UART_C2_TE        (1U)          /*!< Bit field size in bits for UART_C2_TE. */

/*! @brief Read current value of the UART_C2_TE field. */
#define BR_UART_C2_TE(x)     (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_TE, BS_UART_C2_TE))

/*! @brief Format value for bitfield UART_C2_TE. */
#define BF_UART_C2_TE(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C2_TE) & BM_UART_C2_TE)

/*! @brief Set the TE field to a new value. */
#define BW_UART_C2_TE(x, v)  (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_TE), BP_UART_C2_TE, 1))
/*@}*/

/*!
 * @name Register UART_C2, field ILIE[4] (RW)
 *
 * Enables the idle line flag, S1[IDLE], to generate interrupt requests
 *
 * Values:
 * - 0 - IDLE interrupt requests disabled.
 * - 1 - IDLE interrupt requests enabled.
 */
/*@{*/
#define BP_UART_C2_ILIE      (4U)          /*!< Bit position for UART_C2_ILIE. */
#define BM_UART_C2_ILIE      (0x10U)       /*!< Bit mask for UART_C2_ILIE. */
#define BS_UART_C2_ILIE      (1U)          /*!< Bit field size in bits for UART_C2_ILIE. */

/*! @brief Read current value of the UART_C2_ILIE field. */
#define BR_UART_C2_ILIE(x)   (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_ILIE, BS_UART_C2_ILIE))

/*! @brief Format value for bitfield UART_C2_ILIE. */
#define BF_UART_C2_ILIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C2_ILIE) & BM_UART_C2_ILIE)

/*! @brief Set the ILIE field to a new value. */
#define BW_UART_C2_ILIE(x, v) (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_ILIE), BP_UART_C2_ILIE, 1))
/*@}*/

/*!
 * @name Register UART_C2, field RIE[5] (RW)
 *
 * Enables S1[RDRF] to generate interrupt requests or DMA transfer requests,
 * based on the state of C5[RDMAS].
 *
 * Values:
 * - 0 - RDRF interrupt and DMA transfer requests disabled.
 * - 1 - RDRF interrupt or DMA transfer requests enabled.
 */
/*@{*/
#define BP_UART_C2_RIE       (5U)          /*!< Bit position for UART_C2_RIE. */
#define BM_UART_C2_RIE       (0x20U)       /*!< Bit mask for UART_C2_RIE. */
#define BS_UART_C2_RIE       (1U)          /*!< Bit field size in bits for UART_C2_RIE. */

/*! @brief Read current value of the UART_C2_RIE field. */
#define BR_UART_C2_RIE(x)    (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_RIE, BS_UART_C2_RIE))

/*! @brief Format value for bitfield UART_C2_RIE. */
#define BF_UART_C2_RIE(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C2_RIE) & BM_UART_C2_RIE)

/*! @brief Set the RIE field to a new value. */
#define BW_UART_C2_RIE(x, v) (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_RIE), BP_UART_C2_RIE, 1))
/*@}*/

/*!
 * @name Register UART_C2, field TCIE[6] (RW)
 *
 * Enables the transmission complete flag, S1[TC], to generate interrupt
 * requests .
 *
 * Values:
 * - 0 - TC interrupt requests disabled.
 * - 1 - TC interrupt requests enabled.
 */
/*@{*/
#define BP_UART_C2_TCIE      (6U)          /*!< Bit position for UART_C2_TCIE. */
#define BM_UART_C2_TCIE      (0x40U)       /*!< Bit mask for UART_C2_TCIE. */
#define BS_UART_C2_TCIE      (1U)          /*!< Bit field size in bits for UART_C2_TCIE. */

/*! @brief Read current value of the UART_C2_TCIE field. */
#define BR_UART_C2_TCIE(x)   (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_TCIE, BS_UART_C2_TCIE))

/*! @brief Format value for bitfield UART_C2_TCIE. */
#define BF_UART_C2_TCIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C2_TCIE) & BM_UART_C2_TCIE)

/*! @brief Set the TCIE field to a new value. */
#define BW_UART_C2_TCIE(x, v) (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_TCIE), BP_UART_C2_TCIE, 1))
/*@}*/

/*!
 * @name Register UART_C2, field TIE[7] (RW)
 *
 * Enables S1[TDRE] to generate interrupt requests or DMA transfer requests,
 * based on the state of C5[TDMAS]. If C2[TIE] and C5[TDMAS] are both set, then TCIE
 * must be cleared, and D[D] must not be written unless servicing a DMA request.
 *
 * Values:
 * - 0 - TDRE interrupt and DMA transfer requests disabled.
 * - 1 - TDRE interrupt or DMA transfer requests enabled.
 */
/*@{*/
#define BP_UART_C2_TIE       (7U)          /*!< Bit position for UART_C2_TIE. */
#define BM_UART_C2_TIE       (0x80U)       /*!< Bit mask for UART_C2_TIE. */
#define BS_UART_C2_TIE       (1U)          /*!< Bit field size in bits for UART_C2_TIE. */

/*! @brief Read current value of the UART_C2_TIE field. */
#define BR_UART_C2_TIE(x)    (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_TIE, BS_UART_C2_TIE))

/*! @brief Format value for bitfield UART_C2_TIE. */
#define BF_UART_C2_TIE(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C2_TIE) & BM_UART_C2_TIE)

/*! @brief Set the TIE field to a new value. */
#define BW_UART_C2_TIE(x, v) (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_TIE), BP_UART_C2_TIE, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_S1 - UART Status Register 1
 ******************************************************************************/

/*!
 * @brief HW_UART_S1 - UART Status Register 1 (RO)
 *
 * Reset value: 0xC0U
 *
 * The S1 register provides inputs to the MCU for generation of UART interrupts
 * or DMA requests. This register can also be polled by the MCU to check the
 * status of its fields. To clear a flag, the status register should be read followed
 * by a read or write to D register, depending on the interrupt flag type. Other
 * instructions can be executed between the two steps as long the handling of
 * I/O is not compromised, but the order of operations is important for flag
 * clearing. When a flag is configured to trigger a DMA request, assertion of the
 * associated DMA done signal from the DMA controller clears the flag. If the
 * condition that results in the assertion of the flag, interrupt, or DMA request is not
 * resolved prior to clearing the flag, the flag, and interrupt/DMA request,
 * reasserts. For example, if the DMA or interrupt service routine fails to write
 * sufficient data to the transmit buffer to raise it above the watermark level, the
 * flag reasserts and generates another interrupt or DMA request. Reading an
 * empty data register to clear one of the flags of the S1 register causes the FIFO
 * pointers to become misaligned. A receive FIFO flush reinitializes the
 * pointers. A better way to prevent this situation is to always leave one byte in FIFO
 * and this byte will be read eventually in clearing the flag bit.
 */
typedef union _hw_uart_s1
{
    uint8_t U;
    struct _hw_uart_s1_bitfields
    {
        uint8_t PF : 1;                /*!< [0] Parity Error Flag */
        uint8_t FE : 1;                /*!< [1] Framing Error Flag */
        uint8_t NF : 1;                /*!< [2] Noise Flag */
        uint8_t OR : 1;                /*!< [3] Receiver Overrun Flag */
        uint8_t IDLE : 1;              /*!< [4] Idle Line Flag */
        uint8_t RDRF : 1;              /*!< [5] Receive Data Register Full Flag */
        uint8_t TC : 1;                /*!< [6] Transmit Complete Flag */
        uint8_t TDRE : 1;              /*!< [7] Transmit Data Register Empty Flag */
    } B;
} hw_uart_s1_t;

/*!
 * @name Constants and macros for entire UART_S1 register
 */
/*@{*/
#define HW_UART_S1_ADDR(x)       ((uint32_t)(x) + 0x4U)

#define HW_UART_S1(x)            (*(__I hw_uart_s1_t *) HW_UART_S1_ADDR(x))
#define HW_UART_S1_RD(x)         (HW_UART_S1(x).U)
/*@}*/

/*
 * Constants & macros for individual UART_S1 bitfields
 */

/*!
 * @name Register UART_S1, field PF[0] (RO)
 *
 * PF is set when PE is set and the parity of the received data does not match
 * its parity bit. The PF is not set in the case of an overrun condition. When PF
 * is set, it indicates only that a dataword was received with parity error since
 * the last time it was cleared. There is no guarantee that the first dataword
 * read from the receive buffer has a parity error or that there is only one
 * dataword in the buffer that was received with a parity error, unless the receive
 * buffer has a depth of one. To clear PF, read S1 and then read D.
 *
 * Values:
 * - 0 - No parity error detected since the last time this flag was cleared. If
 *     the receive buffer has a depth greater than 1, then there may be data in
 *     the receive buffer what was received with a parity error.
 * - 1 - At least one dataword was received with a parity error since the last
 *     time this flag was cleared.
 */
/*@{*/
#define BP_UART_S1_PF        (0U)          /*!< Bit position for UART_S1_PF. */
#define BM_UART_S1_PF        (0x01U)       /*!< Bit mask for UART_S1_PF. */
#define BS_UART_S1_PF        (1U)          /*!< Bit field size in bits for UART_S1_PF. */

/*! @brief Read current value of the UART_S1_PF field. */
#define BR_UART_S1_PF(x)     (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_PF, BS_UART_S1_PF))
/*@}*/

/*!
 * @name Register UART_S1, field FE[1] (RO)
 *
 * FE is set when a logic 0 is accepted as the stop bit. FE does not set in the
 * case of an overrun. FE inhibits further data reception until it is cleared. To
 * clear FE, read S1 with FE set and then read D. The last data in the receive
 * buffer represents the data that was received with the frame error enabled.
 * Framing errors are not supported when 7816E is set/enabled. However, if this flag
 * is set, data is still not received in 7816 mode.
 *
 * Values:
 * - 0 - No framing error detected.
 * - 1 - Framing error.
 */
/*@{*/
#define BP_UART_S1_FE        (1U)          /*!< Bit position for UART_S1_FE. */
#define BM_UART_S1_FE        (0x02U)       /*!< Bit mask for UART_S1_FE. */
#define BS_UART_S1_FE        (1U)          /*!< Bit field size in bits for UART_S1_FE. */

/*! @brief Read current value of the UART_S1_FE field. */
#define BR_UART_S1_FE(x)     (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_FE, BS_UART_S1_FE))
/*@}*/

/*!
 * @name Register UART_S1, field NF[2] (RO)
 *
 * NF is set when the UART detects noise on the receiver input. NF does not
 * become set in the case of an overrun. When NF is set, it indicates only that a
 * dataword has been received with noise since the last time it was cleared. There
 * is no guarantee that the first dataword read from the receive buffer has noise
 * or that there is only one dataword in the buffer that was received with noise
 * unless the receive buffer has a depth of one. To clear NF, read S1 and then
 * read D.
 *
 * Values:
 * - 0 - No noise detected since the last time this flag was cleared. If the
 *     receive buffer has a depth greater than 1 then there may be data in the
 *     receiver buffer that was received with noise.
 * - 1 - At least one dataword was received with noise detected since the last
 *     time the flag was cleared.
 */
/*@{*/
#define BP_UART_S1_NF        (2U)          /*!< Bit position for UART_S1_NF. */
#define BM_UART_S1_NF        (0x04U)       /*!< Bit mask for UART_S1_NF. */
#define BS_UART_S1_NF        (1U)          /*!< Bit field size in bits for UART_S1_NF. */

/*! @brief Read current value of the UART_S1_NF field. */
#define BR_UART_S1_NF(x)     (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_NF, BS_UART_S1_NF))
/*@}*/

/*!
 * @name Register UART_S1, field OR[3] (RO)
 *
 * OR is set when software fails to prevent the receive data register from
 * overflowing with data. The OR bit is set immediately after the stop bit has been
 * completely received for the dataword that overflows the buffer and all the other
 * error flags (FE, NF, and PF) are prevented from setting. The data in the
 * shift register is lost, but the data already in the UART data registers is not
 * affected. If the OR flag is set, no data is stored in the data buffer even if
 * sufficient room exists. Additionally, while the OR flag is set, the RDRF and IDLE
 * flags are blocked from asserting, that is, transition from an inactive to an
 * active state. To clear OR, read S1 when OR is set and then read D. See
 * functional description for more details regarding the operation of the OR bit. In
 * 7816 mode, it is possible to configure a NACK to be returned by programing
 * C7816[ONACK].
 *
 * Values:
 * - 0 - No overrun has occurred since the last time the flag was cleared.
 * - 1 - Overrun has occurred or the overrun flag has not been cleared since the
 *     last overrun occured.
 */
/*@{*/
#define BP_UART_S1_OR        (3U)          /*!< Bit position for UART_S1_OR. */
#define BM_UART_S1_OR        (0x08U)       /*!< Bit mask for UART_S1_OR. */
#define BS_UART_S1_OR        (1U)          /*!< Bit field size in bits for UART_S1_OR. */

/*! @brief Read current value of the UART_S1_OR field. */
#define BR_UART_S1_OR(x)     (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_OR, BS_UART_S1_OR))
/*@}*/

/*!
 * @name Register UART_S1, field IDLE[4] (RO)
 *
 * After the IDLE flag is cleared, a frame must be received (although not
 * necessarily stored in the data buffer, for example if C2[RWU] is set). To clear
 * IDLE, read UART status S1 with IDLE set and then read D. IDLE is set when either
 * of the following appear on the receiver input: 10 consecutive logic 1s if C1[M]
 * = 0 11 consecutive logic 1s if C1[M] = 1 and C4[M10] = 0 12 consecutive logic
 * 1s if C1[M] = 1, C4[M10] = 1, and C1[PE] = 1 Idle detection is not supported
 * when 7816E is set/enabled and hence this flag is ignored. When RWU is set and
 * WAKE is cleared, an idle line condition sets the IDLE flag if RWUID is set,
 * else the IDLE flag does not become set.
 *
 * Values:
 * - 0 - Receiver input is either active now or has never become active since
 *     the IDLE flag was last cleared.
 * - 1 - Receiver input has become idle or the flag has not been cleared since
 *     it last asserted.
 */
/*@{*/
#define BP_UART_S1_IDLE      (4U)          /*!< Bit position for UART_S1_IDLE. */
#define BM_UART_S1_IDLE      (0x10U)       /*!< Bit mask for UART_S1_IDLE. */
#define BS_UART_S1_IDLE      (1U)          /*!< Bit field size in bits for UART_S1_IDLE. */

/*! @brief Read current value of the UART_S1_IDLE field. */
#define BR_UART_S1_IDLE(x)   (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_IDLE, BS_UART_S1_IDLE))
/*@}*/

/*!
 * @name Register UART_S1, field RDRF[5] (RO)
 *
 * RDRF is set when the number of datawords in the receive buffer is equal to or
 * more than the number indicated by RWFIFO[RXWATER]. A dataword that is in the
 * process of being received is not included in the count. To clear RDRF, read S1
 * when RDRF is set and then read D. For more efficient interrupt and DMA
 * operation, read all data except the final value from the buffer, using D/C3[T8]/ED.
 * Then read S1 and the final data value, resulting in the clearing of the RDRF
 * flag. Even if RDRF is set, data will continue to be received until an overrun
 * condition occurs.
 *
 * Values:
 * - 0 - The number of datawords in the receive buffer is less than the number
 *     indicated by RXWATER.
 * - 1 - The number of datawords in the receive buffer is equal to or greater
 *     than the number indicated by RXWATER at some point in time since this flag
 *     was last cleared.
 */
/*@{*/
#define BP_UART_S1_RDRF      (5U)          /*!< Bit position for UART_S1_RDRF. */
#define BM_UART_S1_RDRF      (0x20U)       /*!< Bit mask for UART_S1_RDRF. */
#define BS_UART_S1_RDRF      (1U)          /*!< Bit field size in bits for UART_S1_RDRF. */

/*! @brief Read current value of the UART_S1_RDRF field. */
#define BR_UART_S1_RDRF(x)   (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_RDRF, BS_UART_S1_RDRF))
/*@}*/

/*!
 * @name Register UART_S1, field TC[6] (RO)
 *
 * TC is set when the transmit buffer is empty and no data, preamble, or break
 * character is being transmitted. When TC is set, the transmit data output signal
 * becomes idle (logic 1). TC is cleared by reading S1 with TC set and then
 * doing one of the following: When C7816[ISO_7816E] is set/enabled, this field is
 * set after any NACK signal has been received, but prior to any corresponding
 * guard times expiring. Writing to D to transmit new data. Queuing a preamble by
 * clearing and then setting C2[TE]. Queuing a break character by writing 1 to SBK
 * in C2.
 *
 * Values:
 * - 0 - Transmitter active (sending data, a preamble, or a break).
 * - 1 - Transmitter idle (transmission activity complete).
 */
/*@{*/
#define BP_UART_S1_TC        (6U)          /*!< Bit position for UART_S1_TC. */
#define BM_UART_S1_TC        (0x40U)       /*!< Bit mask for UART_S1_TC. */
#define BS_UART_S1_TC        (1U)          /*!< Bit field size in bits for UART_S1_TC. */

/*! @brief Read current value of the UART_S1_TC field. */
#define BR_UART_S1_TC(x)     (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_TC, BS_UART_S1_TC))
/*@}*/

/*!
 * @name Register UART_S1, field TDRE[7] (RO)
 *
 * TDRE will set when the number of datawords in the transmit buffer (D and
 * C3[T8])is equal to or less than the number indicated by TWFIFO[TXWATER]. A
 * character that is in the process of being transmitted is not included in the count.
 * To clear TDRE, read S1 when TDRE is set and then write to the UART data
 * register (D). For more efficient interrupt servicing, all data except the final value
 * to be written to the buffer must be written to D/C3[T8]. Then S1 can be read
 * before writing the final data value, resulting in the clearing of the TRDE
 * flag. This is more efficient because the TDRE reasserts until the watermark has
 * been exceeded. So, attempting to clear the TDRE with every write will be
 * ineffective until sufficient data has been written.
 *
 * Values:
 * - 0 - The amount of data in the transmit buffer is greater than the value
 *     indicated by TWFIFO[TXWATER].
 * - 1 - The amount of data in the transmit buffer is less than or equal to the
 *     value indicated by TWFIFO[TXWATER] at some point in time since the flag
 *     has been cleared.
 */
/*@{*/
#define BP_UART_S1_TDRE      (7U)          /*!< Bit position for UART_S1_TDRE. */
#define BM_UART_S1_TDRE      (0x80U)       /*!< Bit mask for UART_S1_TDRE. */
#define BS_UART_S1_TDRE      (1U)          /*!< Bit field size in bits for UART_S1_TDRE. */

/*! @brief Read current value of the UART_S1_TDRE field. */
#define BR_UART_S1_TDRE(x)   (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_TDRE, BS_UART_S1_TDRE))
/*@}*/

/*******************************************************************************
 * HW_UART_S2 - UART Status Register 2
 ******************************************************************************/

/*!
 * @brief HW_UART_S2 - UART Status Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * The S2 register provides inputs to the MCU for generation of UART interrupts
 * or DMA requests. Also, this register can be polled by the MCU to check the
 * status of these bits. This register can be read or written at any time, with the
 * exception of the MSBF and RXINV bits, which should be changed by the user only
 * between transmit and receive packets.
 */
typedef union _hw_uart_s2
{
    uint8_t U;
    struct _hw_uart_s2_bitfields
    {
        uint8_t RAF : 1;               /*!< [0] Receiver Active Flag */
        uint8_t RESERVED0 : 1;         /*!< [1] Reserved. */
        uint8_t BRK13 : 1;             /*!< [2] Break Transmit Character Length */
        uint8_t RWUID : 1;             /*!< [3] Receive Wakeup Idle Detect */
        uint8_t RXINV : 1;             /*!< [4] Receive Data Inversion */
        uint8_t MSBF : 1;              /*!< [5] Most Significant Bit First */
        uint8_t RXEDGIF : 1;           /*!< [6] RxD Pin Active Edge Interrupt Flag */
        uint8_t RESERVED1 : 1;         /*!< [7]  */
    } B;
} hw_uart_s2_t;

/*!
 * @name Constants and macros for entire UART_S2 register
 */
/*@{*/
#define HW_UART_S2_ADDR(x)       ((uint32_t)(x) + 0x5U)

#define HW_UART_S2(x)            (*(__IO hw_uart_s2_t *) HW_UART_S2_ADDR(x))
#define HW_UART_S2_RD(x)         (HW_UART_S2(x).U)
#define HW_UART_S2_WR(x, v)      (HW_UART_S2(x).U = (v))
#define HW_UART_S2_SET(x, v)     (BME_OR8(HW_UART_S2_ADDR(x), (uint8_t)(v)))
#define HW_UART_S2_CLR(x, v)     (BME_AND8(HW_UART_S2_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_S2_TOG(x, v)     (BME_XOR8(HW_UART_S2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_S2 bitfields
 */

/*!
 * @name Register UART_S2, field RAF[0] (RO)
 *
 * RAF is set when the UART receiver detects a logic 0 during the RT1 time
 * period of the start bit search. RAF is cleared when the receiver detects an idle
 * character when C7816[ISO7816E] is cleared/disabled. When C7816[ISO7816E] is
 * enabled, the RAF is cleared if the C7816[TTYPE] = 0 expires or the C7816[TTYPE] =
 * 1 expires.In case C7816[ISO7816E] is set and C7816[TTYPE] = 0, it is possible
 * to configure the guard time to 12. However, if a NACK is required to be
 * transmitted, the data transfer actually takes 13 ETU with the 13th ETU slot being a
 * inactive buffer. Therefore, in this situation, the RAF may deassert one ETU
 * prior to actually being inactive.
 *
 * Values:
 * - 0 - UART receiver idle/inactive waiting for a start bit.
 * - 1 - UART receiver active, RxD input not idle.
 */
/*@{*/
#define BP_UART_S2_RAF       (0U)          /*!< Bit position for UART_S2_RAF. */
#define BM_UART_S2_RAF       (0x01U)       /*!< Bit mask for UART_S2_RAF. */
#define BS_UART_S2_RAF       (1U)          /*!< Bit field size in bits for UART_S2_RAF. */

/*! @brief Read current value of the UART_S2_RAF field. */
#define BR_UART_S2_RAF(x)    (BME_UBFX8(HW_UART_S2_ADDR(x), BP_UART_S2_RAF, BS_UART_S2_RAF))
/*@}*/

/*!
 * @name Register UART_S2, field BRK13[2] (RW)
 *
 * Determines whether the transmit break character is 10, 11, or 12 bits long,
 * or 13 or 14 bits long. See for the length of the break character for the
 * different configurations. The detection of a framing error is not affected by this
 * field. Transmitting break characters
 *
 * Values:
 * - 0 - Break character is 10, 11, or 12 bits long.
 * - 1 - Break character is 13 or 14 bits long.
 */
/*@{*/
#define BP_UART_S2_BRK13     (2U)          /*!< Bit position for UART_S2_BRK13. */
#define BM_UART_S2_BRK13     (0x04U)       /*!< Bit mask for UART_S2_BRK13. */
#define BS_UART_S2_BRK13     (1U)          /*!< Bit field size in bits for UART_S2_BRK13. */

/*! @brief Read current value of the UART_S2_BRK13 field. */
#define BR_UART_S2_BRK13(x)  (BME_UBFX8(HW_UART_S2_ADDR(x), BP_UART_S2_BRK13, BS_UART_S2_BRK13))

/*! @brief Format value for bitfield UART_S2_BRK13. */
#define BF_UART_S2_BRK13(v)  ((uint8_t)((uint8_t)(v) << BP_UART_S2_BRK13) & BM_UART_S2_BRK13)

/*! @brief Set the BRK13 field to a new value. */
#define BW_UART_S2_BRK13(x, v) (BME_BFI8(HW_UART_S2_ADDR(x), ((uint8_t)(v) << BP_UART_S2_BRK13), BP_UART_S2_BRK13, 1))
/*@}*/

/*!
 * @name Register UART_S2, field RWUID[3] (RW)
 *
 * When RWU is set and WAKE is cleared, this field controls whether the idle
 * character that wakes the receiver sets S1[IDLE]. This field must be cleared when
 * C7816[ISO7816E] is set/enabled.
 *
 * Values:
 * - 0 - S1[IDLE] is not set upon detection of an idle character.
 * - 1 - S1[IDLE] is set upon detection of an idle character.
 */
/*@{*/
#define BP_UART_S2_RWUID     (3U)          /*!< Bit position for UART_S2_RWUID. */
#define BM_UART_S2_RWUID     (0x08U)       /*!< Bit mask for UART_S2_RWUID. */
#define BS_UART_S2_RWUID     (1U)          /*!< Bit field size in bits for UART_S2_RWUID. */

/*! @brief Read current value of the UART_S2_RWUID field. */
#define BR_UART_S2_RWUID(x)  (BME_UBFX8(HW_UART_S2_ADDR(x), BP_UART_S2_RWUID, BS_UART_S2_RWUID))

/*! @brief Format value for bitfield UART_S2_RWUID. */
#define BF_UART_S2_RWUID(v)  ((uint8_t)((uint8_t)(v) << BP_UART_S2_RWUID) & BM_UART_S2_RWUID)

/*! @brief Set the RWUID field to a new value. */
#define BW_UART_S2_RWUID(x, v) (BME_BFI8(HW_UART_S2_ADDR(x), ((uint8_t)(v) << BP_UART_S2_RWUID), BP_UART_S2_RWUID, 1))
/*@}*/

/*!
 * @name Register UART_S2, field RXINV[4] (RW)
 *
 * Setting this field reverses the polarity of the received data input. In NRZ
 * format, a one is represented by a mark and a zero is represented by a space for
 * normal polarity, and the opposite for inverted polarity. This field is
 * automatically set when C7816[INIT] and C7816[ISO7816E] are enabled and an initial
 * character is detected in T = 0 protocol mode. Setting RXINV inverts the RxD
 * input for data bits, start and stop bits, break, and idle. When C7816[ISO7816E] is
 * set/enabled, only the data bits and the parity bit are inverted.
 *
 * Values:
 * - 0 - Receive data is not inverted.
 * - 1 - Receive data is inverted.
 */
/*@{*/
#define BP_UART_S2_RXINV     (4U)          /*!< Bit position for UART_S2_RXINV. */
#define BM_UART_S2_RXINV     (0x10U)       /*!< Bit mask for UART_S2_RXINV. */
#define BS_UART_S2_RXINV     (1U)          /*!< Bit field size in bits for UART_S2_RXINV. */

/*! @brief Read current value of the UART_S2_RXINV field. */
#define BR_UART_S2_RXINV(x)  (BME_UBFX8(HW_UART_S2_ADDR(x), BP_UART_S2_RXINV, BS_UART_S2_RXINV))

/*! @brief Format value for bitfield UART_S2_RXINV. */
#define BF_UART_S2_RXINV(v)  ((uint8_t)((uint8_t)(v) << BP_UART_S2_RXINV) & BM_UART_S2_RXINV)

/*! @brief Set the RXINV field to a new value. */
#define BW_UART_S2_RXINV(x, v) (BME_BFI8(HW_UART_S2_ADDR(x), ((uint8_t)(v) << BP_UART_S2_RXINV), BP_UART_S2_RXINV, 1))
/*@}*/

/*!
 * @name Register UART_S2, field MSBF[5] (RW)
 *
 * Setting this field reverses the order of the bits that are transmitted and
 * received on the wire. This field does not affect the polarity of the bits, the
 * location of the parity bit, or the location of the start or stop bits. This
 * field is automatically set when C7816[INIT] and C7816[ISO7816E] are enabled and
 * an initial character is detected in T = 0 protocol mode.
 *
 * Values:
 * - 0 - LSB (bit0) is the first bit that is transmitted following the start
 *     bit. Further, the first bit received after the start bit is identified as
 *     bit0.
 * - 1 - MSB (bit8, bit7 or bit6) is the first bit that is transmitted following
 *     the start bit, depending on the setting of C1[M] and C1[PE]. Further, the
 *     first bit received after the start bit is identified as bit8, bit7, or
 *     bit6, depending on the setting of C1[M] and C1[PE].
 */
/*@{*/
#define BP_UART_S2_MSBF      (5U)          /*!< Bit position for UART_S2_MSBF. */
#define BM_UART_S2_MSBF      (0x20U)       /*!< Bit mask for UART_S2_MSBF. */
#define BS_UART_S2_MSBF      (1U)          /*!< Bit field size in bits for UART_S2_MSBF. */

/*! @brief Read current value of the UART_S2_MSBF field. */
#define BR_UART_S2_MSBF(x)   (BME_UBFX8(HW_UART_S2_ADDR(x), BP_UART_S2_MSBF, BS_UART_S2_MSBF))

/*! @brief Format value for bitfield UART_S2_MSBF. */
#define BF_UART_S2_MSBF(v)   ((uint8_t)((uint8_t)(v) << BP_UART_S2_MSBF) & BM_UART_S2_MSBF)

/*! @brief Set the MSBF field to a new value. */
#define BW_UART_S2_MSBF(x, v) (BME_BFI8(HW_UART_S2_ADDR(x), ((uint8_t)(v) << BP_UART_S2_MSBF), BP_UART_S2_MSBF, 1))
/*@}*/

/*!
 * @name Register UART_S2, field RXEDGIF[6] (W1C)
 *
 * RXEDGIF is set when an active edge occurs on the RxD pin. The active edge is
 * falling if RXINV = 0, and rising if RXINV=1. RXEDGIF is cleared by writing a 1
 * to it. See for additional details. RXEDGIF description The active edge is
 * detected only in two wire mode and on receiving data coming from the RxD pin.
 *
 * Values:
 * - 0 - No active edge on the receive pin has occurred.
 * - 1 - An active edge on the receive pin has occurred.
 */
/*@{*/
#define BP_UART_S2_RXEDGIF   (6U)          /*!< Bit position for UART_S2_RXEDGIF. */
#define BM_UART_S2_RXEDGIF   (0x40U)       /*!< Bit mask for UART_S2_RXEDGIF. */
#define BS_UART_S2_RXEDGIF   (1U)          /*!< Bit field size in bits for UART_S2_RXEDGIF. */

/*! @brief Read current value of the UART_S2_RXEDGIF field. */
#define BR_UART_S2_RXEDGIF(x) (BME_UBFX8(HW_UART_S2_ADDR(x), BP_UART_S2_RXEDGIF, BS_UART_S2_RXEDGIF))

/*! @brief Format value for bitfield UART_S2_RXEDGIF. */
#define BF_UART_S2_RXEDGIF(v) ((uint8_t)((uint8_t)(v) << BP_UART_S2_RXEDGIF) & BM_UART_S2_RXEDGIF)

/*! @brief Set the RXEDGIF field to a new value. */
#define BW_UART_S2_RXEDGIF(x, v) (BME_BFI8(HW_UART_S2_ADDR(x), ((uint8_t)(v) << BP_UART_S2_RXEDGIF), BP_UART_S2_RXEDGIF, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_C3 - UART Control Register 3
 ******************************************************************************/

/*!
 * @brief HW_UART_C3 - UART Control Register 3 (RW)
 *
 * Reset value: 0x00U
 *
 * Writing R8 does not have any effect. TXDIR and TXINV can be changed only
 * between transmit and receive packets.
 */
typedef union _hw_uart_c3
{
    uint8_t U;
    struct _hw_uart_c3_bitfields
    {
        uint8_t PEIE : 1;              /*!< [0] Parity Error Interrupt Enable */
        uint8_t FEIE : 1;              /*!< [1] Framing Error Interrupt Enable */
        uint8_t NEIE : 1;              /*!< [2] Noise Error Interrupt Enable */
        uint8_t ORIE : 1;              /*!< [3] Overrun Error Interrupt Enable */
        uint8_t TXINV : 1;             /*!< [4] Transmit Data Inversion. */
        uint8_t TXDIR : 1;             /*!< [5] Transmitter Pin Data Direction in
                                        * Single-Wire mode */
        uint8_t T8 : 1;                /*!< [6] Transmit Bit 8 */
        uint8_t R8 : 1;                /*!< [7] Received Bit 8 */
    } B;
} hw_uart_c3_t;

/*!
 * @name Constants and macros for entire UART_C3 register
 */
/*@{*/
#define HW_UART_C3_ADDR(x)       ((uint32_t)(x) + 0x6U)

#define HW_UART_C3(x)            (*(__IO hw_uart_c3_t *) HW_UART_C3_ADDR(x))
#define HW_UART_C3_RD(x)         (HW_UART_C3(x).U)
#define HW_UART_C3_WR(x, v)      (HW_UART_C3(x).U = (v))
#define HW_UART_C3_SET(x, v)     (BME_OR8(HW_UART_C3_ADDR(x), (uint8_t)(v)))
#define HW_UART_C3_CLR(x, v)     (BME_AND8(HW_UART_C3_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_C3_TOG(x, v)     (BME_XOR8(HW_UART_C3_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_C3 bitfields
 */

/*!
 * @name Register UART_C3, field PEIE[0] (RW)
 *
 * Enables the parity error flag, S1[PF], to generate interrupt requests.
 *
 * Values:
 * - 0 - PF interrupt requests are disabled.
 * - 1 - PF interrupt requests are enabled.
 */
/*@{*/
#define BP_UART_C3_PEIE      (0U)          /*!< Bit position for UART_C3_PEIE. */
#define BM_UART_C3_PEIE      (0x01U)       /*!< Bit mask for UART_C3_PEIE. */
#define BS_UART_C3_PEIE      (1U)          /*!< Bit field size in bits for UART_C3_PEIE. */

/*! @brief Read current value of the UART_C3_PEIE field. */
#define BR_UART_C3_PEIE(x)   (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_PEIE, BS_UART_C3_PEIE))

/*! @brief Format value for bitfield UART_C3_PEIE. */
#define BF_UART_C3_PEIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C3_PEIE) & BM_UART_C3_PEIE)

/*! @brief Set the PEIE field to a new value. */
#define BW_UART_C3_PEIE(x, v) (BME_BFI8(HW_UART_C3_ADDR(x), ((uint8_t)(v) << BP_UART_C3_PEIE), BP_UART_C3_PEIE, 1))
/*@}*/

/*!
 * @name Register UART_C3, field FEIE[1] (RW)
 *
 * Enables the framing error flag, S1[FE], to generate interrupt requests.
 *
 * Values:
 * - 0 - FE interrupt requests are disabled.
 * - 1 - FE interrupt requests are enabled.
 */
/*@{*/
#define BP_UART_C3_FEIE      (1U)          /*!< Bit position for UART_C3_FEIE. */
#define BM_UART_C3_FEIE      (0x02U)       /*!< Bit mask for UART_C3_FEIE. */
#define BS_UART_C3_FEIE      (1U)          /*!< Bit field size in bits for UART_C3_FEIE. */

/*! @brief Read current value of the UART_C3_FEIE field. */
#define BR_UART_C3_FEIE(x)   (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_FEIE, BS_UART_C3_FEIE))

/*! @brief Format value for bitfield UART_C3_FEIE. */
#define BF_UART_C3_FEIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C3_FEIE) & BM_UART_C3_FEIE)

/*! @brief Set the FEIE field to a new value. */
#define BW_UART_C3_FEIE(x, v) (BME_BFI8(HW_UART_C3_ADDR(x), ((uint8_t)(v) << BP_UART_C3_FEIE), BP_UART_C3_FEIE, 1))
/*@}*/

/*!
 * @name Register UART_C3, field NEIE[2] (RW)
 *
 * Enables the noise flag, S1[NF], to generate interrupt requests.
 *
 * Values:
 * - 0 - NF interrupt requests are disabled.
 * - 1 - NF interrupt requests are enabled.
 */
/*@{*/
#define BP_UART_C3_NEIE      (2U)          /*!< Bit position for UART_C3_NEIE. */
#define BM_UART_C3_NEIE      (0x04U)       /*!< Bit mask for UART_C3_NEIE. */
#define BS_UART_C3_NEIE      (1U)          /*!< Bit field size in bits for UART_C3_NEIE. */

/*! @brief Read current value of the UART_C3_NEIE field. */
#define BR_UART_C3_NEIE(x)   (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_NEIE, BS_UART_C3_NEIE))

/*! @brief Format value for bitfield UART_C3_NEIE. */
#define BF_UART_C3_NEIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C3_NEIE) & BM_UART_C3_NEIE)

/*! @brief Set the NEIE field to a new value. */
#define BW_UART_C3_NEIE(x, v) (BME_BFI8(HW_UART_C3_ADDR(x), ((uint8_t)(v) << BP_UART_C3_NEIE), BP_UART_C3_NEIE, 1))
/*@}*/

/*!
 * @name Register UART_C3, field ORIE[3] (RW)
 *
 * Enables the overrun error flag, S1[OR], to generate interrupt requests.
 *
 * Values:
 * - 0 - OR interrupts are disabled.
 * - 1 - OR interrupt requests are enabled.
 */
/*@{*/
#define BP_UART_C3_ORIE      (3U)          /*!< Bit position for UART_C3_ORIE. */
#define BM_UART_C3_ORIE      (0x08U)       /*!< Bit mask for UART_C3_ORIE. */
#define BS_UART_C3_ORIE      (1U)          /*!< Bit field size in bits for UART_C3_ORIE. */

/*! @brief Read current value of the UART_C3_ORIE field. */
#define BR_UART_C3_ORIE(x)   (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_ORIE, BS_UART_C3_ORIE))

/*! @brief Format value for bitfield UART_C3_ORIE. */
#define BF_UART_C3_ORIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C3_ORIE) & BM_UART_C3_ORIE)

/*! @brief Set the ORIE field to a new value. */
#define BW_UART_C3_ORIE(x, v) (BME_BFI8(HW_UART_C3_ADDR(x), ((uint8_t)(v) << BP_UART_C3_ORIE), BP_UART_C3_ORIE, 1))
/*@}*/

/*!
 * @name Register UART_C3, field TXINV[4] (RW)
 *
 * Setting this field reverses the polarity of the transmitted data output. In
 * NRZ format, a one is represented by a mark and a zero is represented by a space
 * for normal polarity, and the opposite for inverted polarity. This field is
 * automatically set when C7816[INIT] and C7816[ISO7816E] are enabled and an
 * initial character is detected in T = 0 protocol mode. Setting TXINV inverts all
 * transmitted values, including idle, break, start, and stop bits. In loop mode, if
 * TXINV is set, the receiver gets the transmit inversion bit when RXINV is
 * disabled. When C7816[ISO7816E] is set/enabled then only the transmitted data bits
 * and parity bit are inverted.
 *
 * Values:
 * - 0 - Transmit data is not inverted.
 * - 1 - Transmit data is inverted.
 */
/*@{*/
#define BP_UART_C3_TXINV     (4U)          /*!< Bit position for UART_C3_TXINV. */
#define BM_UART_C3_TXINV     (0x10U)       /*!< Bit mask for UART_C3_TXINV. */
#define BS_UART_C3_TXINV     (1U)          /*!< Bit field size in bits for UART_C3_TXINV. */

/*! @brief Read current value of the UART_C3_TXINV field. */
#define BR_UART_C3_TXINV(x)  (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_TXINV, BS_UART_C3_TXINV))

/*! @brief Format value for bitfield UART_C3_TXINV. */
#define BF_UART_C3_TXINV(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C3_TXINV) & BM_UART_C3_TXINV)

/*! @brief Set the TXINV field to a new value. */
#define BW_UART_C3_TXINV(x, v) (BME_BFI8(HW_UART_C3_ADDR(x), ((uint8_t)(v) << BP_UART_C3_TXINV), BP_UART_C3_TXINV, 1))
/*@}*/

/*!
 * @name Register UART_C3, field TXDIR[5] (RW)
 *
 * Determines whether the TXD pin is used as an input or output in the
 * single-wire mode of operation. This field is relevant only to the single wire mode.
 * When C7816[ISO7816E] is set/enabled and C7816[TTYPE] = 1, this field is
 * automatically cleared after the requested block is transmitted. This condition is
 * detected when TL7816[TLEN] = 0 and 4 additional characters are transmitted.
 * Additionally, if C7816[ISO7816E] is set/enabled and C7816[TTYPE] = 0 and a NACK is
 * being transmitted, the hardware automatically overrides this field as needed. In
 * this situation, TXDIR does not reflect the temporary state associated with
 * the NACK.
 *
 * Values:
 * - 0 - TXD pin is an input in single wire mode.
 * - 1 - TXD pin is an output in single wire mode.
 */
/*@{*/
#define BP_UART_C3_TXDIR     (5U)          /*!< Bit position for UART_C3_TXDIR. */
#define BM_UART_C3_TXDIR     (0x20U)       /*!< Bit mask for UART_C3_TXDIR. */
#define BS_UART_C3_TXDIR     (1U)          /*!< Bit field size in bits for UART_C3_TXDIR. */

/*! @brief Read current value of the UART_C3_TXDIR field. */
#define BR_UART_C3_TXDIR(x)  (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_TXDIR, BS_UART_C3_TXDIR))

/*! @brief Format value for bitfield UART_C3_TXDIR. */
#define BF_UART_C3_TXDIR(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C3_TXDIR) & BM_UART_C3_TXDIR)

/*! @brief Set the TXDIR field to a new value. */
#define BW_UART_C3_TXDIR(x, v) (BME_BFI8(HW_UART_C3_ADDR(x), ((uint8_t)(v) << BP_UART_C3_TXDIR), BP_UART_C3_TXDIR, 1))
/*@}*/

/*!
 * @name Register UART_C3, field T8[6] (RW)
 *
 * T8 is the ninth data bit transmitted when the UART is configured for 9-bit
 * data format, that is, if C1[M] = 1 or C4[M10] = 1. If the value of T8 is the
 * same as in the previous transmission, T8 does not have to be rewritten. The same
 * value is transmitted until T8 is rewritten. To correctly transmit the 9th bit,
 * write UARTx_C3[T8] to the desired value, then write the UARTx_D register with
 * the remaining data.
 */
/*@{*/
#define BP_UART_C3_T8        (6U)          /*!< Bit position for UART_C3_T8. */
#define BM_UART_C3_T8        (0x40U)       /*!< Bit mask for UART_C3_T8. */
#define BS_UART_C3_T8        (1U)          /*!< Bit field size in bits for UART_C3_T8. */

/*! @brief Read current value of the UART_C3_T8 field. */
#define BR_UART_C3_T8(x)     (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_T8, BS_UART_C3_T8))

/*! @brief Format value for bitfield UART_C3_T8. */
#define BF_UART_C3_T8(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C3_T8) & BM_UART_C3_T8)

/*! @brief Set the T8 field to a new value. */
#define BW_UART_C3_T8(x, v)  (BME_BFI8(HW_UART_C3_ADDR(x), ((uint8_t)(v) << BP_UART_C3_T8), BP_UART_C3_T8, 1))
/*@}*/

/*!
 * @name Register UART_C3, field R8[7] (RO)
 *
 * R8 is the ninth data bit received when the UART is configured for 9-bit data
 * format, that is, if C1[M] = 1 or C4[M10] = 1. The R8 value corresponds to the
 * current data value in the UARTx_D register. To read the 9th bit, read the
 * value of UARTx_C3[R8], then read the UARTx_D register.
 */
/*@{*/
#define BP_UART_C3_R8        (7U)          /*!< Bit position for UART_C3_R8. */
#define BM_UART_C3_R8        (0x80U)       /*!< Bit mask for UART_C3_R8. */
#define BS_UART_C3_R8        (1U)          /*!< Bit field size in bits for UART_C3_R8. */

/*! @brief Read current value of the UART_C3_R8 field. */
#define BR_UART_C3_R8(x)     (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_R8, BS_UART_C3_R8))
/*@}*/

/*******************************************************************************
 * HW_UART_D - UART Data Register
 ******************************************************************************/

/*!
 * @brief HW_UART_D - UART Data Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register is actually two separate registers. Reads return the contents
 * of the read-only receive data register and writes go to the write-only transmit
 * data register. In 8-bit or 9-bit data format, only UART data register (D)
 * needs to be accessed to clear the S1[RDRF] bit (assuming receiver buffer level is
 * less than RWFIFO[RXWATER]). The C3 register needs to be read, prior to the D
 * register, only if the ninth bit of data needs to be captured. Similarly, the
 * ED register needs to be read, prior to the D register, only if the additional
 * flag data for the dataword needs to be captured. In the normal 8-bit mode (M
 * bit cleared) if the parity is enabled, you get seven data bits and one parity
 * bit. That one parity bit is loaded into the D register. So, for the data bits,
 * mask off the parity bit from the value you read out of this register. When
 * transmitting in 9-bit data format and using 8-bit write instructions, write first
 * to transmit bit 8 in UART control register 3 (C3[T8]), then D. A write to
 * C3[T8] stores the data in a temporary register. If D register is written first,
 * and then the new data on data bus is stored in D, the temporary value written by
 * the last write to C3[T8] gets stored in the C3[T8] register.
 */
typedef union _hw_uart_d
{
    uint8_t U;
    struct _hw_uart_d_bitfields
    {
        uint8_t RT : 8;                /*!< [7:0]  */
    } B;
} hw_uart_d_t;

/*!
 * @name Constants and macros for entire UART_D register
 */
/*@{*/
#define HW_UART_D_ADDR(x)        ((uint32_t)(x) + 0x7U)

#define HW_UART_D(x)             (*(__IO hw_uart_d_t *) HW_UART_D_ADDR(x))
#define HW_UART_D_RD(x)          (HW_UART_D(x).U)
#define HW_UART_D_WR(x, v)       (HW_UART_D(x).U = (v))
#define HW_UART_D_SET(x, v)      (BME_OR8(HW_UART_D_ADDR(x), (uint8_t)(v)))
#define HW_UART_D_CLR(x, v)      (BME_AND8(HW_UART_D_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_D_TOG(x, v)      (BME_XOR8(HW_UART_D_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_D bitfields
 */

/*!
 * @name Register UART_D, field RT[7:0] (RW)
 *
 * Reads return the contents of the read-only receive data register and writes
 * go to the write-only transmit data register.
 */
/*@{*/
#define BP_UART_D_RT         (0U)          /*!< Bit position for UART_D_RT. */
#define BM_UART_D_RT         (0xFFU)       /*!< Bit mask for UART_D_RT. */
#define BS_UART_D_RT         (8U)          /*!< Bit field size in bits for UART_D_RT. */

/*! @brief Read current value of the UART_D_RT field. */
#define BR_UART_D_RT(x)      (HW_UART_D(x).U)

/*! @brief Format value for bitfield UART_D_RT. */
#define BF_UART_D_RT(v)      ((uint8_t)((uint8_t)(v) << BP_UART_D_RT) & BM_UART_D_RT)

/*! @brief Set the RT field to a new value. */
#define BW_UART_D_RT(x, v)   (HW_UART_D_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_MA1 - UART Match Address Registers 1
 ******************************************************************************/

/*!
 * @brief HW_UART_MA1 - UART Match Address Registers 1 (RW)
 *
 * Reset value: 0x00U
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated C4[MAEN] field is set. If a match
 * occurs, the following data is transferred to the data register. If a match
 * fails, the following data is discarded. These registers can be read and written at
 * anytime.
 */
typedef union _hw_uart_ma1
{
    uint8_t U;
    struct _hw_uart_ma1_bitfields
    {
        uint8_t MA : 8;                /*!< [7:0] Match Address */
    } B;
} hw_uart_ma1_t;

/*!
 * @name Constants and macros for entire UART_MA1 register
 */
/*@{*/
#define HW_UART_MA1_ADDR(x)      ((uint32_t)(x) + 0x8U)

#define HW_UART_MA1(x)           (*(__IO hw_uart_ma1_t *) HW_UART_MA1_ADDR(x))
#define HW_UART_MA1_RD(x)        (HW_UART_MA1(x).U)
#define HW_UART_MA1_WR(x, v)     (HW_UART_MA1(x).U = (v))
#define HW_UART_MA1_SET(x, v)    (BME_OR8(HW_UART_MA1_ADDR(x), (uint8_t)(v)))
#define HW_UART_MA1_CLR(x, v)    (BME_AND8(HW_UART_MA1_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_MA1_TOG(x, v)    (BME_XOR8(HW_UART_MA1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_MA1 bitfields
 */

/*!
 * @name Register UART_MA1, field MA[7:0] (RW)
 */
/*@{*/
#define BP_UART_MA1_MA       (0U)          /*!< Bit position for UART_MA1_MA. */
#define BM_UART_MA1_MA       (0xFFU)       /*!< Bit mask for UART_MA1_MA. */
#define BS_UART_MA1_MA       (8U)          /*!< Bit field size in bits for UART_MA1_MA. */

/*! @brief Read current value of the UART_MA1_MA field. */
#define BR_UART_MA1_MA(x)    (HW_UART_MA1(x).U)

/*! @brief Format value for bitfield UART_MA1_MA. */
#define BF_UART_MA1_MA(v)    ((uint8_t)((uint8_t)(v) << BP_UART_MA1_MA) & BM_UART_MA1_MA)

/*! @brief Set the MA field to a new value. */
#define BW_UART_MA1_MA(x, v) (HW_UART_MA1_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_MA2 - UART Match Address Registers 2
 ******************************************************************************/

/*!
 * @brief HW_UART_MA2 - UART Match Address Registers 2 (RW)
 *
 * Reset value: 0x00U
 *
 * These registers can be read and written at anytime. The MA1 and MA2 registers
 * are compared to input data addresses when the most significant bit is set and
 * the associated C4[MAEN] field is set. If a match occurs, the following data
 * is transferred to the data register. If a match fails, the following data is
 * discarded.
 */
typedef union _hw_uart_ma2
{
    uint8_t U;
    struct _hw_uart_ma2_bitfields
    {
        uint8_t MA : 8;                /*!< [7:0] Match Address */
    } B;
} hw_uart_ma2_t;

/*!
 * @name Constants and macros for entire UART_MA2 register
 */
/*@{*/
#define HW_UART_MA2_ADDR(x)      ((uint32_t)(x) + 0x9U)

#define HW_UART_MA2(x)           (*(__IO hw_uart_ma2_t *) HW_UART_MA2_ADDR(x))
#define HW_UART_MA2_RD(x)        (HW_UART_MA2(x).U)
#define HW_UART_MA2_WR(x, v)     (HW_UART_MA2(x).U = (v))
#define HW_UART_MA2_SET(x, v)    (BME_OR8(HW_UART_MA2_ADDR(x), (uint8_t)(v)))
#define HW_UART_MA2_CLR(x, v)    (BME_AND8(HW_UART_MA2_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_MA2_TOG(x, v)    (BME_XOR8(HW_UART_MA2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_MA2 bitfields
 */

/*!
 * @name Register UART_MA2, field MA[7:0] (RW)
 */
/*@{*/
#define BP_UART_MA2_MA       (0U)          /*!< Bit position for UART_MA2_MA. */
#define BM_UART_MA2_MA       (0xFFU)       /*!< Bit mask for UART_MA2_MA. */
#define BS_UART_MA2_MA       (8U)          /*!< Bit field size in bits for UART_MA2_MA. */

/*! @brief Read current value of the UART_MA2_MA field. */
#define BR_UART_MA2_MA(x)    (HW_UART_MA2(x).U)

/*! @brief Format value for bitfield UART_MA2_MA. */
#define BF_UART_MA2_MA(v)    ((uint8_t)((uint8_t)(v) << BP_UART_MA2_MA) & BM_UART_MA2_MA)

/*! @brief Set the MA field to a new value. */
#define BW_UART_MA2_MA(x, v) (HW_UART_MA2_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_C4 - UART Control Register 4
 ******************************************************************************/

/*!
 * @brief HW_UART_C4 - UART Control Register 4 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_c4
{
    uint8_t U;
    struct _hw_uart_c4_bitfields
    {
        uint8_t BRFA : 5;              /*!< [4:0] Baud Rate Fine Adjust */
        uint8_t M10 : 1;               /*!< [5] 10-bit Mode select */
        uint8_t MAEN2 : 1;             /*!< [6] Match Address Mode Enable 2 */
        uint8_t MAEN1 : 1;             /*!< [7] Match Address Mode Enable 1 */
    } B;
} hw_uart_c4_t;

/*!
 * @name Constants and macros for entire UART_C4 register
 */
/*@{*/
#define HW_UART_C4_ADDR(x)       ((uint32_t)(x) + 0xAU)

#define HW_UART_C4(x)            (*(__IO hw_uart_c4_t *) HW_UART_C4_ADDR(x))
#define HW_UART_C4_RD(x)         (HW_UART_C4(x).U)
#define HW_UART_C4_WR(x, v)      (HW_UART_C4(x).U = (v))
#define HW_UART_C4_SET(x, v)     (BME_OR8(HW_UART_C4_ADDR(x), (uint8_t)(v)))
#define HW_UART_C4_CLR(x, v)     (BME_AND8(HW_UART_C4_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_C4_TOG(x, v)     (BME_XOR8(HW_UART_C4_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_C4 bitfields
 */

/*!
 * @name Register UART_C4, field BRFA[4:0] (RW)
 *
 * This bit field is used to add more timing resolution to the average baud
 * frequency, in increments of 1/32. See Baud rate generation for more information.
 */
/*@{*/
#define BP_UART_C4_BRFA      (0U)          /*!< Bit position for UART_C4_BRFA. */
#define BM_UART_C4_BRFA      (0x1FU)       /*!< Bit mask for UART_C4_BRFA. */
#define BS_UART_C4_BRFA      (5U)          /*!< Bit field size in bits for UART_C4_BRFA. */

/*! @brief Read current value of the UART_C4_BRFA field. */
#define BR_UART_C4_BRFA(x)   (BME_UBFX8(HW_UART_C4_ADDR(x), BP_UART_C4_BRFA, BS_UART_C4_BRFA))

/*! @brief Format value for bitfield UART_C4_BRFA. */
#define BF_UART_C4_BRFA(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C4_BRFA) & BM_UART_C4_BRFA)

/*! @brief Set the BRFA field to a new value. */
#define BW_UART_C4_BRFA(x, v) (BME_BFI8(HW_UART_C4_ADDR(x), ((uint8_t)(v) << BP_UART_C4_BRFA), BP_UART_C4_BRFA, 5))
/*@}*/

/*!
 * @name Register UART_C4, field M10[5] (RW)
 *
 * Causes a tenth, non-memory mapped bit to be part of the serial transmission.
 * This tenth bit is generated and interpreted as a parity bit. If M10 is set,
 * then both C1[M] and C1[PE] must also be set. This field must be cleared when
 * C7816[ISO7816E] is set/enabled. See Data format (non ISO-7816) for more
 * information.
 *
 * Values:
 * - 0 - The parity bit is the ninth bit in the serial transmission.
 * - 1 - The parity bit is the tenth bit in the serial transmission.
 */
/*@{*/
#define BP_UART_C4_M10       (5U)          /*!< Bit position for UART_C4_M10. */
#define BM_UART_C4_M10       (0x20U)       /*!< Bit mask for UART_C4_M10. */
#define BS_UART_C4_M10       (1U)          /*!< Bit field size in bits for UART_C4_M10. */

/*! @brief Read current value of the UART_C4_M10 field. */
#define BR_UART_C4_M10(x)    (BME_UBFX8(HW_UART_C4_ADDR(x), BP_UART_C4_M10, BS_UART_C4_M10))

/*! @brief Format value for bitfield UART_C4_M10. */
#define BF_UART_C4_M10(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C4_M10) & BM_UART_C4_M10)

/*! @brief Set the M10 field to a new value. */
#define BW_UART_C4_M10(x, v) (BME_BFI8(HW_UART_C4_ADDR(x), ((uint8_t)(v) << BP_UART_C4_M10), BP_UART_C4_M10, 1))
/*@}*/

/*!
 * @name Register UART_C4, field MAEN2[6] (RW)
 *
 * See Match address operation for more information.
 *
 * Values:
 * - 0 - All data received is transferred to the data buffer if MAEN1 is cleared.
 * - 1 - All data received with the most significant bit cleared, is discarded.
 *     All data received with the most significant bit set, is compared with
 *     contents of MA2 register. If no match occurs, the data is discarded. If a
 *     match occurs, data is transferred to the data buffer. This field must be
 *     cleared when C7816[ISO7816E] is set/enabled.
 */
/*@{*/
#define BP_UART_C4_MAEN2     (6U)          /*!< Bit position for UART_C4_MAEN2. */
#define BM_UART_C4_MAEN2     (0x40U)       /*!< Bit mask for UART_C4_MAEN2. */
#define BS_UART_C4_MAEN2     (1U)          /*!< Bit field size in bits for UART_C4_MAEN2. */

/*! @brief Read current value of the UART_C4_MAEN2 field. */
#define BR_UART_C4_MAEN2(x)  (BME_UBFX8(HW_UART_C4_ADDR(x), BP_UART_C4_MAEN2, BS_UART_C4_MAEN2))

/*! @brief Format value for bitfield UART_C4_MAEN2. */
#define BF_UART_C4_MAEN2(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C4_MAEN2) & BM_UART_C4_MAEN2)

/*! @brief Set the MAEN2 field to a new value. */
#define BW_UART_C4_MAEN2(x, v) (BME_BFI8(HW_UART_C4_ADDR(x), ((uint8_t)(v) << BP_UART_C4_MAEN2), BP_UART_C4_MAEN2, 1))
/*@}*/

/*!
 * @name Register UART_C4, field MAEN1[7] (RW)
 *
 * See Match address operation for more information.
 *
 * Values:
 * - 0 - All data received is transferred to the data buffer if MAEN2 is cleared.
 * - 1 - All data received with the most significant bit cleared, is discarded.
 *     All data received with the most significant bit set, is compared with
 *     contents of MA1 register. If no match occurs, the data is discarded. If match
 *     occurs, data is transferred to the data buffer. This field must be cleared
 *     when C7816[ISO7816E] is set/enabled.
 */
/*@{*/
#define BP_UART_C4_MAEN1     (7U)          /*!< Bit position for UART_C4_MAEN1. */
#define BM_UART_C4_MAEN1     (0x80U)       /*!< Bit mask for UART_C4_MAEN1. */
#define BS_UART_C4_MAEN1     (1U)          /*!< Bit field size in bits for UART_C4_MAEN1. */

/*! @brief Read current value of the UART_C4_MAEN1 field. */
#define BR_UART_C4_MAEN1(x)  (BME_UBFX8(HW_UART_C4_ADDR(x), BP_UART_C4_MAEN1, BS_UART_C4_MAEN1))

/*! @brief Format value for bitfield UART_C4_MAEN1. */
#define BF_UART_C4_MAEN1(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C4_MAEN1) & BM_UART_C4_MAEN1)

/*! @brief Set the MAEN1 field to a new value. */
#define BW_UART_C4_MAEN1(x, v) (BME_BFI8(HW_UART_C4_ADDR(x), ((uint8_t)(v) << BP_UART_C4_MAEN1), BP_UART_C4_MAEN1, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_C5 - UART Control Register 5
 ******************************************************************************/

/*!
 * @brief HW_UART_C5 - UART Control Register 5 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_c5
{
    uint8_t U;
    struct _hw_uart_c5_bitfields
    {
        uint8_t RESERVED0 : 5;         /*!< [4:0]  */
        uint8_t RDMAS : 1;             /*!< [5] Receiver Full DMA Select */
        uint8_t RESERVED1 : 1;         /*!< [6]  */
        uint8_t TDMAS : 1;             /*!< [7] Transmitter DMA Select */
    } B;
} hw_uart_c5_t;

/*!
 * @name Constants and macros for entire UART_C5 register
 */
/*@{*/
#define HW_UART_C5_ADDR(x)       ((uint32_t)(x) + 0xBU)

#define HW_UART_C5(x)            (*(__IO hw_uart_c5_t *) HW_UART_C5_ADDR(x))
#define HW_UART_C5_RD(x)         (HW_UART_C5(x).U)
#define HW_UART_C5_WR(x, v)      (HW_UART_C5(x).U = (v))
#define HW_UART_C5_SET(x, v)     (BME_OR8(HW_UART_C5_ADDR(x), (uint8_t)(v)))
#define HW_UART_C5_CLR(x, v)     (BME_AND8(HW_UART_C5_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_C5_TOG(x, v)     (BME_XOR8(HW_UART_C5_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_C5 bitfields
 */

/*!
 * @name Register UART_C5, field RDMAS[5] (RW)
 *
 * Configures the receiver data register full flag, S1[RDRF], to generate
 * interrupt or DMA requests if C2[RIE] is set. If C2[RIE] is cleared, and S1[RDRF] is
 * set, the RDRF DMA and RDFR interrupt request signals are not asserted,
 * regardless of the state of RDMAS.
 *
 * Values:
 * - 0 - If C2[RIE] and S1[RDRF] are set, the RDFR interrupt request signal is
 *     asserted to request an interrupt service.
 * - 1 - If C2[RIE] and S1[RDRF] are set, the RDRF DMA request signal is
 *     asserted to request a DMA transfer.
 */
/*@{*/
#define BP_UART_C5_RDMAS     (5U)          /*!< Bit position for UART_C5_RDMAS. */
#define BM_UART_C5_RDMAS     (0x20U)       /*!< Bit mask for UART_C5_RDMAS. */
#define BS_UART_C5_RDMAS     (1U)          /*!< Bit field size in bits for UART_C5_RDMAS. */

/*! @brief Read current value of the UART_C5_RDMAS field. */
#define BR_UART_C5_RDMAS(x)  (BME_UBFX8(HW_UART_C5_ADDR(x), BP_UART_C5_RDMAS, BS_UART_C5_RDMAS))

/*! @brief Format value for bitfield UART_C5_RDMAS. */
#define BF_UART_C5_RDMAS(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C5_RDMAS) & BM_UART_C5_RDMAS)

/*! @brief Set the RDMAS field to a new value. */
#define BW_UART_C5_RDMAS(x, v) (BME_BFI8(HW_UART_C5_ADDR(x), ((uint8_t)(v) << BP_UART_C5_RDMAS), BP_UART_C5_RDMAS, 1))
/*@}*/

/*!
 * @name Register UART_C5, field TDMAS[7] (RW)
 *
 * Configures the transmit data register empty flag, S1[TDRE], to generate
 * interrupt or DMA requests if C2[TIE] is set. If C2[TIE] is cleared, TDRE DMA and
 * TDRE interrupt request signals are not asserted when the TDRE flag is set,
 * regardless of the state of TDMAS. If C2[TIE] and TDMAS are both set, then C2[TCIE]
 * must be cleared, and D must not be written unless a DMA request is being
 * serviced.
 *
 * Values:
 * - 0 - If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE interrupt
 *     request signal is asserted to request interrupt service.
 * - 1 - If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE DMA request
 *     signal is asserted to request a DMA transfer.
 */
/*@{*/
#define BP_UART_C5_TDMAS     (7U)          /*!< Bit position for UART_C5_TDMAS. */
#define BM_UART_C5_TDMAS     (0x80U)       /*!< Bit mask for UART_C5_TDMAS. */
#define BS_UART_C5_TDMAS     (1U)          /*!< Bit field size in bits for UART_C5_TDMAS. */

/*! @brief Read current value of the UART_C5_TDMAS field. */
#define BR_UART_C5_TDMAS(x)  (BME_UBFX8(HW_UART_C5_ADDR(x), BP_UART_C5_TDMAS, BS_UART_C5_TDMAS))

/*! @brief Format value for bitfield UART_C5_TDMAS. */
#define BF_UART_C5_TDMAS(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C5_TDMAS) & BM_UART_C5_TDMAS)

/*! @brief Set the TDMAS field to a new value. */
#define BW_UART_C5_TDMAS(x, v) (BME_BFI8(HW_UART_C5_ADDR(x), ((uint8_t)(v) << BP_UART_C5_TDMAS), BP_UART_C5_TDMAS, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_C7816 - UART 7816 Control Register
 ******************************************************************************/

/*!
 * @brief HW_UART_C7816 - UART 7816 Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The C7816 register is the primary control register for ISO-7816 specific
 * functionality. This register is specific to 7816 functionality and the values in
 * this register have no effect on UART operation and should be ignored if
 * ISO_7816E is not set/enabled. This register may be read at any time but values must
 * be changed only when ISO_7816E is not set.
 */
typedef union _hw_uart_c7816
{
    uint8_t U;
    struct _hw_uart_c7816_bitfields
    {
        uint8_t ISO_7816E : 1;         /*!< [0] ISO-7816 Functionality Enabled */
        uint8_t TTYPE : 1;             /*!< [1] Transfer Type */
        uint8_t INIT : 1;              /*!< [2] Detect Initial Character */
        uint8_t ANACK : 1;             /*!< [3] Generate NACK on Error */
        uint8_t ONACK : 1;             /*!< [4] Generate NACK on Overflow */
        uint8_t RESERVED0 : 3;         /*!< [7:5]  */
    } B;
} hw_uart_c7816_t;

/*!
 * @name Constants and macros for entire UART_C7816 register
 */
/*@{*/
#define HW_UART_C7816_ADDR(x)    ((uint32_t)(x) + 0x18U)

#define HW_UART_C7816(x)         (*(__IO hw_uart_c7816_t *) HW_UART_C7816_ADDR(x))
#define HW_UART_C7816_RD(x)      (HW_UART_C7816(x).U)
#define HW_UART_C7816_WR(x, v)   (HW_UART_C7816(x).U = (v))
#define HW_UART_C7816_SET(x, v)  (BME_OR8(HW_UART_C7816_ADDR(x), (uint8_t)(v)))
#define HW_UART_C7816_CLR(x, v)  (BME_AND8(HW_UART_C7816_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_C7816_TOG(x, v)  (BME_XOR8(HW_UART_C7816_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_C7816 bitfields
 */

/*!
 * @name Register UART_C7816, field ISO_7816E[0] (RW)
 *
 * Indicates that the UART is operating according to the ISO-7816 protocol. This
 * field must be modified only when no transmit or receive is occurring. If this
 * field is changed during a data transfer, the data being transmitted or
 * received may be transferred incorrectly.
 *
 * Values:
 * - 0 - ISO-7816 functionality is turned off/not enabled.
 * - 1 - ISO-7816 functionality is turned on/enabled.
 */
/*@{*/
#define BP_UART_C7816_ISO_7816E (0U)       /*!< Bit position for UART_C7816_ISO_7816E. */
#define BM_UART_C7816_ISO_7816E (0x01U)    /*!< Bit mask for UART_C7816_ISO_7816E. */
#define BS_UART_C7816_ISO_7816E (1U)       /*!< Bit field size in bits for UART_C7816_ISO_7816E. */

/*! @brief Read current value of the UART_C7816_ISO_7816E field. */
#define BR_UART_C7816_ISO_7816E(x) (BME_UBFX8(HW_UART_C7816_ADDR(x), BP_UART_C7816_ISO_7816E, BS_UART_C7816_ISO_7816E))

/*! @brief Format value for bitfield UART_C7816_ISO_7816E. */
#define BF_UART_C7816_ISO_7816E(v) ((uint8_t)((uint8_t)(v) << BP_UART_C7816_ISO_7816E) & BM_UART_C7816_ISO_7816E)

/*! @brief Set the ISO_7816E field to a new value. */
#define BW_UART_C7816_ISO_7816E(x, v) (BME_BFI8(HW_UART_C7816_ADDR(x), ((uint8_t)(v) << BP_UART_C7816_ISO_7816E), BP_UART_C7816_ISO_7816E, 1))
/*@}*/

/*!
 * @name Register UART_C7816, field TTYPE[1] (RW)
 *
 * Indicates the transfer protocol being used. See ISO-7816 / smartcard support
 * for more details.
 *
 * Values:
 * - 0 - T = 0 per the ISO-7816 specification.
 * - 1 - T = 1 per the ISO-7816 specification.
 */
/*@{*/
#define BP_UART_C7816_TTYPE  (1U)          /*!< Bit position for UART_C7816_TTYPE. */
#define BM_UART_C7816_TTYPE  (0x02U)       /*!< Bit mask for UART_C7816_TTYPE. */
#define BS_UART_C7816_TTYPE  (1U)          /*!< Bit field size in bits for UART_C7816_TTYPE. */

/*! @brief Read current value of the UART_C7816_TTYPE field. */
#define BR_UART_C7816_TTYPE(x) (BME_UBFX8(HW_UART_C7816_ADDR(x), BP_UART_C7816_TTYPE, BS_UART_C7816_TTYPE))

/*! @brief Format value for bitfield UART_C7816_TTYPE. */
#define BF_UART_C7816_TTYPE(v) ((uint8_t)((uint8_t)(v) << BP_UART_C7816_TTYPE) & BM_UART_C7816_TTYPE)

/*! @brief Set the TTYPE field to a new value. */
#define BW_UART_C7816_TTYPE(x, v) (BME_BFI8(HW_UART_C7816_ADDR(x), ((uint8_t)(v) << BP_UART_C7816_TTYPE), BP_UART_C7816_TTYPE, 1))
/*@}*/

/*!
 * @name Register UART_C7816, field INIT[2] (RW)
 *
 * When this field is set, all received characters are searched for a valid
 * initial character. If an invalid initial character is identified, and ANACK is
 * set, a NACK is sent. All received data is discarded and error flags blocked
 * (S1[NF], S1[OR], S1[FE], S1[PF], IS7816[WT], IS7816[CWT], IS7816[BWT], IS7816[ADT],
 * IS7816[GTV]) until a valid initial character is detected. Upon detecting a
 * valid initial character, the configuration values S2[MSBF], C3[TXINV], and
 * S2[RXINV] are automatically updated to reflect the initial character that was
 * received. The actual INIT data value is not stored in the receive buffer.
 * Additionally, upon detection of a valid initial character, IS7816[INITD] is set and an
 * interrupt issued as programmed by IE7816[INITDE]. When a valid initial
 * character is detected, INIT is automatically cleared. This Initial Character Detect
 * feature is supported only in T = 0 protocol mode.
 *
 * Values:
 * - 0 - Normal operating mode. Receiver does not seek to identify initial
 *     character.
 * - 1 - Receiver searches for initial character.
 */
/*@{*/
#define BP_UART_C7816_INIT   (2U)          /*!< Bit position for UART_C7816_INIT. */
#define BM_UART_C7816_INIT   (0x04U)       /*!< Bit mask for UART_C7816_INIT. */
#define BS_UART_C7816_INIT   (1U)          /*!< Bit field size in bits for UART_C7816_INIT. */

/*! @brief Read current value of the UART_C7816_INIT field. */
#define BR_UART_C7816_INIT(x) (BME_UBFX8(HW_UART_C7816_ADDR(x), BP_UART_C7816_INIT, BS_UART_C7816_INIT))

/*! @brief Format value for bitfield UART_C7816_INIT. */
#define BF_UART_C7816_INIT(v) ((uint8_t)((uint8_t)(v) << BP_UART_C7816_INIT) & BM_UART_C7816_INIT)

/*! @brief Set the INIT field to a new value. */
#define BW_UART_C7816_INIT(x, v) (BME_BFI8(HW_UART_C7816_ADDR(x), ((uint8_t)(v) << BP_UART_C7816_INIT), BP_UART_C7816_INIT, 1))
/*@}*/

/*!
 * @name Register UART_C7816, field ANACK[3] (RW)
 *
 * When this field is set, the receiver automatically generates a NACK response
 * if a parity error occurs or if INIT is set and an invalid initial character is
 * detected. A NACK is generated only if TTYPE = 0. If ANACK is set, the UART
 * attempts to retransmit the data indefinitely. To stop retransmission attempts,
 * clear C2[TE] or ISO_7816E and do not set until S1[TC] sets C2[TE] again.
 *
 * Values:
 * - 0 - No NACK is automatically generated.
 * - 1 - A NACK is automatically generated if a parity error is detected or if
 *     an invalid initial character is detected.
 */
/*@{*/
#define BP_UART_C7816_ANACK  (3U)          /*!< Bit position for UART_C7816_ANACK. */
#define BM_UART_C7816_ANACK  (0x08U)       /*!< Bit mask for UART_C7816_ANACK. */
#define BS_UART_C7816_ANACK  (1U)          /*!< Bit field size in bits for UART_C7816_ANACK. */

/*! @brief Read current value of the UART_C7816_ANACK field. */
#define BR_UART_C7816_ANACK(x) (BME_UBFX8(HW_UART_C7816_ADDR(x), BP_UART_C7816_ANACK, BS_UART_C7816_ANACK))

/*! @brief Format value for bitfield UART_C7816_ANACK. */
#define BF_UART_C7816_ANACK(v) ((uint8_t)((uint8_t)(v) << BP_UART_C7816_ANACK) & BM_UART_C7816_ANACK)

/*! @brief Set the ANACK field to a new value. */
#define BW_UART_C7816_ANACK(x, v) (BME_BFI8(HW_UART_C7816_ADDR(x), ((uint8_t)(v) << BP_UART_C7816_ANACK), BP_UART_C7816_ANACK, 1))
/*@}*/

/*!
 * @name Register UART_C7816, field ONACK[4] (RW)
 *
 * When this field is set, the receiver automatically generates a NACK response
 * if a receive buffer overrun occurs, as indicated by S1[OR]. In many systems,
 * this results in the transmitter resending the packet that overflowed until the
 * retransmit threshold for that transmitter is reached. A NACK is generated only
 * if TTYPE=0. This field operates independently of ANACK. See . Overrun NACK
 * considerations
 *
 * Values:
 * - 0 - The received data does not generate a NACK when the receipt of the data
 *     results in an overflow event.
 * - 1 - If the receiver buffer overflows, a NACK is automatically sent on a
 *     received character.
 */
/*@{*/
#define BP_UART_C7816_ONACK  (4U)          /*!< Bit position for UART_C7816_ONACK. */
#define BM_UART_C7816_ONACK  (0x10U)       /*!< Bit mask for UART_C7816_ONACK. */
#define BS_UART_C7816_ONACK  (1U)          /*!< Bit field size in bits for UART_C7816_ONACK. */

/*! @brief Read current value of the UART_C7816_ONACK field. */
#define BR_UART_C7816_ONACK(x) (BME_UBFX8(HW_UART_C7816_ADDR(x), BP_UART_C7816_ONACK, BS_UART_C7816_ONACK))

/*! @brief Format value for bitfield UART_C7816_ONACK. */
#define BF_UART_C7816_ONACK(v) ((uint8_t)((uint8_t)(v) << BP_UART_C7816_ONACK) & BM_UART_C7816_ONACK)

/*! @brief Set the ONACK field to a new value. */
#define BW_UART_C7816_ONACK(x, v) (BME_BFI8(HW_UART_C7816_ADDR(x), ((uint8_t)(v) << BP_UART_C7816_ONACK), BP_UART_C7816_ONACK, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_IE7816 - UART 7816 Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief HW_UART_IE7816 - UART 7816 Interrupt Enable Register (RW)
 *
 * Reset value: 0x00U
 *
 * The IE7816 register controls which flags result in an interrupt being issued.
 * This register is specific to 7816 functionality, the corresponding flags that
 * drive the interrupts are not asserted when 7816E is not set/enabled. However,
 * these flags may remain set if they are asserted while 7816E was set and not
 * subsequently cleared. This register may be read or written to at any time.
 */
typedef union _hw_uart_ie7816
{
    uint8_t U;
    struct _hw_uart_ie7816_bitfields
    {
        uint8_t RXTE : 1;              /*!< [0] Receive Threshold Exceeded Interrupt
                                        * Enable */
        uint8_t TXTE : 1;              /*!< [1] Transmit Threshold Exceeded Interrupt
                                        * Enable */
        uint8_t GTVE : 1;              /*!< [2] Guard Timer Violated Interrupt Enable */
        uint8_t ADTE : 1;              /*!< [3] ATR Duration Timer Interrupt Enable */
        uint8_t INITDE : 1;            /*!< [4] Initial Character Detected Interrupt
                                        * Enable */
        uint8_t BWTE : 1;              /*!< [5] Block Wait Timer Interrupt Enable */
        uint8_t CWTE : 1;              /*!< [6] Character Wait Timer Interrupt Enable */
        uint8_t WTE : 1;               /*!< [7] Wait Timer Interrupt Enable */
    } B;
} hw_uart_ie7816_t;

/*!
 * @name Constants and macros for entire UART_IE7816 register
 */
/*@{*/
#define HW_UART_IE7816_ADDR(x)   ((uint32_t)(x) + 0x19U)

#define HW_UART_IE7816(x)        (*(__IO hw_uart_ie7816_t *) HW_UART_IE7816_ADDR(x))
#define HW_UART_IE7816_RD(x)     (HW_UART_IE7816(x).U)
#define HW_UART_IE7816_WR(x, v)  (HW_UART_IE7816(x).U = (v))
#define HW_UART_IE7816_SET(x, v) (BME_OR8(HW_UART_IE7816_ADDR(x), (uint8_t)(v)))
#define HW_UART_IE7816_CLR(x, v) (BME_AND8(HW_UART_IE7816_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_IE7816_TOG(x, v) (BME_XOR8(HW_UART_IE7816_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_IE7816 bitfields
 */

/*!
 * @name Register UART_IE7816, field RXTE[0] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[RXT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[RXT] results in the generation of an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_RXTE  (0U)          /*!< Bit position for UART_IE7816_RXTE. */
#define BM_UART_IE7816_RXTE  (0x01U)       /*!< Bit mask for UART_IE7816_RXTE. */
#define BS_UART_IE7816_RXTE  (1U)          /*!< Bit field size in bits for UART_IE7816_RXTE. */

/*! @brief Read current value of the UART_IE7816_RXTE field. */
#define BR_UART_IE7816_RXTE(x) (BME_UBFX8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_RXTE, BS_UART_IE7816_RXTE))

/*! @brief Format value for bitfield UART_IE7816_RXTE. */
#define BF_UART_IE7816_RXTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_RXTE) & BM_UART_IE7816_RXTE)

/*! @brief Set the RXTE field to a new value. */
#define BW_UART_IE7816_RXTE(x, v) (BME_BFI8(HW_UART_IE7816_ADDR(x), ((uint8_t)(v) << BP_UART_IE7816_RXTE), BP_UART_IE7816_RXTE, 1))
/*@}*/

/*!
 * @name Register UART_IE7816, field TXTE[1] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[TXT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[TXT] results in the generation of an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_TXTE  (1U)          /*!< Bit position for UART_IE7816_TXTE. */
#define BM_UART_IE7816_TXTE  (0x02U)       /*!< Bit mask for UART_IE7816_TXTE. */
#define BS_UART_IE7816_TXTE  (1U)          /*!< Bit field size in bits for UART_IE7816_TXTE. */

/*! @brief Read current value of the UART_IE7816_TXTE field. */
#define BR_UART_IE7816_TXTE(x) (BME_UBFX8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_TXTE, BS_UART_IE7816_TXTE))

/*! @brief Format value for bitfield UART_IE7816_TXTE. */
#define BF_UART_IE7816_TXTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_TXTE) & BM_UART_IE7816_TXTE)

/*! @brief Set the TXTE field to a new value. */
#define BW_UART_IE7816_TXTE(x, v) (BME_BFI8(HW_UART_IE7816_ADDR(x), ((uint8_t)(v) << BP_UART_IE7816_TXTE), BP_UART_IE7816_TXTE, 1))
/*@}*/

/*!
 * @name Register UART_IE7816, field GTVE[2] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[GTV] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[GTV] results in the generation of an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_GTVE  (2U)          /*!< Bit position for UART_IE7816_GTVE. */
#define BM_UART_IE7816_GTVE  (0x04U)       /*!< Bit mask for UART_IE7816_GTVE. */
#define BS_UART_IE7816_GTVE  (1U)          /*!< Bit field size in bits for UART_IE7816_GTVE. */

/*! @brief Read current value of the UART_IE7816_GTVE field. */
#define BR_UART_IE7816_GTVE(x) (BME_UBFX8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_GTVE, BS_UART_IE7816_GTVE))

/*! @brief Format value for bitfield UART_IE7816_GTVE. */
#define BF_UART_IE7816_GTVE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_GTVE) & BM_UART_IE7816_GTVE)

/*! @brief Set the GTVE field to a new value. */
#define BW_UART_IE7816_GTVE(x, v) (BME_BFI8(HW_UART_IE7816_ADDR(x), ((uint8_t)(v) << BP_UART_IE7816_GTVE), BP_UART_IE7816_GTVE, 1))
/*@}*/

/*!
 * @name Register UART_IE7816, field ADTE[3] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[ADT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[ADT] results in the generation of an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_ADTE  (3U)          /*!< Bit position for UART_IE7816_ADTE. */
#define BM_UART_IE7816_ADTE  (0x08U)       /*!< Bit mask for UART_IE7816_ADTE. */
#define BS_UART_IE7816_ADTE  (1U)          /*!< Bit field size in bits for UART_IE7816_ADTE. */

/*! @brief Read current value of the UART_IE7816_ADTE field. */
#define BR_UART_IE7816_ADTE(x) (BME_UBFX8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_ADTE, BS_UART_IE7816_ADTE))

/*! @brief Format value for bitfield UART_IE7816_ADTE. */
#define BF_UART_IE7816_ADTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_ADTE) & BM_UART_IE7816_ADTE)

/*! @brief Set the ADTE field to a new value. */
#define BW_UART_IE7816_ADTE(x, v) (BME_BFI8(HW_UART_IE7816_ADDR(x), ((uint8_t)(v) << BP_UART_IE7816_ADTE), BP_UART_IE7816_ADTE, 1))
/*@}*/

/*!
 * @name Register UART_IE7816, field INITDE[4] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[INITD] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[INITD] results in the generation of an
 *     interrupt.
 */
/*@{*/
#define BP_UART_IE7816_INITDE (4U)         /*!< Bit position for UART_IE7816_INITDE. */
#define BM_UART_IE7816_INITDE (0x10U)      /*!< Bit mask for UART_IE7816_INITDE. */
#define BS_UART_IE7816_INITDE (1U)         /*!< Bit field size in bits for UART_IE7816_INITDE. */

/*! @brief Read current value of the UART_IE7816_INITDE field. */
#define BR_UART_IE7816_INITDE(x) (BME_UBFX8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_INITDE, BS_UART_IE7816_INITDE))

/*! @brief Format value for bitfield UART_IE7816_INITDE. */
#define BF_UART_IE7816_INITDE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_INITDE) & BM_UART_IE7816_INITDE)

/*! @brief Set the INITDE field to a new value. */
#define BW_UART_IE7816_INITDE(x, v) (BME_BFI8(HW_UART_IE7816_ADDR(x), ((uint8_t)(v) << BP_UART_IE7816_INITDE), BP_UART_IE7816_INITDE, 1))
/*@}*/

/*!
 * @name Register UART_IE7816, field BWTE[5] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[BWT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[BWT] results in the generation of an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_BWTE  (5U)          /*!< Bit position for UART_IE7816_BWTE. */
#define BM_UART_IE7816_BWTE  (0x20U)       /*!< Bit mask for UART_IE7816_BWTE. */
#define BS_UART_IE7816_BWTE  (1U)          /*!< Bit field size in bits for UART_IE7816_BWTE. */

/*! @brief Read current value of the UART_IE7816_BWTE field. */
#define BR_UART_IE7816_BWTE(x) (BME_UBFX8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_BWTE, BS_UART_IE7816_BWTE))

/*! @brief Format value for bitfield UART_IE7816_BWTE. */
#define BF_UART_IE7816_BWTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_BWTE) & BM_UART_IE7816_BWTE)

/*! @brief Set the BWTE field to a new value. */
#define BW_UART_IE7816_BWTE(x, v) (BME_BFI8(HW_UART_IE7816_ADDR(x), ((uint8_t)(v) << BP_UART_IE7816_BWTE), BP_UART_IE7816_BWTE, 1))
/*@}*/

/*!
 * @name Register UART_IE7816, field CWTE[6] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[CWT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[CWT] results in the generation of an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_CWTE  (6U)          /*!< Bit position for UART_IE7816_CWTE. */
#define BM_UART_IE7816_CWTE  (0x40U)       /*!< Bit mask for UART_IE7816_CWTE. */
#define BS_UART_IE7816_CWTE  (1U)          /*!< Bit field size in bits for UART_IE7816_CWTE. */

/*! @brief Read current value of the UART_IE7816_CWTE field. */
#define BR_UART_IE7816_CWTE(x) (BME_UBFX8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_CWTE, BS_UART_IE7816_CWTE))

/*! @brief Format value for bitfield UART_IE7816_CWTE. */
#define BF_UART_IE7816_CWTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_CWTE) & BM_UART_IE7816_CWTE)

/*! @brief Set the CWTE field to a new value. */
#define BW_UART_IE7816_CWTE(x, v) (BME_BFI8(HW_UART_IE7816_ADDR(x), ((uint8_t)(v) << BP_UART_IE7816_CWTE), BP_UART_IE7816_CWTE, 1))
/*@}*/

/*!
 * @name Register UART_IE7816, field WTE[7] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[WT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[WT] results in the generation of an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_WTE   (7U)          /*!< Bit position for UART_IE7816_WTE. */
#define BM_UART_IE7816_WTE   (0x80U)       /*!< Bit mask for UART_IE7816_WTE. */
#define BS_UART_IE7816_WTE   (1U)          /*!< Bit field size in bits for UART_IE7816_WTE. */

/*! @brief Read current value of the UART_IE7816_WTE field. */
#define BR_UART_IE7816_WTE(x) (BME_UBFX8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_WTE, BS_UART_IE7816_WTE))

/*! @brief Format value for bitfield UART_IE7816_WTE. */
#define BF_UART_IE7816_WTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_WTE) & BM_UART_IE7816_WTE)

/*! @brief Set the WTE field to a new value. */
#define BW_UART_IE7816_WTE(x, v) (BME_BFI8(HW_UART_IE7816_ADDR(x), ((uint8_t)(v) << BP_UART_IE7816_WTE), BP_UART_IE7816_WTE, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_IS7816 - UART 7816 Interrupt Status Register
 ******************************************************************************/

/*!
 * @brief HW_UART_IS7816 - UART 7816 Interrupt Status Register (W1C)
 *
 * Reset value: 0x00U
 *
 * The IS7816 register provides a mechanism to read and clear the interrupt
 * flags. All flags/interrupts are cleared by writing a 1 to the field location.
 * Writing a 0 has no effect. All bits are "sticky", meaning they indicate that only
 * the flag condition that occurred since the last time the bit was cleared, not
 * that the condition currently exists. The status flags are set regardless of
 * whether the corresponding field in the IE7816 is set or cleared. The IE7816
 * controls only if an interrupt is issued to the host processor. This register is
 * specific to 7816 functionality and the values in this register have no affect on
 * UART operation and should be ignored if 7816E is not set/enabled. This
 * register may be read or written at anytime.
 */
typedef union _hw_uart_is7816
{
    uint8_t U;
    struct _hw_uart_is7816_bitfields
    {
        uint8_t RXT : 1;               /*!< [0] Receive Threshold Exceeded Interrupt */
        uint8_t TXT : 1;               /*!< [1] Transmit Threshold Exceeded Interrupt */
        uint8_t GTV : 1;               /*!< [2] Guard Timer Violated Interrupt */
        uint8_t ADT : 1;               /*!< [3] ATR Duration Time Interrupt */
        uint8_t INITD : 1;             /*!< [4] Initial Character Detected Interrupt */
        uint8_t BWT : 1;               /*!< [5] Block Wait Timer Interrupt */
        uint8_t CWT : 1;               /*!< [6] Character Wait Timer Interrupt */
        uint8_t WT : 1;                /*!< [7] Wait Timer Interrupt */
    } B;
} hw_uart_is7816_t;

/*!
 * @name Constants and macros for entire UART_IS7816 register
 */
/*@{*/
#define HW_UART_IS7816_ADDR(x)   ((uint32_t)(x) + 0x1AU)

#define HW_UART_IS7816(x)        (*(__IO hw_uart_is7816_t *) HW_UART_IS7816_ADDR(x))
#define HW_UART_IS7816_RD(x)     (HW_UART_IS7816(x).U)
#define HW_UART_IS7816_WR(x, v)  (HW_UART_IS7816(x).U = (v))
#define HW_UART_IS7816_SET(x, v) (BME_OR8(HW_UART_IS7816_ADDR(x), (uint8_t)(v)))
#define HW_UART_IS7816_CLR(x, v) (BME_AND8(HW_UART_IS7816_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_IS7816_TOG(x, v) (BME_XOR8(HW_UART_IS7816_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_IS7816 bitfields
 */

/*!
 * @name Register UART_IS7816, field RXT[0] (W1C)
 *
 * Indicates that there are more than ET7816[RXTHRESHOLD] consecutive NACKS
 * generated in response to parity errors on received data. This flag requires ANACK
 * to be set. Additionally, this flag asserts only when C7816[TTYPE] = 0.
 * Clearing this field also resets the counter keeping track of consecutive NACKS. The
 * UART will continue to attempt to receive data regardless of whether this flag
 * is set. If 7816E is cleared/disabled, RE is cleared/disabled, C7816[TTYPE] = 1,
 * or packet is received without needing to issue a NACK, the internal NACK
 * detection counter is cleared and the count restarts from zero on the next
 * transmitted NACK. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - The number of consecutive NACKS generated as a result of parity errors
 *     and buffer overruns is less than or equal to the value in
 *     ET7816[RXTHRESHOLD].
 * - 1 - The number of consecutive NACKS generated as a result of parity errors
 *     and buffer overruns is greater than the value in ET7816[RXTHRESHOLD].
 */
/*@{*/
#define BP_UART_IS7816_RXT   (0U)          /*!< Bit position for UART_IS7816_RXT. */
#define BM_UART_IS7816_RXT   (0x01U)       /*!< Bit mask for UART_IS7816_RXT. */
#define BS_UART_IS7816_RXT   (1U)          /*!< Bit field size in bits for UART_IS7816_RXT. */

/*! @brief Read current value of the UART_IS7816_RXT field. */
#define BR_UART_IS7816_RXT(x) (BME_UBFX8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_RXT, BS_UART_IS7816_RXT))

/*! @brief Format value for bitfield UART_IS7816_RXT. */
#define BF_UART_IS7816_RXT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_RXT) & BM_UART_IS7816_RXT)

/*! @brief Set the RXT field to a new value. */
#define BW_UART_IS7816_RXT(x, v) (BME_BFI8(HW_UART_IS7816_ADDR(x), ((uint8_t)(v) << BP_UART_IS7816_RXT), BP_UART_IS7816_RXT, 1))
/*@}*/

/*!
 * @name Register UART_IS7816, field TXT[1] (W1C)
 *
 * Indicates that the transmit NACK threshold has been exceeded as indicated by
 * ET7816[TXTHRESHOLD]. Regardless of whether this flag is set, the UART
 * continues to retransmit indefinitely. This flag asserts only when C7816[TTYPE] = 0. If
 * 7816E is cleared/disabled, ANACK is cleared/disabled, C2[TE] is
 * cleared/disabled, C7816[TTYPE] = 1, or packet is transferred without receiving a NACK, the
 * internal NACK detection counter is cleared and the count restarts from zero on
 * the next received NACK. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - The number of retries and corresponding NACKS does not exceed the value
 *     in ET7816[TXTHRESHOLD].
 * - 1 - The number of retries and corresponding NACKS exceeds the value in
 *     ET7816[TXTHRESHOLD].
 */
/*@{*/
#define BP_UART_IS7816_TXT   (1U)          /*!< Bit position for UART_IS7816_TXT. */
#define BM_UART_IS7816_TXT   (0x02U)       /*!< Bit mask for UART_IS7816_TXT. */
#define BS_UART_IS7816_TXT   (1U)          /*!< Bit field size in bits for UART_IS7816_TXT. */

/*! @brief Read current value of the UART_IS7816_TXT field. */
#define BR_UART_IS7816_TXT(x) (BME_UBFX8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_TXT, BS_UART_IS7816_TXT))

/*! @brief Format value for bitfield UART_IS7816_TXT. */
#define BF_UART_IS7816_TXT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_TXT) & BM_UART_IS7816_TXT)

/*! @brief Set the TXT field to a new value. */
#define BW_UART_IS7816_TXT(x, v) (BME_BFI8(HW_UART_IS7816_ADDR(x), ((uint8_t)(v) << BP_UART_IS7816_TXT), BP_UART_IS7816_TXT, 1))
/*@}*/

/*!
 * @name Register UART_IS7816, field GTV[2] (W1C)
 *
 * Indicates that one or more of the character guard time, block guard time, or
 * guard time are violated. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - A guard time (GT, CGT, or BGT) has not been violated.
 * - 1 - A guard time (GT, CGT, or BGT) has been violated.
 */
/*@{*/
#define BP_UART_IS7816_GTV   (2U)          /*!< Bit position for UART_IS7816_GTV. */
#define BM_UART_IS7816_GTV   (0x04U)       /*!< Bit mask for UART_IS7816_GTV. */
#define BS_UART_IS7816_GTV   (1U)          /*!< Bit field size in bits for UART_IS7816_GTV. */

/*! @brief Read current value of the UART_IS7816_GTV field. */
#define BR_UART_IS7816_GTV(x) (BME_UBFX8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_GTV, BS_UART_IS7816_GTV))

/*! @brief Format value for bitfield UART_IS7816_GTV. */
#define BF_UART_IS7816_GTV(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_GTV) & BM_UART_IS7816_GTV)

/*! @brief Set the GTV field to a new value. */
#define BW_UART_IS7816_GTV(x, v) (BME_BFI8(HW_UART_IS7816_ADDR(x), ((uint8_t)(v) << BP_UART_IS7816_GTV), BP_UART_IS7816_GTV, 1))
/*@}*/

/*!
 * @name Register UART_IS7816, field ADT[3] (W1C)
 *
 * Indicates that the ATR duration time, the time between the leading edge of
 * the TS character being received and the leading edge of the next response
 * character, has exceeded the programmed value. This flag asserts only when
 * C7816[TTYPE] = 0. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - ATR Duration time (ADT) has not been violated.
 * - 1 - ATR Duration time (ADT) has been violated.
 */
/*@{*/
#define BP_UART_IS7816_ADT   (3U)          /*!< Bit position for UART_IS7816_ADT. */
#define BM_UART_IS7816_ADT   (0x08U)       /*!< Bit mask for UART_IS7816_ADT. */
#define BS_UART_IS7816_ADT   (1U)          /*!< Bit field size in bits for UART_IS7816_ADT. */

/*! @brief Read current value of the UART_IS7816_ADT field. */
#define BR_UART_IS7816_ADT(x) (BME_UBFX8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_ADT, BS_UART_IS7816_ADT))

/*! @brief Format value for bitfield UART_IS7816_ADT. */
#define BF_UART_IS7816_ADT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_ADT) & BM_UART_IS7816_ADT)

/*! @brief Set the ADT field to a new value. */
#define BW_UART_IS7816_ADT(x, v) (BME_BFI8(HW_UART_IS7816_ADDR(x), ((uint8_t)(v) << BP_UART_IS7816_ADT), BP_UART_IS7816_ADT, 1))
/*@}*/

/*!
 * @name Register UART_IS7816, field INITD[4] (W1C)
 *
 * Indicates that a valid initial character is received. This interrupt is
 * cleared by writing 1.
 *
 * Values:
 * - 0 - A valid initial character has not been received.
 * - 1 - A valid initial character has been received.
 */
/*@{*/
#define BP_UART_IS7816_INITD (4U)          /*!< Bit position for UART_IS7816_INITD. */
#define BM_UART_IS7816_INITD (0x10U)       /*!< Bit mask for UART_IS7816_INITD. */
#define BS_UART_IS7816_INITD (1U)          /*!< Bit field size in bits for UART_IS7816_INITD. */

/*! @brief Read current value of the UART_IS7816_INITD field. */
#define BR_UART_IS7816_INITD(x) (BME_UBFX8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_INITD, BS_UART_IS7816_INITD))

/*! @brief Format value for bitfield UART_IS7816_INITD. */
#define BF_UART_IS7816_INITD(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_INITD) & BM_UART_IS7816_INITD)

/*! @brief Set the INITD field to a new value. */
#define BW_UART_IS7816_INITD(x, v) (BME_BFI8(HW_UART_IS7816_ADDR(x), ((uint8_t)(v) << BP_UART_IS7816_INITD), BP_UART_IS7816_INITD, 1))
/*@}*/

/*!
 * @name Register UART_IS7816, field BWT[5] (W1C)
 *
 * Indicates that the block wait time, the time between the leading edge of
 * first received character of a block and the leading edge of the last character the
 * previously transmitted block, has exceeded the programmed value. This flag
 * asserts only when C7816[TTYPE] = 1.This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - Block wait time (BWT) has not been violated.
 * - 1 - Block wait time (BWT) has been violated.
 */
/*@{*/
#define BP_UART_IS7816_BWT   (5U)          /*!< Bit position for UART_IS7816_BWT. */
#define BM_UART_IS7816_BWT   (0x20U)       /*!< Bit mask for UART_IS7816_BWT. */
#define BS_UART_IS7816_BWT   (1U)          /*!< Bit field size in bits for UART_IS7816_BWT. */

/*! @brief Read current value of the UART_IS7816_BWT field. */
#define BR_UART_IS7816_BWT(x) (BME_UBFX8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_BWT, BS_UART_IS7816_BWT))

/*! @brief Format value for bitfield UART_IS7816_BWT. */
#define BF_UART_IS7816_BWT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_BWT) & BM_UART_IS7816_BWT)

/*! @brief Set the BWT field to a new value. */
#define BW_UART_IS7816_BWT(x, v) (BME_BFI8(HW_UART_IS7816_ADDR(x), ((uint8_t)(v) << BP_UART_IS7816_BWT), BP_UART_IS7816_BWT, 1))
/*@}*/

/*!
 * @name Register UART_IS7816, field CWT[6] (W1C)
 *
 * Indicates that the character wait time, the time between the leading edges of
 * two consecutive characters in a block, has exceeded the programmed value.
 * This flag asserts only when C7816[TTYPE] = 1. This interrupt is cleared by
 * writing 1.
 *
 * Values:
 * - 0 - Character wait time (CWT) has not been violated.
 * - 1 - Character wait time (CWT) has been violated.
 */
/*@{*/
#define BP_UART_IS7816_CWT   (6U)          /*!< Bit position for UART_IS7816_CWT. */
#define BM_UART_IS7816_CWT   (0x40U)       /*!< Bit mask for UART_IS7816_CWT. */
#define BS_UART_IS7816_CWT   (1U)          /*!< Bit field size in bits for UART_IS7816_CWT. */

/*! @brief Read current value of the UART_IS7816_CWT field. */
#define BR_UART_IS7816_CWT(x) (BME_UBFX8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_CWT, BS_UART_IS7816_CWT))

/*! @brief Format value for bitfield UART_IS7816_CWT. */
#define BF_UART_IS7816_CWT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_CWT) & BM_UART_IS7816_CWT)

/*! @brief Set the CWT field to a new value. */
#define BW_UART_IS7816_CWT(x, v) (BME_BFI8(HW_UART_IS7816_ADDR(x), ((uint8_t)(v) << BP_UART_IS7816_CWT), BP_UART_IS7816_CWT, 1))
/*@}*/

/*!
 * @name Register UART_IS7816, field WT[7] (W1C)
 *
 * Indicates that the wait time, the time between the leading edge of a
 * character being transmitted and the leading edge of the next response character, has
 * exceeded the programmed value. This flag asserts only when C7816[TTYPE] = 0.
 * This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - Wait time (WT) has not been violated.
 * - 1 - Wait time (WT) has been violated.
 */
/*@{*/
#define BP_UART_IS7816_WT    (7U)          /*!< Bit position for UART_IS7816_WT. */
#define BM_UART_IS7816_WT    (0x80U)       /*!< Bit mask for UART_IS7816_WT. */
#define BS_UART_IS7816_WT    (1U)          /*!< Bit field size in bits for UART_IS7816_WT. */

/*! @brief Read current value of the UART_IS7816_WT field. */
#define BR_UART_IS7816_WT(x) (BME_UBFX8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_WT, BS_UART_IS7816_WT))

/*! @brief Format value for bitfield UART_IS7816_WT. */
#define BF_UART_IS7816_WT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_WT) & BM_UART_IS7816_WT)

/*! @brief Set the WT field to a new value. */
#define BW_UART_IS7816_WT(x, v) (BME_BFI8(HW_UART_IS7816_ADDR(x), ((uint8_t)(v) << BP_UART_IS7816_WT), BP_UART_IS7816_WT, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_WP7816 - UART 7816 Wait Parameter Register
 ******************************************************************************/

/*!
 * @brief HW_UART_WP7816 - UART 7816 Wait Parameter Register (RW)
 *
 * Reset value: 0x00U
 *
 * The WP7816 register contains the WTX variable used in the generation of the
 * block wait timer. This register may be read at any time. This register must be
 * written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wp7816
{
    uint8_t U;
    struct _hw_uart_wp7816_bitfields
    {
        uint8_t WTX : 8;               /*!< [7:0] Wait Time Multiplier (C7816[TTYPE] = 1) */
    } B;
} hw_uart_wp7816_t;

/*!
 * @name Constants and macros for entire UART_WP7816 register
 */
/*@{*/
#define HW_UART_WP7816_ADDR(x)   ((uint32_t)(x) + 0x1BU)

#define HW_UART_WP7816(x)        (*(__IO hw_uart_wp7816_t *) HW_UART_WP7816_ADDR(x))
#define HW_UART_WP7816_RD(x)     (HW_UART_WP7816(x).U)
#define HW_UART_WP7816_WR(x, v)  (HW_UART_WP7816(x).U = (v))
#define HW_UART_WP7816_SET(x, v) (BME_OR8(HW_UART_WP7816_ADDR(x), (uint8_t)(v)))
#define HW_UART_WP7816_CLR(x, v) (BME_AND8(HW_UART_WP7816_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_WP7816_TOG(x, v) (BME_XOR8(HW_UART_WP7816_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_WP7816 bitfields
 */

/*!
 * @name Register UART_WP7816, field WTX[7:0] (RW)
 *
 * Used to calculate the value used for the BWT counter. It represents a value
 * between 0 and 255. This value is used only when C7816[TTYPE] = 1. See Wait time
 * and guard time parameters.
 */
/*@{*/
#define BP_UART_WP7816_WTX   (0U)          /*!< Bit position for UART_WP7816_WTX. */
#define BM_UART_WP7816_WTX   (0xFFU)       /*!< Bit mask for UART_WP7816_WTX. */
#define BS_UART_WP7816_WTX   (8U)          /*!< Bit field size in bits for UART_WP7816_WTX. */

/*! @brief Read current value of the UART_WP7816_WTX field. */
#define BR_UART_WP7816_WTX(x) (HW_UART_WP7816(x).U)

/*! @brief Format value for bitfield UART_WP7816_WTX. */
#define BF_UART_WP7816_WTX(v) ((uint8_t)((uint8_t)(v) << BP_UART_WP7816_WTX) & BM_UART_WP7816_WTX)

/*! @brief Set the WTX field to a new value. */
#define BW_UART_WP7816_WTX(x, v) (HW_UART_WP7816_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_WN7816 - UART 7816 Wait N Register
 ******************************************************************************/

/*!
 * @brief HW_UART_WN7816 - UART 7816 Wait N Register (RW)
 *
 * Reset value: 0x00U
 *
 * The WN7816 register contains a parameter that is used in the calculation of
 * the guard time counter. This register may be read at any time. This register
 * must be written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wn7816
{
    uint8_t U;
    struct _hw_uart_wn7816_bitfields
    {
        uint8_t GTN : 8;               /*!< [7:0] Guard Band N */
    } B;
} hw_uart_wn7816_t;

/*!
 * @name Constants and macros for entire UART_WN7816 register
 */
/*@{*/
#define HW_UART_WN7816_ADDR(x)   ((uint32_t)(x) + 0x1CU)

#define HW_UART_WN7816(x)        (*(__IO hw_uart_wn7816_t *) HW_UART_WN7816_ADDR(x))
#define HW_UART_WN7816_RD(x)     (HW_UART_WN7816(x).U)
#define HW_UART_WN7816_WR(x, v)  (HW_UART_WN7816(x).U = (v))
#define HW_UART_WN7816_SET(x, v) (BME_OR8(HW_UART_WN7816_ADDR(x), (uint8_t)(v)))
#define HW_UART_WN7816_CLR(x, v) (BME_AND8(HW_UART_WN7816_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_WN7816_TOG(x, v) (BME_XOR8(HW_UART_WN7816_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_WN7816 bitfields
 */

/*!
 * @name Register UART_WN7816, field GTN[7:0] (RW)
 *
 * Defines a parameter used in the calculation of GT, CGT, and BGT counters. The
 * value represents an integer number between 0 and 255. See Wait time and guard
 * time parameters .
 */
/*@{*/
#define BP_UART_WN7816_GTN   (0U)          /*!< Bit position for UART_WN7816_GTN. */
#define BM_UART_WN7816_GTN   (0xFFU)       /*!< Bit mask for UART_WN7816_GTN. */
#define BS_UART_WN7816_GTN   (8U)          /*!< Bit field size in bits for UART_WN7816_GTN. */

/*! @brief Read current value of the UART_WN7816_GTN field. */
#define BR_UART_WN7816_GTN(x) (HW_UART_WN7816(x).U)

/*! @brief Format value for bitfield UART_WN7816_GTN. */
#define BF_UART_WN7816_GTN(v) ((uint8_t)((uint8_t)(v) << BP_UART_WN7816_GTN) & BM_UART_WN7816_GTN)

/*! @brief Set the GTN field to a new value. */
#define BW_UART_WN7816_GTN(x, v) (HW_UART_WN7816_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_WF7816 - UART 7816 Wait FD Register
 ******************************************************************************/

/*!
 * @brief HW_UART_WF7816 - UART 7816 Wait FD Register (RW)
 *
 * Reset value: 0x01U
 *
 * The WF7816 contains parameters that are used in the generation of various
 * counters including GT, CGT, BGT, WT, and BWT. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wf7816
{
    uint8_t U;
    struct _hw_uart_wf7816_bitfields
    {
        uint8_t GTFD : 8;              /*!< [7:0] FD Multiplier */
    } B;
} hw_uart_wf7816_t;

/*!
 * @name Constants and macros for entire UART_WF7816 register
 */
/*@{*/
#define HW_UART_WF7816_ADDR(x)   ((uint32_t)(x) + 0x1DU)

#define HW_UART_WF7816(x)        (*(__IO hw_uart_wf7816_t *) HW_UART_WF7816_ADDR(x))
#define HW_UART_WF7816_RD(x)     (HW_UART_WF7816(x).U)
#define HW_UART_WF7816_WR(x, v)  (HW_UART_WF7816(x).U = (v))
#define HW_UART_WF7816_SET(x, v) (BME_OR8(HW_UART_WF7816_ADDR(x), (uint8_t)(v)))
#define HW_UART_WF7816_CLR(x, v) (BME_AND8(HW_UART_WF7816_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_WF7816_TOG(x, v) (BME_XOR8(HW_UART_WF7816_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_WF7816 bitfields
 */

/*!
 * @name Register UART_WF7816, field GTFD[7:0] (RW)
 *
 * Used as another multiplier in the calculation of BWT. This value represents a
 * number between 1 and 255. The value of 0 is invalid. This value is not used
 * in baud rate generation. See Wait time and guard time parameters and Baud rate
 * generation .
 */
/*@{*/
#define BP_UART_WF7816_GTFD  (0U)          /*!< Bit position for UART_WF7816_GTFD. */
#define BM_UART_WF7816_GTFD  (0xFFU)       /*!< Bit mask for UART_WF7816_GTFD. */
#define BS_UART_WF7816_GTFD  (8U)          /*!< Bit field size in bits for UART_WF7816_GTFD. */

/*! @brief Read current value of the UART_WF7816_GTFD field. */
#define BR_UART_WF7816_GTFD(x) (HW_UART_WF7816(x).U)

/*! @brief Format value for bitfield UART_WF7816_GTFD. */
#define BF_UART_WF7816_GTFD(v) ((uint8_t)((uint8_t)(v) << BP_UART_WF7816_GTFD) & BM_UART_WF7816_GTFD)

/*! @brief Set the GTFD field to a new value. */
#define BW_UART_WF7816_GTFD(x, v) (HW_UART_WF7816_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_ET7816 - UART 7816 Error Threshold Register
 ******************************************************************************/

/*!
 * @brief HW_UART_ET7816 - UART 7816 Error Threshold Register (RW)
 *
 * Reset value: 0x00U
 *
 * The ET7816 register contains fields that determine the number of NACKs that
 * must be received or transmitted before the host processor is notified. This
 * register may be read at anytime. This register must be written to only when
 * C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_et7816
{
    uint8_t U;
    struct _hw_uart_et7816_bitfields
    {
        uint8_t RXTHRESHOLD : 4;       /*!< [3:0] Receive NACK Threshold */
        uint8_t TXTHRESHOLD : 4;       /*!< [7:4] Transmit NACK Threshold */
    } B;
} hw_uart_et7816_t;

/*!
 * @name Constants and macros for entire UART_ET7816 register
 */
/*@{*/
#define HW_UART_ET7816_ADDR(x)   ((uint32_t)(x) + 0x1EU)

#define HW_UART_ET7816(x)        (*(__IO hw_uart_et7816_t *) HW_UART_ET7816_ADDR(x))
#define HW_UART_ET7816_RD(x)     (HW_UART_ET7816(x).U)
#define HW_UART_ET7816_WR(x, v)  (HW_UART_ET7816(x).U = (v))
#define HW_UART_ET7816_SET(x, v) (BME_OR8(HW_UART_ET7816_ADDR(x), (uint8_t)(v)))
#define HW_UART_ET7816_CLR(x, v) (BME_AND8(HW_UART_ET7816_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_ET7816_TOG(x, v) (BME_XOR8(HW_UART_ET7816_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_ET7816 bitfields
 */

/*!
 * @name Register UART_ET7816, field RXTHRESHOLD[3:0] (RW)
 *
 * The value written to this field indicates the maximum number of consecutive
 * NACKs generated as a result of a parity error or receiver buffer overruns
 * before the host processor is notified. After the counter exceeds that value in the
 * field, the IS7816[RXT] is asserted. This field is meaningful only when
 * C7816[TTYPE] = 0. The value read from this field represents the number of consecutive
 * NACKs that have been transmitted since the last successful reception. This
 * counter saturates at 4'hF and does not wrap around. Regardless of the number of
 * NACKs sent, the UART continues to receive valid packets indefinitely. For
 * additional information, see IS7816[RXT] field description.
 */
/*@{*/
#define BP_UART_ET7816_RXTHRESHOLD (0U)    /*!< Bit position for UART_ET7816_RXTHRESHOLD. */
#define BM_UART_ET7816_RXTHRESHOLD (0x0FU) /*!< Bit mask for UART_ET7816_RXTHRESHOLD. */
#define BS_UART_ET7816_RXTHRESHOLD (4U)    /*!< Bit field size in bits for UART_ET7816_RXTHRESHOLD. */

/*! @brief Read current value of the UART_ET7816_RXTHRESHOLD field. */
#define BR_UART_ET7816_RXTHRESHOLD(x) (BME_UBFX8(HW_UART_ET7816_ADDR(x), BP_UART_ET7816_RXTHRESHOLD, BS_UART_ET7816_RXTHRESHOLD))

/*! @brief Format value for bitfield UART_ET7816_RXTHRESHOLD. */
#define BF_UART_ET7816_RXTHRESHOLD(v) ((uint8_t)((uint8_t)(v) << BP_UART_ET7816_RXTHRESHOLD) & BM_UART_ET7816_RXTHRESHOLD)

/*! @brief Set the RXTHRESHOLD field to a new value. */
#define BW_UART_ET7816_RXTHRESHOLD(x, v) (BME_BFI8(HW_UART_ET7816_ADDR(x), ((uint8_t)(v) << BP_UART_ET7816_RXTHRESHOLD), BP_UART_ET7816_RXTHRESHOLD, 4))
/*@}*/

/*!
 * @name Register UART_ET7816, field TXTHRESHOLD[7:4] (RW)
 *
 * The value written to this field indicates the maximum number of failed
 * attempts (NACKs) a transmitted character can have before the host processor is
 * notified. This field is meaningful only when C7816[TTYPE] = 0 and C7816[ANACK] = 1.
 * The value read from this field represents the number of consecutive NACKs
 * that have been received since the last successful transmission. This counter
 * saturates at 4'hF and does not wrap around. Regardless of how many NACKs that are
 * received, the UART continues to retransmit indefinitely. This flag only
 * asserts when C7816[TTYPE] = 0. For additional information see the IS7816[TXT] field
 * description.
 *
 * Values:
 * - 0 - TXT asserts on the first NACK that is received.
 * - 1 - TXT asserts on the second NACK that is received.
 */
/*@{*/
#define BP_UART_ET7816_TXTHRESHOLD (4U)    /*!< Bit position for UART_ET7816_TXTHRESHOLD. */
#define BM_UART_ET7816_TXTHRESHOLD (0xF0U) /*!< Bit mask for UART_ET7816_TXTHRESHOLD. */
#define BS_UART_ET7816_TXTHRESHOLD (4U)    /*!< Bit field size in bits for UART_ET7816_TXTHRESHOLD. */

/*! @brief Read current value of the UART_ET7816_TXTHRESHOLD field. */
#define BR_UART_ET7816_TXTHRESHOLD(x) (BME_UBFX8(HW_UART_ET7816_ADDR(x), BP_UART_ET7816_TXTHRESHOLD, BS_UART_ET7816_TXTHRESHOLD))

/*! @brief Format value for bitfield UART_ET7816_TXTHRESHOLD. */
#define BF_UART_ET7816_TXTHRESHOLD(v) ((uint8_t)((uint8_t)(v) << BP_UART_ET7816_TXTHRESHOLD) & BM_UART_ET7816_TXTHRESHOLD)

/*! @brief Set the TXTHRESHOLD field to a new value. */
#define BW_UART_ET7816_TXTHRESHOLD(x, v) (BME_BFI8(HW_UART_ET7816_ADDR(x), ((uint8_t)(v) << BP_UART_ET7816_TXTHRESHOLD), BP_UART_ET7816_TXTHRESHOLD, 4))
/*@}*/

/*******************************************************************************
 * HW_UART_TL7816 - UART 7816 Transmit Length Register
 ******************************************************************************/

/*!
 * @brief HW_UART_TL7816 - UART 7816 Transmit Length Register (RW)
 *
 * Reset value: 0x00U
 *
 * The TL7816 register is used to indicate the number of characters contained in
 * the block being transmitted. This register is used only when C7816[TTYPE] =
 * 1. This register may be read at anytime. This register must be written only
 * when C2[TE] is not enabled.
 */
typedef union _hw_uart_tl7816
{
    uint8_t U;
    struct _hw_uart_tl7816_bitfields
    {
        uint8_t TLEN : 8;              /*!< [7:0] Transmit Length */
    } B;
} hw_uart_tl7816_t;

/*!
 * @name Constants and macros for entire UART_TL7816 register
 */
/*@{*/
#define HW_UART_TL7816_ADDR(x)   ((uint32_t)(x) + 0x1FU)

#define HW_UART_TL7816(x)        (*(__IO hw_uart_tl7816_t *) HW_UART_TL7816_ADDR(x))
#define HW_UART_TL7816_RD(x)     (HW_UART_TL7816(x).U)
#define HW_UART_TL7816_WR(x, v)  (HW_UART_TL7816(x).U = (v))
#define HW_UART_TL7816_SET(x, v) (BME_OR8(HW_UART_TL7816_ADDR(x), (uint8_t)(v)))
#define HW_UART_TL7816_CLR(x, v) (BME_AND8(HW_UART_TL7816_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_TL7816_TOG(x, v) (BME_XOR8(HW_UART_TL7816_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_TL7816 bitfields
 */

/*!
 * @name Register UART_TL7816, field TLEN[7:0] (RW)
 *
 * This value plus four indicates the number of characters contained in the
 * block being transmitted. This register is automatically decremented by 1 for each
 * character in the information field portion of the block. Additionally, this
 * register is automatically decremented by 1 for the first character of a CRC in
 * the epilogue field. Therefore, this register must be programmed with the number
 * of bytes in the data packet if an LRC is being transmitted, and the number of
 * bytes + 1 if a CRC is being transmitted. This register is not decremented for
 * characters that are assumed to be part of the Prologue field, that is, the
 * first three characters transmitted in a block, or the LRC or last CRC character
 * in the Epilogue field, that is, the last character transmitted. This field
 * must be programed or adjusted only when C2[TE] is cleared.
 */
/*@{*/
#define BP_UART_TL7816_TLEN  (0U)          /*!< Bit position for UART_TL7816_TLEN. */
#define BM_UART_TL7816_TLEN  (0xFFU)       /*!< Bit mask for UART_TL7816_TLEN. */
#define BS_UART_TL7816_TLEN  (8U)          /*!< Bit field size in bits for UART_TL7816_TLEN. */

/*! @brief Read current value of the UART_TL7816_TLEN field. */
#define BR_UART_TL7816_TLEN(x) (HW_UART_TL7816(x).U)

/*! @brief Format value for bitfield UART_TL7816_TLEN. */
#define BF_UART_TL7816_TLEN(v) ((uint8_t)((uint8_t)(v) << BP_UART_TL7816_TLEN) & BM_UART_TL7816_TLEN)

/*! @brief Set the TLEN field to a new value. */
#define BW_UART_TL7816_TLEN(x, v) (HW_UART_TL7816_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_AP7816A_T0 - UART 7816 ATR Duration Timer Register A
 ******************************************************************************/

/*!
 * @brief HW_UART_AP7816A_T0 - UART 7816 ATR Duration Timer Register A (RW)
 *
 * Reset value: 0x00U
 *
 * The AP7816A_T0 register contains variables used in the generation of the ATR
 * Duration Timer. This register may be read at any time. This register must be
 * written to only when C7816[ISO_7816E] is not set, except when writing 0 to
 * clear the ADT Counter. The ADT Counter starts counting on detection of the
 * complete TS Character. It must be noted that by this time, exactly 10 ETUs have
 * elapsed since the start bit of the TS character. The user must take this into
 * account while programming this register.
 */
typedef union _hw_uart_ap7816a_t0
{
    uint8_t U;
    struct _hw_uart_ap7816a_t0_bitfields
    {
        uint8_t ADTI_H : 8;            /*!< [7:0] ATR Duration Time Integer High
                                        * (C7816[TTYPE] = 0) */
    } B;
} hw_uart_ap7816a_t0_t;

/*!
 * @name Constants and macros for entire UART_AP7816A_T0 register
 */
/*@{*/
#define HW_UART_AP7816A_T0_ADDR(x) ((uint32_t)(x) + 0x3AU)

#define HW_UART_AP7816A_T0(x)    (*(__IO hw_uart_ap7816a_t0_t *) HW_UART_AP7816A_T0_ADDR(x))
#define HW_UART_AP7816A_T0_RD(x) (HW_UART_AP7816A_T0(x).U)
#define HW_UART_AP7816A_T0_WR(x, v) (HW_UART_AP7816A_T0(x).U = (v))
#define HW_UART_AP7816A_T0_SET(x, v) (BME_OR8(HW_UART_AP7816A_T0_ADDR(x), (uint8_t)(v)))
#define HW_UART_AP7816A_T0_CLR(x, v) (BME_AND8(HW_UART_AP7816A_T0_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_AP7816A_T0_TOG(x, v) (BME_XOR8(HW_UART_AP7816A_T0_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_AP7816A_T0 bitfields
 */

/*!
 * @name Register UART_AP7816A_T0, field ADTI_H[7:0] (RW)
 *
 * Used to calculate the value used for the ADT Counter. This register field
 * provides the most significant byte of the 16 bit ATR Duration Time Integer field
 * ADTI formed by {AP7816A_T0[ADTI_H], AP7816B_T0[ADTI_L]}. Programming a value
 * of ADTI = 0 disables the ADT counter. This value is used only when C7816[TTYPE]
 * = 0. See ATR Duration Time Counter.
 */
/*@{*/
#define BP_UART_AP7816A_T0_ADTI_H (0U)     /*!< Bit position for UART_AP7816A_T0_ADTI_H. */
#define BM_UART_AP7816A_T0_ADTI_H (0xFFU)  /*!< Bit mask for UART_AP7816A_T0_ADTI_H. */
#define BS_UART_AP7816A_T0_ADTI_H (8U)     /*!< Bit field size in bits for UART_AP7816A_T0_ADTI_H. */

/*! @brief Read current value of the UART_AP7816A_T0_ADTI_H field. */
#define BR_UART_AP7816A_T0_ADTI_H(x) (HW_UART_AP7816A_T0(x).U)

/*! @brief Format value for bitfield UART_AP7816A_T0_ADTI_H. */
#define BF_UART_AP7816A_T0_ADTI_H(v) ((uint8_t)((uint8_t)(v) << BP_UART_AP7816A_T0_ADTI_H) & BM_UART_AP7816A_T0_ADTI_H)

/*! @brief Set the ADTI_H field to a new value. */
#define BW_UART_AP7816A_T0_ADTI_H(x, v) (HW_UART_AP7816A_T0_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_AP7816B_T0 - UART 7816 ATR Duration Timer Register B
 ******************************************************************************/

/*!
 * @brief HW_UART_AP7816B_T0 - UART 7816 ATR Duration Timer Register B (RW)
 *
 * Reset value: 0x00U
 *
 * The AP7816B_T0 register contains variables used in the generation of the ATR
 * Duration Timer. This register may be read at any time. This register must be
 * written to only when C7816[ISO_7816E] is not set, except when writing 0 to
 * clear the ADT Counter. The ADT Counter starts counting on detection of the
 * complete TS Character. It must be noted that by this time, exactly 10 ETUs have
 * elapsed since the start bit of the TS character. The user must take this into
 * account while programming this register.
 */
typedef union _hw_uart_ap7816b_t0
{
    uint8_t U;
    struct _hw_uart_ap7816b_t0_bitfields
    {
        uint8_t ADTI_L : 8;            /*!< [7:0] ATR Duration Time Integer Low
                                        * (C7816[TTYPE] = 0) */
    } B;
} hw_uart_ap7816b_t0_t;

/*!
 * @name Constants and macros for entire UART_AP7816B_T0 register
 */
/*@{*/
#define HW_UART_AP7816B_T0_ADDR(x) ((uint32_t)(x) + 0x3BU)

#define HW_UART_AP7816B_T0(x)    (*(__IO hw_uart_ap7816b_t0_t *) HW_UART_AP7816B_T0_ADDR(x))
#define HW_UART_AP7816B_T0_RD(x) (HW_UART_AP7816B_T0(x).U)
#define HW_UART_AP7816B_T0_WR(x, v) (HW_UART_AP7816B_T0(x).U = (v))
#define HW_UART_AP7816B_T0_SET(x, v) (BME_OR8(HW_UART_AP7816B_T0_ADDR(x), (uint8_t)(v)))
#define HW_UART_AP7816B_T0_CLR(x, v) (BME_AND8(HW_UART_AP7816B_T0_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_AP7816B_T0_TOG(x, v) (BME_XOR8(HW_UART_AP7816B_T0_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_AP7816B_T0 bitfields
 */

/*!
 * @name Register UART_AP7816B_T0, field ADTI_L[7:0] (RW)
 *
 * Used to calculate the value used for the ADT counter. This register field
 * provides the least significant byte of the 16 bit ATR Duration Time Integer field
 * ADTI formed by {AP7816A_T0[ADTI_H], AP7816B_T0[ADTI_L]}. Programming a value
 * of ADTI = 0 disables the ADT counter. This value is used only when
 * C7816[TTYPE] = 0. See ATR Duration Time Counter.
 */
/*@{*/
#define BP_UART_AP7816B_T0_ADTI_L (0U)     /*!< Bit position for UART_AP7816B_T0_ADTI_L. */
#define BM_UART_AP7816B_T0_ADTI_L (0xFFU)  /*!< Bit mask for UART_AP7816B_T0_ADTI_L. */
#define BS_UART_AP7816B_T0_ADTI_L (8U)     /*!< Bit field size in bits for UART_AP7816B_T0_ADTI_L. */

/*! @brief Read current value of the UART_AP7816B_T0_ADTI_L field. */
#define BR_UART_AP7816B_T0_ADTI_L(x) (HW_UART_AP7816B_T0(x).U)

/*! @brief Format value for bitfield UART_AP7816B_T0_ADTI_L. */
#define BF_UART_AP7816B_T0_ADTI_L(v) ((uint8_t)((uint8_t)(v) << BP_UART_AP7816B_T0_ADTI_L) & BM_UART_AP7816B_T0_ADTI_L)

/*! @brief Set the ADTI_L field to a new value. */
#define BW_UART_AP7816B_T0_ADTI_L(x, v) (HW_UART_AP7816B_T0_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_WP7816A_T0 - UART 7816 Wait Parameter Register A
 ******************************************************************************/

/*!
 * @brief HW_UART_WP7816A_T0 - UART 7816 Wait Parameter Register A (RW)
 *
 * Reset value: 0x00U
 *
 * The WP7816A_T0 register contains constants used in the generation of various
 * wait time counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wp7816a_t0
{
    uint8_t U;
    struct _hw_uart_wp7816a_t0_bitfields
    {
        uint8_t WI_H : 8;              /*!< [7:0] Wait Time Integer High (C7816[TTYPE] =
                                        * 0) */
    } B;
} hw_uart_wp7816a_t0_t;

/*!
 * @name Constants and macros for entire UART_WP7816A_T0 register
 */
/*@{*/
#define HW_UART_WP7816A_T0_ADDR(x) ((uint32_t)(x) + 0x3CU)

#define HW_UART_WP7816A_T0(x)    (*(__IO hw_uart_wp7816a_t0_t *) HW_UART_WP7816A_T0_ADDR(x))
#define HW_UART_WP7816A_T0_RD(x) (HW_UART_WP7816A_T0(x).U)
#define HW_UART_WP7816A_T0_WR(x, v) (HW_UART_WP7816A_T0(x).U = (v))
#define HW_UART_WP7816A_T0_SET(x, v) (BME_OR8(HW_UART_WP7816A_T0_ADDR(x), (uint8_t)(v)))
#define HW_UART_WP7816A_T0_CLR(x, v) (BME_AND8(HW_UART_WP7816A_T0_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_WP7816A_T0_TOG(x, v) (BME_XOR8(HW_UART_WP7816A_T0_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_WP7816A_T0 bitfields
 */

/*!
 * @name Register UART_WP7816A_T0, field WI_H[7:0] (RW)
 *
 * Used to calculate the value used for the WT counter. This register field
 * provides the most significant byte of the 16 bit Wait Time Integer field WI formed
 * by {WP7816A_T0[WI_H], WP7816B_T0[WI_L]}. The value of WI = 0 is invalid and
 * must not be programmed. This value is used only when C7816[TTYPE] = 0. See Wait
 * time and guard time parameters.
 */
/*@{*/
#define BP_UART_WP7816A_T0_WI_H (0U)       /*!< Bit position for UART_WP7816A_T0_WI_H. */
#define BM_UART_WP7816A_T0_WI_H (0xFFU)    /*!< Bit mask for UART_WP7816A_T0_WI_H. */
#define BS_UART_WP7816A_T0_WI_H (8U)       /*!< Bit field size in bits for UART_WP7816A_T0_WI_H. */

/*! @brief Read current value of the UART_WP7816A_T0_WI_H field. */
#define BR_UART_WP7816A_T0_WI_H(x) (HW_UART_WP7816A_T0(x).U)

/*! @brief Format value for bitfield UART_WP7816A_T0_WI_H. */
#define BF_UART_WP7816A_T0_WI_H(v) ((uint8_t)((uint8_t)(v) << BP_UART_WP7816A_T0_WI_H) & BM_UART_WP7816A_T0_WI_H)

/*! @brief Set the WI_H field to a new value. */
#define BW_UART_WP7816A_T0_WI_H(x, v) (HW_UART_WP7816A_T0_WR(x, v))
/*@}*/
/*******************************************************************************
 * HW_UART_WP7816B_T0 - UART 7816 Wait Parameter Register B
 ******************************************************************************/

/*!
 * @brief HW_UART_WP7816B_T0 - UART 7816 Wait Parameter Register B (RW)
 *
 * Reset value: 0x14U
 *
 * The WP7816B_T0 register contains constants used in the generation of various
 * wait time counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wp7816b_t0
{
    uint8_t U;
    struct _hw_uart_wp7816b_t0_bitfields
    {
        uint8_t WI_L : 8;              /*!< [7:0] Wait Time Integer Low (C7816[TTYPE] = 0)
                                        * */
    } B;
} hw_uart_wp7816b_t0_t;

/*!
 * @name Constants and macros for entire UART_WP7816B_T0 register
 */
/*@{*/
#define HW_UART_WP7816B_T0_ADDR(x) ((uint32_t)(x) + 0x3DU)

#define HW_UART_WP7816B_T0(x)    (*(__IO hw_uart_wp7816b_t0_t *) HW_UART_WP7816B_T0_ADDR(x))
#define HW_UART_WP7816B_T0_RD(x) (HW_UART_WP7816B_T0(x).U)
#define HW_UART_WP7816B_T0_WR(x, v) (HW_UART_WP7816B_T0(x).U = (v))
#define HW_UART_WP7816B_T0_SET(x, v) (BME_OR8(HW_UART_WP7816B_T0_ADDR(x), (uint8_t)(v)))
#define HW_UART_WP7816B_T0_CLR(x, v) (BME_AND8(HW_UART_WP7816B_T0_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_WP7816B_T0_TOG(x, v) (BME_XOR8(HW_UART_WP7816B_T0_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_WP7816B_T0 bitfields
 */

/*!
 * @name Register UART_WP7816B_T0, field WI_L[7:0] (RW)
 *
 * Used to calculate the value used for the WT counter. This register field
 * provides the least significant byte of the 16 bit Wait Time Integer field WI
 * formed by {WP7816A_T0[WI_H], WP7816B_T0[WI_L]} . The value of WI = 0 is invalid and
 * must not be programmed. This value is used only when C7816[TTYPE] = 0. See
 * Wait time and guard time parameters.
 */
/*@{*/
#define BP_UART_WP7816B_T0_WI_L (0U)       /*!< Bit position for UART_WP7816B_T0_WI_L. */
#define BM_UART_WP7816B_T0_WI_L (0xFFU)    /*!< Bit mask for UART_WP7816B_T0_WI_L. */
#define BS_UART_WP7816B_T0_WI_L (8U)       /*!< Bit field size in bits for UART_WP7816B_T0_WI_L. */

/*! @brief Read current value of the UART_WP7816B_T0_WI_L field. */
#define BR_UART_WP7816B_T0_WI_L(x) (HW_UART_WP7816B_T0(x).U)

/*! @brief Format value for bitfield UART_WP7816B_T0_WI_L. */
#define BF_UART_WP7816B_T0_WI_L(v) ((uint8_t)((uint8_t)(v) << BP_UART_WP7816B_T0_WI_L) & BM_UART_WP7816B_T0_WI_L)

/*! @brief Set the WI_L field to a new value. */
#define BW_UART_WP7816B_T0_WI_L(x, v) (HW_UART_WP7816B_T0_WR(x, v))
/*@}*/
/*******************************************************************************
 * HW_UART_WP7816A_T1 - UART 7816 Wait Parameter Register A
 ******************************************************************************/

/*!
 * @brief HW_UART_WP7816A_T1 - UART 7816 Wait Parameter Register A (RW)
 *
 * Reset value: 0x00U
 *
 * The WP7816A_T1 register contains constants used in the generation of various
 * wait time counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wp7816a_t1
{
    uint8_t U;
    struct _hw_uart_wp7816a_t1_bitfields
    {
        uint8_t BWI_H : 8;             /*!< [7:0] Block Wait Time Integer High
                                        * (C7816[TTYPE] = 1) */
    } B;
} hw_uart_wp7816a_t1_t;

/*!
 * @name Constants and macros for entire UART_WP7816A_T1 register
 */
/*@{*/
#define HW_UART_WP7816A_T1_ADDR(x) ((uint32_t)(x) + 0x3CU)

#define HW_UART_WP7816A_T1(x)    (*(__IO hw_uart_wp7816a_t1_t *) HW_UART_WP7816A_T1_ADDR(x))
#define HW_UART_WP7816A_T1_RD(x) (HW_UART_WP7816A_T1(x).U)
#define HW_UART_WP7816A_T1_WR(x, v) (HW_UART_WP7816A_T1(x).U = (v))
#define HW_UART_WP7816A_T1_SET(x, v) (BME_OR8(HW_UART_WP7816A_T1_ADDR(x), (uint8_t)(v)))
#define HW_UART_WP7816A_T1_CLR(x, v) (BME_AND8(HW_UART_WP7816A_T1_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_WP7816A_T1_TOG(x, v) (BME_XOR8(HW_UART_WP7816A_T1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_WP7816A_T1 bitfields
 */

/*!
 * @name Register UART_WP7816A_T1, field BWI_H[7:0] (RW)
 *
 * Used to calculate the value used for the BWT counter. This register field
 * provides the most significant byte of the 16 bit Block Wait Time Integer field
 * BWI formed by {WP7816A_T1[BWI_H], WP7816B_T1[BWI_L]}. The value of BWI = 0 is
 * invalid and should not be programmed. This value is used only when C7816[TTYPE]
 * = 1. See Wait time and guard time parameters.
 */
/*@{*/
#define BP_UART_WP7816A_T1_BWI_H (0U)      /*!< Bit position for UART_WP7816A_T1_BWI_H. */
#define BM_UART_WP7816A_T1_BWI_H (0xFFU)   /*!< Bit mask for UART_WP7816A_T1_BWI_H. */
#define BS_UART_WP7816A_T1_BWI_H (8U)      /*!< Bit field size in bits for UART_WP7816A_T1_BWI_H. */

/*! @brief Read current value of the UART_WP7816A_T1_BWI_H field. */
#define BR_UART_WP7816A_T1_BWI_H(x) (HW_UART_WP7816A_T1(x).U)

/*! @brief Format value for bitfield UART_WP7816A_T1_BWI_H. */
#define BF_UART_WP7816A_T1_BWI_H(v) ((uint8_t)((uint8_t)(v) << BP_UART_WP7816A_T1_BWI_H) & BM_UART_WP7816A_T1_BWI_H)

/*! @brief Set the BWI_H field to a new value. */
#define BW_UART_WP7816A_T1_BWI_H(x, v) (HW_UART_WP7816A_T1_WR(x, v))
/*@}*/
/*******************************************************************************
 * HW_UART_WP7816B_T1 - UART 7816 Wait Parameter Register B
 ******************************************************************************/

/*!
 * @brief HW_UART_WP7816B_T1 - UART 7816 Wait Parameter Register B (RW)
 *
 * Reset value: 0x14U
 *
 * The WP7816B_T1 register contains constants used in the generation of various
 * wait time counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wp7816b_t1
{
    uint8_t U;
    struct _hw_uart_wp7816b_t1_bitfields
    {
        uint8_t BWI_L : 8;             /*!< [7:0] Block Wait Time Integer Low
                                        * (C7816[TTYPE] = 1) */
    } B;
} hw_uart_wp7816b_t1_t;

/*!
 * @name Constants and macros for entire UART_WP7816B_T1 register
 */
/*@{*/
#define HW_UART_WP7816B_T1_ADDR(x) ((uint32_t)(x) + 0x3DU)

#define HW_UART_WP7816B_T1(x)    (*(__IO hw_uart_wp7816b_t1_t *) HW_UART_WP7816B_T1_ADDR(x))
#define HW_UART_WP7816B_T1_RD(x) (HW_UART_WP7816B_T1(x).U)
#define HW_UART_WP7816B_T1_WR(x, v) (HW_UART_WP7816B_T1(x).U = (v))
#define HW_UART_WP7816B_T1_SET(x, v) (BME_OR8(HW_UART_WP7816B_T1_ADDR(x), (uint8_t)(v)))
#define HW_UART_WP7816B_T1_CLR(x, v) (BME_AND8(HW_UART_WP7816B_T1_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_WP7816B_T1_TOG(x, v) (BME_XOR8(HW_UART_WP7816B_T1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_WP7816B_T1 bitfields
 */

/*!
 * @name Register UART_WP7816B_T1, field BWI_L[7:0] (RW)
 *
 * Used to calculate the value used for the BWT counter. This register field
 * provides the least significant byte of the 16 bit Block Wait Time Integer field
 * BWI formed by {WP7816A_T1[BWI_H], WP7816B_T1[BWI_L]}. The value of BWI = 0 is
 * invalid and should not be programmed. This value is used only when C7816[TTYPE]
 * = 1. See Wait time and guard time parameters.
 */
/*@{*/
#define BP_UART_WP7816B_T1_BWI_L (0U)      /*!< Bit position for UART_WP7816B_T1_BWI_L. */
#define BM_UART_WP7816B_T1_BWI_L (0xFFU)   /*!< Bit mask for UART_WP7816B_T1_BWI_L. */
#define BS_UART_WP7816B_T1_BWI_L (8U)      /*!< Bit field size in bits for UART_WP7816B_T1_BWI_L. */

/*! @brief Read current value of the UART_WP7816B_T1_BWI_L field. */
#define BR_UART_WP7816B_T1_BWI_L(x) (HW_UART_WP7816B_T1(x).U)

/*! @brief Format value for bitfield UART_WP7816B_T1_BWI_L. */
#define BF_UART_WP7816B_T1_BWI_L(v) ((uint8_t)((uint8_t)(v) << BP_UART_WP7816B_T1_BWI_L) & BM_UART_WP7816B_T1_BWI_L)

/*! @brief Set the BWI_L field to a new value. */
#define BW_UART_WP7816B_T1_BWI_L(x, v) (HW_UART_WP7816B_T1_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_WGP7816_T1 - UART 7816 Wait and Guard Parameter Register
 ******************************************************************************/

/*!
 * @brief HW_UART_WGP7816_T1 - UART 7816 Wait and Guard Parameter Register (RW)
 *
 * Reset value: 0x06U
 *
 * The WGP7816_T1 register contains constants used in the generation of various
 * wait and guard timer counters. This register may be read at any time. This
 * register must be written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wgp7816_t1
{
    uint8_t U;
    struct _hw_uart_wgp7816_t1_bitfields
    {
        uint8_t BGI : 4;               /*!< [3:0] Block Guard Time Integer (C7816[TTYPE] =
                                        * 1) */
        uint8_t CWI1 : 4;              /*!< [7:4] Character Wait Time Integer 1
                                        * (C7816[TTYPE] = 1) */
    } B;
} hw_uart_wgp7816_t1_t;

/*!
 * @name Constants and macros for entire UART_WGP7816_T1 register
 */
/*@{*/
#define HW_UART_WGP7816_T1_ADDR(x) ((uint32_t)(x) + 0x3EU)

#define HW_UART_WGP7816_T1(x)    (*(__IO hw_uart_wgp7816_t1_t *) HW_UART_WGP7816_T1_ADDR(x))
#define HW_UART_WGP7816_T1_RD(x) (HW_UART_WGP7816_T1(x).U)
#define HW_UART_WGP7816_T1_WR(x, v) (HW_UART_WGP7816_T1(x).U = (v))
#define HW_UART_WGP7816_T1_SET(x, v) (BME_OR8(HW_UART_WGP7816_T1_ADDR(x), (uint8_t)(v)))
#define HW_UART_WGP7816_T1_CLR(x, v) (BME_AND8(HW_UART_WGP7816_T1_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_WGP7816_T1_TOG(x, v) (BME_XOR8(HW_UART_WGP7816_T1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_WGP7816_T1 bitfields
 */

/*!
 * @name Register UART_WGP7816_T1, field BGI[3:0] (RW)
 *
 * Used to calculate the value used for the BGT counter. It represent a value
 * between 0 and 15. This value is used only when C7816[TTYPE] = 1. See Wait time
 * and guard time parameters .
 */
/*@{*/
#define BP_UART_WGP7816_T1_BGI (0U)        /*!< Bit position for UART_WGP7816_T1_BGI. */
#define BM_UART_WGP7816_T1_BGI (0x0FU)     /*!< Bit mask for UART_WGP7816_T1_BGI. */
#define BS_UART_WGP7816_T1_BGI (4U)        /*!< Bit field size in bits for UART_WGP7816_T1_BGI. */

/*! @brief Read current value of the UART_WGP7816_T1_BGI field. */
#define BR_UART_WGP7816_T1_BGI(x) (BME_UBFX8(HW_UART_WGP7816_T1_ADDR(x), BP_UART_WGP7816_T1_BGI, BS_UART_WGP7816_T1_BGI))

/*! @brief Format value for bitfield UART_WGP7816_T1_BGI. */
#define BF_UART_WGP7816_T1_BGI(v) ((uint8_t)((uint8_t)(v) << BP_UART_WGP7816_T1_BGI) & BM_UART_WGP7816_T1_BGI)

/*! @brief Set the BGI field to a new value. */
#define BW_UART_WGP7816_T1_BGI(x, v) (BME_BFI8(HW_UART_WGP7816_T1_ADDR(x), ((uint8_t)(v) << BP_UART_WGP7816_T1_BGI), BP_UART_WGP7816_T1_BGI, 4))
/*@}*/

/*!
 * @name Register UART_WGP7816_T1, field CWI1[7:4] (RW)
 *
 * Used to calculate the value used for the CWT counter. It represents a value
 * between 0 and 15. This value is used only when C7816[TTYPE] = 1. See Wait time
 * and guard time parameters .
 */
/*@{*/
#define BP_UART_WGP7816_T1_CWI1 (4U)       /*!< Bit position for UART_WGP7816_T1_CWI1. */
#define BM_UART_WGP7816_T1_CWI1 (0xF0U)    /*!< Bit mask for UART_WGP7816_T1_CWI1. */
#define BS_UART_WGP7816_T1_CWI1 (4U)       /*!< Bit field size in bits for UART_WGP7816_T1_CWI1. */

/*! @brief Read current value of the UART_WGP7816_T1_CWI1 field. */
#define BR_UART_WGP7816_T1_CWI1(x) (BME_UBFX8(HW_UART_WGP7816_T1_ADDR(x), BP_UART_WGP7816_T1_CWI1, BS_UART_WGP7816_T1_CWI1))

/*! @brief Format value for bitfield UART_WGP7816_T1_CWI1. */
#define BF_UART_WGP7816_T1_CWI1(v) ((uint8_t)((uint8_t)(v) << BP_UART_WGP7816_T1_CWI1) & BM_UART_WGP7816_T1_CWI1)

/*! @brief Set the CWI1 field to a new value. */
#define BW_UART_WGP7816_T1_CWI1(x, v) (BME_BFI8(HW_UART_WGP7816_T1_ADDR(x), ((uint8_t)(v) << BP_UART_WGP7816_T1_CWI1), BP_UART_WGP7816_T1_CWI1, 4))
/*@}*/

/*******************************************************************************
 * HW_UART_WP7816C_T1 - UART 7816 Wait Parameter Register C
 ******************************************************************************/

/*!
 * @brief HW_UART_WP7816C_T1 - UART 7816 Wait Parameter Register C (RW)
 *
 * Reset value: 0x0BU
 *
 * The WP7816C_T1 register contains constants used in the generation of various
 * wait timer counters. This register may be read at any time. This register must
 * be written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wp7816c_t1
{
    uint8_t U;
    struct _hw_uart_wp7816c_t1_bitfields
    {
        uint8_t CWI2 : 5;              /*!< [4:0] Character Wait Time Integer 2
                                        * (C7816[TTYPE] = 1) */
        uint8_t RESERVED0 : 3;         /*!< [7:5]  */
    } B;
} hw_uart_wp7816c_t1_t;

/*!
 * @name Constants and macros for entire UART_WP7816C_T1 register
 */
/*@{*/
#define HW_UART_WP7816C_T1_ADDR(x) ((uint32_t)(x) + 0x3FU)

#define HW_UART_WP7816C_T1(x)    (*(__IO hw_uart_wp7816c_t1_t *) HW_UART_WP7816C_T1_ADDR(x))
#define HW_UART_WP7816C_T1_RD(x) (HW_UART_WP7816C_T1(x).U)
#define HW_UART_WP7816C_T1_WR(x, v) (HW_UART_WP7816C_T1(x).U = (v))
#define HW_UART_WP7816C_T1_SET(x, v) (BME_OR8(HW_UART_WP7816C_T1_ADDR(x), (uint8_t)(v)))
#define HW_UART_WP7816C_T1_CLR(x, v) (BME_AND8(HW_UART_WP7816C_T1_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_WP7816C_T1_TOG(x, v) (BME_XOR8(HW_UART_WP7816C_T1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_WP7816C_T1 bitfields
 */

/*!
 * @name Register UART_WP7816C_T1, field CWI2[4:0] (RW)
 *
 * Used to calculate the value used for the CWT counter. It represents a value
 * between 0 and 31. This value is used only when C7816[TTYPE] = 1. See Wait time
 * and guard time parameters .
 */
/*@{*/
#define BP_UART_WP7816C_T1_CWI2 (0U)       /*!< Bit position for UART_WP7816C_T1_CWI2. */
#define BM_UART_WP7816C_T1_CWI2 (0x1FU)    /*!< Bit mask for UART_WP7816C_T1_CWI2. */
#define BS_UART_WP7816C_T1_CWI2 (5U)       /*!< Bit field size in bits for UART_WP7816C_T1_CWI2. */

/*! @brief Read current value of the UART_WP7816C_T1_CWI2 field. */
#define BR_UART_WP7816C_T1_CWI2(x) (BME_UBFX8(HW_UART_WP7816C_T1_ADDR(x), BP_UART_WP7816C_T1_CWI2, BS_UART_WP7816C_T1_CWI2))

/*! @brief Format value for bitfield UART_WP7816C_T1_CWI2. */
#define BF_UART_WP7816C_T1_CWI2(v) ((uint8_t)((uint8_t)(v) << BP_UART_WP7816C_T1_CWI2) & BM_UART_WP7816C_T1_CWI2)

/*! @brief Set the CWI2 field to a new value. */
#define BW_UART_WP7816C_T1_CWI2(x, v) (BME_BFI8(HW_UART_WP7816C_T1_ADDR(x), ((uint8_t)(v) << BP_UART_WP7816C_T1_CWI2), BP_UART_WP7816C_T1_CWI2, 5))
/*@}*/

/*
** Start of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma push
  #pragma anon_unions
#elif defined(__CWCC__)
  #pragma push
  #pragma cpp_extensions on
#elif defined(__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=extended
#else
  #error Not supported compiler type
#endif

/*******************************************************************************
 * hw_uart_t - module struct
 ******************************************************************************/
/*!
 * @brief All UART module registers.
 */
#pragma pack(1)
typedef struct _hw_uart
{
    __IO hw_uart_bdh_t BDH;                /*!< [0x0] UART Baud Rate Registers: High */
    __IO hw_uart_bdl_t BDL;                /*!< [0x1] UART Baud Rate Registers: Low */
    __IO hw_uart_c1_t C1;                  /*!< [0x2] UART Control Register 1 */
    __IO hw_uart_c2_t C2;                  /*!< [0x3] UART Control Register 2 */
    __I hw_uart_s1_t S1;                   /*!< [0x4] UART Status Register 1 */
    __IO hw_uart_s2_t S2;                  /*!< [0x5] UART Status Register 2 */
    __IO hw_uart_c3_t C3;                  /*!< [0x6] UART Control Register 3 */
    __IO hw_uart_d_t D;                    /*!< [0x7] UART Data Register */
    __IO hw_uart_ma1_t MA1;                /*!< [0x8] UART Match Address Registers 1 */
    __IO hw_uart_ma2_t MA2;                /*!< [0x9] UART Match Address Registers 2 */
    __IO hw_uart_c4_t C4;                  /*!< [0xA] UART Control Register 4 */
    __IO hw_uart_c5_t C5;                  /*!< [0xB] UART Control Register 5 */
    uint8_t _reserved0[12];
    __IO hw_uart_c7816_t C7816;            /*!< [0x18] UART 7816 Control Register */
    __IO hw_uart_ie7816_t IE7816;          /*!< [0x19] UART 7816 Interrupt Enable Register */
    __IO hw_uart_is7816_t IS7816;          /*!< [0x1A] UART 7816 Interrupt Status Register */
    __IO hw_uart_wp7816_t WP7816;          /*!< [0x1B] UART 7816 Wait Parameter Register */
    __IO hw_uart_wn7816_t WN7816;          /*!< [0x1C] UART 7816 Wait N Register */
    __IO hw_uart_wf7816_t WF7816;          /*!< [0x1D] UART 7816 Wait FD Register */
    __IO hw_uart_et7816_t ET7816;          /*!< [0x1E] UART 7816 Error Threshold Register */
    __IO hw_uart_tl7816_t TL7816;          /*!< [0x1F] UART 7816 Transmit Length Register */
    uint8_t _reserved1[26];
    __IO hw_uart_ap7816a_t0_t AP7816A_T0;  /*!< [0x3A] UART 7816 ATR Duration Timer Register A */
    __IO hw_uart_ap7816b_t0_t AP7816B_T0;  /*!< [0x3B] UART 7816 ATR Duration Timer Register B */
    union {
        struct {
            __IO hw_uart_wp7816a_t0_t WP7816A_T0; /*!< [0x3C] UART 7816 Wait Parameter Register A */
            __IO hw_uart_wp7816b_t0_t WP7816B_T0; /*!< [0x3D] UART 7816 Wait Parameter Register B */
        } TYPE0;
        struct {
            __IO hw_uart_wp7816a_t1_t WP7816A_T1; /*!< [0x3C] UART 7816 Wait Parameter Register A */
            __IO hw_uart_wp7816b_t1_t WP7816B_T1; /*!< [0x3D] UART 7816 Wait Parameter Register B */
        } TYPE1;
    };
    __IO hw_uart_wgp7816_t1_t WGP7816_T1;  /*!< [0x3E] UART 7816 Wait and Guard Parameter Register */
    __IO hw_uart_wp7816c_t1_t WP7816C_T1;  /*!< [0x3F] UART 7816 Wait Parameter Register C */
} hw_uart_t;
#pragma pack()

/*! @brief Macro to access all UART registers. */
/*! @param x UART module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_UART_REGS(UART2_BASE)</code>. */
#define HW_UART_REGS(x) (*(hw_uart_t *)(x))

/*
** End of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma pop
#elif defined(__CWCC__)
  #pragma pop
#elif defined(__GNUC__)
  /* leave anonymous unions enabled */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=default
#else
  #error Not supported compiler type
#endif

/*
 * MKL43Z4 USB
 *
 * Universal Serial Bus, OTG Capable Controller
 *
 * Registers defined in this header file:
 * - HW_USB_PERID - Peripheral ID register
 * - HW_USB_IDCOMP - Peripheral ID Complement register
 * - HW_USB_REV - Peripheral Revision register
 * - HW_USB_ADDINFO - Peripheral Additional Info register
 * - HW_USB_OTGCTL - OTG Control register
 * - HW_USB_ISTAT - Interrupt Status register
 * - HW_USB_INTEN - Interrupt Enable register
 * - HW_USB_ERRSTAT - Error Interrupt Status register
 * - HW_USB_ERREN - Error Interrupt Enable register
 * - HW_USB_STAT - Status register
 * - HW_USB_CTL - Control register
 * - HW_USB_ADDR - Address register
 * - HW_USB_BDTPAGE1 - BDT Page register 1
 * - HW_USB_FRMNUML - Frame Number register Low
 * - HW_USB_FRMNUMH - Frame Number register High
 * - HW_USB_BDTPAGE2 - BDT Page Register 2
 * - HW_USB_BDTPAGE3 - BDT Page Register 3
 * - HW_USB_ENDPTn - Endpoint Control register
 * - HW_USB_USBCTRL - USB Control register
 * - HW_USB_OBSERVE - USB OTG Observe register
 * - HW_USB_CONTROL - USB OTG Control register
 * - HW_USB_USBTRC0 - USB Transceiver Control register 0
 * - HW_USB_USBFRMADJUST - Frame Adjust Register
 * - HW_USB_CLK_RECOVER_CTRL - USB Clock recovery control
 * - HW_USB_CLK_RECOVER_IRC_EN - IRC48M oscillator enable register
 * - HW_USB_CLK_RECOVER_INT_EN - Clock recovery combined interrupt enable
 * - HW_USB_CLK_RECOVER_INT_STATUS - Clock recovery separated interrupt status
 *
 * - hw_usb_t - Struct containing all module registers.
 */

#define HW_USB_INSTANCE_COUNT (1U) /*!< Number of instances of the USB module. */
#define HW_USB0 (0U) /*!< Instance number for USB0. */

/*******************************************************************************
 * HW_USB_PERID - Peripheral ID register
 ******************************************************************************/

/*!
 * @brief HW_USB_PERID - Peripheral ID register (RO)
 *
 * Reset value: 0x04U
 *
 * Reads back the value of 0x04. This value is defined for the USB peripheral.
 */
typedef union _hw_usb_perid
{
    uint8_t U;
    struct _hw_usb_perid_bitfields
    {
        uint8_t ID : 6;                /*!< [5:0] Peripheral Identification */
        uint8_t RESERVED0 : 2;         /*!< [7:6]  */
    } B;
} hw_usb_perid_t;

/*!
 * @name Constants and macros for entire USB_PERID register
 */
/*@{*/
#define HW_USB_PERID_ADDR(x)     ((uint32_t)(x) + 0x0U)

#define HW_USB_PERID(x)          (*(__I hw_usb_perid_t *) HW_USB_PERID_ADDR(x))
#define HW_USB_PERID_RD(x)       (HW_USB_PERID(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_PERID bitfields
 */

/*!
 * @name Register USB_PERID, field ID[5:0] (RO)
 *
 * This field always reads 0x4h.
 */
/*@{*/
#define BP_USB_PERID_ID      (0U)          /*!< Bit position for USB_PERID_ID. */
#define BM_USB_PERID_ID      (0x3FU)       /*!< Bit mask for USB_PERID_ID. */
#define BS_USB_PERID_ID      (6U)          /*!< Bit field size in bits for USB_PERID_ID. */

/*! @brief Read current value of the USB_PERID_ID field. */
#define BR_USB_PERID_ID(x)   (BME_UBFX8(HW_USB_PERID_ADDR(x), BP_USB_PERID_ID, BS_USB_PERID_ID))
/*@}*/

/*******************************************************************************
 * HW_USB_IDCOMP - Peripheral ID Complement register
 ******************************************************************************/

/*!
 * @brief HW_USB_IDCOMP - Peripheral ID Complement register (RO)
 *
 * Reset value: 0xFBU
 *
 * Reads back the complement of the Peripheral ID register. For the USB
 * peripheral, the value is 0xFB.
 */
typedef union _hw_usb_idcomp
{
    uint8_t U;
    struct _hw_usb_idcomp_bitfields
    {
        uint8_t NID : 6;               /*!< [5:0]  */
        uint8_t RESERVED0 : 2;         /*!< [7:6]  */
    } B;
} hw_usb_idcomp_t;

/*!
 * @name Constants and macros for entire USB_IDCOMP register
 */
/*@{*/
#define HW_USB_IDCOMP_ADDR(x)    ((uint32_t)(x) + 0x4U)

#define HW_USB_IDCOMP(x)         (*(__I hw_usb_idcomp_t *) HW_USB_IDCOMP_ADDR(x))
#define HW_USB_IDCOMP_RD(x)      (HW_USB_IDCOMP(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_IDCOMP bitfields
 */

/*!
 * @name Register USB_IDCOMP, field NID[5:0] (RO)
 *
 * Ones' complement of PERID[ID]. bits.
 */
/*@{*/
#define BP_USB_IDCOMP_NID    (0U)          /*!< Bit position for USB_IDCOMP_NID. */
#define BM_USB_IDCOMP_NID    (0x3FU)       /*!< Bit mask for USB_IDCOMP_NID. */
#define BS_USB_IDCOMP_NID    (6U)          /*!< Bit field size in bits for USB_IDCOMP_NID. */

/*! @brief Read current value of the USB_IDCOMP_NID field. */
#define BR_USB_IDCOMP_NID(x) (BME_UBFX8(HW_USB_IDCOMP_ADDR(x), BP_USB_IDCOMP_NID, BS_USB_IDCOMP_NID))
/*@}*/

/*******************************************************************************
 * HW_USB_REV - Peripheral Revision register
 ******************************************************************************/

/*!
 * @brief HW_USB_REV - Peripheral Revision register (RO)
 *
 * Reset value: 0x33U
 *
 * Contains the revision number of the USB module.
 */
typedef union _hw_usb_rev
{
    uint8_t U;
    struct _hw_usb_rev_bitfields
    {
        uint8_t REV : 8;               /*!< [7:0] Revision */
    } B;
} hw_usb_rev_t;

/*!
 * @name Constants and macros for entire USB_REV register
 */
/*@{*/
#define HW_USB_REV_ADDR(x)       ((uint32_t)(x) + 0x8U)

#define HW_USB_REV(x)            (*(__I hw_usb_rev_t *) HW_USB_REV_ADDR(x))
#define HW_USB_REV_RD(x)         (HW_USB_REV(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_REV bitfields
 */

/*!
 * @name Register USB_REV, field REV[7:0] (RO)
 *
 * Indicates the revision number of the USB Core.
 */
/*@{*/
#define BP_USB_REV_REV       (0U)          /*!< Bit position for USB_REV_REV. */
#define BM_USB_REV_REV       (0xFFU)       /*!< Bit mask for USB_REV_REV. */
#define BS_USB_REV_REV       (8U)          /*!< Bit field size in bits for USB_REV_REV. */

/*! @brief Read current value of the USB_REV_REV field. */
#define BR_USB_REV_REV(x)    (HW_USB_REV(x).U)
/*@}*/

/*******************************************************************************
 * HW_USB_ADDINFO - Peripheral Additional Info register
 ******************************************************************************/

/*!
 * @brief HW_USB_ADDINFO - Peripheral Additional Info register (RO)
 *
 * Reset value: 0x01U
 *
 * Reads back the value of the Host Enable bit.
 */
typedef union _hw_usb_addinfo
{
    uint8_t U;
    struct _hw_usb_addinfo_bitfields
    {
        uint8_t IEHOST : 1;            /*!< [0]  */
        uint8_t RESERVED0 : 7;         /*!< [7:1]  */
    } B;
} hw_usb_addinfo_t;

/*!
 * @name Constants and macros for entire USB_ADDINFO register
 */
/*@{*/
#define HW_USB_ADDINFO_ADDR(x)   ((uint32_t)(x) + 0xCU)

#define HW_USB_ADDINFO(x)        (*(__I hw_usb_addinfo_t *) HW_USB_ADDINFO_ADDR(x))
#define HW_USB_ADDINFO_RD(x)     (HW_USB_ADDINFO(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_ADDINFO bitfields
 */

/*!
 * @name Register USB_ADDINFO, field IEHOST[0] (RO)
 *
 * This bit is set if host mode is enabled.
 */
/*@{*/
#define BP_USB_ADDINFO_IEHOST (0U)         /*!< Bit position for USB_ADDINFO_IEHOST. */
#define BM_USB_ADDINFO_IEHOST (0x01U)      /*!< Bit mask for USB_ADDINFO_IEHOST. */
#define BS_USB_ADDINFO_IEHOST (1U)         /*!< Bit field size in bits for USB_ADDINFO_IEHOST. */

/*! @brief Read current value of the USB_ADDINFO_IEHOST field. */
#define BR_USB_ADDINFO_IEHOST(x) (BME_UBFX8(HW_USB_ADDINFO_ADDR(x), BP_USB_ADDINFO_IEHOST, BS_USB_ADDINFO_IEHOST))
/*@}*/

/*******************************************************************************
 * HW_USB_OTGCTL - OTG Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_OTGCTL - OTG Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Controls the operation of VBUS and Data Line termination resistors.
 */
typedef union _hw_usb_otgctl
{
    uint8_t U;
    struct _hw_usb_otgctl_bitfields
    {
        uint8_t RESERVED0 : 7;         /*!< [6:0]  */
        uint8_t DPHIGH : 1;            /*!< [7] D+ Data Line pullup resistor enable */
    } B;
} hw_usb_otgctl_t;

/*!
 * @name Constants and macros for entire USB_OTGCTL register
 */
/*@{*/
#define HW_USB_OTGCTL_ADDR(x)    ((uint32_t)(x) + 0x1CU)

#define HW_USB_OTGCTL(x)         (*(__IO hw_usb_otgctl_t *) HW_USB_OTGCTL_ADDR(x))
#define HW_USB_OTGCTL_RD(x)      (HW_USB_OTGCTL(x).U)
#define HW_USB_OTGCTL_WR(x, v)   (HW_USB_OTGCTL(x).U = (v))
#define HW_USB_OTGCTL_SET(x, v)  (BME_OR8(HW_USB_OTGCTL_ADDR(x), (uint8_t)(v)))
#define HW_USB_OTGCTL_CLR(x, v)  (BME_AND8(HW_USB_OTGCTL_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_OTGCTL_TOG(x, v)  (BME_XOR8(HW_USB_OTGCTL_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGCTL bitfields
 */

/*!
 * @name Register USB_OTGCTL, field DPHIGH[7] (RW)
 *
 * Values:
 * - 0 - D+ pullup resistor is not enabled
 * - 1 - D+ pullup resistor is enabled
 */
/*@{*/
#define BP_USB_OTGCTL_DPHIGH (7U)          /*!< Bit position for USB_OTGCTL_DPHIGH. */
#define BM_USB_OTGCTL_DPHIGH (0x80U)       /*!< Bit mask for USB_OTGCTL_DPHIGH. */
#define BS_USB_OTGCTL_DPHIGH (1U)          /*!< Bit field size in bits for USB_OTGCTL_DPHIGH. */

/*! @brief Read current value of the USB_OTGCTL_DPHIGH field. */
#define BR_USB_OTGCTL_DPHIGH(x) (BME_UBFX8(HW_USB_OTGCTL_ADDR(x), BP_USB_OTGCTL_DPHIGH, BS_USB_OTGCTL_DPHIGH))

/*! @brief Format value for bitfield USB_OTGCTL_DPHIGH. */
#define BF_USB_OTGCTL_DPHIGH(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGCTL_DPHIGH) & BM_USB_OTGCTL_DPHIGH)

/*! @brief Set the DPHIGH field to a new value. */
#define BW_USB_OTGCTL_DPHIGH(x, v) (BME_BFI8(HW_USB_OTGCTL_ADDR(x), ((uint8_t)(v) << BP_USB_OTGCTL_DPHIGH), BP_USB_OTGCTL_DPHIGH, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_ISTAT - Interrupt Status register
 ******************************************************************************/

/*!
 * @brief HW_USB_ISTAT - Interrupt Status register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains fields for each of the interrupt sources within the USB Module. Each
 * of these fields are qualified with their respective interrupt enable bits.
 * After an interrupt bit has been set it may only be cleared by writing a one to
 * the respective interrupt bit. This register contains the value of 0x00 after a
 * reset.
 */
typedef union _hw_usb_istat
{
    uint8_t U;
    struct _hw_usb_istat_bitfields
    {
        uint8_t USBRST : 1;            /*!< [0]  */
        uint8_t ERROR : 1;             /*!< [1]  */
        uint8_t SOFTOK : 1;            /*!< [2]  */
        uint8_t TOKDNE : 1;            /*!< [3]  */
        uint8_t SLEEP : 1;             /*!< [4]  */
        uint8_t RESUME : 1;            /*!< [5]  */
        uint8_t RESERVED0 : 1;         /*!< [6] Reserved */
        uint8_t STALL : 1;             /*!< [7] Stall Interrupt */
    } B;
} hw_usb_istat_t;

/*!
 * @name Constants and macros for entire USB_ISTAT register
 */
/*@{*/
#define HW_USB_ISTAT_ADDR(x)     ((uint32_t)(x) + 0x80U)

#define HW_USB_ISTAT(x)          (*(__IO hw_usb_istat_t *) HW_USB_ISTAT_ADDR(x))
#define HW_USB_ISTAT_RD(x)       (HW_USB_ISTAT(x).U)
#define HW_USB_ISTAT_WR(x, v)    (HW_USB_ISTAT(x).U = (v))
#define HW_USB_ISTAT_SET(x, v)   (BME_OR8(HW_USB_ISTAT_ADDR(x), (uint8_t)(v)))
#define HW_USB_ISTAT_CLR(x, v)   (BME_AND8(HW_USB_ISTAT_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_ISTAT_TOG(x, v)   (BME_XOR8(HW_USB_ISTAT_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_ISTAT bitfields
 */

/*!
 * @name Register USB_ISTAT, field USBRST[0] (W1C)
 *
 * This bit is set when the USB Module has decoded a valid USB reset. This
 * informs the processor that it should write 0x00 into the address register and
 * enable endpoint 0. USBRST is set after a USB reset has been detected for 2.5
 * microseconds. It is not asserted again until the USB reset condition has been
 * removed and then reasserted.
 */
/*@{*/
#define BP_USB_ISTAT_USBRST  (0U)          /*!< Bit position for USB_ISTAT_USBRST. */
#define BM_USB_ISTAT_USBRST  (0x01U)       /*!< Bit mask for USB_ISTAT_USBRST. */
#define BS_USB_ISTAT_USBRST  (1U)          /*!< Bit field size in bits for USB_ISTAT_USBRST. */

/*! @brief Read current value of the USB_ISTAT_USBRST field. */
#define BR_USB_ISTAT_USBRST(x) (BME_UBFX8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_USBRST, BS_USB_ISTAT_USBRST))

/*! @brief Format value for bitfield USB_ISTAT_USBRST. */
#define BF_USB_ISTAT_USBRST(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_USBRST) & BM_USB_ISTAT_USBRST)

/*! @brief Set the USBRST field to a new value. */
#define BW_USB_ISTAT_USBRST(x, v) (BME_BFI8(HW_USB_ISTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ISTAT_USBRST), BP_USB_ISTAT_USBRST, 1))
/*@}*/

/*!
 * @name Register USB_ISTAT, field ERROR[1] (W1C)
 *
 * This bit is set when any of the error conditions within Error Interrupt
 * Status (ERRSTAT) register occur. The processor must then read the ERRSTAT register
 * to determine the source of the error.
 */
/*@{*/
#define BP_USB_ISTAT_ERROR   (1U)          /*!< Bit position for USB_ISTAT_ERROR. */
#define BM_USB_ISTAT_ERROR   (0x02U)       /*!< Bit mask for USB_ISTAT_ERROR. */
#define BS_USB_ISTAT_ERROR   (1U)          /*!< Bit field size in bits for USB_ISTAT_ERROR. */

/*! @brief Read current value of the USB_ISTAT_ERROR field. */
#define BR_USB_ISTAT_ERROR(x) (BME_UBFX8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_ERROR, BS_USB_ISTAT_ERROR))

/*! @brief Format value for bitfield USB_ISTAT_ERROR. */
#define BF_USB_ISTAT_ERROR(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_ERROR) & BM_USB_ISTAT_ERROR)

/*! @brief Set the ERROR field to a new value. */
#define BW_USB_ISTAT_ERROR(x, v) (BME_BFI8(HW_USB_ISTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ISTAT_ERROR), BP_USB_ISTAT_ERROR, 1))
/*@}*/

/*!
 * @name Register USB_ISTAT, field SOFTOK[2] (W1C)
 *
 * This bit is set when the USB Module receives a Start Of Frame (SOF) token.
 */
/*@{*/
#define BP_USB_ISTAT_SOFTOK  (2U)          /*!< Bit position for USB_ISTAT_SOFTOK. */
#define BM_USB_ISTAT_SOFTOK  (0x04U)       /*!< Bit mask for USB_ISTAT_SOFTOK. */
#define BS_USB_ISTAT_SOFTOK  (1U)          /*!< Bit field size in bits for USB_ISTAT_SOFTOK. */

/*! @brief Read current value of the USB_ISTAT_SOFTOK field. */
#define BR_USB_ISTAT_SOFTOK(x) (BME_UBFX8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_SOFTOK, BS_USB_ISTAT_SOFTOK))

/*! @brief Format value for bitfield USB_ISTAT_SOFTOK. */
#define BF_USB_ISTAT_SOFTOK(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_SOFTOK) & BM_USB_ISTAT_SOFTOK)

/*! @brief Set the SOFTOK field to a new value. */
#define BW_USB_ISTAT_SOFTOK(x, v) (BME_BFI8(HW_USB_ISTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ISTAT_SOFTOK), BP_USB_ISTAT_SOFTOK, 1))
/*@}*/

/*!
 * @name Register USB_ISTAT, field TOKDNE[3] (W1C)
 *
 * This bit is set when the current token being processed has completed. The
 * processor must immediately read the STATUS (STAT) register to determine the
 * EndPoint and BD used for this token. Clearing this bit (by writing a one) causes
 * STAT to be cleared or the STAT holding register to be loaded into the STAT
 * register.
 */
/*@{*/
#define BP_USB_ISTAT_TOKDNE  (3U)          /*!< Bit position for USB_ISTAT_TOKDNE. */
#define BM_USB_ISTAT_TOKDNE  (0x08U)       /*!< Bit mask for USB_ISTAT_TOKDNE. */
#define BS_USB_ISTAT_TOKDNE  (1U)          /*!< Bit field size in bits for USB_ISTAT_TOKDNE. */

/*! @brief Read current value of the USB_ISTAT_TOKDNE field. */
#define BR_USB_ISTAT_TOKDNE(x) (BME_UBFX8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_TOKDNE, BS_USB_ISTAT_TOKDNE))

/*! @brief Format value for bitfield USB_ISTAT_TOKDNE. */
#define BF_USB_ISTAT_TOKDNE(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_TOKDNE) & BM_USB_ISTAT_TOKDNE)

/*! @brief Set the TOKDNE field to a new value. */
#define BW_USB_ISTAT_TOKDNE(x, v) (BME_BFI8(HW_USB_ISTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ISTAT_TOKDNE), BP_USB_ISTAT_TOKDNE, 1))
/*@}*/

/*!
 * @name Register USB_ISTAT, field SLEEP[4] (W1C)
 *
 * This bit is set when the USB Module detects a constant idle on the USB bus
 * for 3 ms. The sleep timer is reset by activity on the USB bus.
 */
/*@{*/
#define BP_USB_ISTAT_SLEEP   (4U)          /*!< Bit position for USB_ISTAT_SLEEP. */
#define BM_USB_ISTAT_SLEEP   (0x10U)       /*!< Bit mask for USB_ISTAT_SLEEP. */
#define BS_USB_ISTAT_SLEEP   (1U)          /*!< Bit field size in bits for USB_ISTAT_SLEEP. */

/*! @brief Read current value of the USB_ISTAT_SLEEP field. */
#define BR_USB_ISTAT_SLEEP(x) (BME_UBFX8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_SLEEP, BS_USB_ISTAT_SLEEP))

/*! @brief Format value for bitfield USB_ISTAT_SLEEP. */
#define BF_USB_ISTAT_SLEEP(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_SLEEP) & BM_USB_ISTAT_SLEEP)

/*! @brief Set the SLEEP field to a new value. */
#define BW_USB_ISTAT_SLEEP(x, v) (BME_BFI8(HW_USB_ISTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ISTAT_SLEEP), BP_USB_ISTAT_SLEEP, 1))
/*@}*/

/*!
 * @name Register USB_ISTAT, field RESUME[5] (W1C)
 *
 * This bit is set when a K-state is observed on the DP/DM signals for 2.5 us.
 * When not in suspend mode this interrupt must be disabled.
 */
/*@{*/
#define BP_USB_ISTAT_RESUME  (5U)          /*!< Bit position for USB_ISTAT_RESUME. */
#define BM_USB_ISTAT_RESUME  (0x20U)       /*!< Bit mask for USB_ISTAT_RESUME. */
#define BS_USB_ISTAT_RESUME  (1U)          /*!< Bit field size in bits for USB_ISTAT_RESUME. */

/*! @brief Read current value of the USB_ISTAT_RESUME field. */
#define BR_USB_ISTAT_RESUME(x) (BME_UBFX8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_RESUME, BS_USB_ISTAT_RESUME))

/*! @brief Format value for bitfield USB_ISTAT_RESUME. */
#define BF_USB_ISTAT_RESUME(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_RESUME) & BM_USB_ISTAT_RESUME)

/*! @brief Set the RESUME field to a new value. */
#define BW_USB_ISTAT_RESUME(x, v) (BME_BFI8(HW_USB_ISTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ISTAT_RESUME), BP_USB_ISTAT_RESUME, 1))
/*@}*/

/*!
 * @name Register USB_ISTAT, field STALL[7] (W1C)
 *
 * In Target mode this bit is asserted when a STALL handshake is sent by the SIE.
 */
/*@{*/
#define BP_USB_ISTAT_STALL   (7U)          /*!< Bit position for USB_ISTAT_STALL. */
#define BM_USB_ISTAT_STALL   (0x80U)       /*!< Bit mask for USB_ISTAT_STALL. */
#define BS_USB_ISTAT_STALL   (1U)          /*!< Bit field size in bits for USB_ISTAT_STALL. */

/*! @brief Read current value of the USB_ISTAT_STALL field. */
#define BR_USB_ISTAT_STALL(x) (BME_UBFX8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_STALL, BS_USB_ISTAT_STALL))

/*! @brief Format value for bitfield USB_ISTAT_STALL. */
#define BF_USB_ISTAT_STALL(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_STALL) & BM_USB_ISTAT_STALL)

/*! @brief Set the STALL field to a new value. */
#define BW_USB_ISTAT_STALL(x, v) (BME_BFI8(HW_USB_ISTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ISTAT_STALL), BP_USB_ISTAT_STALL, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_INTEN - Interrupt Enable register
 ******************************************************************************/

/*!
 * @brief HW_USB_INTEN - Interrupt Enable register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains enable fields for each of the interrupt sources within the USB
 * Module. Setting any of these bits enables the respective interrupt source in the
 * ISTAT register. This register contains the value of 0x00 after a reset.
 */
typedef union _hw_usb_inten
{
    uint8_t U;
    struct _hw_usb_inten_bitfields
    {
        uint8_t USBRSTEN : 1;          /*!< [0] USBRST Interrupt Enable */
        uint8_t ERROREN : 1;           /*!< [1] ERROR Interrupt Enable */
        uint8_t SOFTOKEN : 1;          /*!< [2] SOFTOK Interrupt Enable */
        uint8_t TOKDNEEN : 1;          /*!< [3] TOKDNE Interrupt Enable */
        uint8_t SLEEPEN : 1;           /*!< [4] SLEEP Interrupt Enable */
        uint8_t RESUMEEN : 1;          /*!< [5] RESUME Interrupt Enable */
        uint8_t RESERVED0 : 1;         /*!< [6]  */
        uint8_t STALLEN : 1;           /*!< [7] STALL Interrupt Enable */
    } B;
} hw_usb_inten_t;

/*!
 * @name Constants and macros for entire USB_INTEN register
 */
/*@{*/
#define HW_USB_INTEN_ADDR(x)     ((uint32_t)(x) + 0x84U)

#define HW_USB_INTEN(x)          (*(__IO hw_usb_inten_t *) HW_USB_INTEN_ADDR(x))
#define HW_USB_INTEN_RD(x)       (HW_USB_INTEN(x).U)
#define HW_USB_INTEN_WR(x, v)    (HW_USB_INTEN(x).U = (v))
#define HW_USB_INTEN_SET(x, v)   (BME_OR8(HW_USB_INTEN_ADDR(x), (uint8_t)(v)))
#define HW_USB_INTEN_CLR(x, v)   (BME_AND8(HW_USB_INTEN_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_INTEN_TOG(x, v)   (BME_XOR8(HW_USB_INTEN_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_INTEN bitfields
 */

/*!
 * @name Register USB_INTEN, field USBRSTEN[0] (RW)
 *
 * Values:
 * - 0 - Disables the USBRST interrupt.
 * - 1 - Enables the USBRST interrupt.
 */
/*@{*/
#define BP_USB_INTEN_USBRSTEN (0U)         /*!< Bit position for USB_INTEN_USBRSTEN. */
#define BM_USB_INTEN_USBRSTEN (0x01U)      /*!< Bit mask for USB_INTEN_USBRSTEN. */
#define BS_USB_INTEN_USBRSTEN (1U)         /*!< Bit field size in bits for USB_INTEN_USBRSTEN. */

/*! @brief Read current value of the USB_INTEN_USBRSTEN field. */
#define BR_USB_INTEN_USBRSTEN(x) (BME_UBFX8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_USBRSTEN, BS_USB_INTEN_USBRSTEN))

/*! @brief Format value for bitfield USB_INTEN_USBRSTEN. */
#define BF_USB_INTEN_USBRSTEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_USBRSTEN) & BM_USB_INTEN_USBRSTEN)

/*! @brief Set the USBRSTEN field to a new value. */
#define BW_USB_INTEN_USBRSTEN(x, v) (BME_BFI8(HW_USB_INTEN_ADDR(x), ((uint8_t)(v) << BP_USB_INTEN_USBRSTEN), BP_USB_INTEN_USBRSTEN, 1))
/*@}*/

/*!
 * @name Register USB_INTEN, field ERROREN[1] (RW)
 *
 * Values:
 * - 0 - Disables the ERROR interrupt.
 * - 1 - Enables the ERROR interrupt.
 */
/*@{*/
#define BP_USB_INTEN_ERROREN (1U)          /*!< Bit position for USB_INTEN_ERROREN. */
#define BM_USB_INTEN_ERROREN (0x02U)       /*!< Bit mask for USB_INTEN_ERROREN. */
#define BS_USB_INTEN_ERROREN (1U)          /*!< Bit field size in bits for USB_INTEN_ERROREN. */

/*! @brief Read current value of the USB_INTEN_ERROREN field. */
#define BR_USB_INTEN_ERROREN(x) (BME_UBFX8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_ERROREN, BS_USB_INTEN_ERROREN))

/*! @brief Format value for bitfield USB_INTEN_ERROREN. */
#define BF_USB_INTEN_ERROREN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_ERROREN) & BM_USB_INTEN_ERROREN)

/*! @brief Set the ERROREN field to a new value. */
#define BW_USB_INTEN_ERROREN(x, v) (BME_BFI8(HW_USB_INTEN_ADDR(x), ((uint8_t)(v) << BP_USB_INTEN_ERROREN), BP_USB_INTEN_ERROREN, 1))
/*@}*/

/*!
 * @name Register USB_INTEN, field SOFTOKEN[2] (RW)
 *
 * Values:
 * - 0 - Disbles the SOFTOK interrupt.
 * - 1 - Enables the SOFTOK interrupt.
 */
/*@{*/
#define BP_USB_INTEN_SOFTOKEN (2U)         /*!< Bit position for USB_INTEN_SOFTOKEN. */
#define BM_USB_INTEN_SOFTOKEN (0x04U)      /*!< Bit mask for USB_INTEN_SOFTOKEN. */
#define BS_USB_INTEN_SOFTOKEN (1U)         /*!< Bit field size in bits for USB_INTEN_SOFTOKEN. */

/*! @brief Read current value of the USB_INTEN_SOFTOKEN field. */
#define BR_USB_INTEN_SOFTOKEN(x) (BME_UBFX8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_SOFTOKEN, BS_USB_INTEN_SOFTOKEN))

/*! @brief Format value for bitfield USB_INTEN_SOFTOKEN. */
#define BF_USB_INTEN_SOFTOKEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_SOFTOKEN) & BM_USB_INTEN_SOFTOKEN)

/*! @brief Set the SOFTOKEN field to a new value. */
#define BW_USB_INTEN_SOFTOKEN(x, v) (BME_BFI8(HW_USB_INTEN_ADDR(x), ((uint8_t)(v) << BP_USB_INTEN_SOFTOKEN), BP_USB_INTEN_SOFTOKEN, 1))
/*@}*/

/*!
 * @name Register USB_INTEN, field TOKDNEEN[3] (RW)
 *
 * Values:
 * - 0 - Disables the TOKDNE interrupt.
 * - 1 - Enables the TOKDNE interrupt.
 */
/*@{*/
#define BP_USB_INTEN_TOKDNEEN (3U)         /*!< Bit position for USB_INTEN_TOKDNEEN. */
#define BM_USB_INTEN_TOKDNEEN (0x08U)      /*!< Bit mask for USB_INTEN_TOKDNEEN. */
#define BS_USB_INTEN_TOKDNEEN (1U)         /*!< Bit field size in bits for USB_INTEN_TOKDNEEN. */

/*! @brief Read current value of the USB_INTEN_TOKDNEEN field. */
#define BR_USB_INTEN_TOKDNEEN(x) (BME_UBFX8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_TOKDNEEN, BS_USB_INTEN_TOKDNEEN))

/*! @brief Format value for bitfield USB_INTEN_TOKDNEEN. */
#define BF_USB_INTEN_TOKDNEEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_TOKDNEEN) & BM_USB_INTEN_TOKDNEEN)

/*! @brief Set the TOKDNEEN field to a new value. */
#define BW_USB_INTEN_TOKDNEEN(x, v) (BME_BFI8(HW_USB_INTEN_ADDR(x), ((uint8_t)(v) << BP_USB_INTEN_TOKDNEEN), BP_USB_INTEN_TOKDNEEN, 1))
/*@}*/

/*!
 * @name Register USB_INTEN, field SLEEPEN[4] (RW)
 *
 * Values:
 * - 0 - Disables the SLEEP interrupt.
 * - 1 - Enables the SLEEP interrupt.
 */
/*@{*/
#define BP_USB_INTEN_SLEEPEN (4U)          /*!< Bit position for USB_INTEN_SLEEPEN. */
#define BM_USB_INTEN_SLEEPEN (0x10U)       /*!< Bit mask for USB_INTEN_SLEEPEN. */
#define BS_USB_INTEN_SLEEPEN (1U)          /*!< Bit field size in bits for USB_INTEN_SLEEPEN. */

/*! @brief Read current value of the USB_INTEN_SLEEPEN field. */
#define BR_USB_INTEN_SLEEPEN(x) (BME_UBFX8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_SLEEPEN, BS_USB_INTEN_SLEEPEN))

/*! @brief Format value for bitfield USB_INTEN_SLEEPEN. */
#define BF_USB_INTEN_SLEEPEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_SLEEPEN) & BM_USB_INTEN_SLEEPEN)

/*! @brief Set the SLEEPEN field to a new value. */
#define BW_USB_INTEN_SLEEPEN(x, v) (BME_BFI8(HW_USB_INTEN_ADDR(x), ((uint8_t)(v) << BP_USB_INTEN_SLEEPEN), BP_USB_INTEN_SLEEPEN, 1))
/*@}*/

/*!
 * @name Register USB_INTEN, field RESUMEEN[5] (RW)
 *
 * Values:
 * - 0 - Disables the RESUME interrupt.
 * - 1 - Enables the RESUME interrupt.
 */
/*@{*/
#define BP_USB_INTEN_RESUMEEN (5U)         /*!< Bit position for USB_INTEN_RESUMEEN. */
#define BM_USB_INTEN_RESUMEEN (0x20U)      /*!< Bit mask for USB_INTEN_RESUMEEN. */
#define BS_USB_INTEN_RESUMEEN (1U)         /*!< Bit field size in bits for USB_INTEN_RESUMEEN. */

/*! @brief Read current value of the USB_INTEN_RESUMEEN field. */
#define BR_USB_INTEN_RESUMEEN(x) (BME_UBFX8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_RESUMEEN, BS_USB_INTEN_RESUMEEN))

/*! @brief Format value for bitfield USB_INTEN_RESUMEEN. */
#define BF_USB_INTEN_RESUMEEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_RESUMEEN) & BM_USB_INTEN_RESUMEEN)

/*! @brief Set the RESUMEEN field to a new value. */
#define BW_USB_INTEN_RESUMEEN(x, v) (BME_BFI8(HW_USB_INTEN_ADDR(x), ((uint8_t)(v) << BP_USB_INTEN_RESUMEEN), BP_USB_INTEN_RESUMEEN, 1))
/*@}*/

/*!
 * @name Register USB_INTEN, field STALLEN[7] (RW)
 *
 * Values:
 * - 0 - Diasbles the STALL interrupt.
 * - 1 - Enables the STALL interrupt.
 */
/*@{*/
#define BP_USB_INTEN_STALLEN (7U)          /*!< Bit position for USB_INTEN_STALLEN. */
#define BM_USB_INTEN_STALLEN (0x80U)       /*!< Bit mask for USB_INTEN_STALLEN. */
#define BS_USB_INTEN_STALLEN (1U)          /*!< Bit field size in bits for USB_INTEN_STALLEN. */

/*! @brief Read current value of the USB_INTEN_STALLEN field. */
#define BR_USB_INTEN_STALLEN(x) (BME_UBFX8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_STALLEN, BS_USB_INTEN_STALLEN))

/*! @brief Format value for bitfield USB_INTEN_STALLEN. */
#define BF_USB_INTEN_STALLEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_STALLEN) & BM_USB_INTEN_STALLEN)

/*! @brief Set the STALLEN field to a new value. */
#define BW_USB_INTEN_STALLEN(x, v) (BME_BFI8(HW_USB_INTEN_ADDR(x), ((uint8_t)(v) << BP_USB_INTEN_STALLEN), BP_USB_INTEN_STALLEN, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_ERRSTAT - Error Interrupt Status register
 ******************************************************************************/

/*!
 * @brief HW_USB_ERRSTAT - Error Interrupt Status register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains enable bits for each of the error sources within the USB Module.
 * Each of these bits are qualified with their respective error enable bits. All
 * bits of this register are logically OR'd together and the result placed in the
 * ERROR bit of the ISTAT register. After an interrupt bit has been set it may only
 * be cleared by writing a one to the respective interrupt bit. Each bit is set
 * as soon as the error condition is detected. Therefore, the interrupt does not
 * typically correspond with the end of a token being processed. This register
 * contains the value of 0x00 after a reset.
 */
typedef union _hw_usb_errstat
{
    uint8_t U;
    struct _hw_usb_errstat_bitfields
    {
        uint8_t PIDERR : 1;            /*!< [0]  */
        uint8_t CRC5 : 1;              /*!< [1]  */
        uint8_t CRC16 : 1;             /*!< [2]  */
        uint8_t DFN8 : 1;              /*!< [3]  */
        uint8_t BTOERR : 1;            /*!< [4]  */
        uint8_t DMAERR : 1;            /*!< [5]  */
        uint8_t RESERVED0 : 1;         /*!< [6]  */
        uint8_t BTSERR : 1;            /*!< [7]  */
    } B;
} hw_usb_errstat_t;

/*!
 * @name Constants and macros for entire USB_ERRSTAT register
 */
/*@{*/
#define HW_USB_ERRSTAT_ADDR(x)   ((uint32_t)(x) + 0x88U)

#define HW_USB_ERRSTAT(x)        (*(__IO hw_usb_errstat_t *) HW_USB_ERRSTAT_ADDR(x))
#define HW_USB_ERRSTAT_RD(x)     (HW_USB_ERRSTAT(x).U)
#define HW_USB_ERRSTAT_WR(x, v)  (HW_USB_ERRSTAT(x).U = (v))
#define HW_USB_ERRSTAT_SET(x, v) (BME_OR8(HW_USB_ERRSTAT_ADDR(x), (uint8_t)(v)))
#define HW_USB_ERRSTAT_CLR(x, v) (BME_AND8(HW_USB_ERRSTAT_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_ERRSTAT_TOG(x, v) (BME_XOR8(HW_USB_ERRSTAT_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_ERRSTAT bitfields
 */

/*!
 * @name Register USB_ERRSTAT, field PIDERR[0] (W1C)
 *
 * This bit is set when the PID check field fails.
 */
/*@{*/
#define BP_USB_ERRSTAT_PIDERR (0U)         /*!< Bit position for USB_ERRSTAT_PIDERR. */
#define BM_USB_ERRSTAT_PIDERR (0x01U)      /*!< Bit mask for USB_ERRSTAT_PIDERR. */
#define BS_USB_ERRSTAT_PIDERR (1U)         /*!< Bit field size in bits for USB_ERRSTAT_PIDERR. */

/*! @brief Read current value of the USB_ERRSTAT_PIDERR field. */
#define BR_USB_ERRSTAT_PIDERR(x) (BME_UBFX8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_PIDERR, BS_USB_ERRSTAT_PIDERR))

/*! @brief Format value for bitfield USB_ERRSTAT_PIDERR. */
#define BF_USB_ERRSTAT_PIDERR(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_PIDERR) & BM_USB_ERRSTAT_PIDERR)

/*! @brief Set the PIDERR field to a new value. */
#define BW_USB_ERRSTAT_PIDERR(x, v) (BME_BFI8(HW_USB_ERRSTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ERRSTAT_PIDERR), BP_USB_ERRSTAT_PIDERR, 1))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field CRC5[1] (W1C)
 *
 * This error interrupt has two functions. When the USB Module is operating in
 * peripheral mode (HOSTMODEEN=0), this interrupt detects CRC5 errors in the token
 * packets generated by the host. If set the token packet was rejected due to a
 * CRC5 error.
 */
/*@{*/
#define BP_USB_ERRSTAT_CRC5  (1U)          /*!< Bit position for USB_ERRSTAT_CRC5. */
#define BM_USB_ERRSTAT_CRC5  (0x02U)       /*!< Bit mask for USB_ERRSTAT_CRC5. */
#define BS_USB_ERRSTAT_CRC5  (1U)          /*!< Bit field size in bits for USB_ERRSTAT_CRC5. */

/*! @brief Read current value of the USB_ERRSTAT_CRC5 field. */
#define BR_USB_ERRSTAT_CRC5(x) (BME_UBFX8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_CRC5, BS_USB_ERRSTAT_CRC5))

/*! @brief Format value for bitfield USB_ERRSTAT_CRC5. */
#define BF_USB_ERRSTAT_CRC5(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_CRC5) & BM_USB_ERRSTAT_CRC5)

/*! @brief Set the CRC5 field to a new value. */
#define BW_USB_ERRSTAT_CRC5(x, v) (BME_BFI8(HW_USB_ERRSTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ERRSTAT_CRC5), BP_USB_ERRSTAT_CRC5, 1))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field CRC16[2] (W1C)
 *
 * This bit is set when a data packet is rejected due to a CRC16 error.
 */
/*@{*/
#define BP_USB_ERRSTAT_CRC16 (2U)          /*!< Bit position for USB_ERRSTAT_CRC16. */
#define BM_USB_ERRSTAT_CRC16 (0x04U)       /*!< Bit mask for USB_ERRSTAT_CRC16. */
#define BS_USB_ERRSTAT_CRC16 (1U)          /*!< Bit field size in bits for USB_ERRSTAT_CRC16. */

/*! @brief Read current value of the USB_ERRSTAT_CRC16 field. */
#define BR_USB_ERRSTAT_CRC16(x) (BME_UBFX8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_CRC16, BS_USB_ERRSTAT_CRC16))

/*! @brief Format value for bitfield USB_ERRSTAT_CRC16. */
#define BF_USB_ERRSTAT_CRC16(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_CRC16) & BM_USB_ERRSTAT_CRC16)

/*! @brief Set the CRC16 field to a new value. */
#define BW_USB_ERRSTAT_CRC16(x, v) (BME_BFI8(HW_USB_ERRSTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ERRSTAT_CRC16), BP_USB_ERRSTAT_CRC16, 1))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field DFN8[3] (W1C)
 *
 * This bit is set if the data field received was not 8 bits in length. USB
 * Specification 1.0 requires that data fields be an integral number of bytes. If the
 * data field was not an integral number of bytes, this bit is set.
 */
/*@{*/
#define BP_USB_ERRSTAT_DFN8  (3U)          /*!< Bit position for USB_ERRSTAT_DFN8. */
#define BM_USB_ERRSTAT_DFN8  (0x08U)       /*!< Bit mask for USB_ERRSTAT_DFN8. */
#define BS_USB_ERRSTAT_DFN8  (1U)          /*!< Bit field size in bits for USB_ERRSTAT_DFN8. */

/*! @brief Read current value of the USB_ERRSTAT_DFN8 field. */
#define BR_USB_ERRSTAT_DFN8(x) (BME_UBFX8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_DFN8, BS_USB_ERRSTAT_DFN8))

/*! @brief Format value for bitfield USB_ERRSTAT_DFN8. */
#define BF_USB_ERRSTAT_DFN8(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_DFN8) & BM_USB_ERRSTAT_DFN8)

/*! @brief Set the DFN8 field to a new value. */
#define BW_USB_ERRSTAT_DFN8(x, v) (BME_BFI8(HW_USB_ERRSTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ERRSTAT_DFN8), BP_USB_ERRSTAT_DFN8, 1))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field BTOERR[4] (W1C)
 *
 * This bit is set when a bus turnaround timeout error occurs. The USB module
 * contains a bus turnaround timer that keeps track of the amount of time elapsed
 * between the token and data phases of a SETUP or OUT TOKEN or the data and
 * handshake phases of a IN TOKEN. If more than 16 bit times are counted from the
 * previous EOP before a transition from IDLE, a bus turnaround timeout error occurs.
 */
/*@{*/
#define BP_USB_ERRSTAT_BTOERR (4U)         /*!< Bit position for USB_ERRSTAT_BTOERR. */
#define BM_USB_ERRSTAT_BTOERR (0x10U)      /*!< Bit mask for USB_ERRSTAT_BTOERR. */
#define BS_USB_ERRSTAT_BTOERR (1U)         /*!< Bit field size in bits for USB_ERRSTAT_BTOERR. */

/*! @brief Read current value of the USB_ERRSTAT_BTOERR field. */
#define BR_USB_ERRSTAT_BTOERR(x) (BME_UBFX8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_BTOERR, BS_USB_ERRSTAT_BTOERR))

/*! @brief Format value for bitfield USB_ERRSTAT_BTOERR. */
#define BF_USB_ERRSTAT_BTOERR(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_BTOERR) & BM_USB_ERRSTAT_BTOERR)

/*! @brief Set the BTOERR field to a new value. */
#define BW_USB_ERRSTAT_BTOERR(x, v) (BME_BFI8(HW_USB_ERRSTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ERRSTAT_BTOERR), BP_USB_ERRSTAT_BTOERR, 1))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field DMAERR[5] (W1C)
 *
 * This bit is set if the USB Module has requested a DMA access to read a new
 * BDT but has not been given the bus before it needs to receive or transmit data.
 * If processing a TX transfer this would cause a transmit data underflow
 * condition. If processing a RX transfer this would cause a receive data overflow
 * condition. This interrupt is useful when developing device arbitration hardware for
 * the microprocessor and the USB module to minimize bus request and bus grant
 * latency. This bit is also set if a data packet to or from the host is larger
 * than the buffer size allocated in the BDT. In this case the data packet is
 * truncated as it is put in buffer memory.
 */
/*@{*/
#define BP_USB_ERRSTAT_DMAERR (5U)         /*!< Bit position for USB_ERRSTAT_DMAERR. */
#define BM_USB_ERRSTAT_DMAERR (0x20U)      /*!< Bit mask for USB_ERRSTAT_DMAERR. */
#define BS_USB_ERRSTAT_DMAERR (1U)         /*!< Bit field size in bits for USB_ERRSTAT_DMAERR. */

/*! @brief Read current value of the USB_ERRSTAT_DMAERR field. */
#define BR_USB_ERRSTAT_DMAERR(x) (BME_UBFX8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_DMAERR, BS_USB_ERRSTAT_DMAERR))

/*! @brief Format value for bitfield USB_ERRSTAT_DMAERR. */
#define BF_USB_ERRSTAT_DMAERR(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_DMAERR) & BM_USB_ERRSTAT_DMAERR)

/*! @brief Set the DMAERR field to a new value. */
#define BW_USB_ERRSTAT_DMAERR(x, v) (BME_BFI8(HW_USB_ERRSTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ERRSTAT_DMAERR), BP_USB_ERRSTAT_DMAERR, 1))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field BTSERR[7] (W1C)
 *
 * This bit is set when a bit stuff error is detected. If set, the corresponding
 * packet is rejected due to the error.
 */
/*@{*/
#define BP_USB_ERRSTAT_BTSERR (7U)         /*!< Bit position for USB_ERRSTAT_BTSERR. */
#define BM_USB_ERRSTAT_BTSERR (0x80U)      /*!< Bit mask for USB_ERRSTAT_BTSERR. */
#define BS_USB_ERRSTAT_BTSERR (1U)         /*!< Bit field size in bits for USB_ERRSTAT_BTSERR. */

/*! @brief Read current value of the USB_ERRSTAT_BTSERR field. */
#define BR_USB_ERRSTAT_BTSERR(x) (BME_UBFX8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_BTSERR, BS_USB_ERRSTAT_BTSERR))

/*! @brief Format value for bitfield USB_ERRSTAT_BTSERR. */
#define BF_USB_ERRSTAT_BTSERR(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_BTSERR) & BM_USB_ERRSTAT_BTSERR)

/*! @brief Set the BTSERR field to a new value. */
#define BW_USB_ERRSTAT_BTSERR(x, v) (BME_BFI8(HW_USB_ERRSTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ERRSTAT_BTSERR), BP_USB_ERRSTAT_BTSERR, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_ERREN - Error Interrupt Enable register
 ******************************************************************************/

/*!
 * @brief HW_USB_ERREN - Error Interrupt Enable register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains enable bits for each of the error interrupt sources within the USB
 * module. Setting any of these bits enables the respective interrupt source in
 * ERRSTAT. Each bit is set as soon as the error condition is detected. Therefore,
 * the interrupt does not typically correspond with the end of a token being
 * processed. This register contains the value of 0x00 after a reset.
 */
typedef union _hw_usb_erren
{
    uint8_t U;
    struct _hw_usb_erren_bitfields
    {
        uint8_t PIDERREN : 1;          /*!< [0] PIDERR Interrupt Enable */
        uint8_t CRC5EOFEN : 1;         /*!< [1] CRC5/EOF Interrupt Enable */
        uint8_t CRC16EN : 1;           /*!< [2] CRC16 Interrupt Enable */
        uint8_t DFN8EN : 1;            /*!< [3] DFN8 Interrupt Enable */
        uint8_t BTOERREN : 1;          /*!< [4] BTOERR Interrupt Enable */
        uint8_t DMAERREN : 1;          /*!< [5] DMAERR Interrupt Enable */
        uint8_t RESERVED0 : 1;         /*!< [6]  */
        uint8_t BTSERREN : 1;          /*!< [7] BTSERR Interrupt Enable */
    } B;
} hw_usb_erren_t;

/*!
 * @name Constants and macros for entire USB_ERREN register
 */
/*@{*/
#define HW_USB_ERREN_ADDR(x)     ((uint32_t)(x) + 0x8CU)

#define HW_USB_ERREN(x)          (*(__IO hw_usb_erren_t *) HW_USB_ERREN_ADDR(x))
#define HW_USB_ERREN_RD(x)       (HW_USB_ERREN(x).U)
#define HW_USB_ERREN_WR(x, v)    (HW_USB_ERREN(x).U = (v))
#define HW_USB_ERREN_SET(x, v)   (BME_OR8(HW_USB_ERREN_ADDR(x), (uint8_t)(v)))
#define HW_USB_ERREN_CLR(x, v)   (BME_AND8(HW_USB_ERREN_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_ERREN_TOG(x, v)   (BME_XOR8(HW_USB_ERREN_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_ERREN bitfields
 */

/*!
 * @name Register USB_ERREN, field PIDERREN[0] (RW)
 *
 * Values:
 * - 0 - Disables the PIDERR interrupt.
 * - 1 - Enters the PIDERR interrupt.
 */
/*@{*/
#define BP_USB_ERREN_PIDERREN (0U)         /*!< Bit position for USB_ERREN_PIDERREN. */
#define BM_USB_ERREN_PIDERREN (0x01U)      /*!< Bit mask for USB_ERREN_PIDERREN. */
#define BS_USB_ERREN_PIDERREN (1U)         /*!< Bit field size in bits for USB_ERREN_PIDERREN. */

/*! @brief Read current value of the USB_ERREN_PIDERREN field. */
#define BR_USB_ERREN_PIDERREN(x) (BME_UBFX8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_PIDERREN, BS_USB_ERREN_PIDERREN))

/*! @brief Format value for bitfield USB_ERREN_PIDERREN. */
#define BF_USB_ERREN_PIDERREN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_PIDERREN) & BM_USB_ERREN_PIDERREN)

/*! @brief Set the PIDERREN field to a new value. */
#define BW_USB_ERREN_PIDERREN(x, v) (BME_BFI8(HW_USB_ERREN_ADDR(x), ((uint8_t)(v) << BP_USB_ERREN_PIDERREN), BP_USB_ERREN_PIDERREN, 1))
/*@}*/

/*!
 * @name Register USB_ERREN, field CRC5EOFEN[1] (RW)
 *
 * Values:
 * - 0 - Disables the CRC5/EOF interrupt.
 * - 1 - Enables the CRC5/EOF interrupt.
 */
/*@{*/
#define BP_USB_ERREN_CRC5EOFEN (1U)        /*!< Bit position for USB_ERREN_CRC5EOFEN. */
#define BM_USB_ERREN_CRC5EOFEN (0x02U)     /*!< Bit mask for USB_ERREN_CRC5EOFEN. */
#define BS_USB_ERREN_CRC5EOFEN (1U)        /*!< Bit field size in bits for USB_ERREN_CRC5EOFEN. */

/*! @brief Read current value of the USB_ERREN_CRC5EOFEN field. */
#define BR_USB_ERREN_CRC5EOFEN(x) (BME_UBFX8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_CRC5EOFEN, BS_USB_ERREN_CRC5EOFEN))

/*! @brief Format value for bitfield USB_ERREN_CRC5EOFEN. */
#define BF_USB_ERREN_CRC5EOFEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_CRC5EOFEN) & BM_USB_ERREN_CRC5EOFEN)

/*! @brief Set the CRC5EOFEN field to a new value. */
#define BW_USB_ERREN_CRC5EOFEN(x, v) (BME_BFI8(HW_USB_ERREN_ADDR(x), ((uint8_t)(v) << BP_USB_ERREN_CRC5EOFEN), BP_USB_ERREN_CRC5EOFEN, 1))
/*@}*/

/*!
 * @name Register USB_ERREN, field CRC16EN[2] (RW)
 *
 * Values:
 * - 0 - Disables the CRC16 interrupt.
 * - 1 - Enables the CRC16 interrupt.
 */
/*@{*/
#define BP_USB_ERREN_CRC16EN (2U)          /*!< Bit position for USB_ERREN_CRC16EN. */
#define BM_USB_ERREN_CRC16EN (0x04U)       /*!< Bit mask for USB_ERREN_CRC16EN. */
#define BS_USB_ERREN_CRC16EN (1U)          /*!< Bit field size in bits for USB_ERREN_CRC16EN. */

/*! @brief Read current value of the USB_ERREN_CRC16EN field. */
#define BR_USB_ERREN_CRC16EN(x) (BME_UBFX8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_CRC16EN, BS_USB_ERREN_CRC16EN))

/*! @brief Format value for bitfield USB_ERREN_CRC16EN. */
#define BF_USB_ERREN_CRC16EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_CRC16EN) & BM_USB_ERREN_CRC16EN)

/*! @brief Set the CRC16EN field to a new value. */
#define BW_USB_ERREN_CRC16EN(x, v) (BME_BFI8(HW_USB_ERREN_ADDR(x), ((uint8_t)(v) << BP_USB_ERREN_CRC16EN), BP_USB_ERREN_CRC16EN, 1))
/*@}*/

/*!
 * @name Register USB_ERREN, field DFN8EN[3] (RW)
 *
 * Values:
 * - 0 - Disables the DFN8 interrupt.
 * - 1 - Enables the DFN8 interrupt.
 */
/*@{*/
#define BP_USB_ERREN_DFN8EN  (3U)          /*!< Bit position for USB_ERREN_DFN8EN. */
#define BM_USB_ERREN_DFN8EN  (0x08U)       /*!< Bit mask for USB_ERREN_DFN8EN. */
#define BS_USB_ERREN_DFN8EN  (1U)          /*!< Bit field size in bits for USB_ERREN_DFN8EN. */

/*! @brief Read current value of the USB_ERREN_DFN8EN field. */
#define BR_USB_ERREN_DFN8EN(x) (BME_UBFX8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_DFN8EN, BS_USB_ERREN_DFN8EN))

/*! @brief Format value for bitfield USB_ERREN_DFN8EN. */
#define BF_USB_ERREN_DFN8EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_DFN8EN) & BM_USB_ERREN_DFN8EN)

/*! @brief Set the DFN8EN field to a new value. */
#define BW_USB_ERREN_DFN8EN(x, v) (BME_BFI8(HW_USB_ERREN_ADDR(x), ((uint8_t)(v) << BP_USB_ERREN_DFN8EN), BP_USB_ERREN_DFN8EN, 1))
/*@}*/

/*!
 * @name Register USB_ERREN, field BTOERREN[4] (RW)
 *
 * Values:
 * - 0 - Disables the BTOERR interrupt.
 * - 1 - Enables the BTOERR interrupt.
 */
/*@{*/
#define BP_USB_ERREN_BTOERREN (4U)         /*!< Bit position for USB_ERREN_BTOERREN. */
#define BM_USB_ERREN_BTOERREN (0x10U)      /*!< Bit mask for USB_ERREN_BTOERREN. */
#define BS_USB_ERREN_BTOERREN (1U)         /*!< Bit field size in bits for USB_ERREN_BTOERREN. */

/*! @brief Read current value of the USB_ERREN_BTOERREN field. */
#define BR_USB_ERREN_BTOERREN(x) (BME_UBFX8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_BTOERREN, BS_USB_ERREN_BTOERREN))

/*! @brief Format value for bitfield USB_ERREN_BTOERREN. */
#define BF_USB_ERREN_BTOERREN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_BTOERREN) & BM_USB_ERREN_BTOERREN)

/*! @brief Set the BTOERREN field to a new value. */
#define BW_USB_ERREN_BTOERREN(x, v) (BME_BFI8(HW_USB_ERREN_ADDR(x), ((uint8_t)(v) << BP_USB_ERREN_BTOERREN), BP_USB_ERREN_BTOERREN, 1))
/*@}*/

/*!
 * @name Register USB_ERREN, field DMAERREN[5] (RW)
 *
 * Values:
 * - 0 - Disables the DMAERR interrupt.
 * - 1 - Enables the DMAERR interrupt.
 */
/*@{*/
#define BP_USB_ERREN_DMAERREN (5U)         /*!< Bit position for USB_ERREN_DMAERREN. */
#define BM_USB_ERREN_DMAERREN (0x20U)      /*!< Bit mask for USB_ERREN_DMAERREN. */
#define BS_USB_ERREN_DMAERREN (1U)         /*!< Bit field size in bits for USB_ERREN_DMAERREN. */

/*! @brief Read current value of the USB_ERREN_DMAERREN field. */
#define BR_USB_ERREN_DMAERREN(x) (BME_UBFX8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_DMAERREN, BS_USB_ERREN_DMAERREN))

/*! @brief Format value for bitfield USB_ERREN_DMAERREN. */
#define BF_USB_ERREN_DMAERREN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_DMAERREN) & BM_USB_ERREN_DMAERREN)

/*! @brief Set the DMAERREN field to a new value. */
#define BW_USB_ERREN_DMAERREN(x, v) (BME_BFI8(HW_USB_ERREN_ADDR(x), ((uint8_t)(v) << BP_USB_ERREN_DMAERREN), BP_USB_ERREN_DMAERREN, 1))
/*@}*/

/*!
 * @name Register USB_ERREN, field BTSERREN[7] (RW)
 *
 * Values:
 * - 0 - Disables the BTSERR interrupt.
 * - 1 - Enables the BTSERR interrupt.
 */
/*@{*/
#define BP_USB_ERREN_BTSERREN (7U)         /*!< Bit position for USB_ERREN_BTSERREN. */
#define BM_USB_ERREN_BTSERREN (0x80U)      /*!< Bit mask for USB_ERREN_BTSERREN. */
#define BS_USB_ERREN_BTSERREN (1U)         /*!< Bit field size in bits for USB_ERREN_BTSERREN. */

/*! @brief Read current value of the USB_ERREN_BTSERREN field. */
#define BR_USB_ERREN_BTSERREN(x) (BME_UBFX8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_BTSERREN, BS_USB_ERREN_BTSERREN))

/*! @brief Format value for bitfield USB_ERREN_BTSERREN. */
#define BF_USB_ERREN_BTSERREN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_BTSERREN) & BM_USB_ERREN_BTSERREN)

/*! @brief Set the BTSERREN field to a new value. */
#define BW_USB_ERREN_BTSERREN(x, v) (BME_BFI8(HW_USB_ERREN_ADDR(x), ((uint8_t)(v) << BP_USB_ERREN_BTSERREN), BP_USB_ERREN_BTSERREN, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_STAT - Status register
 ******************************************************************************/

/*!
 * @brief HW_USB_STAT - Status register (RO)
 *
 * Reset value: 0x00U
 *
 * Reports the transaction status within the USB module. When the processor's
 * interrupt controller has received a TOKDNE, interrupt the Status Register must
 * be read to determine the status of the previous endpoint communication. The
 * data in the status register is valid when TOKDNE interrupt is asserted. The
 * Status register is actually a read window into a status FIFO maintained by the USB
 * module. When the USB module uses a BD, it updates the Status register. If
 * another USB transaction is performed before the TOKDNE interrupt is serviced, the
 * USB module stores the status of the next transaction in the STAT FIFO. Thus
 * STAT is actually a four byte FIFO that allows the processor core to process one
 * transaction while the SIE is processing the next transaction. Clearing the
 * TOKDNE bit in the ISTAT register causes the SIE to update STAT with the contents
 * of the next STAT value. If the data in the STAT holding register is valid, the
 * SIE immediately reasserts to TOKDNE interrupt.
 */
typedef union _hw_usb_stat
{
    uint8_t U;
    struct _hw_usb_stat_bitfields
    {
        uint8_t RESERVED0 : 2;         /*!< [1:0]  */
        uint8_t ODD : 1;               /*!< [2]  */
        uint8_t TX : 1;                /*!< [3] Transmit Indicator */
        uint8_t ENDP : 4;              /*!< [7:4]  */
    } B;
} hw_usb_stat_t;

/*!
 * @name Constants and macros for entire USB_STAT register
 */
/*@{*/
#define HW_USB_STAT_ADDR(x)      ((uint32_t)(x) + 0x90U)

#define HW_USB_STAT(x)           (*(__I hw_usb_stat_t *) HW_USB_STAT_ADDR(x))
#define HW_USB_STAT_RD(x)        (HW_USB_STAT(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_STAT bitfields
 */

/*!
 * @name Register USB_STAT, field ODD[2] (RO)
 *
 * This bit is set if the last buffer descriptor updated was in the odd bank of
 * the BDT.
 */
/*@{*/
#define BP_USB_STAT_ODD      (2U)          /*!< Bit position for USB_STAT_ODD. */
#define BM_USB_STAT_ODD      (0x04U)       /*!< Bit mask for USB_STAT_ODD. */
#define BS_USB_STAT_ODD      (1U)          /*!< Bit field size in bits for USB_STAT_ODD. */

/*! @brief Read current value of the USB_STAT_ODD field. */
#define BR_USB_STAT_ODD(x)   (BME_UBFX8(HW_USB_STAT_ADDR(x), BP_USB_STAT_ODD, BS_USB_STAT_ODD))
/*@}*/

/*!
 * @name Register USB_STAT, field TX[3] (RO)
 *
 * Values:
 * - 0 - The most recent transaction was a receive operation.
 * - 1 - The most recent transaction was a transmit operation.
 */
/*@{*/
#define BP_USB_STAT_TX       (3U)          /*!< Bit position for USB_STAT_TX. */
#define BM_USB_STAT_TX       (0x08U)       /*!< Bit mask for USB_STAT_TX. */
#define BS_USB_STAT_TX       (1U)          /*!< Bit field size in bits for USB_STAT_TX. */

/*! @brief Read current value of the USB_STAT_TX field. */
#define BR_USB_STAT_TX(x)    (BME_UBFX8(HW_USB_STAT_ADDR(x), BP_USB_STAT_TX, BS_USB_STAT_TX))
/*@}*/

/*!
 * @name Register USB_STAT, field ENDP[7:4] (RO)
 *
 * This four-bit field encodes the endpoint address that received or transmitted
 * the previous token. This allows the processor core to determine the BDT entry
 * that was updated by the last USB transaction.
 */
/*@{*/
#define BP_USB_STAT_ENDP     (4U)          /*!< Bit position for USB_STAT_ENDP. */
#define BM_USB_STAT_ENDP     (0xF0U)       /*!< Bit mask for USB_STAT_ENDP. */
#define BS_USB_STAT_ENDP     (4U)          /*!< Bit field size in bits for USB_STAT_ENDP. */

/*! @brief Read current value of the USB_STAT_ENDP field. */
#define BR_USB_STAT_ENDP(x)  (BME_UBFX8(HW_USB_STAT_ADDR(x), BP_USB_STAT_ENDP, BS_USB_STAT_ENDP))
/*@}*/

/*******************************************************************************
 * HW_USB_CTL - Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_CTL - Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Provides various control and configuration information for the USB module.
 */
typedef union _hw_usb_ctl
{
    uint8_t U;
    struct _hw_usb_ctl_bitfields
    {
        uint8_t USBENSOFEN : 1;        /*!< [0] USB Enable */
        uint8_t ODDRST : 1;            /*!< [1]  */
        uint8_t RESERVED0 : 3;         /*!< [4:2]  */
        uint8_t TXSUSPENDTOKENBUSY : 1; /*!< [5]  */
        uint8_t SE0 : 1;               /*!< [6] Live USB Single Ended Zero signal */
        uint8_t JSTATE : 1;            /*!< [7] Live USB differential receiver JSTATE
                                        * signal */
    } B;
} hw_usb_ctl_t;

/*!
 * @name Constants and macros for entire USB_CTL register
 */
/*@{*/
#define HW_USB_CTL_ADDR(x)       ((uint32_t)(x) + 0x94U)

#define HW_USB_CTL(x)            (*(__IO hw_usb_ctl_t *) HW_USB_CTL_ADDR(x))
#define HW_USB_CTL_RD(x)         (HW_USB_CTL(x).U)
#define HW_USB_CTL_WR(x, v)      (HW_USB_CTL(x).U = (v))
#define HW_USB_CTL_SET(x, v)     (BME_OR8(HW_USB_CTL_ADDR(x), (uint8_t)(v)))
#define HW_USB_CTL_CLR(x, v)     (BME_AND8(HW_USB_CTL_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_CTL_TOG(x, v)     (BME_XOR8(HW_USB_CTL_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_CTL bitfields
 */

/*!
 * @name Register USB_CTL, field USBENSOFEN[0] (RW)
 *
 * Setting this bit enables the USB-FS to operate; clearing it disables the
 * USB-FS. Setting the bit causes the SIE to reset all of its ODD bits to the BDTs.
 * Therefore, setting this bit resets much of the logic in the SIE.
 *
 * Values:
 * - 0 - Disables the USB Module.
 * - 1 - Enables the USB Module.
 */
/*@{*/
#define BP_USB_CTL_USBENSOFEN (0U)         /*!< Bit position for USB_CTL_USBENSOFEN. */
#define BM_USB_CTL_USBENSOFEN (0x01U)      /*!< Bit mask for USB_CTL_USBENSOFEN. */
#define BS_USB_CTL_USBENSOFEN (1U)         /*!< Bit field size in bits for USB_CTL_USBENSOFEN. */

/*! @brief Read current value of the USB_CTL_USBENSOFEN field. */
#define BR_USB_CTL_USBENSOFEN(x) (BME_UBFX8(HW_USB_CTL_ADDR(x), BP_USB_CTL_USBENSOFEN, BS_USB_CTL_USBENSOFEN))

/*! @brief Format value for bitfield USB_CTL_USBENSOFEN. */
#define BF_USB_CTL_USBENSOFEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CTL_USBENSOFEN) & BM_USB_CTL_USBENSOFEN)

/*! @brief Set the USBENSOFEN field to a new value. */
#define BW_USB_CTL_USBENSOFEN(x, v) (BME_BFI8(HW_USB_CTL_ADDR(x), ((uint8_t)(v) << BP_USB_CTL_USBENSOFEN), BP_USB_CTL_USBENSOFEN, 1))
/*@}*/

/*!
 * @name Register USB_CTL, field ODDRST[1] (RW)
 *
 * Setting this bit to 1 resets all the BDT ODD ping/pong fields to 0, which
 * then specifies the EVEN BDT bank.
 */
/*@{*/
#define BP_USB_CTL_ODDRST    (1U)          /*!< Bit position for USB_CTL_ODDRST. */
#define BM_USB_CTL_ODDRST    (0x02U)       /*!< Bit mask for USB_CTL_ODDRST. */
#define BS_USB_CTL_ODDRST    (1U)          /*!< Bit field size in bits for USB_CTL_ODDRST. */

/*! @brief Read current value of the USB_CTL_ODDRST field. */
#define BR_USB_CTL_ODDRST(x) (BME_UBFX8(HW_USB_CTL_ADDR(x), BP_USB_CTL_ODDRST, BS_USB_CTL_ODDRST))

/*! @brief Format value for bitfield USB_CTL_ODDRST. */
#define BF_USB_CTL_ODDRST(v) ((uint8_t)((uint8_t)(v) << BP_USB_CTL_ODDRST) & BM_USB_CTL_ODDRST)

/*! @brief Set the ODDRST field to a new value. */
#define BW_USB_CTL_ODDRST(x, v) (BME_BFI8(HW_USB_CTL_ADDR(x), ((uint8_t)(v) << BP_USB_CTL_ODDRST), BP_USB_CTL_ODDRST, 1))
/*@}*/

/*!
 * @name Register USB_CTL, field TXSUSPENDTOKENBUSY[5] (RW)
 *
 * In Target mode, TXD_SUSPEND is set when the SIE has disabled packet
 * transmission and reception. Clearing this bit allows the SIE to continue token
 * processing. This bit is set by the SIE when a SETUP Token is received allowing
 * software to dequeue any pending packet transactions in the BDT before resuming token
 * processing.
 */
/*@{*/
#define BP_USB_CTL_TXSUSPENDTOKENBUSY (5U) /*!< Bit position for USB_CTL_TXSUSPENDTOKENBUSY. */
#define BM_USB_CTL_TXSUSPENDTOKENBUSY (0x20U) /*!< Bit mask for USB_CTL_TXSUSPENDTOKENBUSY. */
#define BS_USB_CTL_TXSUSPENDTOKENBUSY (1U) /*!< Bit field size in bits for USB_CTL_TXSUSPENDTOKENBUSY. */

/*! @brief Read current value of the USB_CTL_TXSUSPENDTOKENBUSY field. */
#define BR_USB_CTL_TXSUSPENDTOKENBUSY(x) (BME_UBFX8(HW_USB_CTL_ADDR(x), BP_USB_CTL_TXSUSPENDTOKENBUSY, BS_USB_CTL_TXSUSPENDTOKENBUSY))

/*! @brief Format value for bitfield USB_CTL_TXSUSPENDTOKENBUSY. */
#define BF_USB_CTL_TXSUSPENDTOKENBUSY(v) ((uint8_t)((uint8_t)(v) << BP_USB_CTL_TXSUSPENDTOKENBUSY) & BM_USB_CTL_TXSUSPENDTOKENBUSY)

/*! @brief Set the TXSUSPENDTOKENBUSY field to a new value. */
#define BW_USB_CTL_TXSUSPENDTOKENBUSY(x, v) (BME_BFI8(HW_USB_CTL_ADDR(x), ((uint8_t)(v) << BP_USB_CTL_TXSUSPENDTOKENBUSY), BP_USB_CTL_TXSUSPENDTOKENBUSY, 1))
/*@}*/

/*!
 * @name Register USB_CTL, field SE0[6] (RW)
 */
/*@{*/
#define BP_USB_CTL_SE0       (6U)          /*!< Bit position for USB_CTL_SE0. */
#define BM_USB_CTL_SE0       (0x40U)       /*!< Bit mask for USB_CTL_SE0. */
#define BS_USB_CTL_SE0       (1U)          /*!< Bit field size in bits for USB_CTL_SE0. */

/*! @brief Read current value of the USB_CTL_SE0 field. */
#define BR_USB_CTL_SE0(x)    (BME_UBFX8(HW_USB_CTL_ADDR(x), BP_USB_CTL_SE0, BS_USB_CTL_SE0))

/*! @brief Format value for bitfield USB_CTL_SE0. */
#define BF_USB_CTL_SE0(v)    ((uint8_t)((uint8_t)(v) << BP_USB_CTL_SE0) & BM_USB_CTL_SE0)

/*! @brief Set the SE0 field to a new value. */
#define BW_USB_CTL_SE0(x, v) (BME_BFI8(HW_USB_CTL_ADDR(x), ((uint8_t)(v) << BP_USB_CTL_SE0), BP_USB_CTL_SE0, 1))
/*@}*/

/*!
 * @name Register USB_CTL, field JSTATE[7] (RW)
 *
 * The polarity of this signal is affected by the current state of LSEN .
 */
/*@{*/
#define BP_USB_CTL_JSTATE    (7U)          /*!< Bit position for USB_CTL_JSTATE. */
#define BM_USB_CTL_JSTATE    (0x80U)       /*!< Bit mask for USB_CTL_JSTATE. */
#define BS_USB_CTL_JSTATE    (1U)          /*!< Bit field size in bits for USB_CTL_JSTATE. */

/*! @brief Read current value of the USB_CTL_JSTATE field. */
#define BR_USB_CTL_JSTATE(x) (BME_UBFX8(HW_USB_CTL_ADDR(x), BP_USB_CTL_JSTATE, BS_USB_CTL_JSTATE))

/*! @brief Format value for bitfield USB_CTL_JSTATE. */
#define BF_USB_CTL_JSTATE(v) ((uint8_t)((uint8_t)(v) << BP_USB_CTL_JSTATE) & BM_USB_CTL_JSTATE)

/*! @brief Set the JSTATE field to a new value. */
#define BW_USB_CTL_JSTATE(x, v) (BME_BFI8(HW_USB_CTL_ADDR(x), ((uint8_t)(v) << BP_USB_CTL_JSTATE), BP_USB_CTL_JSTATE, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_ADDR - Address register
 ******************************************************************************/

/*!
 * @brief HW_USB_ADDR - Address register (RW)
 *
 * Reset value: 0x00U
 *
 * Holds the unique USB address that the USB module decodes when in Peripheral
 * mode (HOSTMODEEN=0). CTL[USBENSOFEN] must be 1. The Address register is reset
 * to 0x00 after the reset input becomes active or the USB module decodes a USB
 * reset signal. This action initializes the Address register to decode address
 * 0x00 as required by the USB specification.
 */
typedef union _hw_usb_addr
{
    uint8_t U;
    struct _hw_usb_addr_bitfields
    {
        uint8_t ADDR : 7;              /*!< [6:0] USB Address */
        uint8_t RESERVED0 : 1;         /*!< [7]  */
    } B;
} hw_usb_addr_t;

/*!
 * @name Constants and macros for entire USB_ADDR register
 */
/*@{*/
#define HW_USB_ADDR_ADDR(x)      ((uint32_t)(x) + 0x98U)

#define HW_USB_ADDR(x)           (*(__IO hw_usb_addr_t *) HW_USB_ADDR_ADDR(x))
#define HW_USB_ADDR_RD(x)        (HW_USB_ADDR(x).U)
#define HW_USB_ADDR_WR(x, v)     (HW_USB_ADDR(x).U = (v))
#define HW_USB_ADDR_SET(x, v)    (BME_OR8(HW_USB_ADDR_ADDR(x), (uint8_t)(v)))
#define HW_USB_ADDR_CLR(x, v)    (BME_AND8(HW_USB_ADDR_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_ADDR_TOG(x, v)    (BME_XOR8(HW_USB_ADDR_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_ADDR bitfields
 */

/*!
 * @name Register USB_ADDR, field ADDR[6:0] (RW)
 *
 * Defines the USB address that the USB module decodes in peripheral mode.
 */
/*@{*/
#define BP_USB_ADDR_ADDR     (0U)          /*!< Bit position for USB_ADDR_ADDR. */
#define BM_USB_ADDR_ADDR     (0x7FU)       /*!< Bit mask for USB_ADDR_ADDR. */
#define BS_USB_ADDR_ADDR     (7U)          /*!< Bit field size in bits for USB_ADDR_ADDR. */

/*! @brief Read current value of the USB_ADDR_ADDR field. */
#define BR_USB_ADDR_ADDR(x)  (BME_UBFX8(HW_USB_ADDR_ADDR(x), BP_USB_ADDR_ADDR, BS_USB_ADDR_ADDR))

/*! @brief Format value for bitfield USB_ADDR_ADDR. */
#define BF_USB_ADDR_ADDR(v)  ((uint8_t)((uint8_t)(v) << BP_USB_ADDR_ADDR) & BM_USB_ADDR_ADDR)

/*! @brief Set the ADDR field to a new value. */
#define BW_USB_ADDR_ADDR(x, v) (BME_BFI8(HW_USB_ADDR_ADDR(x), ((uint8_t)(v) << BP_USB_ADDR_ADDR), BP_USB_ADDR_ADDR, 7))
/*@}*/

/*******************************************************************************
 * HW_USB_BDTPAGE1 - BDT Page register 1
 ******************************************************************************/

/*!
 * @brief HW_USB_BDTPAGE1 - BDT Page register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * Provides address bits 15 through 9 of the base address where the current
 * Buffer Descriptor Table (BDT) resides in system memory. See Buffer Descriptor
 * Table. The 32-bit BDT Base Address is always aligned on 512-byte boundaries, so
 * bits 8 through 0 of the base address are always zero.
 */
typedef union _hw_usb_bdtpage1
{
    uint8_t U;
    struct _hw_usb_bdtpage1_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t BDTBA : 7;             /*!< [7:1]  */
    } B;
} hw_usb_bdtpage1_t;

/*!
 * @name Constants and macros for entire USB_BDTPAGE1 register
 */
/*@{*/
#define HW_USB_BDTPAGE1_ADDR(x)  ((uint32_t)(x) + 0x9CU)

#define HW_USB_BDTPAGE1(x)       (*(__IO hw_usb_bdtpage1_t *) HW_USB_BDTPAGE1_ADDR(x))
#define HW_USB_BDTPAGE1_RD(x)    (HW_USB_BDTPAGE1(x).U)
#define HW_USB_BDTPAGE1_WR(x, v) (HW_USB_BDTPAGE1(x).U = (v))
#define HW_USB_BDTPAGE1_SET(x, v) (BME_OR8(HW_USB_BDTPAGE1_ADDR(x), (uint8_t)(v)))
#define HW_USB_BDTPAGE1_CLR(x, v) (BME_AND8(HW_USB_BDTPAGE1_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_BDTPAGE1_TOG(x, v) (BME_XOR8(HW_USB_BDTPAGE1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_BDTPAGE1 bitfields
 */

/*!
 * @name Register USB_BDTPAGE1, field BDTBA[7:1] (RW)
 *
 * Provides address bits 15 through 9 of the BDT base address.
 */
/*@{*/
#define BP_USB_BDTPAGE1_BDTBA (1U)         /*!< Bit position for USB_BDTPAGE1_BDTBA. */
#define BM_USB_BDTPAGE1_BDTBA (0xFEU)      /*!< Bit mask for USB_BDTPAGE1_BDTBA. */
#define BS_USB_BDTPAGE1_BDTBA (7U)         /*!< Bit field size in bits for USB_BDTPAGE1_BDTBA. */

/*! @brief Read current value of the USB_BDTPAGE1_BDTBA field. */
#define BR_USB_BDTPAGE1_BDTBA(x) (BME_UBFX8(HW_USB_BDTPAGE1_ADDR(x), BP_USB_BDTPAGE1_BDTBA, BS_USB_BDTPAGE1_BDTBA))

/*! @brief Format value for bitfield USB_BDTPAGE1_BDTBA. */
#define BF_USB_BDTPAGE1_BDTBA(v) ((uint8_t)((uint8_t)(v) << BP_USB_BDTPAGE1_BDTBA) & BM_USB_BDTPAGE1_BDTBA)

/*! @brief Set the BDTBA field to a new value. */
#define BW_USB_BDTPAGE1_BDTBA(x, v) (BME_BFI8(HW_USB_BDTPAGE1_ADDR(x), ((uint8_t)(v) << BP_USB_BDTPAGE1_BDTBA), BP_USB_BDTPAGE1_BDTBA, 7))
/*@}*/

/*******************************************************************************
 * HW_USB_FRMNUML - Frame Number register Low
 ******************************************************************************/

/*!
 * @brief HW_USB_FRMNUML - Frame Number register Low (RW)
 *
 * Reset value: 0x00U
 *
 * The Frame Number registers (low and high) contain the 11-bit frame number.
 * These registers are updated with the current frame number whenever a SOF TOKEN
 * is received.
 */
typedef union _hw_usb_frmnuml
{
    uint8_t U;
    struct _hw_usb_frmnuml_bitfields
    {
        uint8_t FRM : 8;               /*!< [7:0]  */
    } B;
} hw_usb_frmnuml_t;

/*!
 * @name Constants and macros for entire USB_FRMNUML register
 */
/*@{*/
#define HW_USB_FRMNUML_ADDR(x)   ((uint32_t)(x) + 0xA0U)

#define HW_USB_FRMNUML(x)        (*(__IO hw_usb_frmnuml_t *) HW_USB_FRMNUML_ADDR(x))
#define HW_USB_FRMNUML_RD(x)     (HW_USB_FRMNUML(x).U)
#define HW_USB_FRMNUML_WR(x, v)  (HW_USB_FRMNUML(x).U = (v))
#define HW_USB_FRMNUML_SET(x, v) (BME_OR8(HW_USB_FRMNUML_ADDR(x), (uint8_t)(v)))
#define HW_USB_FRMNUML_CLR(x, v) (BME_AND8(HW_USB_FRMNUML_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_FRMNUML_TOG(x, v) (BME_XOR8(HW_USB_FRMNUML_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_FRMNUML bitfields
 */

/*!
 * @name Register USB_FRMNUML, field FRM[7:0] (RW)
 *
 * This 8-bit field and the 3-bit field in the Frame Number Register High are
 * used to compute the address where the current Buffer Descriptor Table (BDT)
 * resides in system memory.
 */
/*@{*/
#define BP_USB_FRMNUML_FRM   (0U)          /*!< Bit position for USB_FRMNUML_FRM. */
#define BM_USB_FRMNUML_FRM   (0xFFU)       /*!< Bit mask for USB_FRMNUML_FRM. */
#define BS_USB_FRMNUML_FRM   (8U)          /*!< Bit field size in bits for USB_FRMNUML_FRM. */

/*! @brief Read current value of the USB_FRMNUML_FRM field. */
#define BR_USB_FRMNUML_FRM(x) (HW_USB_FRMNUML(x).U)

/*! @brief Format value for bitfield USB_FRMNUML_FRM. */
#define BF_USB_FRMNUML_FRM(v) ((uint8_t)((uint8_t)(v) << BP_USB_FRMNUML_FRM) & BM_USB_FRMNUML_FRM)

/*! @brief Set the FRM field to a new value. */
#define BW_USB_FRMNUML_FRM(x, v) (HW_USB_FRMNUML_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_USB_FRMNUMH - Frame Number register High
 ******************************************************************************/

/*!
 * @brief HW_USB_FRMNUMH - Frame Number register High (RW)
 *
 * Reset value: 0x00U
 *
 * The Frame Number registers (low and high) contain the 11-bit frame number.
 * These registers are updated with the current frame number whenever a SOF TOKEN
 * is received.
 */
typedef union _hw_usb_frmnumh
{
    uint8_t U;
    struct _hw_usb_frmnumh_bitfields
    {
        uint8_t FRM : 3;               /*!< [2:0]  */
        uint8_t RESERVED0 : 5;         /*!< [7:3]  */
    } B;
} hw_usb_frmnumh_t;

/*!
 * @name Constants and macros for entire USB_FRMNUMH register
 */
/*@{*/
#define HW_USB_FRMNUMH_ADDR(x)   ((uint32_t)(x) + 0xA4U)

#define HW_USB_FRMNUMH(x)        (*(__IO hw_usb_frmnumh_t *) HW_USB_FRMNUMH_ADDR(x))
#define HW_USB_FRMNUMH_RD(x)     (HW_USB_FRMNUMH(x).U)
#define HW_USB_FRMNUMH_WR(x, v)  (HW_USB_FRMNUMH(x).U = (v))
#define HW_USB_FRMNUMH_SET(x, v) (BME_OR8(HW_USB_FRMNUMH_ADDR(x), (uint8_t)(v)))
#define HW_USB_FRMNUMH_CLR(x, v) (BME_AND8(HW_USB_FRMNUMH_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_FRMNUMH_TOG(x, v) (BME_XOR8(HW_USB_FRMNUMH_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_FRMNUMH bitfields
 */

/*!
 * @name Register USB_FRMNUMH, field FRM[2:0] (RW)
 *
 * This 3-bit field and the 8-bit field in the Frame Number Register Low are
 * used to compute the address where the current Buffer Descriptor Table (BDT)
 * resides in system memory.
 */
/*@{*/
#define BP_USB_FRMNUMH_FRM   (0U)          /*!< Bit position for USB_FRMNUMH_FRM. */
#define BM_USB_FRMNUMH_FRM   (0x07U)       /*!< Bit mask for USB_FRMNUMH_FRM. */
#define BS_USB_FRMNUMH_FRM   (3U)          /*!< Bit field size in bits for USB_FRMNUMH_FRM. */

/*! @brief Read current value of the USB_FRMNUMH_FRM field. */
#define BR_USB_FRMNUMH_FRM(x) (BME_UBFX8(HW_USB_FRMNUMH_ADDR(x), BP_USB_FRMNUMH_FRM, BS_USB_FRMNUMH_FRM))

/*! @brief Format value for bitfield USB_FRMNUMH_FRM. */
#define BF_USB_FRMNUMH_FRM(v) ((uint8_t)((uint8_t)(v) << BP_USB_FRMNUMH_FRM) & BM_USB_FRMNUMH_FRM)

/*! @brief Set the FRM field to a new value. */
#define BW_USB_FRMNUMH_FRM(x, v) (BME_BFI8(HW_USB_FRMNUMH_ADDR(x), ((uint8_t)(v) << BP_USB_FRMNUMH_FRM), BP_USB_FRMNUMH_FRM, 3))
/*@}*/

/*******************************************************************************
 * HW_USB_BDTPAGE2 - BDT Page Register 2
 ******************************************************************************/

/*!
 * @brief HW_USB_BDTPAGE2 - BDT Page Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * Contains an 8-bit value used to compute the address where the current Buffer
 * Descriptor Table (BDT) resides in system memory. See Buffer Descriptor Table.
 */
typedef union _hw_usb_bdtpage2
{
    uint8_t U;
    struct _hw_usb_bdtpage2_bitfields
    {
        uint8_t BDTBA : 8;             /*!< [7:0]  */
    } B;
} hw_usb_bdtpage2_t;

/*!
 * @name Constants and macros for entire USB_BDTPAGE2 register
 */
/*@{*/
#define HW_USB_BDTPAGE2_ADDR(x)  ((uint32_t)(x) + 0xB0U)

#define HW_USB_BDTPAGE2(x)       (*(__IO hw_usb_bdtpage2_t *) HW_USB_BDTPAGE2_ADDR(x))
#define HW_USB_BDTPAGE2_RD(x)    (HW_USB_BDTPAGE2(x).U)
#define HW_USB_BDTPAGE2_WR(x, v) (HW_USB_BDTPAGE2(x).U = (v))
#define HW_USB_BDTPAGE2_SET(x, v) (BME_OR8(HW_USB_BDTPAGE2_ADDR(x), (uint8_t)(v)))
#define HW_USB_BDTPAGE2_CLR(x, v) (BME_AND8(HW_USB_BDTPAGE2_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_BDTPAGE2_TOG(x, v) (BME_XOR8(HW_USB_BDTPAGE2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_BDTPAGE2 bitfields
 */

/*!
 * @name Register USB_BDTPAGE2, field BDTBA[7:0] (RW)
 *
 * Provides address bits 23 through 16 of the BDT base address that defines the
 * location of Buffer Descriptor Table resides in system memory.
 */
/*@{*/
#define BP_USB_BDTPAGE2_BDTBA (0U)         /*!< Bit position for USB_BDTPAGE2_BDTBA. */
#define BM_USB_BDTPAGE2_BDTBA (0xFFU)      /*!< Bit mask for USB_BDTPAGE2_BDTBA. */
#define BS_USB_BDTPAGE2_BDTBA (8U)         /*!< Bit field size in bits for USB_BDTPAGE2_BDTBA. */

/*! @brief Read current value of the USB_BDTPAGE2_BDTBA field. */
#define BR_USB_BDTPAGE2_BDTBA(x) (HW_USB_BDTPAGE2(x).U)

/*! @brief Format value for bitfield USB_BDTPAGE2_BDTBA. */
#define BF_USB_BDTPAGE2_BDTBA(v) ((uint8_t)((uint8_t)(v) << BP_USB_BDTPAGE2_BDTBA) & BM_USB_BDTPAGE2_BDTBA)

/*! @brief Set the BDTBA field to a new value. */
#define BW_USB_BDTPAGE2_BDTBA(x, v) (HW_USB_BDTPAGE2_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_USB_BDTPAGE3 - BDT Page Register 3
 ******************************************************************************/

/*!
 * @brief HW_USB_BDTPAGE3 - BDT Page Register 3 (RW)
 *
 * Reset value: 0x00U
 *
 * Contains an 8-bit value used to compute the address where the current Buffer
 * Descriptor Table (BDT) resides in system memory. See Buffer Descriptor Table.
 */
typedef union _hw_usb_bdtpage3
{
    uint8_t U;
    struct _hw_usb_bdtpage3_bitfields
    {
        uint8_t BDTBA : 8;             /*!< [7:0]  */
    } B;
} hw_usb_bdtpage3_t;

/*!
 * @name Constants and macros for entire USB_BDTPAGE3 register
 */
/*@{*/
#define HW_USB_BDTPAGE3_ADDR(x)  ((uint32_t)(x) + 0xB4U)

#define HW_USB_BDTPAGE3(x)       (*(__IO hw_usb_bdtpage3_t *) HW_USB_BDTPAGE3_ADDR(x))
#define HW_USB_BDTPAGE3_RD(x)    (HW_USB_BDTPAGE3(x).U)
#define HW_USB_BDTPAGE3_WR(x, v) (HW_USB_BDTPAGE3(x).U = (v))
#define HW_USB_BDTPAGE3_SET(x, v) (BME_OR8(HW_USB_BDTPAGE3_ADDR(x), (uint8_t)(v)))
#define HW_USB_BDTPAGE3_CLR(x, v) (BME_AND8(HW_USB_BDTPAGE3_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_BDTPAGE3_TOG(x, v) (BME_XOR8(HW_USB_BDTPAGE3_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_BDTPAGE3 bitfields
 */

/*!
 * @name Register USB_BDTPAGE3, field BDTBA[7:0] (RW)
 *
 * Provides address bits 31 through 24 of the BDT base address that defines the
 * location of Buffer Descriptor Table resides in system memory.
 */
/*@{*/
#define BP_USB_BDTPAGE3_BDTBA (0U)         /*!< Bit position for USB_BDTPAGE3_BDTBA. */
#define BM_USB_BDTPAGE3_BDTBA (0xFFU)      /*!< Bit mask for USB_BDTPAGE3_BDTBA. */
#define BS_USB_BDTPAGE3_BDTBA (8U)         /*!< Bit field size in bits for USB_BDTPAGE3_BDTBA. */

/*! @brief Read current value of the USB_BDTPAGE3_BDTBA field. */
#define BR_USB_BDTPAGE3_BDTBA(x) (HW_USB_BDTPAGE3(x).U)

/*! @brief Format value for bitfield USB_BDTPAGE3_BDTBA. */
#define BF_USB_BDTPAGE3_BDTBA(v) ((uint8_t)((uint8_t)(v) << BP_USB_BDTPAGE3_BDTBA) & BM_USB_BDTPAGE3_BDTBA)

/*! @brief Set the BDTBA field to a new value. */
#define BW_USB_BDTPAGE3_BDTBA(x, v) (HW_USB_BDTPAGE3_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_USB_ENDPTn - Endpoint Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_ENDPTn - Endpoint Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains the endpoint control bits for each of the 16 endpoints available
 * within the USB module for a decoded address. The format for these registers is
 * shown in the following figure. Endpoint 0 (ENDPT0) is associated with control
 * pipe 0, which is required for all USB functions. Therefore, after a USBRST
 * interrupt occurs the processor core should set ENDPT0 to contain 0x0D. The three
 * bits EPCTLDIS, EPRXEN, and EPTXEN define if an endpoint is enabled and define
 * the direction of the endpoint. The endpoint enable/direction control is defined
 * in the following table. Endpoint enable and direction control EPCTLDIS EPRXEN
 * EPTXEN Endpoint enable/direction control X 0 0 Disable endpoint X 0 1 Enable
 * endpoint for Tx transfers only X 1 0 Enable endpoint for Rx transfers only 1 1
 * 1 Enable endpoint for Rx and Tx transfers 0 1 1 Enable Endpoint for RX and TX
 * as well as control (SETUP) transfers.
 */
typedef union _hw_usb_endptn
{
    uint8_t U;
    struct _hw_usb_endptn_bitfields
    {
        uint8_t EPHSHK : 1;            /*!< [0]  */
        uint8_t EPSTALL : 1;           /*!< [1]  */
        uint8_t EPTXEN : 1;            /*!< [2]  */
        uint8_t EPRXEN : 1;            /*!< [3]  */
        uint8_t EPCTLDIS : 1;          /*!< [4]  */
        uint8_t RESERVED0 : 3;         /*!< [7:5]  */
    } B;
} hw_usb_endptn_t;

/*!
 * @name Constants and macros for entire USB_ENDPTn register
 */
/*@{*/
#define HW_USB_ENDPTn_COUNT (16U)

#define HW_USB_ENDPTn_ADDR(x, n) ((uint32_t)(x) + 0xC0U + (0x4U * (n)))

#define HW_USB_ENDPTn(x, n)      (*(__IO hw_usb_endptn_t *) HW_USB_ENDPTn_ADDR(x, n))
#define HW_USB_ENDPTn_RD(x, n)   (HW_USB_ENDPTn(x, n).U)
#define HW_USB_ENDPTn_WR(x, n, v) (HW_USB_ENDPTn(x, n).U = (v))
#define HW_USB_ENDPTn_SET(x, n, v) (BME_OR8(HW_USB_ENDPTn_ADDR(x, n), (uint8_t)(v)))
#define HW_USB_ENDPTn_CLR(x, n, v) (BME_AND8(HW_USB_ENDPTn_ADDR(x, n), (uint8_t)(~(v))))
#define HW_USB_ENDPTn_TOG(x, n, v) (BME_XOR8(HW_USB_ENDPTn_ADDR(x, n), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_ENDPTn bitfields
 */

/*!
 * @name Register USB_ENDPTn, field EPHSHK[0] (RW)
 *
 * When set this bit enables an endpoint to perform handshaking during a
 * transaction to this endpoint. This bit is generally 1 unless the endpoint is
 * Isochronous.
 */
/*@{*/
#define BP_USB_ENDPTn_EPHSHK (0U)          /*!< Bit position for USB_ENDPTn_EPHSHK. */
#define BM_USB_ENDPTn_EPHSHK (0x01U)       /*!< Bit mask for USB_ENDPTn_EPHSHK. */
#define BS_USB_ENDPTn_EPHSHK (1U)          /*!< Bit field size in bits for USB_ENDPTn_EPHSHK. */

/*! @brief Read current value of the USB_ENDPTn_EPHSHK field. */
#define BR_USB_ENDPTn_EPHSHK(x, n) (BME_UBFX8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPHSHK, BS_USB_ENDPTn_EPHSHK))

/*! @brief Format value for bitfield USB_ENDPTn_EPHSHK. */
#define BF_USB_ENDPTn_EPHSHK(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_EPHSHK) & BM_USB_ENDPTn_EPHSHK)

/*! @brief Set the EPHSHK field to a new value. */
#define BW_USB_ENDPTn_EPHSHK(x, n, v) (BME_BFI8(HW_USB_ENDPTn_ADDR(x, n), ((uint8_t)(v) << BP_USB_ENDPTn_EPHSHK), BP_USB_ENDPTn_EPHSHK, 1))
/*@}*/

/*!
 * @name Register USB_ENDPTn, field EPSTALL[1] (RW)
 *
 * When set this bit indicates that the endpoint is called. This bit has
 * priority over all other control bits in the EndPoint Enable Register, but it is only
 * valid if EPTXEN=1 or EPRXEN=1. Any access to this endpoint causes the USB
 * Module to return a STALL handshake. After an endpoint is stalled it requires
 * intervention from the Host Controller.
 */
/*@{*/
#define BP_USB_ENDPTn_EPSTALL (1U)         /*!< Bit position for USB_ENDPTn_EPSTALL. */
#define BM_USB_ENDPTn_EPSTALL (0x02U)      /*!< Bit mask for USB_ENDPTn_EPSTALL. */
#define BS_USB_ENDPTn_EPSTALL (1U)         /*!< Bit field size in bits for USB_ENDPTn_EPSTALL. */

/*! @brief Read current value of the USB_ENDPTn_EPSTALL field. */
#define BR_USB_ENDPTn_EPSTALL(x, n) (BME_UBFX8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPSTALL, BS_USB_ENDPTn_EPSTALL))

/*! @brief Format value for bitfield USB_ENDPTn_EPSTALL. */
#define BF_USB_ENDPTn_EPSTALL(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_EPSTALL) & BM_USB_ENDPTn_EPSTALL)

/*! @brief Set the EPSTALL field to a new value. */
#define BW_USB_ENDPTn_EPSTALL(x, n, v) (BME_BFI8(HW_USB_ENDPTn_ADDR(x, n), ((uint8_t)(v) << BP_USB_ENDPTn_EPSTALL), BP_USB_ENDPTn_EPSTALL, 1))
/*@}*/

/*!
 * @name Register USB_ENDPTn, field EPTXEN[2] (RW)
 *
 * This bit, when set, enables the endpoint for TX transfers. See #aal353jj
 */
/*@{*/
#define BP_USB_ENDPTn_EPTXEN (2U)          /*!< Bit position for USB_ENDPTn_EPTXEN. */
#define BM_USB_ENDPTn_EPTXEN (0x04U)       /*!< Bit mask for USB_ENDPTn_EPTXEN. */
#define BS_USB_ENDPTn_EPTXEN (1U)          /*!< Bit field size in bits for USB_ENDPTn_EPTXEN. */

/*! @brief Read current value of the USB_ENDPTn_EPTXEN field. */
#define BR_USB_ENDPTn_EPTXEN(x, n) (BME_UBFX8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPTXEN, BS_USB_ENDPTn_EPTXEN))

/*! @brief Format value for bitfield USB_ENDPTn_EPTXEN. */
#define BF_USB_ENDPTn_EPTXEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_EPTXEN) & BM_USB_ENDPTn_EPTXEN)

/*! @brief Set the EPTXEN field to a new value. */
#define BW_USB_ENDPTn_EPTXEN(x, n, v) (BME_BFI8(HW_USB_ENDPTn_ADDR(x, n), ((uint8_t)(v) << BP_USB_ENDPTn_EPTXEN), BP_USB_ENDPTn_EPTXEN, 1))
/*@}*/

/*!
 * @name Register USB_ENDPTn, field EPRXEN[3] (RW)
 *
 * This bit, when set, enables the endpoint for RX transfers. See #aal353jj
 */
/*@{*/
#define BP_USB_ENDPTn_EPRXEN (3U)          /*!< Bit position for USB_ENDPTn_EPRXEN. */
#define BM_USB_ENDPTn_EPRXEN (0x08U)       /*!< Bit mask for USB_ENDPTn_EPRXEN. */
#define BS_USB_ENDPTn_EPRXEN (1U)          /*!< Bit field size in bits for USB_ENDPTn_EPRXEN. */

/*! @brief Read current value of the USB_ENDPTn_EPRXEN field. */
#define BR_USB_ENDPTn_EPRXEN(x, n) (BME_UBFX8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPRXEN, BS_USB_ENDPTn_EPRXEN))

/*! @brief Format value for bitfield USB_ENDPTn_EPRXEN. */
#define BF_USB_ENDPTn_EPRXEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_EPRXEN) & BM_USB_ENDPTn_EPRXEN)

/*! @brief Set the EPRXEN field to a new value. */
#define BW_USB_ENDPTn_EPRXEN(x, n, v) (BME_BFI8(HW_USB_ENDPTn_ADDR(x, n), ((uint8_t)(v) << BP_USB_ENDPTn_EPRXEN), BP_USB_ENDPTn_EPRXEN, 1))
/*@}*/

/*!
 * @name Register USB_ENDPTn, field EPCTLDIS[4] (RW)
 *
 * This bit, when set, disables control (SETUP) transfers. When cleared, control
 * transfers are enabled. This applies if and only if the EPRXEN and EPTXEN bits
 * are also set. See #aal353jj
 */
/*@{*/
#define BP_USB_ENDPTn_EPCTLDIS (4U)        /*!< Bit position for USB_ENDPTn_EPCTLDIS. */
#define BM_USB_ENDPTn_EPCTLDIS (0x10U)     /*!< Bit mask for USB_ENDPTn_EPCTLDIS. */
#define BS_USB_ENDPTn_EPCTLDIS (1U)        /*!< Bit field size in bits for USB_ENDPTn_EPCTLDIS. */

/*! @brief Read current value of the USB_ENDPTn_EPCTLDIS field. */
#define BR_USB_ENDPTn_EPCTLDIS(x, n) (BME_UBFX8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPCTLDIS, BS_USB_ENDPTn_EPCTLDIS))

/*! @brief Format value for bitfield USB_ENDPTn_EPCTLDIS. */
#define BF_USB_ENDPTn_EPCTLDIS(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_EPCTLDIS) & BM_USB_ENDPTn_EPCTLDIS)

/*! @brief Set the EPCTLDIS field to a new value. */
#define BW_USB_ENDPTn_EPCTLDIS(x, n, v) (BME_BFI8(HW_USB_ENDPTn_ADDR(x, n), ((uint8_t)(v) << BP_USB_ENDPTn_EPCTLDIS), BP_USB_ENDPTn_EPCTLDIS, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_USBCTRL - USB Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_USBCTRL - USB Control register (RW)
 *
 * Reset value: 0xC0U
 */
typedef union _hw_usb_usbctrl
{
    uint8_t U;
    struct _hw_usb_usbctrl_bitfields
    {
        uint8_t RESERVED0 : 6;         /*!< [5:0]  */
        uint8_t PDE : 1;               /*!< [6]  */
        uint8_t SUSP : 1;              /*!< [7]  */
    } B;
} hw_usb_usbctrl_t;

/*!
 * @name Constants and macros for entire USB_USBCTRL register
 */
/*@{*/
#define HW_USB_USBCTRL_ADDR(x)   ((uint32_t)(x) + 0x100U)

#define HW_USB_USBCTRL(x)        (*(__IO hw_usb_usbctrl_t *) HW_USB_USBCTRL_ADDR(x))
#define HW_USB_USBCTRL_RD(x)     (HW_USB_USBCTRL(x).U)
#define HW_USB_USBCTRL_WR(x, v)  (HW_USB_USBCTRL(x).U = (v))
#define HW_USB_USBCTRL_SET(x, v) (BME_OR8(HW_USB_USBCTRL_ADDR(x), (uint8_t)(v)))
#define HW_USB_USBCTRL_CLR(x, v) (BME_AND8(HW_USB_USBCTRL_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_USBCTRL_TOG(x, v) (BME_XOR8(HW_USB_USBCTRL_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_USBCTRL bitfields
 */

/*!
 * @name Register USB_USBCTRL, field PDE[6] (RW)
 *
 * Enables the weak pulldowns on the USB transceiver.
 *
 * Values:
 * - 0 - Weak pulldowns are disabled on D+ and D-.
 * - 1 - Weak pulldowns are enabled on D+ and D-.
 */
/*@{*/
#define BP_USB_USBCTRL_PDE   (6U)          /*!< Bit position for USB_USBCTRL_PDE. */
#define BM_USB_USBCTRL_PDE   (0x40U)       /*!< Bit mask for USB_USBCTRL_PDE. */
#define BS_USB_USBCTRL_PDE   (1U)          /*!< Bit field size in bits for USB_USBCTRL_PDE. */

/*! @brief Read current value of the USB_USBCTRL_PDE field. */
#define BR_USB_USBCTRL_PDE(x) (BME_UBFX8(HW_USB_USBCTRL_ADDR(x), BP_USB_USBCTRL_PDE, BS_USB_USBCTRL_PDE))

/*! @brief Format value for bitfield USB_USBCTRL_PDE. */
#define BF_USB_USBCTRL_PDE(v) ((uint8_t)((uint8_t)(v) << BP_USB_USBCTRL_PDE) & BM_USB_USBCTRL_PDE)

/*! @brief Set the PDE field to a new value. */
#define BW_USB_USBCTRL_PDE(x, v) (BME_BFI8(HW_USB_USBCTRL_ADDR(x), ((uint8_t)(v) << BP_USB_USBCTRL_PDE), BP_USB_USBCTRL_PDE, 1))
/*@}*/

/*!
 * @name Register USB_USBCTRL, field SUSP[7] (RW)
 *
 * Places the USB transceiver into the suspend state.
 *
 * Values:
 * - 0 - USB transceiver is not in suspend state.
 * - 1 - USB transceiver is in suspend state.
 */
/*@{*/
#define BP_USB_USBCTRL_SUSP  (7U)          /*!< Bit position for USB_USBCTRL_SUSP. */
#define BM_USB_USBCTRL_SUSP  (0x80U)       /*!< Bit mask for USB_USBCTRL_SUSP. */
#define BS_USB_USBCTRL_SUSP  (1U)          /*!< Bit field size in bits for USB_USBCTRL_SUSP. */

/*! @brief Read current value of the USB_USBCTRL_SUSP field. */
#define BR_USB_USBCTRL_SUSP(x) (BME_UBFX8(HW_USB_USBCTRL_ADDR(x), BP_USB_USBCTRL_SUSP, BS_USB_USBCTRL_SUSP))

/*! @brief Format value for bitfield USB_USBCTRL_SUSP. */
#define BF_USB_USBCTRL_SUSP(v) ((uint8_t)((uint8_t)(v) << BP_USB_USBCTRL_SUSP) & BM_USB_USBCTRL_SUSP)

/*! @brief Set the SUSP field to a new value. */
#define BW_USB_USBCTRL_SUSP(x, v) (BME_BFI8(HW_USB_USBCTRL_ADDR(x), ((uint8_t)(v) << BP_USB_USBCTRL_SUSP), BP_USB_USBCTRL_SUSP, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_OBSERVE - USB OTG Observe register
 ******************************************************************************/

/*!
 * @brief HW_USB_OBSERVE - USB OTG Observe register (RO)
 *
 * Reset value: 0x50U
 *
 * Provides visibility on the state of the pull-ups and pull-downs at the
 * transceiver. Useful when interfacing to an external OTG control module via a serial
 * interface.
 */
typedef union _hw_usb_observe
{
    uint8_t U;
    struct _hw_usb_observe_bitfields
    {
        uint8_t RESERVED0 : 4;         /*!< [3:0]  */
        uint8_t DMPD : 1;              /*!< [4]  */
        uint8_t RESERVED1 : 1;         /*!< [5]  */
        uint8_t DPPD : 1;              /*!< [6]  */
        uint8_t DPPU : 1;              /*!< [7]  */
    } B;
} hw_usb_observe_t;

/*!
 * @name Constants and macros for entire USB_OBSERVE register
 */
/*@{*/
#define HW_USB_OBSERVE_ADDR(x)   ((uint32_t)(x) + 0x104U)

#define HW_USB_OBSERVE(x)        (*(__I hw_usb_observe_t *) HW_USB_OBSERVE_ADDR(x))
#define HW_USB_OBSERVE_RD(x)     (HW_USB_OBSERVE(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_OBSERVE bitfields
 */

/*!
 * @name Register USB_OBSERVE, field DMPD[4] (RO)
 *
 * Provides observability of the D- Pulldown signal output from USB.
 *
 * Values:
 * - 0 - D- pulldown disabled.
 * - 1 - D- pulldown enabled.
 */
/*@{*/
#define BP_USB_OBSERVE_DMPD  (4U)          /*!< Bit position for USB_OBSERVE_DMPD. */
#define BM_USB_OBSERVE_DMPD  (0x10U)       /*!< Bit mask for USB_OBSERVE_DMPD. */
#define BS_USB_OBSERVE_DMPD  (1U)          /*!< Bit field size in bits for USB_OBSERVE_DMPD. */

/*! @brief Read current value of the USB_OBSERVE_DMPD field. */
#define BR_USB_OBSERVE_DMPD(x) (BME_UBFX8(HW_USB_OBSERVE_ADDR(x), BP_USB_OBSERVE_DMPD, BS_USB_OBSERVE_DMPD))
/*@}*/

/*!
 * @name Register USB_OBSERVE, field DPPD[6] (RO)
 *
 * Provides observability of the D+ Pulldown signal output from USB.
 *
 * Values:
 * - 0 - D+ pulldown disabled.
 * - 1 - D+ pulldown enabled.
 */
/*@{*/
#define BP_USB_OBSERVE_DPPD  (6U)          /*!< Bit position for USB_OBSERVE_DPPD. */
#define BM_USB_OBSERVE_DPPD  (0x40U)       /*!< Bit mask for USB_OBSERVE_DPPD. */
#define BS_USB_OBSERVE_DPPD  (1U)          /*!< Bit field size in bits for USB_OBSERVE_DPPD. */

/*! @brief Read current value of the USB_OBSERVE_DPPD field. */
#define BR_USB_OBSERVE_DPPD(x) (BME_UBFX8(HW_USB_OBSERVE_ADDR(x), BP_USB_OBSERVE_DPPD, BS_USB_OBSERVE_DPPD))
/*@}*/

/*!
 * @name Register USB_OBSERVE, field DPPU[7] (RO)
 *
 * Provides observability of the D+ Pullup signal output from USB .
 *
 * Values:
 * - 0 - D+ pullup disabled.
 * - 1 - D+ pullup enabled.
 */
/*@{*/
#define BP_USB_OBSERVE_DPPU  (7U)          /*!< Bit position for USB_OBSERVE_DPPU. */
#define BM_USB_OBSERVE_DPPU  (0x80U)       /*!< Bit mask for USB_OBSERVE_DPPU. */
#define BS_USB_OBSERVE_DPPU  (1U)          /*!< Bit field size in bits for USB_OBSERVE_DPPU. */

/*! @brief Read current value of the USB_OBSERVE_DPPU field. */
#define BR_USB_OBSERVE_DPPU(x) (BME_UBFX8(HW_USB_OBSERVE_ADDR(x), BP_USB_OBSERVE_DPPU, BS_USB_OBSERVE_DPPU))
/*@}*/

/*******************************************************************************
 * HW_USB_CONTROL - USB OTG Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_CONTROL - USB OTG Control register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_usb_control
{
    uint8_t U;
    struct _hw_usb_control_bitfields
    {
        uint8_t RESERVED0 : 4;         /*!< [3:0]  */
        uint8_t DPPULLUPNONOTG : 1;    /*!< [4]  */
        uint8_t RESERVED1 : 3;         /*!< [7:5]  */
    } B;
} hw_usb_control_t;

/*!
 * @name Constants and macros for entire USB_CONTROL register
 */
/*@{*/
#define HW_USB_CONTROL_ADDR(x)   ((uint32_t)(x) + 0x108U)

#define HW_USB_CONTROL(x)        (*(__IO hw_usb_control_t *) HW_USB_CONTROL_ADDR(x))
#define HW_USB_CONTROL_RD(x)     (HW_USB_CONTROL(x).U)
#define HW_USB_CONTROL_WR(x, v)  (HW_USB_CONTROL(x).U = (v))
#define HW_USB_CONTROL_SET(x, v) (BME_OR8(HW_USB_CONTROL_ADDR(x), (uint8_t)(v)))
#define HW_USB_CONTROL_CLR(x, v) (BME_AND8(HW_USB_CONTROL_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_CONTROL_TOG(x, v) (BME_XOR8(HW_USB_CONTROL_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_CONTROL bitfields
 */

/*!
 * @name Register USB_CONTROL, field DPPULLUPNONOTG[4] (RW)
 *
 * Provides control of the DP Pullup in USB, if USB is configured in non-OTG
 * device mode.
 *
 * Values:
 * - 0 - DP Pullup in non-OTG device mode is not enabled.
 * - 1 - DP Pullup in non-OTG device mode is enabled.
 */
/*@{*/
#define BP_USB_CONTROL_DPPULLUPNONOTG (4U) /*!< Bit position for USB_CONTROL_DPPULLUPNONOTG. */
#define BM_USB_CONTROL_DPPULLUPNONOTG (0x10U) /*!< Bit mask for USB_CONTROL_DPPULLUPNONOTG. */
#define BS_USB_CONTROL_DPPULLUPNONOTG (1U) /*!< Bit field size in bits for USB_CONTROL_DPPULLUPNONOTG. */

/*! @brief Read current value of the USB_CONTROL_DPPULLUPNONOTG field. */
#define BR_USB_CONTROL_DPPULLUPNONOTG(x) (BME_UBFX8(HW_USB_CONTROL_ADDR(x), BP_USB_CONTROL_DPPULLUPNONOTG, BS_USB_CONTROL_DPPULLUPNONOTG))

/*! @brief Format value for bitfield USB_CONTROL_DPPULLUPNONOTG. */
#define BF_USB_CONTROL_DPPULLUPNONOTG(v) ((uint8_t)((uint8_t)(v) << BP_USB_CONTROL_DPPULLUPNONOTG) & BM_USB_CONTROL_DPPULLUPNONOTG)

/*! @brief Set the DPPULLUPNONOTG field to a new value. */
#define BW_USB_CONTROL_DPPULLUPNONOTG(x, v) (BME_BFI8(HW_USB_CONTROL_ADDR(x), ((uint8_t)(v) << BP_USB_CONTROL_DPPULLUPNONOTG), BP_USB_CONTROL_DPPULLUPNONOTG, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_USBTRC0 - USB Transceiver Control register 0
 ******************************************************************************/

/*!
 * @brief HW_USB_USBTRC0 - USB Transceiver Control register 0 (RW)
 *
 * Reset value: 0x00U
 *
 * Includes signals for basic operation of the on-chip USB Full Speed
 * transceiver and configuration of the USB data connection that are not otherwise included
 * in the USB Full Speed controller registers.
 */
typedef union _hw_usb_usbtrc0
{
    uint8_t U;
    struct _hw_usb_usbtrc0_bitfields
    {
        uint8_t USB_RESUME_INT : 1;    /*!< [0] USB Asynchronous Interrupt */
        uint8_t SYNC_DET : 1;          /*!< [1] Synchronous USB Interrupt Detect */
        uint8_t USB_CLK_RECOVERY_INT : 1; /*!< [2] Combined USB Clock
                                        * Recovery interrupt status */
        uint8_t RESERVED0 : 2;         /*!< [4:3]  */
        uint8_t USBRESMEN : 1;         /*!< [5] Asynchronous Resume Interrupt Enable
                                        * */
        uint8_t RESERVED1 : 1;         /*!< [6]  */
        uint8_t USBRESET : 1;          /*!< [7] USB Reset */
    } B;
} hw_usb_usbtrc0_t;

/*!
 * @name Constants and macros for entire USB_USBTRC0 register
 */
/*@{*/
#define HW_USB_USBTRC0_ADDR(x)   ((uint32_t)(x) + 0x10CU)

#define HW_USB_USBTRC0(x)        (*(__IO hw_usb_usbtrc0_t *) HW_USB_USBTRC0_ADDR(x))
#define HW_USB_USBTRC0_RD(x)     (HW_USB_USBTRC0(x).U)
#define HW_USB_USBTRC0_WR(x, v)  (HW_USB_USBTRC0(x).U = (v))
#define HW_USB_USBTRC0_SET(x, v) (BME_OR8(HW_USB_USBTRC0_ADDR(x), (uint8_t)(v)))
#define HW_USB_USBTRC0_CLR(x, v) (BME_AND8(HW_USB_USBTRC0_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_USBTRC0_TOG(x, v) (BME_XOR8(HW_USB_USBTRC0_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_USBTRC0 bitfields
 */

/*!
 * @name Register USB_USBTRC0, field USB_RESUME_INT[0] (RO)
 *
 * Values:
 * - 0 - No interrupt was generated.
 * - 1 - Interrupt was generated because of the USB asynchronous interrupt.
 */
/*@{*/
#define BP_USB_USBTRC0_USB_RESUME_INT (0U) /*!< Bit position for USB_USBTRC0_USB_RESUME_INT. */
#define BM_USB_USBTRC0_USB_RESUME_INT (0x01U) /*!< Bit mask for USB_USBTRC0_USB_RESUME_INT. */
#define BS_USB_USBTRC0_USB_RESUME_INT (1U) /*!< Bit field size in bits for USB_USBTRC0_USB_RESUME_INT. */

/*! @brief Read current value of the USB_USBTRC0_USB_RESUME_INT field. */
#define BR_USB_USBTRC0_USB_RESUME_INT(x) (BME_UBFX8(HW_USB_USBTRC0_ADDR(x), BP_USB_USBTRC0_USB_RESUME_INT, BS_USB_USBTRC0_USB_RESUME_INT))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field SYNC_DET[1] (RO)
 *
 * Values:
 * - 0 - Synchronous interrupt has not been detected.
 * - 1 - Synchronous interrupt has been detected.
 */
/*@{*/
#define BP_USB_USBTRC0_SYNC_DET (1U)       /*!< Bit position for USB_USBTRC0_SYNC_DET. */
#define BM_USB_USBTRC0_SYNC_DET (0x02U)    /*!< Bit mask for USB_USBTRC0_SYNC_DET. */
#define BS_USB_USBTRC0_SYNC_DET (1U)       /*!< Bit field size in bits for USB_USBTRC0_SYNC_DET. */

/*! @brief Read current value of the USB_USBTRC0_SYNC_DET field. */
#define BR_USB_USBTRC0_SYNC_DET(x) (BME_UBFX8(HW_USB_USBTRC0_ADDR(x), BP_USB_USBTRC0_SYNC_DET, BS_USB_USBTRC0_SYNC_DET))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field USB_CLK_RECOVERY_INT[2] (RO)
 *
 * This read-only field will be set to value high at 1'b1 when any of USB clock
 * recovery interrupt conditions are detected and those interrupts are unmasked.
 * For customer use the only unmasked USB clock recovery interrupt condition
 * results from an overflow of the frequency trim setting values indicating that the
 * frequency trim calculated is out of the adjustment range of the IRC48M output
 * clock. To clear this bit after it has been set, Write 0xFF to register
 * USB_CLK_RECOVER_INT_STATUS.
 */
/*@{*/
#define BP_USB_USBTRC0_USB_CLK_RECOVERY_INT (2U) /*!< Bit position for USB_USBTRC0_USB_CLK_RECOVERY_INT. */
#define BM_USB_USBTRC0_USB_CLK_RECOVERY_INT (0x04U) /*!< Bit mask for USB_USBTRC0_USB_CLK_RECOVERY_INT. */
#define BS_USB_USBTRC0_USB_CLK_RECOVERY_INT (1U) /*!< Bit field size in bits for USB_USBTRC0_USB_CLK_RECOVERY_INT. */

/*! @brief Read current value of the USB_USBTRC0_USB_CLK_RECOVERY_INT field. */
#define BR_USB_USBTRC0_USB_CLK_RECOVERY_INT(x) (BME_UBFX8(HW_USB_USBTRC0_ADDR(x), BP_USB_USBTRC0_USB_CLK_RECOVERY_INT, BS_USB_USBTRC0_USB_CLK_RECOVERY_INT))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field USBRESMEN[5] (RW)
 *
 * This bit, when set, allows the USB module to send an asynchronous wakeup
 * event to the MCU upon detection of resume signaling on the USB bus. The MCU then
 * re-enables clocks to the USB module. It is used for low-power suspend mode when
 * USB module clocks are stopped or the USB transceiver is in Suspend mode.
 * Async wakeup only works in device mode.
 *
 * Values:
 * - 0 - USB asynchronous wakeup from suspend mode disabled.
 * - 1 - USB asynchronous wakeup from suspend mode enabled. The asynchronous
 *     resume interrupt differs from the synchronous resume interrupt in that it
 *     asynchronously detects K-state using the unfiltered state of the D+ and D-
 *     pins. This interrupt should only be enabled when the Transceiver is
 *     suspended.
 */
/*@{*/
#define BP_USB_USBTRC0_USBRESMEN (5U)      /*!< Bit position for USB_USBTRC0_USBRESMEN. */
#define BM_USB_USBTRC0_USBRESMEN (0x20U)   /*!< Bit mask for USB_USBTRC0_USBRESMEN. */
#define BS_USB_USBTRC0_USBRESMEN (1U)      /*!< Bit field size in bits for USB_USBTRC0_USBRESMEN. */

/*! @brief Read current value of the USB_USBTRC0_USBRESMEN field. */
#define BR_USB_USBTRC0_USBRESMEN(x) (BME_UBFX8(HW_USB_USBTRC0_ADDR(x), BP_USB_USBTRC0_USBRESMEN, BS_USB_USBTRC0_USBRESMEN))

/*! @brief Format value for bitfield USB_USBTRC0_USBRESMEN. */
#define BF_USB_USBTRC0_USBRESMEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_USBTRC0_USBRESMEN) & BM_USB_USBTRC0_USBRESMEN)

/*! @brief Set the USBRESMEN field to a new value. */
#define BW_USB_USBTRC0_USBRESMEN(x, v) (BME_BFI8(HW_USB_USBTRC0_ADDR(x), ((uint8_t)(v) << BP_USB_USBTRC0_USBRESMEN), BP_USB_USBTRC0_USBRESMEN, 1))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field USBRESET[7] (WO)
 *
 * Generates a hard reset to USB. After this bit is set and the reset occurs,
 * this bit is automatically cleared. This bit is always read as zero. Wait two USB
 * clock cycles after setting this bit.
 *
 * Values:
 * - 0 - Normal USB module operation.
 * - 1 - Returns the USB module to its reset state.
 */
/*@{*/
#define BP_USB_USBTRC0_USBRESET (7U)       /*!< Bit position for USB_USBTRC0_USBRESET. */
#define BM_USB_USBTRC0_USBRESET (0x80U)    /*!< Bit mask for USB_USBTRC0_USBRESET. */
#define BS_USB_USBTRC0_USBRESET (1U)       /*!< Bit field size in bits for USB_USBTRC0_USBRESET. */

/*! @brief Format value for bitfield USB_USBTRC0_USBRESET. */
#define BF_USB_USBTRC0_USBRESET(v) ((uint8_t)((uint8_t)(v) << BP_USB_USBTRC0_USBRESET) & BM_USB_USBTRC0_USBRESET)
/*@}*/

/*******************************************************************************
 * HW_USB_USBFRMADJUST - Frame Adjust Register
 ******************************************************************************/

/*!
 * @brief HW_USB_USBFRMADJUST - Frame Adjust Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_usb_usbfrmadjust
{
    uint8_t U;
    struct _hw_usb_usbfrmadjust_bitfields
    {
        uint8_t ADJ : 8;               /*!< [7:0] Frame Adjustment */
    } B;
} hw_usb_usbfrmadjust_t;

/*!
 * @name Constants and macros for entire USB_USBFRMADJUST register
 */
/*@{*/
#define HW_USB_USBFRMADJUST_ADDR(x) ((uint32_t)(x) + 0x114U)

#define HW_USB_USBFRMADJUST(x)   (*(__IO hw_usb_usbfrmadjust_t *) HW_USB_USBFRMADJUST_ADDR(x))
#define HW_USB_USBFRMADJUST_RD(x) (HW_USB_USBFRMADJUST(x).U)
#define HW_USB_USBFRMADJUST_WR(x, v) (HW_USB_USBFRMADJUST(x).U = (v))
#define HW_USB_USBFRMADJUST_SET(x, v) (BME_OR8(HW_USB_USBFRMADJUST_ADDR(x), (uint8_t)(v)))
#define HW_USB_USBFRMADJUST_CLR(x, v) (BME_AND8(HW_USB_USBFRMADJUST_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_USBFRMADJUST_TOG(x, v) (BME_XOR8(HW_USB_USBFRMADJUST_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_USBFRMADJUST bitfields
 */

/*!
 * @name Register USB_USBFRMADJUST, field ADJ[7:0] (RW)
 *
 * In Host mode, the frame adjustment is a twos complement number that adjusts
 * the period of each USB frame in 12-MHz clock periods. A SOF is normally
 * generated every 12,000 12-MHz clock cycles. The Frame Adjust Register can adjust this
 * by -128 to +127 to compensate for inaccuracies in the USB 48-MHz clock.
 * Changes to the ADJ bit take effect at the next start of the next frame.
 */
/*@{*/
#define BP_USB_USBFRMADJUST_ADJ (0U)       /*!< Bit position for USB_USBFRMADJUST_ADJ. */
#define BM_USB_USBFRMADJUST_ADJ (0xFFU)    /*!< Bit mask for USB_USBFRMADJUST_ADJ. */
#define BS_USB_USBFRMADJUST_ADJ (8U)       /*!< Bit field size in bits for USB_USBFRMADJUST_ADJ. */

/*! @brief Read current value of the USB_USBFRMADJUST_ADJ field. */
#define BR_USB_USBFRMADJUST_ADJ(x) (HW_USB_USBFRMADJUST(x).U)

/*! @brief Format value for bitfield USB_USBFRMADJUST_ADJ. */
#define BF_USB_USBFRMADJUST_ADJ(v) ((uint8_t)((uint8_t)(v) << BP_USB_USBFRMADJUST_ADJ) & BM_USB_USBFRMADJUST_ADJ)

/*! @brief Set the ADJ field to a new value. */
#define BW_USB_USBFRMADJUST_ADJ(x, v) (HW_USB_USBFRMADJUST_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_USB_CLK_RECOVER_CTRL - USB Clock recovery control
 ******************************************************************************/

/*!
 * @brief HW_USB_CLK_RECOVER_CTRL - USB Clock recovery control (RW)
 *
 * Reset value: 0x00U
 *
 * Signals in this register control the crystal-less USB clock mode in which the
 * internal IRC48M oscillator is tuned to match the clock extracted from the
 * incoming USB data stream. The IRC48M internal oscillator module must be enabled
 * in register USB_CLK_RECOVER_IRC_EN for this mode.
 */
typedef union _hw_usb_clk_recover_ctrl
{
    uint8_t U;
    struct _hw_usb_clk_recover_ctrl_bitfields
    {
        uint8_t RESERVED0 : 5;         /*!< [4:0]  */
        uint8_t RESTART_IFRTRIM_EN : 1; /*!< [5] Restart from IFR trim value
                                        * */
        uint8_t RESET_RESUME_ROUGH_EN : 1; /*!< [6] Reset/resume to rough
                                        * phase enable */
        uint8_t CLOCK_RECOVER_EN : 1;  /*!< [7] Crystal-less USB enable */
    } B;
} hw_usb_clk_recover_ctrl_t;

/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_CTRL register
 */
/*@{*/
#define HW_USB_CLK_RECOVER_CTRL_ADDR(x) ((uint32_t)(x) + 0x140U)

#define HW_USB_CLK_RECOVER_CTRL(x) (*(__IO hw_usb_clk_recover_ctrl_t *) HW_USB_CLK_RECOVER_CTRL_ADDR(x))
#define HW_USB_CLK_RECOVER_CTRL_RD(x) (HW_USB_CLK_RECOVER_CTRL(x).U)
#define HW_USB_CLK_RECOVER_CTRL_WR(x, v) (HW_USB_CLK_RECOVER_CTRL(x).U = (v))
#define HW_USB_CLK_RECOVER_CTRL_SET(x, v) (BME_OR8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), (uint8_t)(v)))
#define HW_USB_CLK_RECOVER_CTRL_CLR(x, v) (BME_AND8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_CLK_RECOVER_CTRL_TOG(x, v) (BME_XOR8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_CTRL bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_CTRL, field RESTART_IFRTRIM_EN[5] (RW)
 *
 * IRC48 has a default trim fine value whose default value is factory trimmed
 * (the IFR trim value). Clock recover block tracks the accuracy of the clock 48Mhz
 * and keeps updating the trim fine value accordingly
 *
 * Values:
 * - 0 - Trim fine adjustment always works based on the previous updated trim
 *     fine value (default)
 * - 1 - Trim fine restarts from the IFR trim value whenever
 *     bus_reset/bus_resume is detected or module enable is desasserted
 */
/*@{*/
#define BP_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN (5U) /*!< Bit position for USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN. */
#define BM_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN (0x20U) /*!< Bit mask for USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN. */
#define BS_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN. */

/*! @brief Read current value of the USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN field. */
#define BR_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(x) (BME_UBFX8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), BP_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN, BS_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN))

/*! @brief Format value for bitfield USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN. */
#define BF_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN) & BM_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN)

/*! @brief Set the RESTART_IFRTRIM_EN field to a new value. */
#define BW_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(x, v) (BME_BFI8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), ((uint8_t)(v) << BP_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN), BP_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN, 1))
/*@}*/

/*!
 * @name Register USB_CLK_RECOVER_CTRL, field RESET_RESUME_ROUGH_EN[6] (RW)
 *
 * The clock recovery block tracks the IRC48Mhz to get an accurate 48Mhz clock.
 * It has two phases after user enables clock_recover_en bit, rough phase and
 * tracking phase. The step to fine tune the IRC 48Mhz by adjusting the trim fine
 * value is different during these two phases. The step in rough phase is larger
 * than that in tracking phase. Switch back to rough stage whenever USB bus reset
 * or bus resume occurs.
 *
 * Values:
 * - 0 - Always works in tracking phase after the 1st time rough to track
 *     transition (default)
 * - 1 - Go back to rough stage whenever bus reset or bus resume occurs
 */
/*@{*/
#define BP_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN (6U) /*!< Bit position for USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN. */
#define BM_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN (0x40U) /*!< Bit mask for USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN. */
#define BS_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN. */

/*! @brief Read current value of the USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN field. */
#define BR_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(x) (BME_UBFX8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), BP_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN, BS_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN))

/*! @brief Format value for bitfield USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN. */
#define BF_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN) & BM_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN)

/*! @brief Set the RESET_RESUME_ROUGH_EN field to a new value. */
#define BW_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(x, v) (BME_BFI8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), ((uint8_t)(v) << BP_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN), BP_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN, 1))
/*@}*/

/*!
 * @name Register USB_CLK_RECOVER_CTRL, field CLOCK_RECOVER_EN[7] (RW)
 *
 * This bit must be enabled if user wants to use the crystal-less USB mode for
 * the Full Speed USB controller and transceiver. This bit should not be set for
 * USB host mode or OTG.
 *
 * Values:
 * - 0 - Disable clock recovery block (default)
 * - 1 - Enable clock recovery block
 */
/*@{*/
#define BP_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN (7U) /*!< Bit position for USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN. */
#define BM_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN (0x80U) /*!< Bit mask for USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN. */
#define BS_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN. */

/*! @brief Read current value of the USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN field. */
#define BR_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(x) (BME_UBFX8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), BP_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN, BS_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN))

/*! @brief Format value for bitfield USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN. */
#define BF_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN) & BM_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN)

/*! @brief Set the CLOCK_RECOVER_EN field to a new value. */
#define BW_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(x, v) (BME_BFI8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), ((uint8_t)(v) << BP_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN), BP_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_CLK_RECOVER_IRC_EN - IRC48M oscillator enable register
 ******************************************************************************/

/*!
 * @brief HW_USB_CLK_RECOVER_IRC_EN - IRC48M oscillator enable register (RW)
 *
 * Reset value: 0x01U
 *
 * Controls basic operation of the on-chip IRC48M module used to produce nominal
 * 48MHz clocks for USB crystal-less operation and other functions. See
 * additional information about the IRC48M operation in the Clock Distribution chapter.
 */
typedef union _hw_usb_clk_recover_irc_en
{
    uint8_t U;
    struct _hw_usb_clk_recover_irc_en_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t IRC_EN : 1;            /*!< [1] IRC48M enable */
        uint8_t RESERVED1 : 6;         /*!< [7:2]  */
    } B;
} hw_usb_clk_recover_irc_en_t;

/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_IRC_EN register
 */
/*@{*/
#define HW_USB_CLK_RECOVER_IRC_EN_ADDR(x) ((uint32_t)(x) + 0x144U)

#define HW_USB_CLK_RECOVER_IRC_EN(x) (*(__IO hw_usb_clk_recover_irc_en_t *) HW_USB_CLK_RECOVER_IRC_EN_ADDR(x))
#define HW_USB_CLK_RECOVER_IRC_EN_RD(x) (HW_USB_CLK_RECOVER_IRC_EN(x).U)
#define HW_USB_CLK_RECOVER_IRC_EN_WR(x, v) (HW_USB_CLK_RECOVER_IRC_EN(x).U = (v))
#define HW_USB_CLK_RECOVER_IRC_EN_SET(x, v) (BME_OR8(HW_USB_CLK_RECOVER_IRC_EN_ADDR(x), (uint8_t)(v)))
#define HW_USB_CLK_RECOVER_IRC_EN_CLR(x, v) (BME_AND8(HW_USB_CLK_RECOVER_IRC_EN_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_CLK_RECOVER_IRC_EN_TOG(x, v) (BME_XOR8(HW_USB_CLK_RECOVER_IRC_EN_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_IRC_EN bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_IRC_EN, field IRC_EN[1] (RW)
 *
 * This bit is used to enable the on-chip IRC48Mhz module to generate clocks for
 * crystal-less USB. It can be used for FS USB device mode operation. This bit
 * must be set before using the crystal-less USB clock configuration.
 *
 * Values:
 * - 0 - Disable the IRC48M module (default)
 * - 1 - Enable the IRC48M module
 */
/*@{*/
#define BP_USB_CLK_RECOVER_IRC_EN_IRC_EN (1U) /*!< Bit position for USB_CLK_RECOVER_IRC_EN_IRC_EN. */
#define BM_USB_CLK_RECOVER_IRC_EN_IRC_EN (0x02U) /*!< Bit mask for USB_CLK_RECOVER_IRC_EN_IRC_EN. */
#define BS_USB_CLK_RECOVER_IRC_EN_IRC_EN (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_IRC_EN_IRC_EN. */

/*! @brief Read current value of the USB_CLK_RECOVER_IRC_EN_IRC_EN field. */
#define BR_USB_CLK_RECOVER_IRC_EN_IRC_EN(x) (BME_UBFX8(HW_USB_CLK_RECOVER_IRC_EN_ADDR(x), BP_USB_CLK_RECOVER_IRC_EN_IRC_EN, BS_USB_CLK_RECOVER_IRC_EN_IRC_EN))

/*! @brief Format value for bitfield USB_CLK_RECOVER_IRC_EN_IRC_EN. */
#define BF_USB_CLK_RECOVER_IRC_EN_IRC_EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_IRC_EN_IRC_EN) & BM_USB_CLK_RECOVER_IRC_EN_IRC_EN)

/*! @brief Set the IRC_EN field to a new value. */
#define BW_USB_CLK_RECOVER_IRC_EN_IRC_EN(x, v) (BME_BFI8(HW_USB_CLK_RECOVER_IRC_EN_ADDR(x), ((uint8_t)(v) << BP_USB_CLK_RECOVER_IRC_EN_IRC_EN), BP_USB_CLK_RECOVER_IRC_EN_IRC_EN, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_CLK_RECOVER_INT_EN - Clock recovery combined interrupt enable
 ******************************************************************************/

/*!
 * @brief HW_USB_CLK_RECOVER_INT_EN - Clock recovery combined interrupt enable (RW)
 *
 * Reset value: 0x10U
 *
 * Enables or masks the individual interrupt flags which are logically OR'ed
 * together to produce the combined interrupt indication on the USB_CLK_RECOVERY_INT
 * bit in the USB_USBTRC0 register if the indicated conditions have been
 * detected in the USB clock recovery algorithm operation.
 */
typedef union _hw_usb_clk_recover_int_en
{
    uint8_t U;
    struct _hw_usb_clk_recover_int_en_bitfields
    {
        uint8_t RESERVED0 : 4;         /*!< [3:0]  */
        uint8_t OVF_ERROR_EN : 1;      /*!< [4]  */
        uint8_t RESERVED1 : 3;         /*!< [7:5]  */
    } B;
} hw_usb_clk_recover_int_en_t;

/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_INT_EN register
 */
/*@{*/
#define HW_USB_CLK_RECOVER_INT_EN_ADDR(x) ((uint32_t)(x) + 0x154U)

#define HW_USB_CLK_RECOVER_INT_EN(x) (*(__IO hw_usb_clk_recover_int_en_t *) HW_USB_CLK_RECOVER_INT_EN_ADDR(x))
#define HW_USB_CLK_RECOVER_INT_EN_RD(x) (HW_USB_CLK_RECOVER_INT_EN(x).U)
#define HW_USB_CLK_RECOVER_INT_EN_WR(x, v) (HW_USB_CLK_RECOVER_INT_EN(x).U = (v))
#define HW_USB_CLK_RECOVER_INT_EN_SET(x, v) (BME_OR8(HW_USB_CLK_RECOVER_INT_EN_ADDR(x), (uint8_t)(v)))
#define HW_USB_CLK_RECOVER_INT_EN_CLR(x, v) (BME_AND8(HW_USB_CLK_RECOVER_INT_EN_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_CLK_RECOVER_INT_EN_TOG(x, v) (BME_XOR8(HW_USB_CLK_RECOVER_INT_EN_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_INT_EN bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_INT_EN, field OVF_ERROR_EN[4] (RW)
 *
 * Determines whether OVF_ERROR condition signal is used in generation of
 * USB_CLK_RECOVERY_INT.
 *
 * Values:
 * - 0 - The interrupt will be masked
 * - 1 - The interrupt will be enabled (default)
 */
/*@{*/
#define BP_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN (4U) /*!< Bit position for USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN. */
#define BM_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN (0x10U) /*!< Bit mask for USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN. */
#define BS_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN. */

/*! @brief Read current value of the USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN field. */
#define BR_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN(x) (BME_UBFX8(HW_USB_CLK_RECOVER_INT_EN_ADDR(x), BP_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN, BS_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN))

/*! @brief Format value for bitfield USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN. */
#define BF_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN) & BM_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN)

/*! @brief Set the OVF_ERROR_EN field to a new value. */
#define BW_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN(x, v) (BME_BFI8(HW_USB_CLK_RECOVER_INT_EN_ADDR(x), ((uint8_t)(v) << BP_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN), BP_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_CLK_RECOVER_INT_STATUS - Clock recovery separated interrupt status
 ******************************************************************************/

/*!
 * @brief HW_USB_CLK_RECOVER_INT_STATUS - Clock recovery separated interrupt status (W1C)
 *
 * Reset value: 0x00U
 *
 * A Write operation with value high at 1'b1 on any combination of individual
 * bits will clear those bits.
 */
typedef union _hw_usb_clk_recover_int_status
{
    uint8_t U;
    struct _hw_usb_clk_recover_int_status_bitfields
    {
        uint8_t RESERVED0 : 4;         /*!< [3:0]  */
        uint8_t OVF_ERROR : 1;         /*!< [4]  */
        uint8_t RESERVED1 : 3;         /*!< [7:5]  */
    } B;
} hw_usb_clk_recover_int_status_t;

/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_INT_STATUS register
 */
/*@{*/
#define HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x) ((uint32_t)(x) + 0x15CU)

#define HW_USB_CLK_RECOVER_INT_STATUS(x) (*(__IO hw_usb_clk_recover_int_status_t *) HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x))
#define HW_USB_CLK_RECOVER_INT_STATUS_RD(x) (HW_USB_CLK_RECOVER_INT_STATUS(x).U)
#define HW_USB_CLK_RECOVER_INT_STATUS_WR(x, v) (HW_USB_CLK_RECOVER_INT_STATUS(x).U = (v))
#define HW_USB_CLK_RECOVER_INT_STATUS_SET(x, v) (BME_OR8(HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x), (uint8_t)(v)))
#define HW_USB_CLK_RECOVER_INT_STATUS_CLR(x, v) (BME_AND8(HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_CLK_RECOVER_INT_STATUS_TOG(x, v) (BME_XOR8(HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_INT_STATUS bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_INT_STATUS, field OVF_ERROR[4] (W1C)
 *
 * Indicates that the USB clock recovery algorithm has detected that the
 * frequency trim adjustment needed for the IRC48M output clock is outside the available
 * TRIM_FINE adjustment range for the IRC48M module.
 *
 * Values:
 * - 0 - No interrupt is reported
 * - 1 - Unmasked interrupt has been generated
 */
/*@{*/
#define BP_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR (4U) /*!< Bit position for USB_CLK_RECOVER_INT_STATUS_OVF_ERROR. */
#define BM_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR (0x10U) /*!< Bit mask for USB_CLK_RECOVER_INT_STATUS_OVF_ERROR. */
#define BS_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_INT_STATUS_OVF_ERROR. */

/*! @brief Read current value of the USB_CLK_RECOVER_INT_STATUS_OVF_ERROR field. */
#define BR_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR(x) (BME_UBFX8(HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x), BP_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR, BS_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR))

/*! @brief Format value for bitfield USB_CLK_RECOVER_INT_STATUS_OVF_ERROR. */
#define BF_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR) & BM_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR)

/*! @brief Set the OVF_ERROR field to a new value. */
#define BW_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR(x, v) (BME_BFI8(HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x), ((uint8_t)(v) << BP_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR), BP_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR, 1))
/*@}*/

/*******************************************************************************
 * hw_usb_t - module struct
 ******************************************************************************/
/*!
 * @brief All USB module registers.
 */
#pragma pack(1)
typedef struct _hw_usb
{
    __I hw_usb_perid_t PERID;              /*!< [0x0] Peripheral ID register */
    uint8_t _reserved0[3];
    __I hw_usb_idcomp_t IDCOMP;            /*!< [0x4] Peripheral ID Complement register */
    uint8_t _reserved1[3];
    __I hw_usb_rev_t REV;                  /*!< [0x8] Peripheral Revision register */
    uint8_t _reserved2[3];
    __I hw_usb_addinfo_t ADDINFO;          /*!< [0xC] Peripheral Additional Info register */
    uint8_t _reserved3[15];
    __IO hw_usb_otgctl_t OTGCTL;           /*!< [0x1C] OTG Control register */
    uint8_t _reserved4[99];
    __IO hw_usb_istat_t ISTAT;             /*!< [0x80] Interrupt Status register */
    uint8_t _reserved5[3];
    __IO hw_usb_inten_t INTEN;             /*!< [0x84] Interrupt Enable register */
    uint8_t _reserved6[3];
    __IO hw_usb_errstat_t ERRSTAT;         /*!< [0x88] Error Interrupt Status register */
    uint8_t _reserved7[3];
    __IO hw_usb_erren_t ERREN;             /*!< [0x8C] Error Interrupt Enable register */
    uint8_t _reserved8[3];
    __I hw_usb_stat_t STAT;                /*!< [0x90] Status register */
    uint8_t _reserved9[3];
    __IO hw_usb_ctl_t CTL;                 /*!< [0x94] Control register */
    uint8_t _reserved10[3];
    __IO hw_usb_addr_t ADDR;               /*!< [0x98] Address register */
    uint8_t _reserved11[3];
    __IO hw_usb_bdtpage1_t BDTPAGE1;       /*!< [0x9C] BDT Page register 1 */
    uint8_t _reserved12[3];
    __IO hw_usb_frmnuml_t FRMNUML;         /*!< [0xA0] Frame Number register Low */
    uint8_t _reserved13[3];
    __IO hw_usb_frmnumh_t FRMNUMH;         /*!< [0xA4] Frame Number register High */
    uint8_t _reserved14[11];
    __IO hw_usb_bdtpage2_t BDTPAGE2;       /*!< [0xB0] BDT Page Register 2 */
    uint8_t _reserved15[3];
    __IO hw_usb_bdtpage3_t BDTPAGE3;       /*!< [0xB4] BDT Page Register 3 */
    uint8_t _reserved16[11];
    struct {
        __IO hw_usb_endptn_t ENDPTn;       /*!< [0xC0] Endpoint Control register */
        uint8_t _reserved0[3];
    } ENDPOINT[16];
    __IO hw_usb_usbctrl_t USBCTRL;         /*!< [0x100] USB Control register */
    uint8_t _reserved17[3];
    __I hw_usb_observe_t OBSERVE;          /*!< [0x104] USB OTG Observe register */
    uint8_t _reserved18[3];
    __IO hw_usb_control_t CONTROL;         /*!< [0x108] USB OTG Control register */
    uint8_t _reserved19[3];
    __IO hw_usb_usbtrc0_t USBTRC0;         /*!< [0x10C] USB Transceiver Control register 0 */
    uint8_t _reserved20[7];
    __IO hw_usb_usbfrmadjust_t USBFRMADJUST; /*!< [0x114] Frame Adjust Register */
    uint8_t _reserved21[43];
    __IO hw_usb_clk_recover_ctrl_t CLK_RECOVER_CTRL; /*!< [0x140] USB Clock recovery control */
    uint8_t _reserved22[3];
    __IO hw_usb_clk_recover_irc_en_t CLK_RECOVER_IRC_EN; /*!< [0x144] IRC48M oscillator enable register */
    uint8_t _reserved23[15];
    __IO hw_usb_clk_recover_int_en_t CLK_RECOVER_INT_EN; /*!< [0x154] Clock recovery combined interrupt enable */
    uint8_t _reserved24[7];
    __IO hw_usb_clk_recover_int_status_t CLK_RECOVER_INT_STATUS; /*!< [0x15C] Clock recovery separated interrupt status */
} hw_usb_t;
#pragma pack()

/*! @brief Macro to access all USB registers. */
/*! @param x USB module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_USB_REGS(USB0_BASE)</code>. */
#define HW_USB_REGS(x) (*(hw_usb_t *)(x))

/*
 * MKL43Z4 VREF
 *
 * Voltage Reference
 *
 * Registers defined in this header file:
 * - HW_VREF_TRM - VREF Trim Register
 * - HW_VREF_SC - VREF Status and Control Register
 *
 * - hw_vref_t - Struct containing all module registers.
 */

#define HW_VREF_INSTANCE_COUNT (1U) /*!< Number of instances of the VREF module. */
#define HW_VREF (0U) /*!< Instance number for VREF. */

/*******************************************************************************
 * HW_VREF_TRM - VREF Trim Register
 ******************************************************************************/

/*!
 * @brief HW_VREF_TRM - VREF Trim Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains bits that contain the trim data for the Voltage
 * Reference.
 */
typedef union _hw_vref_trm
{
    uint8_t U;
    struct _hw_vref_trm_bitfields
    {
        uint8_t TRIM : 6;              /*!< [5:0] Trim bits */
        uint8_t CHOPEN : 1;            /*!< [6] Chop oscillator enable. When set,
                                        * internal chopping operation is enabled and the internal analog offset will be
                                        * minimized. */
        uint8_t RESERVED0 : 1;         /*!< [7]  */
    } B;
} hw_vref_trm_t;

/*!
 * @name Constants and macros for entire VREF_TRM register
 */
/*@{*/
#define HW_VREF_TRM_ADDR(x)      ((uint32_t)(x) + 0x0U)

#define HW_VREF_TRM(x)           (*(__IO hw_vref_trm_t *) HW_VREF_TRM_ADDR(x))
#define HW_VREF_TRM_RD(x)        (HW_VREF_TRM(x).U)
#define HW_VREF_TRM_WR(x, v)     (HW_VREF_TRM(x).U = (v))
#define HW_VREF_TRM_SET(x, v)    (BME_OR8(HW_VREF_TRM_ADDR(x), (uint8_t)(v)))
#define HW_VREF_TRM_CLR(x, v)    (BME_AND8(HW_VREF_TRM_ADDR(x), (uint8_t)(~(v))))
#define HW_VREF_TRM_TOG(x, v)    (BME_XOR8(HW_VREF_TRM_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual VREF_TRM bitfields
 */

/*!
 * @name Register VREF_TRM, field TRIM[5:0] (RW)
 *
 * These bits change the resulting VREF by approximately +/- 0.5 mV for each
 * step. Min = minimum and max = maximum voltage reference output. For minimum and
 * maximum voltage reference output values, refer to the Data Sheet for this chip.
 *
 * Values:
 * - 000000 - Min
 * - 111111 - Max
 */
/*@{*/
#define BP_VREF_TRM_TRIM     (0U)          /*!< Bit position for VREF_TRM_TRIM. */
#define BM_VREF_TRM_TRIM     (0x3FU)       /*!< Bit mask for VREF_TRM_TRIM. */
#define BS_VREF_TRM_TRIM     (6U)          /*!< Bit field size in bits for VREF_TRM_TRIM. */

/*! @brief Read current value of the VREF_TRM_TRIM field. */
#define BR_VREF_TRM_TRIM(x)  (BME_UBFX8(HW_VREF_TRM_ADDR(x), BP_VREF_TRM_TRIM, BS_VREF_TRM_TRIM))

/*! @brief Format value for bitfield VREF_TRM_TRIM. */
#define BF_VREF_TRM_TRIM(v)  ((uint8_t)((uint8_t)(v) << BP_VREF_TRM_TRIM) & BM_VREF_TRM_TRIM)

/*! @brief Set the TRIM field to a new value. */
#define BW_VREF_TRM_TRIM(x, v) (BME_BFI8(HW_VREF_TRM_ADDR(x), ((uint8_t)(v) << BP_VREF_TRM_TRIM), BP_VREF_TRM_TRIM, 6))
/*@}*/

/*!
 * @name Register VREF_TRM, field CHOPEN[6] (RW)
 *
 * This bit is set during factory trimming of the VREF voltage. This bit should
 * be written to 1 to achieve the performance stated in the data sheet. If the
 * chop oscillator is to be used in very low power modes, the system (bandgap)
 * voltage reference must also be enabled. See the chip-specific VREF information
 * (also known as "chip configuration" details) for a description of how this can be
 * achieved.
 *
 * Values:
 * - 0 - Chop oscillator is disabled.
 * - 1 - Chop oscillator is enabled.
 */
/*@{*/
#define BP_VREF_TRM_CHOPEN   (6U)          /*!< Bit position for VREF_TRM_CHOPEN. */
#define BM_VREF_TRM_CHOPEN   (0x40U)       /*!< Bit mask for VREF_TRM_CHOPEN. */
#define BS_VREF_TRM_CHOPEN   (1U)          /*!< Bit field size in bits for VREF_TRM_CHOPEN. */

/*! @brief Read current value of the VREF_TRM_CHOPEN field. */
#define BR_VREF_TRM_CHOPEN(x) (BME_UBFX8(HW_VREF_TRM_ADDR(x), BP_VREF_TRM_CHOPEN, BS_VREF_TRM_CHOPEN))

/*! @brief Format value for bitfield VREF_TRM_CHOPEN. */
#define BF_VREF_TRM_CHOPEN(v) ((uint8_t)((uint8_t)(v) << BP_VREF_TRM_CHOPEN) & BM_VREF_TRM_CHOPEN)

/*! @brief Set the CHOPEN field to a new value. */
#define BW_VREF_TRM_CHOPEN(x, v) (BME_BFI8(HW_VREF_TRM_ADDR(x), ((uint8_t)(v) << BP_VREF_TRM_CHOPEN), BP_VREF_TRM_CHOPEN, 1))
/*@}*/

/*******************************************************************************
 * HW_VREF_SC - VREF Status and Control Register
 ******************************************************************************/

/*!
 * @brief HW_VREF_SC - VREF Status and Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains the control bits used to enable the internal voltage
 * reference and to select the buffer mode to be used.
 */
typedef union _hw_vref_sc
{
    uint8_t U;
    struct _hw_vref_sc_bitfields
    {
        uint8_t MODE_LV : 2;           /*!< [1:0] Buffer Mode selection */
        uint8_t VREFST : 1;            /*!< [2] Internal Voltage Reference stable */
        uint8_t RESERVED0 : 2;         /*!< [4:3]  */
        uint8_t ICOMPEN : 1;           /*!< [5] Second order curvature compensation
                                        * enable */
        uint8_t REGEN : 1;             /*!< [6] Regulator enable */
        uint8_t VREFEN : 1;            /*!< [7] Internal Voltage Reference enable */
    } B;
} hw_vref_sc_t;

/*!
 * @name Constants and macros for entire VREF_SC register
 */
/*@{*/
#define HW_VREF_SC_ADDR(x)       ((uint32_t)(x) + 0x1U)

#define HW_VREF_SC(x)            (*(__IO hw_vref_sc_t *) HW_VREF_SC_ADDR(x))
#define HW_VREF_SC_RD(x)         (HW_VREF_SC(x).U)
#define HW_VREF_SC_WR(x, v)      (HW_VREF_SC(x).U = (v))
#define HW_VREF_SC_SET(x, v)     (BME_OR8(HW_VREF_SC_ADDR(x), (uint8_t)(v)))
#define HW_VREF_SC_CLR(x, v)     (BME_AND8(HW_VREF_SC_ADDR(x), (uint8_t)(~(v))))
#define HW_VREF_SC_TOG(x, v)     (BME_XOR8(HW_VREF_SC_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual VREF_SC bitfields
 */

/*!
 * @name Register VREF_SC, field MODE_LV[1:0] (RW)
 *
 * These bits select the buffer modes for the Voltage Reference module.
 *
 * Values:
 * - 00 - Bandgap on only, for stabilization and startup
 * - 01 - High power buffer mode enabled
 * - 10 - Low-power buffer mode enabled
 * - 11 - Reserved
 */
/*@{*/
#define BP_VREF_SC_MODE_LV   (0U)          /*!< Bit position for VREF_SC_MODE_LV. */
#define BM_VREF_SC_MODE_LV   (0x03U)       /*!< Bit mask for VREF_SC_MODE_LV. */
#define BS_VREF_SC_MODE_LV   (2U)          /*!< Bit field size in bits for VREF_SC_MODE_LV. */

/*! @brief Read current value of the VREF_SC_MODE_LV field. */
#define BR_VREF_SC_MODE_LV(x) (BME_UBFX8(HW_VREF_SC_ADDR(x), BP_VREF_SC_MODE_LV, BS_VREF_SC_MODE_LV))

/*! @brief Format value for bitfield VREF_SC_MODE_LV. */
#define BF_VREF_SC_MODE_LV(v) ((uint8_t)((uint8_t)(v) << BP_VREF_SC_MODE_LV) & BM_VREF_SC_MODE_LV)

/*! @brief Set the MODE_LV field to a new value. */
#define BW_VREF_SC_MODE_LV(x, v) (BME_BFI8(HW_VREF_SC_ADDR(x), ((uint8_t)(v) << BP_VREF_SC_MODE_LV), BP_VREF_SC_MODE_LV, 2))
/*@}*/

/*!
 * @name Register VREF_SC, field VREFST[2] (RO)
 *
 * This bit indicates that the bandgap reference within the Voltage Reference
 * module has completed its startup and stabilization. This bit is valid only when
 * the chop oscillator is not being used.
 *
 * Values:
 * - 0 - The module is disabled or not stable.
 * - 1 - The module is stable.
 */
/*@{*/
#define BP_VREF_SC_VREFST    (2U)          /*!< Bit position for VREF_SC_VREFST. */
#define BM_VREF_SC_VREFST    (0x04U)       /*!< Bit mask for VREF_SC_VREFST. */
#define BS_VREF_SC_VREFST    (1U)          /*!< Bit field size in bits for VREF_SC_VREFST. */

/*! @brief Read current value of the VREF_SC_VREFST field. */
#define BR_VREF_SC_VREFST(x) (BME_UBFX8(HW_VREF_SC_ADDR(x), BP_VREF_SC_VREFST, BS_VREF_SC_VREFST))
/*@}*/

/*!
 * @name Register VREF_SC, field ICOMPEN[5] (RW)
 *
 * This bit should be written to 1 to achieve the performance stated in the data
 * sheet.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_VREF_SC_ICOMPEN   (5U)          /*!< Bit position for VREF_SC_ICOMPEN. */
#define BM_VREF_SC_ICOMPEN   (0x20U)       /*!< Bit mask for VREF_SC_ICOMPEN. */
#define BS_VREF_SC_ICOMPEN   (1U)          /*!< Bit field size in bits for VREF_SC_ICOMPEN. */

/*! @brief Read current value of the VREF_SC_ICOMPEN field. */
#define BR_VREF_SC_ICOMPEN(x) (BME_UBFX8(HW_VREF_SC_ADDR(x), BP_VREF_SC_ICOMPEN, BS_VREF_SC_ICOMPEN))

/*! @brief Format value for bitfield VREF_SC_ICOMPEN. */
#define BF_VREF_SC_ICOMPEN(v) ((uint8_t)((uint8_t)(v) << BP_VREF_SC_ICOMPEN) & BM_VREF_SC_ICOMPEN)

/*! @brief Set the ICOMPEN field to a new value. */
#define BW_VREF_SC_ICOMPEN(x, v) (BME_BFI8(HW_VREF_SC_ADDR(x), ((uint8_t)(v) << BP_VREF_SC_ICOMPEN), BP_VREF_SC_ICOMPEN, 1))
/*@}*/

/*!
 * @name Register VREF_SC, field REGEN[6] (RW)
 *
 * This bit is used to enable the internal 1.75 V regulator to produce a
 * constant internal voltage supply in order to reduce the sensitivity to external
 * supply noise and variation. If it is desired to keep the regulator enabled in very
 * low power modes, refer to the Chip Configuration details for a description on
 * how this can be achieved. This bit should be written to 1 to achieve the
 * performance stated in the data sheet.
 *
 * Values:
 * - 0 - Internal 1.75 V regulator is disabled.
 * - 1 - Internal 1.75 V regulator is enabled.
 */
/*@{*/
#define BP_VREF_SC_REGEN     (6U)          /*!< Bit position for VREF_SC_REGEN. */
#define BM_VREF_SC_REGEN     (0x40U)       /*!< Bit mask for VREF_SC_REGEN. */
#define BS_VREF_SC_REGEN     (1U)          /*!< Bit field size in bits for VREF_SC_REGEN. */

/*! @brief Read current value of the VREF_SC_REGEN field. */
#define BR_VREF_SC_REGEN(x)  (BME_UBFX8(HW_VREF_SC_ADDR(x), BP_VREF_SC_REGEN, BS_VREF_SC_REGEN))

/*! @brief Format value for bitfield VREF_SC_REGEN. */
#define BF_VREF_SC_REGEN(v)  ((uint8_t)((uint8_t)(v) << BP_VREF_SC_REGEN) & BM_VREF_SC_REGEN)

/*! @brief Set the REGEN field to a new value. */
#define BW_VREF_SC_REGEN(x, v) (BME_BFI8(HW_VREF_SC_ADDR(x), ((uint8_t)(v) << BP_VREF_SC_REGEN), BP_VREF_SC_REGEN, 1))
/*@}*/

/*!
 * @name Register VREF_SC, field VREFEN[7] (RW)
 *
 * This bit is used to enable the bandgap reference within the Voltage Reference
 * module. After the VREF is enabled, turning off the clock to the VREF module
 * via the corresponding clock gate register will not disable the VREF. VREF must
 * be disabled via this VREFEN bit.
 *
 * Values:
 * - 0 - The module is disabled.
 * - 1 - The module is enabled.
 */
/*@{*/
#define BP_VREF_SC_VREFEN    (7U)          /*!< Bit position for VREF_SC_VREFEN. */
#define BM_VREF_SC_VREFEN    (0x80U)       /*!< Bit mask for VREF_SC_VREFEN. */
#define BS_VREF_SC_VREFEN    (1U)          /*!< Bit field size in bits for VREF_SC_VREFEN. */

/*! @brief Read current value of the VREF_SC_VREFEN field. */
#define BR_VREF_SC_VREFEN(x) (BME_UBFX8(HW_VREF_SC_ADDR(x), BP_VREF_SC_VREFEN, BS_VREF_SC_VREFEN))

/*! @brief Format value for bitfield VREF_SC_VREFEN. */
#define BF_VREF_SC_VREFEN(v) ((uint8_t)((uint8_t)(v) << BP_VREF_SC_VREFEN) & BM_VREF_SC_VREFEN)

/*! @brief Set the VREFEN field to a new value. */
#define BW_VREF_SC_VREFEN(x, v) (BME_BFI8(HW_VREF_SC_ADDR(x), ((uint8_t)(v) << BP_VREF_SC_VREFEN), BP_VREF_SC_VREFEN, 1))
/*@}*/

/*******************************************************************************
 * hw_vref_t - module struct
 ******************************************************************************/
/*!
 * @brief All VREF module registers.
 */
#pragma pack(1)
typedef struct _hw_vref
{
    __IO hw_vref_trm_t TRM;                /*!< [0x0] VREF Trim Register */
    __IO hw_vref_sc_t SC;                  /*!< [0x1] VREF Status and Control Register */
} hw_vref_t;
#pragma pack()

/*! @brief Macro to access all VREF registers. */
/*! @param x VREF module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_VREF_REGS(VREF_BASE)</code>. */
#define HW_VREF_REGS(x) (*(hw_vref_t *)(x))

/* Instance numbers for core modules */
#define HW_JTAG (0) /*!< Instance number for JTAG. */
#define HW_TPIU (0) /*!< Instance number for TPIU. */
#define HW_SCB (0) /*!< Instance number for SCB. */
#define HW_CoreDebug (0) /*!< Instance number for CoreDebug. */

#endif /* __HW_MKL43Z4_REGISTERS_H__ */
/* EOF */
